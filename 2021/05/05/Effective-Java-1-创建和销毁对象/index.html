

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>Effective_Java_1_创建和销毁对象 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Effective_Java_1_创建和销毁对象">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-05 17:32" pubdate>
        2021年5月5日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      230
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Effective_Java_1_创建和销毁对象</h1>
            
            <div class="markdown-body">
              <h1 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h1><p>何时以及如何创建对象，何时以及如何避免创建对象， 如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作 。</p>
<h2 id="第一条-使用静态工厂方法代替构造函数（构造器Constructor）"><a href="#第一条-使用静态工厂方法代替构造函数（构造器Constructor）" class="headerlink" title="第一条 使用静态工厂方法代替构造函数（构造器Constructor）"></a>第一条 使用静态工厂方法代替构造函数（构造器Constructor）</h2><p>Static Factory Method   VS   Constructor</p>
<p>对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个公有 的构造器。 还有一种方法，也应该在每个程序员的工具箱中占有一席之地 。</p>
<p>类可以提供一个 公有的静态 工厂 方法（ static factory method ），它只是一个返回类的实例的静态方法。</p>
<p>下面是 一个来自 B。 olean （基本类型 boolean 的装箱类）的简单示例 。 这个方法将 boolean 基本 类型值转换成了一个 B o olean 对象引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b ? Boolean.TUE : Boolean.FALSE;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，静态工厂方法与设计模式［ Gamma95 ］中的工厂方法（ Factory Method ） 模式不同 。</p>
<p>如果不通过公有的构造器 ， 或者说除了公有的构造器之外，类还可以给它的客户端提 供静态工厂方法 。 提供静态工厂方法而不是公有的构造器，这样做既有优势，也有劣势:</p>
<ul>
<li>静态工厂方法与构造器不同的第一大优势在于，它们有名称。如果构造器的参数本 身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，产生的 客户端代码也更易于阅读。 例如，构造器 Biginteger (int , int, Random ）返回的Biginteger 可能为素数，如果用名为 B 工 ginteger.probablePrime 的静态工厂方法来表示，显然更为清楚。 (Java 4 版本中增加了这个方法 。 ）    一个类只能有一个带有指定签名的构造器 。 编程人员通常知道如何避开这一限制 ： 通过 提供两个构造器，它们 的参数列表只在参数类型的顺序上有所不同 。 实际上这并不是个好主 意。面对这样的 API ， 用户永远也记不住该用哪个构造器 ， 结果常常会调用错误 的构造器 。 并且在读到使用了这些构造器的代码时，如果没有参考类的文档，往往不知所云 。     由于静态工厂方法有名称，所以它们不受上述限制 。 当一个类需要多个带有相同签名 的构造器时，就用静态工厂方法代替构造器，并且仔细地选择名称以便突出静态工厂方法之 间的区别 。</li>
</ul>
<ul>
<li>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。 这使得不可变类（详见第 17 条）可以使用预先构建好的 实 例，或者将 构建好的 实 例 缓存起来， 进行重复利用，从而避免创建不必要的重复对象。 Boolean. va lueOf (b oolean ）方法说明了这项技术 ： 它从来不创 建对象 。 这种方法类似于享元 (Flyweight ）模式［ Gamma95 ］ 。 如果程序经常请求创建相同的对象，并且创建对象的代价 很高，则这项技术可以极大地提升性能 。      静态工厂方法能够为重复的调用返回相同对象，这样有助于类总能严格控制在某个时· 刻哪些实例应该存在 。 这种类被称作实例受控的类（ instance-controlled ） 。 编写实例受控的 类有几个原因 。 实例受控使得类可 以确保它是一个 Singleton （详见第 3 条 ）或者是不可实例 化的（详见第 4 条） 。 它还使得不可变的值类（详见第 17 条）可 以确保不会存在两个相等的 实例， 即 当且仅当 a==b 时， a . equals(b ）才为 true 。 这是享元模式［ Gamma95 ］ 的基础 。 枚举（巳num ）类型（详见第 34 条 ）保证了这一点 。</li>
</ul>
<ul>
<li>静态工厂方法与构造器不同的第三大优势在子，它们可以返回原返回类型的任何子类型的对象。这样我们在选择返回对象的类时就有 了更大的灵活性 。     这种灵活性的一种应用是 ， API 可以返回对象，同时又不会使对象的类变成公有的 。 以 这种方式隐藏实现类会使 API 变得非常简洁。 这项技术适用于基于接口的框架（ interface四 based framework ) （详见第 20 条），因为在这种框架中 ，接 口 为静态工厂方法提供了自然返回 类型 。     在 Java 8 之前 ，接 口不能有静态方法，因此按照惯例，接口 Type 的静态工厂方法被放在 一个名为 Types 的不可 实例化的伴生类（详见第 4 条）中 。 例如 Java Collections Framework 的集合接口有 45 个工具实现，分别提供了不可修改的集合、 同步集合，等等。 几乎所有这 些实现都通过静态工厂方法在－个不可实例化的类（ java . ut il. Collections ） 中导出 。 所有返回对象的类都是非公有的 。   现在的 Collections Framework API 比导出 45 个独立公有类 的那种实 现方式要小得多， 每种便利实现都对应一个类。 这不仅仅是指 API 数量上 的 减少 ，也是概念意义上的减少：为了使用这个API，用户必须掌握的概念在数量和难度上都减少了 。 程序员知道，被返回的对象是由相关的接口精确指定的，所以他们不需要阅读有关的类文档 。 此外，使用这种静态 工厂方法时，甚至要求客户端通过接口来引用被返回的对象， 而不是通过它的实现类来引用 被返回的对象，这是一种良好的习惯（详见第 64 条） 。 从 Java 8 版本开始，接口中不能包含静态方法 的这一 限制成为历史，因此一般没有任何理由给接口提供一个不可实例化的伴生类 。 已经被放在这种类中的许多公有的静态成员， 应该被放到接口中去 。 但是要注意，仍然有必要将这些静态方法背后的大部分实现代码， 单独放进一个包级私有的类中 。 这是因为在 Java 8 中仍要求接口的所有静态成员都必须是 公有的 。 在 Java 9 中允许接口有私有的静态方法，但是静态域和静态成员类仍然需要是公 有的 。</li>
</ul>
<ul>
<li>静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取 决于静态工厂方法的参数值。 只要是已声明的返回类型的子类型，都是允许的 。 返回对象的 类也可能随着发行版本的不同而不同 。       EnumSet （详见第 36 条）没有公有的构造器，只有静态工厂方法。 在 OpenJDK 实现中， 它们返回两种子类之一的一个实例，具体则取决于底层枚举类型的大小：如果它的元素有 64 个或者更少，就像大多数枚举类型一样，静态工厂方法就会返回一个 RegalarEumSet 实例， 用单个 long 进行支持；如果枚举类型有 65 个或者更多元素，工厂就返回 JumboEnumSet 实例，用一个 long 数组进行支持。     这两个实现类的存在对于客户端来说是不可见的 。 如果 RegularEnumSet 不能再给 小的枚举类型提供性能优势，就可能从未来的发行版本中将它删除，不会造成任何负面的影 H向 。 同样地，如果事实证明对性能有好处，也可能在未来的发行版本中添加第三甚至第四个 EnumSet 实现。 客户端永远不知道也不关心它们从工厂方法中得到的对象的类，它们只关心它是 EnumSet 的某个子类 。</li>
</ul>
<ul>
<li>静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方 法的类时可以不存在。    这种灵活的静态工厂方法构成了服务提供者框架（ Service Provider Framework）的基础，例如 JDBC(Java 数据库连接）API 。 服务提供者框架是指这样一个系统： 多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个 实现中解稠出来 。     服务提供者框架中有三个重要的组件 ：服务接口 （ Service Interface ），这是提供者实现 的；提供者注册 API ( Provider Registration API ），这是提供者用来注册实现的；服务访问 API (Service Access API) ，这是客户端用来获取服务的实例 。 服务访问 API 是客户端用来指 定某种选择实现的条件。 如果没有这样的规定， API 就会返回默认实现的一个实例，或者允 许客户端遍历所有可用的实现。 服务访问 API 是“灵活的静态工厂”，它构成了服务提供者 框架的基础 。    服务提供者框架的第四个组件服务提供者接口（ Service Provid巳r Interface ）是可选的，它表示产生服务接口之实例的工厂对象 。 如果没有服务提供者接口，实现就通过反射方式进行实例化（详见第 65 条） 。 对于 JDBC 来说Connectio 口就是其服务接口的一部分,DriverManager . registerDriver 是提供者注册 API,DriverManager.getConnection是服务访问 API, Driver 是服务提供者接口 。       服务提供者框架模式有着无数种变体。 例如，服务访问 API 可以返回比提供者需要 的 更丰富的服务接口 。 这就是桥接（ Bridge ）模式 ［ Gamma95 ］ 。 依赖、注入框架（详见第 5 条） 可以被看作是一个强大的服务提供者 。 从 Java 6 版本开始， Java 平台就提供了 一个通用的服务提供者框架 j ava . util.ServiceLoader ，因 此你不需要（一般来说也不应该）再自 己编写了（详见第 59 条 ） 。 JDBC 不用 S erv工 ceLoader ，因为前者 出现得比后者早。</li>
</ul>
<ul>
<li>静态工厂方法的主要缺点在子，类如果不含公有的或者受保护的构造器，就不能被子类化 。 例如，要想将 Collections Framework 中的任何便利的实现类子类化 ， 这是不可能的 。 但是这样也许会因祸得福，因为它鼓励程序员使用复合（ composition ），而不是继承（详见 第四条），这正是不可变类型所需要的（详见第 17 条） 。</li>
</ul>
<ul>
<li>静态工厂方法的第二个缺点在于，程序员很难发现它们 。在 API 文档中，它们没有像 构造器那样在 API 文档中明确标识出来， 因 此 对于提供了静态工厂方法而不是构造器的 类来说，要想查明如何实例化一个类是非常困难的 。 Javadoc 工具总有一天会注意到静态工厂方法。 同时，通过在类或者接 口 注释 中关注静态工厂 ， 并遵守标准的命名 习惯，也可以弥补这一劣势。 下面是静态工厂方法 的一些惯用名称 。 这里只列 出了其中的一小部分：</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>from</td>
<td>类型转换方法，它只有单个参数，返回该类型的一个相对应的实例</td>
<td>Date d = Date.from(instant);</td>
</tr>
<tr>
<td>of</td>
<td>聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来</td>
<td>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</td>
</tr>
<tr>
<td>valueOf</td>
<td>比 from 和 of 更烦琐的一种替代方法</td>
<td>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</td>
</tr>
<tr>
<td>instance 或 getInstance</td>
<td>返回的实例是通过方法的（如有）参数来 描述的，但是不能说与参数具有 同样的值</td>
<td>StackWalker Luke = StackWalker.getInstance(options);</td>
</tr>
<tr>
<td>create 或者 newInsatnce</td>
<td>象 instance 或者 getinstaηce 一样，但 create 或者 newInstance 能够确保每次调用都返回一个新的实例</td>
<td>Object newArray = Array.newIntance(classObject, arrayLen);</td>
</tr>
<tr>
<td>get<em>Type</em></td>
<td>像 get Ins taηce 一 样，但是在工厂方法处于不同的类中的时候使 用 ，Type 表示工厂方法所返回的对象类型</td>
<td>FileStore fs = Files.getFileStore(path);</td>
</tr>
<tr>
<td>new<em>Type</em></td>
<td>’象 newInstance 一样，但是在工厂方法处于不同的类中的时候使用。Type 表示工厂方法所返回的对象类型</td>
<td>BufferedReader br = Files.newBufferedReader(path);</td>
</tr>
<tr>
<td><em>type</em></td>
<td><em>getType</em> 和 <em>newType</em> 的简版</td>
<td>List&lt;Complaint&gt; litany = Collections.list(legancyLitany);</td>
</tr>
</tbody></table>
<p>简而言之，静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处。 静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器， 而不先考虑静态工厂 。</p>
<h2 id="第二条-遇到多个构造器参数时要考虑使用构建器"><a href="#第二条-遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="第二条 遇到多个构造器参数时要考虑使用构建器"></a>第二条 遇到多个<em>构造器</em>参数时要考虑使用<em>构建器</em></h2><p>静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。 比如 用一个类表示包装食品外面显示的营养成分标签。 这些标签中有几个域是必需的：每份的含 量、每罐的含量以及每份的卡路里 。 还有超过 20 个的可选域 ： 总脂肪量、饱和脂肪量、转 化脂肪、胆固醇、纳，等等 。 大多数产品在某几个可选域中都会有非零的值。</p>
<p>对于这样的类，应该用哪种构造器或者静态工厂来编写呢？程序员一向习惯采用重叠 构造器（ telescoping constructor ）模式，在这种模式下，提供的第一个构造器只有必要的参 数，第二个构造器有一个可选参数，第三个构造器有两个可选参数，依此类推，最后一个构 造器包含所有可选的参数 。 下面有个示例，为了简单起见，它只显示四个可选域 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.telescopingconstructor;<br><br><span class="hljs-comment">// Telescoping constructor pattern - does not scale well! (Pages 10-11)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NutritionFacts</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servingSize;  <span class="hljs-comment">// (mL)            required</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servings;     <span class="hljs-comment">// (per container) required</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> calories;     <span class="hljs-comment">// (per serving)   optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fat;          <span class="hljs-comment">// (g/serving)     optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sodium;       <span class="hljs-comment">// (mg/serving)    optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> carbohydrate; <span class="hljs-comment">// (g/serving)     optional</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(servingSize, servings, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> calories)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(servingSize, servings, calories, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> calories, <span class="hljs-keyword">int</span> fat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(servingSize, servings, calories, fat, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> calories, <span class="hljs-keyword">int</span> fat, <span class="hljs-keyword">int</span> sodium)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(servingSize, servings, calories, fat, sodium, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> calories, <span class="hljs-keyword">int</span> fat, <span class="hljs-keyword">int</span> sodium, <span class="hljs-keyword">int</span> carbohydrate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.servingSize  = servingSize;<br>        <span class="hljs-keyword">this</span>.servings     = servings;<br>        <span class="hljs-keyword">this</span>.calories     = calories;<br>        <span class="hljs-keyword">this</span>.fat          = fat;<br>        <span class="hljs-keyword">this</span>.sodium       = sodium;<br>        <span class="hljs-keyword">this</span>.carbohydrate = carbohydrate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NutritionFacts cocaCola =<br>                <span class="hljs-keyword">new</span> NutritionFacts(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">35</span>, <span class="hljs-number">27</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>当你想要创建实例的时候，就利用参数列表最短的构造器，但该列表中包含了要设置的所有参数 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">NutritionFacts cocaCloa = <span class="hljs-keyword">new</span> NutritionFacts(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">35</span>, <span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure>
<p>这个构造器调用通常需要许多你本不想设置的参数，但还是不得不为它们传递值。 在 这个例子中，我们给 fat 传递了一个值为 0。 如果“仅仅”是这 6 个参数，看起来还不算太 糟糕，问题是随着参数数目的增加，它很快就失去了控制 。</p>
<p>简而言之，重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难缩写， 并且仍然较难以阅读。 如果读者想知道那些值是什么意思，必须很仔细地数着这些参数来探 个究竟。 一长串类型相同的参数会导致一些微妙的错误。 如果客户端不小心颠倒了其中两个 参数的顺序，编译器也不会出错，但是程序在运行时会出现错误的行为（详见第 51 条） 。</p>
<p>遇到许多可选的构造器参数的时候，还有第二种代替办法，即 JavaBeans 模式，在这 种模式下，先调用一个无参构造器来创建对象，然后再调用 setter 方法来设置每个必要的参 数，以及每个相关的可选参数 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.javabeans;<br><br><span class="hljs-comment">// JavaBeans Pattern - allows inconsistency, mandates mutability  (pages 11-12)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NutritionFacts</span> </span>&#123;<br>    <span class="hljs-comment">// Parameters initialized to default values (if any)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> servingSize  = -<span class="hljs-number">1</span>; <span class="hljs-comment">// Required; no default value</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> servings     = -<span class="hljs-number">1</span>; <span class="hljs-comment">// Required; no default value</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> calories     = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fat          = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sodium       = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> carbohydrate = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// Setters</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServingSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>  </span>&#123; servingSize = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServings</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>     </span>&#123; servings = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCalories</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>     </span>&#123; calories = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>          </span>&#123; fat = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSodium</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>       </span>&#123; sodium = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCarbohydrate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123; carbohydrate = val; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NutritionFacts cocaCola = <span class="hljs-keyword">new</span> NutritionFacts();<br>        cocaCola.setServingSize(<span class="hljs-number">240</span>);<br>        cocaCola.setServings(<span class="hljs-number">8</span>);<br>        cocaCola.setCalories(<span class="hljs-number">100</span>);<br>        cocaCola.setSodium(<span class="hljs-number">35</span>);<br>        cocaCola.setCarbohydrate(<span class="hljs-number">27</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种模式弥补了重叠构造器模式的不足 。 说得明白一点，就是创建实例很容易，这样 产生的代码读起来也很容易：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">NutritionFacts cocaCola = <span class="hljs-keyword">new</span> NutritionFacts();<br>cocaCola.setServingSize(<span class="hljs-number">240</span>);<br>cocaCola.setServings(<span class="hljs-number">8</span>);<br>cocaCola.setCalories(<span class="hljs-number">100</span>);<br>cocaCola.setSodium(<span class="hljs-number">35</span>);<br>cocaCola.setCarbohydrate(<span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure>
<p>遗憾的是， JavaBeans 模式自身有着很严重的缺点 。 因为构造过程被分到了几个调用中， 在构造过程中 Java Bean 可能处于不一致的状态。 类无法仅仅通过检验构造器参数的有效性 来保证一致性 。 试图使用处于不一致状态的对象将会导致失败，这种失败与包含错误的代码 大相径庭，因此调试起来十分困难 。 与此相关的另一点不足在于， Java Beans 模式使得把 类做成不可变的可能性不复存在 （详见第 17 条），这就需要程序员 付出 额外 的努力来确保它 的线程安全 。<br>当对象的构造完成，并且不允许在冻结之前使用时 ，通过手工“冻结”对象可 以 弥补这 些不足，但是这种方式十分笨拙，在实践中很少使用 。 此外，它甚至会在运行时导致错误， 因为编译器无法确保程序员会在使用之前先调用对象上的 freeze 方法进行冻结。</p>
<p>幸运的是，还有第 三种替代方法，它既能保证像重叠构造器模式那样的安全性，也能 保证像 JavaBeans 模式那么好的可读性 。 这就是建造者（ Builder ）模式 ［ Gamma95 ］ 的一 种形式 。 它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静 态工厂），得到一个 builder 对象。 然后客户端在 builder 对象上调用类似于 setter 的方法，来设置每个相关的可选参数。 最后客户端调用无参的 build 方法来生成通常是不可变的对象。 这个 buiider 通常是它构建的类的静态成员类（详见第 24 条） 。 下面就是它的示例 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NutritionFacts</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servingSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servings;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> calories;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fat;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sodium;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> carbohydrate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>        <span class="hljs-comment">// Required parameters</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servingSize;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servings;<br><br>        <span class="hljs-comment">// Optional parameters - initialized to default values</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> calories      = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fat           = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sodium        = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> carbohydrate  = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.servingSize = servingSize;<br>            <span class="hljs-keyword">this</span>.servings    = servings;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">calories</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">        </span>&#123; calories = val;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">fat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">        </span>&#123; fat = val;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">sodium</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">        </span>&#123; sodium = val;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">carbohydrate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">        </span>&#123; carbohydrate = val;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> NutritionFacts <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NutritionFacts(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        servingSize  = builder.servingSize;<br>        servings     = builder.servings;<br>        calories     = builder.calories;<br>        fat          = builder.fat;<br>        sodium       = builder.sodium;<br>        carbohydrate = builder.carbohydrate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NutritionFacts cocaCola = <span class="hljs-keyword">new</span> NutritionFacts.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)<br>                .calories(<span class="hljs-number">100</span>).sodium(<span class="hljs-number">35</span>).carbohydrate(<span class="hljs-number">27</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意 NutritionFacts 是不可变的，所有的默认参数值都单独放在）个地方。 builder的设值方法返回 builder 本身，以便把调用链接起来，得到一个流式的 API。 下面就是其客户端代码 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">NutritionFacts cocaCola = <span class="hljs-keyword">new</span> NutritionFacts.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)<br>    .calories(<span class="hljs-number">100</span>)<br>    .sodium(<span class="hljs-number">35</span>)<br>    .carbohydrate(<span class="hljs-number">27</span>).<br>    build();<br></code></pre></td></tr></table></figure>
<p>这样的客户端代码很容易编写，更为重要的是易于阅读 。 选参数 ，就像 Python 和 Scala 编程语言中的一样 。</p>
<p>为了简洁起见，示例中省略了有效性检查。 要想尽快侦测到无效的参数， 可以在 builder 的构造器和方法中检查参数的有效性。 查看不可变量，包括 build 方法调用的构造 器中的多个参数。 为了确保这些不变量免受攻击， 从 builder 复制完参数之后，要检查对象 域 （详见 第 50 条） 。 如果检 查失败 ，就抛出 I l leg a lArgumen tExcept ion （详 见第 72条），其中的详细信息会说明哪些参数是无效的（详见第 75 条） 。</p>
<p>Builder 模式也适用于类层次结构 。 使用平行层次结构的 builder 时， 各自嵌套在相应的 类中 。 抽象类有抽象的 builder ，具体类有具体的 builder。 假设用类层次根部 的一个抽象类 表示各式各样的比萨：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.hierarchicalbuilder;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">// Builder pattern for class hierarchies (Page 14)</span><br><br><span class="hljs-comment">// Note that the underlying &quot;simulated self-type&quot; idiom  allows for arbitrary fluid hierarchies, not just builders</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pizza</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Topping</span> </span>&#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125;<br>    <span class="hljs-keyword">final</span> Set&lt;Topping&gt; toppings;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">addTopping</span><span class="hljs-params">(Topping topping)</span> </span>&#123;<br>            toppings.add(Objects.requireNonNull(topping));<br>            <span class="hljs-keyword">return</span> self();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">abstract</span> Pizza <span class="hljs-title">build</span><span class="hljs-params">()</span></span>;<br><br>        <span class="hljs-comment">// Subclasses must override this method to return &quot;this&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title">self</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>    <br>    Pizza(Builder&lt;?&gt; builder) &#123;<br>        toppings = builder.toppings.clone(); <span class="hljs-comment">// See Item 50</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意， Pizza . Builder 的类型是泛型（ generic type ），带有一个递归类型参数（recursive type parameter ），详见第 30 条。 它和抽象的 self 方法一样，允许在子类中适当地进行方法 链接，不需要转换类型 。 这个针对 Java 缺乏 self 类型的解决方案，被称作模拟的 self 类型（ simulated self-type ） 。</p>
<p>这里有两个具体的 Pizza 子类，其中一个表示经典纽约风味的比萨，另 一个表示馅料 内置的半月型（ calzone ）比萨。 前者需要一个尺寸参数，后者则要你指定酱汁应该内 置还是 外置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.hierarchicalbuilder;<br><br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-comment">// Subclass with hierarchical builder (Page 15)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NyPizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span> </span>&#123; SMALL, MEDIUM, LARGE &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Size size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span>.<span class="hljs-title">Builder</span>&lt;<span class="hljs-title">Builder</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Size size;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(Size size)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.size = Objects.requireNonNull(size);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> NyPizza <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NyPizza(<span class="hljs-keyword">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> Builder <span class="hljs-title">self</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">NyPizza</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(builder);<br>        size = builder.size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;New York Pizza with &quot;</span> + toppings;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.hierarchicalbuilder;<br><br><span class="hljs-comment">// Subclass with hierarchical builder (Page 15)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calzone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> sauceInside;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span>.<span class="hljs-title">Builder</span>&lt;<span class="hljs-title">Builder</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> sauceInside = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Default</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">sauceInside</span><span class="hljs-params">()</span> </span>&#123;<br>            sauceInside = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Calzone <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Calzone(<span class="hljs-keyword">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> Builder <span class="hljs-title">self</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Calzone</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(builder);<br>        sauceInside = builder.sauceInside;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Calzone with %s and sauce on the %s&quot;</span>,<br>                toppings, sauceInside ? <span class="hljs-string">&quot;inside&quot;</span> : <span class="hljs-string">&quot;outside&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，每个子类的构建器中的 build 方法，都声明返回正确的子类： NyPizza.Bu i lder的 build 方法返回 Ny Pizz a ，而 Cal zo ne.Builder 中的则返回 Calzo口e 。 在该 方法中，子类方法声明返回超级类中声明的返回类型的子类型，这被称作协变返回类型(covariant return type ） 。 它允许客户端无须转换类型就能使用这些构建器。</p>
<p>这些“层次化构建器” 的客户端代码本质上与简单的 NutritionFacts 构建器一样。 为了简洁起见，下列客户端代码示例假设是在枚举常量上静态导人：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.hierarchicalbuilder;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> effectivejava.chapter2.item2.hierarchicalbuilder.Pizza.Topping.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> effectivejava.chapter2.item2.hierarchicalbuilder.NyPizza.Size.*;<br><br><span class="hljs-comment">// Using the hierarchical builder (Page 16)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NyPizza pizza = <span class="hljs-keyword">new</span> NyPizza.Builder(SMALL)<br>                .addTopping(SAUSAGE).addTopping(ONION).build();<br>        Calzone calzone = <span class="hljs-keyword">new</span> Calzone.Builder()<br>                .addTopping(HAM).sauceInside().build();<br>        <br>        System.out.println(pizza);<br>        System.out.println(calzone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>与构造器相比， builder 的 微略优势在于，它可 以有 多 个可 变（ varargs ） 参数。 因为 builder 是利用单独的方法来设置每一个参数。 此外，构造器还可以将多次调用某一个方法而传人的参数集 中到一个域中，如前面的调用了两次 addToppi口q 方法的代码所示 。</p>
<p>Builder 模式十分灵活，可以利用单个 builder 构建多个对象 。 build町的参数可以在调用 build 方法来创建对象期间进行调整，也可以随着不同的对象而改变 。 builder 可以自动填 充某些域，例如每次创建对象时自动增加序列号 。</p>
<p>Builder 模式的确也有它自身的不足。 为了创建对象 ，必须先创建它 的构建器。 虽然创 建这个构建器的开销在实践中可能不那么明显 但是在某些十分注重性能 的情况下，可能就 成问题了 。 Builder 模式还 比重叠构造器模式更加冗长 ，因此它只在有很多参数的时候才使 用，比如 4 个或者更多个参数。 但是记住，将来你可能需要添加参数。 如果一开始就使用构 造器或者静态工厂，等到类需要多个参数时才添加构造器，就会无法控制，那些过时的构造 器或者静态工厂显得十分不协调 。 因 此，通常最好一开始就使用构建器。</p>
<p>简而言之 ， 如果类的构造器或者静态工厂中具有多个参数，设计这种类时， Builde「 模式就是一种不错的选择， 特别是当大多数参数都是可选或者类型相同的时候。 与使用 重叠构造器模式相比，使用 Builder 模式 的客户端代码将更易于 阅读和编写，构建器也比 JavaBeans 更加安全。</p>
<h2 id="第三条-用私有构造器或者枚举类型强化-Singleton-属性"><a href="#第三条-用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="第三条 用私有构造器或者枚举类型强化 Singleton 属性"></a>第三条 用私有构造器或者枚举类型强化 Singleton 属性</h2><p>Singleton 是指仅仅被实例化一次的类 ［ Gamma95 ］ 。 Singleton 通常被用来代表一个无状态的对象，如函数（详见第 24 条），或者那些本质上唯一的系统组件 。 使类成为 Singleton 会使它的害户端测试变得十分困难 ，因为不可能给 Singleton 替换模拟实现，除非实现一个 充当其类型的接口 。</p>
<p>实现 Singleton 有两种常见的方法 。 这两种方法都要保持构造器为私有的，并导出公有 的静态成员，以便允许客户端能够访问该类的唯一实例 。 在第一种方法中，公有静态成员是个 final 域 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item3.field;<br><br><span class="hljs-comment">// Singleton with public final field  (Page 17)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Elvis</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Elvis INSTANCE = <span class="hljs-keyword">new</span> Elvis();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Elvis</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leaveTheBuilding</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Whoa baby, I&#x27;m outta here!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// This code would normally appear outside the class!</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Elvis elvis = Elvis.INSTANCE;<br>        elvis.leaveTheBuilding();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>私有构造器仅被调用一 次，用来实例化公有的静态 final 域 Elvis.INSTANCE 。 由于缺少公有的或者受保护的构造器，所以保证了 Elvis 的全局唯一性 ： 一旦 Elvis 类被实例化，将只会存在一个 Elvis 实例 ，不多也不少。 客户端的任何行为都不会改变这一点， 但要提醒一点：享有特权的客户端可以借助 Access 工bleObject.setAccessible 方法， 通过反射机制（详见第 65 条）调用私有构造器。 如果需要抵御这种攻击，可以修改构造器， 让它在被要求创建第二个实例的时候抛出异常。</p>
<p>在实现 Singleton 的第二种方法中，公有的成员是个静态工厂方法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item3.staticfactory;<br><br><span class="hljs-comment">// Singleton with static factory (Page 17)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Elvis</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Elvis INSTANCE = <span class="hljs-keyword">new</span> Elvis();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Elvis</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Elvis <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> INSTANCE; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leaveTheBuilding</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Whoa baby, I&#x27;m outta here!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// This code would normally appear outside the class!</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Elvis elvis = Elvis.getInstance();<br>        elvis.leaveTheBuilding();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于静态方法 Elvis.getInstance 的所有调用，都会返回同一个对象引用，所以， 永远不会创建其他的 Elvis 实例（上述提醒依然适用） 。</p>
<p>公有域方法的主要优势在于， API 很清楚地表明了这个类是一个 Singleton ： 公有的静态域是 final 的，所以该域总是包含相同的对象引用 。 第二个优势在于它更简单。</p>
<p>静态工厂方法的优势之一在于，它提供了灵活性 ： 在不改变其 API 的前提下 ， 我们可以改变该类是否应该为 Singleton 的想法。 工厂方法返回该类的唯一实例，但是，它很容易被修改， 比如改成为每个调用该方法的线程返回一个唯一的实例 。 第二个优势是， 如果应用程序需要，可以编写一个泛型 Singleton 工厂 （ generic singleton factory) （详见第 30 条） 。 使用静态工厂的最后一个优势是，可以通过方法引用（ method reference ）作为提供者，比如 Elvis::Instance 就是一个 Supplier&lt;Elvis&gt; , 除非满足以上任意一种优势 ， 否则还 是优先考虑公有域（ public-field ）的方法。</p>
<p>为了将利用上述方法实现的 Singleton 类变成是可序列化的 （ Serializable ）（详见第 12 章），仅仅在声明中加上 implements Serializable 是不够的 。 为了维护并保证 Singleton, 必须声明所有实例域都是瞬时（ transient 关键字）的， 并提供一个 readResolve 方法（详见第四条） 。 否则 ，每次反序列化一个序列化的实例时都会创建一个新的实例 ，比如， 在我们的例子中， 会导致“假冒的 Elvis”。为了防止发生这种情况， 要在 Elvis 类中加入如下 readResolve 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// readResolve method to preserve singleton property</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// return the one ture Elvis and let the garbage collector</span><br>    <span class="hljs-comment">// take care of the Elvis impersonator.</span><br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现 Singleton 的第三种方法是声明一个包含单个元素的枚举类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item3.enumtype;<br><br><span class="hljs-comment">// Enum singleton - the preferred approach (Page 18)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Elvis</span> </span>&#123;<br>    INSTANCE;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leaveTheBuilding</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Whoa baby, I&#x27;m outta here!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// This code would normally appear outside the class!</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Elvis elvis = Elvis.INSTANCE;<br>        elvis.leaveTheBuilding();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种方法在功能上与公有域方法相似， 但更加简洁， 无偿地提供了序列化机制， 绝对防止多次实例化， 即使是在面对复杂的序列化或者反射攻击的时候 。 虽然这种方法还没有广泛采用， 但是单元素 的枚举类型经常成为实现 Singleton 的最佳方法。 注意， 如果 Singleton 必须扩展一个超类， 而不是扩展 Enum 的时候， 则不宜使用这个方法（虽然可以声明枚举去实现接口） 。</p>
<h2 id="第四条-通过私有构造器强化不可实例化的能力"><a href="#第四条-通过私有构造器强化不可实例化的能力" class="headerlink" title="第四条 通过私有构造器强化不可实例化的能力"></a>第四条 通过私有构造器强化不可实例化的能力</h2><p>有时可能需要编写只包含静态方法和静态域的类 。 这些类的名声很不好， 因为有些人在面向对象的语言中滥用这样的类来编写过程化的程序，但它们也确实有特别的用处。 我们可以利用这种类， 以 java.lang.Math 或者 java.util.Arrays 的方式， 把基本类型的值或者数组类型上的相关方法组织起来 。 我们也可以通过 java.util.Collections的方式， 把实现特定接口的对象上的静态方法， 包括工厂方法（详见第1条）组织起来 。 （从 Java 8 开始， 也可以把这些方法放进接口中， 假定这是你自己编写的接口可以进行修改 。 ） 最后， 还可以利用这种类把 final 类上的方法组织起来， 因为不能把它们放在子类中 。</p>
<p>这样的 工具 类（ utility class ）不希望被实例化， 因为实例化对它没有任何意义。 然而 ， 在缺少显式构造器的情况下， 编译器会自动提供一个公有的 、 无参的缺省构造器（ default constructor ） 。 对于用户而言， 这个构造器与其他的构造器没有任何区别 。 在已发行的 API 中常常可以看到一些被无意识地实例化的类 。</p>
<p>企图通过将类做成抽 象类 来强制该类不可被实例化是行不通的。 该类可以被子类化 ，并且该子类也可以被实例化。 这样做甚至会误导用户，以为这种类是专门为了继承而设计的 （详见第 19 条） 。 然而，有一些简单的习惯用法可以确保类不可被实例化。 由于只有当类不 包含显式的构造器时－，编译器才会生成缺省的构造器，因此只要让这个类包含一个私有构造器，它就不能被实例化 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item4;<br><br><span class="hljs-comment">// Noninstantiable utility class (Page 19)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UtilityClass</span> </span>&#123;<br>    <span class="hljs-comment">// Suppress default constructor for noninstantiability</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">UtilityClass</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();<br>    &#125;<br><br>    <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于显式的构造器是私有的，所以不可以在该类的外部访问它 。 AssertionError 不是必需的，但是它可以避免不小心在类的 内部调用构造器。 它保证该类在任何情况下都不会被实例化。 这种习惯用法有点违背直觉，好像构造器就是专门设计成不能被调用一样 。 因此，明智的做法就是在代码中增加一条注释，如上所示 。</p>
<p>这种习惯用法也有副作用，它使得一个类不能被子类化。 所有的构造器都必须显式或 隐式地调用超类（ superclass ）构造器，在这种情形下，子类就没有可访问的超类构造器可调用了 。</p>
<h2 id="第五条-优先考虑依赖注人来引用资源"><a href="#第五条-优先考虑依赖注人来引用资源" class="headerlink" title="第五条 优先考虑依赖注人来引用资源"></a>第五条 优先考虑依赖注人来引用资源</h2><p>!!! 理解一下，资源是什么东西？  一个类中的字段分类  属性  和  资源，暂时这样理解吧！</p>
<p>有许多类会依赖一个或多个底层的资源 。 例如，拼写检查器需要依赖词典。 下面这样把类实现为静态工具类的做法并不少见（详见第 4 条）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpellChecker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Lexicon directionary = ...;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SpellChecker</span><span class="hljs-params">(...)</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String word)</span> </span>&#123;...&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">suggestions</span><span class="hljs-params">(String typo)</span> </span>&#123;...&#125;;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样地，将这些类实现为 Singleton 的做法也并不少见（详见第 3 条）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpellChecker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Lexicon directionary = ...;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SpellChecker</span><span class="hljs-params">(...)</span> </span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> INSTABCE = <span class="hljs-keyword">new</span> SpellChecker(...);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String word)</span> </span>&#123;...&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">suggestions</span><span class="hljs-params">(String typo)</span> </span>&#123;...&#125;;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上两种方法都不理想，因为它们都是假定只有一本词典可用 。 实际上，每一种语言都有自己的词典， 特殊词汇还要使用特殊的词典。 此外， 可能还需要用特殊的词典进行测试。 因此假定用一本词典， 就能满足所有需求， 这简直是痴心妄想。</p>
<p>建议尝民用 SpellChecker 来支持多词典， 即在现有的拼写检查器中， 设 dictionary 域为 non final ，并 添加1一个方法用它来修改词典， 但是这样的设置会显得很笨拙、容易出 错，并且无法并行工作 。 静态工具类和 S ingleto n 类不适合于需要引用底层资源的类 。</p>
<p>这里需要的是能够支持类的多个实例（在本例中是指SpellChecker ），每一个实例都使用客户端指定的资源（在本例中是指同典） 。 满足该需求的最简单的模式是， 当创 建一个 新的实例时 ， 就将该资源传到构造器中 。 这是依赖注入（ dependency injection ）的一种形式： 词典（ dictionary ）是拼写检查器的一个依赖（ dependency ），在创建拼写检查器时就将词典注 入（ injected ）其中 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Dependency injection provides flexiblity and testability</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpellChecker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lexicon directionary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SpellChecker</span><span class="hljs-params">(Lexicon dictionary)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.directionary = directionary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String word)</span> </span>&#123;...&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">suggestions</span><span class="hljs-params">(String typo)</span> </span>&#123;...&#125;;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>依赖注入模式就是这么简单， 因此许多程序员使用多年， 却不知道它还有名字呢。 虽然这个拼写检查器的范例中只有一个资源（词典）， 但是依赖注入却适用于任意数量的资源， 以及任意的依赖形式。 依赖注入的对象资源具有不可变性（详见第 17 条）， 因此多个客户端 可以共享依赖对象（假设客户端们想要的是同一个底层资惊 ）。依赖注入也同样适用于构造器、静态工厂（详见第1条）和构建器（详见第 2 条） 。</p>
<p>这个程序模式的另一种有用的变体是， 将资源工厂（ factory ）传给构造器。 工厂是可以被重复调用来创建类型实例的一个对象。 这类工厂具体表现为工厂方法（ Factory Method) 模式［ Gamma95 J 。 在 Java 8 中增加的接口 Supplier＜T&gt;， 最适合用于表示工厂 。 带有 Supplier&lt;T&gt;的方法， 通常应该限制输入工厂的类型参数使用有限制的通配符类 型 ( bounded wildcard type ），详见第 31 条，以便客户端能自多传入一个工厂， 来创建指定类型的任意子类型。马赛克：例如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Mosaic <span class="hljs-title">create</span><span class="hljs-params">(Supplier＜? extends Tile&gt;)</span> </span>&#123; ... &#125;;<br></code></pre></td></tr></table></figure>
<p>虽然依赖注人极大地提升了灵活性和可测试性， 但它会导致大型项目凌乱不堪， 因为它 通常包含上千个依赖。 不过这种凌乱用一个依赖、注入框架（ dependency injection framework ) 便可以终结， 如 Dagger [Dagger］ 、 Guice [Guice］或者 Spring [Spring］ 。 这些框架的用法超 出 了本书的讨论范畴， 但是， 请注意：设计成手动依赖注入的 A凹， 一般都适用于这些框架 。</p>
<p>总而言之，不要用 Singleton 和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为 ；也不要直接用这个类来创建这些资源 。 而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类。 这个实践就被称 作依赖注入，它极大地提升了类的灵活性 、 可重用性和可测试性 。</p>
<h2 id="第六条-避免创建不必要的对象"><a href="#第六条-避免创建不必要的对象" class="headerlink" title="第六条 避免创建不必要的对象"></a>第六条 避免创建不必要的对象</h2><p>一般来说，最好能重用单个对象，而不是在每次需要 的时候就创建一个相同功能的新对象。 重用方式既快速，又流行。 如果对象是不可变的（immutable) （详见第 17 条），它就始终可以被重用。</p>
<p>作为一个极端的反面例子，看看下面的语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;bikini&quot;</span>);   <span class="hljs-comment">//DON&#x27;T DO THIS!</span><br></code></pre></td></tr></table></figure>
<p>该语句每次被执行的时候都创建一个新的 String 实例，但是这些创建对象的动作全都是不必要的 。 传递给 String 构造器的参数（”bikini”）本身就是一个 String 实例， 功能方面等同于构造器创建的所有对象。 如果这种用法是在一个循环中，或者是在一个被频繁调用的方法中，就会创建出成千上万不必要的 String 实例 。</p>
<p>改进后的版本如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;bikini&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>这个版本只用了 一个 String 实例，而不是每次执行的 时候都创建一个新的实例 。 而 且，它可以保证，对于所有在同一台虚拟机中运行的代码，只要它们包含相同的字符串 字面 常量，该对象就会被重用［ JLS , 3 .10. 5 ］。</p>
<p>对于同时提供了静态 工厂方法 （ static factory method) （详见第 l 条）和构造器的不可变 类，通常优先使用静态工厂方法而不是构造器，以避免创建不必要的对象。 例如，静态工厂 方法 Boolean. valueOf (String ）几乎总是优先于构造器 Boolean(String ），注意 构造器 Boolean(String ）在 Java 9 中已经被废弃了 。 构造器在每次被调用的时候都会创 建一个新的对象，而静态工厂方法则从来不要求这样做，实际上也不会这样做。 除了重用不 可变的对象之外，也可以重用那些已知不会被修改的可变对象。</p>
<p>有些对象创建的成本比其他对象要高得多 。 如果重复地需要这类“昂贵的对象”，建议将它缓存下来重用 。 遗憾的是，在创建这种对象的时候，并非总是那么显而易见 。 假设想要编写一个方法，用它确定一个字符串是否为一个有效的罗马数字。 下面介绍一种最容易的方 法，使用一个正则表达式 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item6;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">// Reusing expensive object for improved performance (Pages 22 and 23)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RomanNumerals</span> </span>&#123;<br>    <span class="hljs-comment">// Performance can be greatly improved! (Page 22)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRomanNumeralSlow</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.matches(<span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>                + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Reusing expensive object for improved performance (Page 23)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Pattern ROMAN = Pattern.compile(<br>            <span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>                    + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRomanNumeralFast</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ROMAN.matcher(s).matches();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> numSets = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> numReps = Integer.parseInt(args[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numSets; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numReps; j++) &#123;<br>                b ^= isRomanNumeralSlow(<span class="hljs-string">&quot;MCMLXXVI&quot;</span>);  <span class="hljs-comment">// Change Slow to Fast to see performance difference</span><br>            &#125;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println(((end - start) / (<span class="hljs-number">1_000.</span> * numReps)) + <span class="hljs-string">&quot; μs.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Prevents VM from optimizing away everything.</span><br>        <span class="hljs-keyword">if</span> (!b)<br>            System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个实现的问题在于它依赖 String . matches 方法。虽然 String.matches 方法最易于查看一个字符串是否与正则表达式相匹配 ， 但并不适合在注重性能的情形中重复使用 。 问 题在于 ， 它在 内部为正则表达式创建了一个 Pattern 实例，却只用了一次，之后就可以进 行垃圾回收了 。 创建 Pattern 实例的成本很高 ，因为需要将正则表达式编译成一个有限状 态机（ finite state machine ） 。</p>
<p>为了提升性能，应该显式地将正则表达式编译成一个 Pattern 实例（不可变），让它成 为类初始化的一部分，并将它缓存起来，每当调用 isRomanNumeral 方法的时候就重用同 一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item6;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">// Reusing expensive object for improved performance (Pages 22 and 23)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RomanNumerals</span> </span>&#123;<br>    <span class="hljs-comment">// Performance can be greatly improved! (Page 22)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRomanNumeralSlow</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.matches(<span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>                + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Reusing expensive object for improved performance (Page 23)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Pattern ROMAN = Pattern.compile(<br>            <span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>                    + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRomanNumeralFast</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ROMAN.matcher(s).matches();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> numSets = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> numReps = Integer.parseInt(args[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numSets; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numReps; j++) &#123;<br>                b ^= isRomanNumeralSlow(<span class="hljs-string">&quot;MCMLXXVI&quot;</span>);  <span class="hljs-comment">// Change Slow to Fast to see performance difference</span><br>            &#125;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println(((end - start) / (<span class="hljs-number">1_000.</span> * numReps)) + <span class="hljs-string">&quot; μs.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Prevents VM from optimizing away everything.</span><br>        <span class="hljs-keyword">if</span> (!b)<br>            System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>改进后的 isRomanNumeral 方法如果被频繁地调用，会显示出明显的性能优势。 在我的机器上，原来的版本在一个 8 字符 的输入字符串上花了 1.1 川，而改进后的版本只花了 0.17 µs ，速度快了 6.5 倍。 除了提高性能之外，可以说代码也更清晰了 。 将不可见的 Pattern 实例做成 final 静态域时，可以给它起个名字，这样会比正则表达式本身更有可读性。</p>
<p>如果包含改进后的工 sRomanNumeral 方法的类被初始化了，但是该方法没有被调用，那就没必要初始化 ROMAN 域。通过在 isRomanNumeral 方法第一次被调用的时候延迟初始化（ lazily initializing) （ 详见第 83 条）这个域，有可能消除这个不必要 的初始化工作，但 是不 建议这样做。 正如延迟初始化中常见的情况一样，这样做会使方法的实现更加复杂，从 而无法将性能显著提高到超过已 经达到的水平（详见第 67 条） 。</p>
<p>如果一个对象是不变的，那么它显然能够被安全地重用，但其他有些情形则并不总是 这么明显 。 考虑适配器（ adapter ）的情形［ Gamma95 ］ ，有时也叫作视图（ view ） 。 适配器是 指这样一个对象 ： 它把功能委托给一个后备对象（ backing object ），从而为后备对象提供一 个可以替代的接口 。 由于适配器除了后备对象之外， 没有其他的状态信息，所以针对某个给 定对象的特定适配器而言，它不需要创建多个适配器实例 。</p>
<p>例如 ，Map 接口 的 keySet 方法返回该 Map 对象的 Set 视图，其 中包含该 Map 中所有的键（ key ） 。 乍看之下 ，好像每次调用 keySet 都应该创建一个新 的 Set 实例，但是， 对于一个给定的 Map 对象，实际上每次调用 keySe t 都返回同样的 Set 实例 。 虽然被返回 的 Set 实例一般是可改变的，但是所有返回的对象在功能上是等同的 ： 当其中一个返回对 象发生变化的时候，所有其他的返回对象也要发生变化，因为它们是由 同一个 Map 实例支 撑的 。 虽然创建 key Set 视图对象的多个实例并无害处， 却是没有必要，也没有好处的。</p>
<p>另一种创建多余对象的方法，称作自动装箱（ autoboxing ），它允许程序员将基本类型和 装箱基本类型（ Boxed Primitive Type ）混用，按需要自动装箱和拆箱 。 自动装箱使得基本类 型和装箱基本类型之间的差别变得模糊起来， 但是并没有完全消除 。 它们在语义上还有着微妙的差别，在性能上也有着比较明显的差别（详见第 61 条） 。 请看下面的程序，它计算所有 int 正整数值的总和 。 为此，程序必须使用 long 算法，因为 int 不够大，无法容纳所有 int 正整数值的总和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item6;<br><br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-comment">// Hideously slow program! Can you spot the object creation? (Page 24)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>        Long sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt;= Integer.MAX_VALUE; i++)<br>            sum += i;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> numSets = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">long</span> x = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numSets; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            x += sum();<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println((end - start) / <span class="hljs-number">1_000_000.</span> + <span class="hljs-string">&quot; ms.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Prevents VM from optimizing away everything.</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">42</span>)<br>            System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段程序算出的答案是正确的，但是比实际情况要更慢一些，只因为打错了一个字 符 。 变量 sum 被声明成 Long 而不是 long ，意味着程序构造了大约 231 个多余的 Long 实 例（大约每次往 Long sum 中增加 long 时构造一个实例） 。 将 sum 的声明从 Long 改成 long ，在我的机器上使运行时间从 6.3 秒减少到了 0 . 59 秒。 结论很明显 ： 要优先使用 基本 类型而不是装箱基本类型，要当心无意识的自动装箱。</p>
<p>不要错误地认为本条目所介绍的内容暗示着“创建对象的代价非常昂贵，我们应该要 尽可能地避免创建对象” 。 相反，由于小对象的构造器只做很少量的显式工作，所以小对象 的创建和回收动作是非常廉价的，特别是在现代的 JVM 实现上更是如此。 通过创建附加的 对象，提升程序的清晰性、简洁性和功能性，这通常是件好事 。</p>
<p>反之，通过维护自己的对象池（ object pool ）来避免创建对象并不是一种好的做法，除 非池中的对象是非常重量级的 。 正确使用对象池的典型对象示例就是数据库连接池。 建立数 据库连接的代价是非常昂贵的，因此重用这些对象非常有意义 。 而且，数据库的许可可能限制你只能使用一定数量的连接 。 但是，一般而言，维护自己的对象池必定会把代码弄得很乱，同时增加内存占用（ footprint ），并且还会损害性能 。 现代的 JVM 实现具有高度优化的垃圾回收器，其性能很容易就会超过轻量级对象池的性能 。</p>
<p>与本条目对应的是第 50 条中有关“保护性拷贝”（ defensive copying ）的内容 。 本条目 提及“当你应该重用现有对象的时候，请不要创建新的对象”,而第50条则说“当你应该创建新对象的时候，请不要重用现有的对象” 。 注意，在提倡使用保护性拷贝的时候，因重用 对象而付出的代价要远远大于因创建重复对象而付出的代价 。 必要时如果没能实施保护性拷贝，将会导致潜在的 Bug 和安全漏洞；而不必要地创建对象则只会影响程序的风格和性能。</p>
<h2 id="第七条-消除过期对象的引用"><a href="#第七条-消除过期对象的引用" class="headerlink" title="第七条 消除过期对象的引用"></a>第七条 消除过期对象的引用</h2><p>当你从手工管理内存的语言（比如 C 或 C＋＋）转换到具有垃圾回收功能的比如 Java 语言时，程序员的工作会变得更加容易，因为当你用完了对象之后，它们会被自动回收。 当你 第一次经历对象回收功能的时候，会觉得这简直有点不可思议。 它很容易给你留下这样的印 象， 认为自己不再需要考虑内存管理的事情了，其实不然。</p>
<p>请看下面这个简单的战实现的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item7;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">// Can you spot the &quot;memory leak&quot;?  (Pages 26-27)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] elements;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stack</span><span class="hljs-params">()</span> </span>&#123;<br>        elements = <span class="hljs-keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Object e)</span> </span>&#123;<br>        ensureCapacity();<br>        elements[size++] = e;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();<br>        <span class="hljs-keyword">return</span> elements[--size];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Ensure space for at least one more element, roughly</span><br><span class="hljs-comment">     * doubling the capacity each time the array needs to grow.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (elements.length == size)<br>            elements = Arrays.copyOf(elements, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-comment">//    // Corrected version of pop method (Page 27)</span><br><span class="hljs-comment">//    public Object pop() &#123;</span><br><span class="hljs-comment">//        if (size == 0)</span><br><span class="hljs-comment">//            throw new EmptyStackException();</span><br><span class="hljs-comment">//        Object result = elements[--size];</span><br><span class="hljs-comment">//        elements[size] = null; // Eliminate obsolete reference</span><br><span class="hljs-comment">//        return result;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stack stack = <span class="hljs-keyword">new</span> Stack();<br>        <span class="hljs-keyword">for</span> (String arg : args)<br>            stack.push(arg);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)<br>            System.err.println(stack.pop());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段程序（它的泛型版本请见第 29 条）中并没有很 明显的错误。 无论如何测试，它都 会成功地通过每一项测试，但是这个程序中隐藏着一个问题。 不严格地讲，这段程序有一个 “内存泄漏”，随着垃圾回收器活动的增加，或者由于内存占用的不断增加，程序性能的降低 会逐渐表现出来 。 在极端的情况下，这种内存泄漏会导致磁盘交换（ Disk Paging ），甚至导 致程序失败（ OutOfMemoryError 错误），但是这种失败情形相对比较少见。</p>
<p>那么，程序中哪里发生了内存泄漏呢？ 如果一个战先是增长 ，然后再收缩 ， 那么，从 校中弹出来的对象将不会被当作垃圾回收，即使使用校的程序不再引用这些对象，它们也 不会被回收。 这是因为校内部维护着对这些对象的过期引用 （ obsolete reference ） 。 所谓的过 期引用，是指永远也不会再被解除的引用 。 在本例中，凡是在 elements 数组的“活动部分” (active portion ）之外的任何引用都是过期的 。 活动部分是指 elements 中下标小于 size 的那 些元素 。</p>
<p>在支持垃圾回收的语言中，内存泄漏是很隐蔽的（称这类内存泄漏为“无意识的对象保持”（ unintentional object retention ）更为恰当） 。 如果一个对象引用被无意识地保留起来了， 那么垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对 象 。 即使只有少量的几个对象引用被无意识地保留下来，也会有许许多多的对象被排除在垃 圾回收机制之外，从而对性能造成潜在的重大影响 。</p>
<p>这类问题的修复方法很简单 ： 一旦对象引用已经过期，只需清空这些引用即可 。 对于 上述例子中的 Stack 类而言，只要一个单元被弹出拢，指向它的引用就过期了 。 pop 方法 的修订版本如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//    // Corrected version of pop method (Page 27)</span><br><span class="hljs-comment">//    public Object pop() &#123;</span><br><span class="hljs-comment">//        if (size == 0)</span><br><span class="hljs-comment">//            throw new EmptyStackException();</span><br><span class="hljs-comment">//        Object result = elements[--size];</span><br><span class="hljs-comment">//        elements[size] = null; // Eliminate obsolete reference</span><br><span class="hljs-comment">//        return result;</span><br><span class="hljs-comment">//    &#125;</span><br></code></pre></td></tr></table></figure>
<p>清空过期引用的另一个好处是，如果它们以后又被错误地解除引用，程序就会立即抛出 Null Po 工nterException 异常，而不是悄悄地错误运行下去 。 尽快地检测出程序中的错误总是有益的 。</p>
<p>当程序员第一次被类似这样的问题困扰的时候，他们往往会过分小心 ： 对于每一个对象 引用，一旦程序不再用到它，就把它清空 。 其实这样做既没必要，也不是我们所期望的，因 为这样做会把程序代码弄得很乱。 清空对象引用应该是一种例外 ， 而不是一种规范行为 。 消 除过期引用最好的方法是让包含该引用的变量结束其生命周期 。 如果你是在最紧凑的作用域 范围内定义每一个变量（详见第 57 条），这种情形就会自然而然地发生 。</p>
<p>那么，何时应该清空引用呢？ Stack 类的哪方面特性使它易于遭受 内存泄漏的影响呢？ 简而言之，问题在于， Stack 类自己管理内存。 存储池（ storage pool ）包含了 elements 数 组（对象引用单元，而不是对象本身）的元素 。 数组活动区域（同前面的定义）中的元素是 己分配的（ allocated ），而数组其余部分的元素则是自由的（ free ） 。 但是垃圾回收器并不知道 这一点；对于垃圾回收器而言， elements 数组中的所有对象引用都同等有效 。 只有程序员知 道数组的非活动部分是不重要的 。 程序员可以把这个情况告知垃圾回收器，做法很简单：一 旦数组元素变成了非活动部分的一部分，程序员就手工清空这些数组元素 。</p>
<p>一般来说 ， 只要类是自己管理内存，程序员就应该警惕内存泄漏问题。 一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空。</p>
<p>内存泄漏的另一个常见来源是缓存。 一旦你把对象引用放到缓存中，它就很容易被遗忘掉，从而使得它不再有用之后很长一段时间内仍然留在缓存中 。 对于这个问题，有几种可能的解决方案 。 如果你正好要实现这样的缓存：只要在缓存之外存在对某个项的键的引用， 该项就有意义，那么就可以用 WeakHashMap 代表缓存；当缓存中的项过期之后，它们就会自动被删除。 记住只有当所要的缓存项的生命周期是由该键的外部引用而不是由值决定时，WeakHashMap 才有用处。</p>
<p>更为常见的情形则是，“缓存项的生命周期是否有意义”并不是很容易确定，随着时间 的推移，其中的项会变得越来越没有价值。 在这种情况下，缓存应该时不时地清除掉没用的 项 。 这项清除工作可以由一个后台线程 （ 可能是 ScheduledThreadPoolExecutor ）来 完成，或者也可以在给缓存添加新条目的时候顺便进行清理。 LinkedHashMap 类利用它 的 removeEldestEntry 方法可以很容易地实现后一种方案 。 对于更加复杂的缓存，必须直接使用 java.lang.ref。</p>
<p>内存泄漏的第三个常见来源是监昕器和其他回调 。 如果你实现了一个 API，客户端在 这个 API 中注册回调，却没有显式地取消注册，那么除非你采取某些动作，否则它们就会 不断地堆积起来 。 确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用 （ weak reference ） ，例如，只将它们保存成 WeakHashMap 中的键。</p>
<p>由于内存泄漏通常不会表现成明显的失败，所以它们可以在一个系统中存在很多年。 往往只有通过仔细检查代码，或者借助于 Heap 剖析工具（ Heap Profiler ）才能发现内存泄漏问题。 因此，如果能够在内存泄漏发生之前就知道如何预测此类问题，并阻止它们发生，那是最好不过的了 。</p>
<h2 id="第八条-避免使用终结方法和清除方法"><a href="#第八条-避免使用终结方法和清除方法" class="headerlink" title="第八条 避免使用终结方法和清除方法"></a>第八条 避免使用终结方法和清除方法</h2><p>终结方法（ finalize「）通常是不可预测的，也是很危险的，一般情况下是不必要的 。 使 用终结方法会导致行为不稳定 、 性能降低，以及可移植性问题。 当然，终结方法也有其可用 之处，我们将在本条目的最后再做介绍；但是根据经验，应该避免使用终结方法 。 在 Java 9 中用清除方法（ cleaner ）代替了终结方法。 清除方法没有终结方法那么危险，但仍然是不可 预测、运行缓慢，一般情况下也是不必要的 。</p>
<p>C＋＋的程序员被告知“不要把终结方法当作是 C＋＋中析构器（ destructors ）的对应物” 。 在 C＋＋中，析构器是回收一个对象所占用资源的常规方法，是构造器所必需的对应物 。 在 Java 中，当一个对象变得不可到达的时候，垃圾回收器会回收与该对象相关联的存储空间， 并不需要程序员做专 门 的工作 。 C＋＋的析构器也可以被用来回收其他的非内存资源。 而在 Java 中，一般用 try-fi口ally 块来完成类似的工作（详见第 9 条） 。</p>
<p>终结方法和清除方法的缺点在于不能保证会被及时执行 ［ JLS . 12.6 ］。 从一个对象变得 不可到达开始，到它的终结方法被执行，所花费的这段时间是任意长的 。 这意味着， 注重时间（ time-critical ）的任务不应该由终结方法或者清除方法来完成。 例如，用终结方法或者清除方法来关闭已经打开的文件，就是一个严重的错误，因为打开文件的描述符是一种很有限的资源 。 如果系统元法及时运行终结方法或者清除方法就会导致大量的文件仍然保留在打开状态，于是当一个程序再也不能打开文件的时候，它可能会运行失败。</p>
<p>及时地执行终结方法和清除方法正是垃圾回收算法的一个主要功能，这种算法在不同 的 JVM 实现中会大相径庭。 如果程序依赖于终结方法或者清除方法被执行的时间点，那么这个程序的行为在不同的 JVM 中运行的表现可能就会截然不同 。 一个程序在你测试用的 JVM 平台上运行得非常好，而在你最重要顾客的 JVM 平台上却根本无法运行，这是完全有可能的 。</p>
<p>延迟终结过程并不只是一个理论问题。 在很少见的情况下，为类提供终结方法，可能会随意地延迟其实例的回收过程。 一位同事最近在调试一个长期运行的 GUI 应用程序的时候，该应用程序莫名其妙地出现 OutOfMemoryError 错误而死掉 。 分析表明，该应用程序死掉的时候，其终结方法队列中有数千个图形对象正在等待被终结和回收 。 遗憾的是，终结方法线程的优先级比该应用程序的其他线程的优先级要低得多，所以，图形对象的终结速度达不到它们进入队列的速度 。 Java语言规范并不保证哪个线程将会执行终结方法，所以， 除了不使用终结方法之外，并没有很轻便的办法能够避免这样的问题。 在这方面，清除方法比终结方法稍好一些，因为类的设计者可以控制自己的清除线程， 但清除方法仍然在后台运行，处于垃圾回收器的控制之下，因此不能确保及时清除。</p>
<p>Java 语言规范不仅不保证终结方法或者清除方法会被及时地执行，而且根本就不保证 它们会被执行 。 当一个程序终止的时候，某些已经无法访问的对象上的终结方法却根本没有 被执行，这是完全有可能的 。 结论是： 永远不应该依赖终结方法或者清除方法来更新重要的 持久状态。 例如，依赖终结方法或者清除方法来释放共享资源（比如数据库）上的永久锁， 这很容易让整个分布式系统垮掉。</p>
<p>不要被 System . gc 和 System.runFinalization 这两个方法所诱惑，它们确实增加了终结方法或者清除方法被执行的机会，但是它们并不保证终结方法或者清除方法一定会被执行。 唯一声称保证它们会被执行的两个方法是 System . runFinal 工 zersOnExit, 及其臭名昭著的孪生兄弟 Runtime . runFinalizersOnExit 。 这两个方法都有致命的缺 陷，井且已经被废弃很久了［ ThreadStop ］ 。</p>
<p>使用终结方法的另一个问题是：如果忽略在终结过程中被抛出来的未被捕获的异常，该 对象的终结过程也会终止 ［ JLS, 12 . 6 ］ 。 未被捕获的异常会使对象处于破坏的状态（ corrupt state ），如果另 一个线程企图使用这种被破坏的对象，则可能发生任何不确定的行为 。 正常 情况下，未被捕获的异常将会使线程终止，并打印出战轨迹（ Stack Trace ），但是，如果异常 发生在终结方法之中，则不会如此，甚至连警告都不会打印出来 。 清除方法没有这个问题， 因为使用清除方法的一个类库在控制它的线程 。</p>
<p>使用终结方法和清除方法有一个非常严重的性能损失 。 在我的机器上，创建一个简单 的 AutoCloseable 对象，用 try-with-resources 将它关闭，再让垃圾回收器将它回 收，完成这些工作花费的时间大约为 12ns 。 增加一个终结方法使时间增加到了 550ns。 换句 话说，用终结方法创建和销毁对象慢了大约 50 倍。 这主要是因为终结方法阻止了有效的垃 圾回收 。 如果用清除方法来清除类的所有实例 ，它的速度 比终结方法会稍微快一些（在我的 机器上大约是每个实例花 500ns ），但如果只是把清除方法作为一道安全网（ safety net ），下面将会介绍，那么清除方法的速度还会更快一些 。 在这种情况下，创建、清除和销毁对象，在我的机器上花了大约 66ns ，这意味着，如果没有使用它，为了确保安全网多花了 5 倍（而 不是 50 倍）的代价 。</p>
<p>终结方法有一个严重的安全问题： 它们为终结方法攻击（ finalizer attack ） 打开了类的大 门。 终结方法攻击背后的思想很简单：如果从构造器或者它的序列化对等体（ readObject 和 readResolve 方法，详见第 12 章）抛出异常，恶意子类的终结方法就可以在构造了 一 部分的应该已经半途夭折的对象上运行 。 这个终结方法会将对该对象的引用记录在一个静态 域中，阻止它被垃圾回收 。 一旦记录到异常的对象，就可以轻松地在这个对象上调用任何原 本永远不允许在这里出现的方法 。 从构造器抛出的异常，应该足以防止对象继续存在；有了 终结方法的存在，这一点就做不到了 。 这种攻击可能造成致命的后果 。 final 类不会受到终 结方法攻击，因为没有人能够编写出 final 类的恶意子类 。 为了防止非 final 类受到终结方法 攻击 ， 要编写一个空的 final 的 finalize 方法。</p>
<p>那么，如果类的对象中封装的资源（例如文件或者线程）确实需要终止，应该怎么做 才能不用编写终结方法或者清除方法呢？只需 让类实现 AutoCloseable，并要求其客户端 在每个实例不再需要的时候调用 close 方法，一般是利用 try - with - resources 确保 终止，即使遇到异常也是如此（详见第 9 条） 。 值得提及的一个细节是，该实例必须记录 下自己是否已经被关闭了： close 方法必须在一个私有域中记录下“该对象已经不再有效” 。 如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域，并抛出IllegalStateException 异常 。</p>
<p>那么终结方法和清除方法有什么好处呢？它们有两种合法用途。 第一种用途是，当资源的所有者忘记调用它的 close 方法时，终结方法或者清除方法可以充当“安全网”。虽然这样做井不能保证终结方法或者清除方法会被及时地运行，但是在客户端无法正常结束操作的情况下，迟一点释放资源总比永远不释放要好。 如果考虑编写这样的安全网终结方法，就要认真考虑清楚，这种保护是否值得付出这样的代价。 有些 Java 类（如 FileinputStream 、FileOutputStream 、ThreadPoolExecutor 和 java.sql.Connection ）都具有能充当安全网的终结方法 。</p>
<p>清除方法的第二种合理用途与对象的本地对等体（ native peer ）有关。 本地对等体是一 个本地（非 Java 的）对象（ native object ），普通对象通过本地方法（ native method ）委托给 一个本地对象。 因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的 Java 对等体被回收的时候，它不会被回收。 如果本地对等体没有关键资源，并且性能也可以接受的话，那么清除方法或者终结方法正是执行这项任务最合适的工具。 如果本地对等体拥有必须被及时终止的资源，或者性能无法接受，那么该类就应该具有一个 close 方法， 如前所述。</p>
<p>清除方法的使用有一定的技巧 。 下面以一个简单的 Room 类为例 。 假设房间在收回之前 必须进行清除。 Room 类实现了 AutoCloseable ；它利用清除方法自动清除安全网的过程 只不过是一个实现细节 。 与终结方法不同的是，清除方法不会污染类的公有 API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item8;<br><br><span class="hljs-keyword">import</span> java.lang.ref.Cleaner;<br><br><span class="hljs-comment">// An autocloseable class using a cleaner as a safety net (Page 32)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AutoCloseable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cleaner cleaner = Cleaner.create();<br><br>    <span class="hljs-comment">// Resource that requires cleaning. Must not refer to Room!</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> numJunkPiles; <span class="hljs-comment">// Number of junk piles in this room</span><br><br>        State(<span class="hljs-keyword">int</span> numJunkPiles) &#123;<br>            <span class="hljs-keyword">this</span>.numJunkPiles = numJunkPiles;<br>        &#125;<br><br>        <span class="hljs-comment">// Invoked by close method or cleaner</span><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Cleaning room&quot;</span>);<br>            numJunkPiles = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// The state of this room, shared with our cleanable</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> State state;<br><br>    <span class="hljs-comment">// Our cleanable. Cleans the room when it’s eligible for gc</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Cleaner.Cleanable cleanable;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Room</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numJunkPiles)</span> </span>&#123;<br>        state = <span class="hljs-keyword">new</span> State(numJunkPiles);<br>        cleanable = cleaner.register(<span class="hljs-keyword">this</span>, state);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        cleanable.clean();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>内嵌的静态类 State 保存清除方法清除房 间所需的资源 。 在这个例子中，就是 num-JunkPiles 域，表示房间的杂乱度 。 更现实 地说，它可以 是 final 的 long， 包含一个指 向本地对等体的指针。 State 实现了 Runnable 接口，它的 run 方法最多被 Cleanable 调用一次 ，后者是我们在 Room 构造器中用清除器注册 State 实例时获得的 。 以下两种情 况之一会触发 run 方法的调用：通常是通过调用 Room 的 close 方法触发的，后者又调用 了 Cleanable 的清除方法 。 如 果到了 Room 实例应该被垃圾 回收时，客户端还没有调用 close 方法，清除方法就会（希望如此 ）调用 State 的 run 方法。</p>
<p>关键是 State 实例没有引用它的 Room 实例 。 如果它引用了，会造成循环，阻止 Room实例被垃圾回收 （以及防止被自动清除） 。 因 此 State 必须是一个静态的嵌套类，因为非 静态的嵌套类包含了对其外围实例的引用（详见第 24 条） 。 同样地，也不建议使用 lambda, 因为它们很容易捕捉到对外围对象的引用 。</p>
<p>如前所述， Room 的清除方法只用作安全网 。 如果客户端将所有的 Room 实例化都包在町with-resource 块中 ，将永远不会请求到自动清除。 用下面这个表现良好的客户端代码示范一下 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item8;<br><br><span class="hljs-comment">// Well-behaved client of resource with cleaner safety-net (Page 33)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adult</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (Room myRoom = <span class="hljs-keyword">new</span> Room(<span class="hljs-number">7</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Goodbye&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>正如所期待的一样，运行 Adult 程序会打印出 Goodbye ，接着是 Cleaning room。但是下面这个表现糟糕的程序又如何呢？ 哪一个将永远不会清除它 的房间？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item8;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">// Ill-behaved client of resource with cleaner safety-net (Page 33)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teenager</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Room(<span class="hljs-number">99</span>);<br>        System.out.println(<span class="hljs-string">&quot;Peace out&quot;</span>);<br><br>        <span class="hljs-comment">// Uncomment next line and retest behavior, but note that you MUST NOT depend on this behavior!</span><br><span class="hljs-comment">//      System.gc();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>你可能期望打印出 Peac e out ，然后是 Cleaning room ，但是在我 的机器 上，它 没有打印出 Cleaning room ，就退出程序了 。 这就是我们之前提到过的不可预见性 。 Cleaner 规范指出：“清除方法在 System.exit 期间的行为是与实现相关的 。 不确保清 除动作是否会被调用 。 ”虽然规范没有指明，其实对于正常的程序退出也是如此。 在我的机 器上，只要在 Teenager 的 main 方法上添加代码行 System . gc （），就足以让它在退出之前打印出 Cleaning room ，但是不能保证在你的机器上也能看到相同的行为 。</p>
<p>总而言之，除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用 清除方法，对于在 Java 9 之前的发行版本，则尽量不要使用终结方法。 若使用了终结方法 或者清除方法，则要注意它的不确定性和性能后果。</p>
<h2 id="第九条-try-with-resources-优先于-try-finally"><a href="#第九条-try-with-resources-优先于-try-finally" class="headerlink" title="第九条 try-with-resources 优先于 try-finally"></a>第九条 try-with-resources 优先于 try-finally</h2><p>Java 类库中包括许多必须通过调用 close 方法来手工关闭的资源。 例如 InputStream 、OutputStream 和 java.sql.Connection 。 客户端经常会忽略资源的关闭 ，造成严重的性能后果也就可想而知了。 虽然这其中的许多资源都是用终结方法作为安全网，但是效果并不理想（详见第 8 条） 。</p>
<p>根据经验， try -finally 语句是确保资源会被适时关闭的最佳方法，就算发生异常或 者返回也一样 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-finally - No longer the best way to close resources!</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">firstLineOfFile</span><span class="hljs-params">(String path)</span> throw IOException </span>&#123;<br>    Bufferedeader br = <span class="hljs-keyword">new</span> Bufferedeader(<span class="hljs-keyword">new</span> Fileeader(path));<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> br.readerLine().<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这看起来好像也不算太坏，但是如果再添加第二个资源，就会一团糟了 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-finally is ugly when used with more than one resource! (Page 34)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        InputStream in = <span class="hljs-keyword">new</span> FileInputStream(src);<br>        <span class="hljs-keyword">try</span> &#123;<br>            OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(dst);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[BUFFER_SIZE];<br>                <span class="hljs-keyword">int</span> n;<br>                <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>)<br>                    out.write(buf, <span class="hljs-number">0</span>, n);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                out.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            in.close();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这可能令人有点难以置信，不过就算优秀的程序员也会经常犯这样的错误 。 起先，我 曾经在《 Java Puzzlers &gt; [ Bloch05 ］ 第 88 页犯过这个错误，时隔多年竟然没有人发现。 事实上，在 2007 年，close 方法在 Java 类库中有 2/3 都用错了 。</p>
<p>即使用 try-finally 语句正确地关闭了资源，如前两段代码范例所示，它也存在着些许不足。因为在 try 块和 finally 块中的代码，都会抛出异常。例如在 firstLineOfFile方法中，如果底层的物理设备异常，那么调用 readLine 就会抛出异常，基于同样的原因， 调用 close 也会出现异常 。 在这种情况下，第二个异常完全抹除了第一个异常。 在异常堆 枝轨迹中，完全没有关于第一个异常的记录，这在现实的系统中会导致调试变得非常复杂， 因为通常需要看到第一个异常才能诊断出问题何在 。 虽然可以通过编写代码来禁止第二个异 常，保留第一个异常，但事实上没有人会这么做，因为实现起来太烦琐了 。</p>
<p>当 Java 7 引人 try-with刊sources 语句时［ JLS, 14.20.3 ］，所有这些问题一下子就全部 解决了 。 要使用这个构造的资源，必须先实现 AutoCloseable 接口，其中包含了单个返 回 void 的 close 方法 。 Java 类库与第三方类库中的许多类和接口，现在都实现或扩展了 AutoCloseable 接口 。 如果编写了 一个类，它代表的是必须被关闭的资源，那么这个类也应该实现 AutoCloseable 。</p>
<p>以下就是使用 try-with-resources 的第一个范例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item9.trywithresources;<br><br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopLine</span> </span>&#123;<br>    <span class="hljs-comment">// try-with-resources - the the best way to close resources!  (Page 35)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">firstLineOfFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<br>                <span class="hljs-keyword">new</span> FileReader(path))) &#123;<br>            <span class="hljs-keyword">return</span> br.readLine();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String path = args[<span class="hljs-number">0</span>];<br>        System.out.println(firstLineOfFile(path));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以下是使用 try-with-resources 的第二个范例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item9.trywithresources;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Copy</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BUFFER_SIZE = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// try-with-resources on multiple resources - short and sweet (Page 35)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span> (InputStream   in = <span class="hljs-keyword">new</span> FileInputStream(src);<br>             OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(dst)) &#123;<br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[BUFFER_SIZE];<br>            <span class="hljs-keyword">int</span> n;<br>            <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>)<br>                out.write(buf, <span class="hljs-number">0</span>, n);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String src = args[<span class="hljs-number">0</span>];<br>        String dst = args[<span class="hljs-number">1</span>];<br>        copy(src, dst);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用 try-with-resources 不仅使代码 变得更简洁易懂， 也更容易进行诊断。 以 first LineOfFile 方法为例，如果调用 readLine 和（不可见的） close 方法都抛出异常，后 一个异常就会被禁止，以保留第一个异常。 事实上，为了保留你想要看到的那个异常，即便 多个异常都可以被禁止。 这些被禁止的异常并不是简单地被抛弃了，而是会被打印在堆枝轨 迹中，并注明它们是被禁止的异常 。 通过编程调用 getSuppressed 方法还可以访问到它 们， getsuppres sed 方法也已经添加在 Java 7 的 Throwable 中了 。</p>
<p>在 try-with-resources 语句中还可以使用 catch 子句，就像在平时的 try -finally 语句中 一样。 这样既可以处理异常，又不需要再套用一层代码 。 下面举一个稍费了点心思的范例，这个 firstLineOfFile 方法没有抛出异常读取，就会返回一个默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item9.trywithresources;<br><br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopLineWithDefault</span> </span>&#123;<br>    <span class="hljs-comment">// try-with-resources with a catch clause  (Page 36)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">firstLineOfFile</span><span class="hljs-params">(String path, String defaultVal)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<br>                <span class="hljs-keyword">new</span> FileReader(path))) &#123;<br>            <span class="hljs-keyword">return</span> br.readLine();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">return</span> defaultVal;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String path = args[<span class="hljs-number">0</span>];<br>        System.out.println(firstLineOfFile(path, <span class="hljs-string">&quot;Toppy McTopFace&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结论很明显 ： 在处理必须关闭的资源时，始终要优先考虑用 try-with-resources ，而不是 用 try-finally 。 这样得到的代码将更加简洁、清晰，产生的异常也更有价值。 有了 try-with-resources 语句，在使用必须关闭的资源时，就能更轻松地正确编写代码了 。 实践证明，这个用 try-finally 是不可能做到的 。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/04/Effective-Java-5-%E8%8C%83%E5%9E%8B/">
                        <span class="hidden-mobile">Effective_Java_5_范型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2021/05/05/Effective-Java-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
