

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>Effective_Java_2_所有对象的通用方法 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Effective_Java_2_所有对象的通用方法">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-05 21:57" pubdate>
        2021年5月5日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      56
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Effective_Java_2_所有对象的通用方法</h1>
            
            <div class="markdown-body">
              <h1 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h1><p>尽管 Object 是一个具体类，但设计它主要是为了扩展。 它所有的非 final 方法（equals 、 hashCode 、 t oString 、 clone 和 finalize ）都有 明 确的通 用 约定（ general contract), 因为它们设计成是要被覆盖（ override ）的 。 任何一个类，它在覆盖这些方法的时·候，都有 责任遵守这些通用约定；如果不能做到这一点，其他依赖于这些约定的类（例如 HashMap 和 HashSet ）就无法结合该类一起正常运作 。</p>
<p>本章将讲述何时以及如何覆盖这些非 final 的 Object 方法。 本章不再讨论 finalize 方法，因为第 8 条已经讨论过这个方法了 。 而 Comparable . compareTo 虽然不是 Object 方法，但是本章也将对它进行讨论，因为它具有类似的特征 。</p>
<h2 id="第10条-覆盖equals时请遵守通用规定"><a href="#第10条-覆盖equals时请遵守通用规定" class="headerlink" title="第10条 覆盖equals时请遵守通用规定"></a>第10条 覆盖equals时请遵守通用规定</h2><p>覆盖 equals 方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重 。 最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个 实例都只与它 自身相等 。 如果满足了以下任何一个条件，这就正是所期望的结果 ：</p>
<ul>
<li><p>类的每个实例本质上都是唯一的 。 对于代表活动实体而不是值（ value ）的类来说确 实如 此 ，例如 Thread。 Object 提供的 equals 实 现对于这些类来说正是正确的 行为 。</p>
</li>
<li><p>类没有必要提供“逻辑相等”（ logical equality ）的测试功能。 例如， j ava . util . regex . Pattern 可以覆盖 equals ，以检查两个 Patter口实例是否代表 同 一个 正则表达式，但是设计者并不认为客户需要或者期望这样的功能。 在这类情况之下，从 Object 继承得到的 equals 实现已经足够了 。</p>
</li>
<li><p>超 类 已 经覆盖 了 equals ，超类的行为对于这个 类 也是合适的 。例如，大多数的Set 实现都从 Abstract Set 继承 equals 实现， List 实现从 AbstractList 继 承 equals 实现， Map 实现从 AbstractMap 继承 equals 实现 。</p>
</li>
<li><p>类是私 有的 ， 或者是包级私有的 ， 可以确定它的 equals 方法永远不会 被调用 。 果你非常想要规避风险，可以覆盖 equals 方法，以确保它不会被意外调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();  <span class="hljs-comment">// Method is never called</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么，什么时候应该覆盖 equals 方法呢？如果类具有自己特有的“逻辑相等”（ logical equality ）概念（不同于对象等同的概念），而且超类还没有覆盖 equals 。 这通常属于“值 类”（ value class ）的情形 。 值类仅仅是一个表示值的类，例如 Integer 或者 String。 程 序员在利用 equals 方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不 是想了解它们是否指向同一个对象。 为了满足程序员的要求，不仅必须覆盖 equa ls 方法， 而且这样做也使得这个类的实例可以被用作映射表（ map ）的键（ key ），或者集合（ set ）的元 素，使映射或者集合表现出预期的行为 。</p>
</li>
</ul>
<p>有一种“值类”不需要覆盖 equals 方法，即用实例受控（详见第 l 条）确保“每个 值至多只存在一个对象”的类 。 枚举类型（详见第 34 条）就属于这种类 。 对于这样的类而 言，逻辑相同与对象等同是一回事，因此 Object 的 equals 方法等同于逻辑意义上的equals 方法。</p>
<p>在覆盖 equals 方法的时候，必须要遵守它的通用约定 。 下面是约定的内容，来自Object 的规范 。</p>
<p>equals 方法实现了等价关系（ equivalence relation ），其属性如下：</p>
<p>0 自反性（ reflexive ） ： 对于任何非 null 的引用值 x x . equals(x ）必须返回 true 。 </p>
<p>口 对称性（ symmetric ）：对于任何非 null 的引用值 x 和 y ，当且仅当 y.equals(x ）返 回 true 时＇， x.equals(y ）必须返回 true 。 </p>
<p>口 传递性（ transitive ） ： 对于任何非 null 的引用值 x 、 y 和 z ，如果 x.equals(y ）返回true ，并且 y.equals(z ）也返回 true ，那么 x.equals(z ）也必须返回 true 0 </p>
<p>口 一致性（ consistent ） ： 对于任何非 null 的 引用值 x 和 y ，只要 equals 的比较操作 在对象中所用的信息没有被修改，多次调用 x.equals(y ）就会一致地返回 true, 或者一致地返回 false 。 </p>
<p>口 对于任何非 null 的引用值 x, x.equals (null ）必须返回 false 。</p>
<p>除非你对数学特别感兴趣，否则这些规定看起来可能有点让人感到恐惧，但是绝对不 要忽视这些规定 ！ 如果违反了，就会发现程序将会表现得不正常，甚至崩溃，而且很难找到 失败的根源 。 用 John Donne 的话说 ，没有哪个类是孤立的 。 一个类的实例通常会被频繁地 传递给另一个类的实例 。 有许多类，包括所有的集合类（ collection class ）在内，都依赖于传递给它们的对象是否遵守了 equals 约定 。</p>
<p>现在你已经知道了违反 equals 约定有多么可怕，下面将更细致地讨论这些约定 。 值 得欣慰的是，这些约定虽然看起来很吓人，实际上并不十分复杂。 一旦理解了这些约定，要遵守它们并不困难。</p>
<p>那么什么是等价关系呢？不严格地说，它是一个操作符，将一组元素划分到其元素与 另一个元素等价的分组中 。 这些分组被称作等价类（巳qui valence class ） 。 从用户的角度来看， 对于有用的 equals 方法，每个等价类中的所有元素都必须是可交换的 。 现在我们按照顺 序逐一查看以下 5 个要求 。</p>
<p>!! ……</p>
<p>结合所有这些要求，得出了以下实现高质量 equals 方法的诀窍 ：</p>
<ol>
<li><p>使用＝＝操作符检查“参数是否为这个对象的引用” 。 如果是，则返回 true 。 这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</p>
</li>
<li><p>使用 instanceof 操作符检查 “参数是否为正确的类型” 。 如果不是，则返回 false。 一般说来，所谓“正确的类型”是指 equals 方法所在的那个类 。 某些情况下，是指该类所实现的某个接口 。 如果类实现的接口改进了 equals 约定，允许在实现了该接口的类之间进行比较，那么就使用接口 。 集合接口如 Set 、 List 、 Map 和 Map.Entry 具有这样的特性。  注意 ！！ instanceOf和getClass两种区别</p>
</li>
<li><p>把参数转换成正确的类型。 因为转换之前进行过且stanceof 测试，所以确保会成功 。</p>
</li>
<li><p>对于该类中的每个“关键”（ significant ）域，检查参数中的域是否与该对象中对应的 域相匹配。 如果这些测试全部成功， 则返回 true ；否则返回 false 。 如果第 2 步 中 的类型 是个接口，就必须通过接口方法访问参数中的域；如果该类型是个类，也许就能够直接访问 参数中的域，这要取决于它们 的可访问性 。</p>
</li>
</ol>
<p>！！！ 。。。。。</p>
<p>FBI Warning；</p>
<ol>
<li><p>覆盖 equals 时总要覆盖 hashCode （详见第 l l 条 ） 。</p>
</li>
<li><p>不要企 图让 equals 方法过于 智能 。 如果只是简单地测试域中的值是否相等，则不难做到遵守 equals 约定 。 如果想过度地去寻求各种等价关系， 则很容易陷入麻烦之中 。 把任何一种别名形式考虑到等价的范围内，往往不会是个好主意 。 例如， File类不应该试图把指向同一个文件的符号链接（ symbolic link ） 当作相等的对象来看待 。所幸 File 类没有这样做。</p>
</li>
<li><p>不要将 equa ls 声 明 中 的 Object 对象替换为其他的类型。 程序员编写出下面这样的equals 方法并不鲜见，这会使程序员花上数个小时都搞不清为什么它不能正常工作 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Broken - parameter type must be Object!</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(MyClass o)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>问题在于，这个方法并没有覆盖（ override ) Object. equals ，因为它 的 参数应该是 Object 类型，相反，它重载（ overload ）了 Object. equals （详见第 52 条） 。 在正常 equals 方法的基础上，再提供一个“强类型”（ strongly typed ）的 equals 方法，这是无法接受的，因为会导致子类中的 Override 注解产生错误的正值，带来错误的安全感。</p>
</li>
</ol>
<p>@Override 注解的用法一致，就如本条目中所示，可以防止犯这种错误（详见第 40 条） 。 这个 equal s 方法不能编译，错误消息会告诉你到底哪里出了问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Still broken - but won&#x27;t compile</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(MyClass o)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编写和测试 equa l s （及 hashCode ）方法都是卡分烦琐的，得到的代码也很琐碎。 代 替于工编写 和测试这些方法的最佳途径，是使用 Google 开源的 AutoValue 框架 ，它会自动 替你生成这些方法，通过类 中的单个注解就能触发 。 在大多数情况下 ， AutoValue 生成的方 法本质上与你亲自编写的方法是一样 的 。</p>
<p>IDE 也有 工具 可以生成 e quals 和 hash Code 方法，但得 到的源代码比使用 AutoValue 的更加冗长，可读性也更差，它无法自动追踪类中 的变化，因此需要进行测试。 也就 是说 ，让 IDE 生成 equals （及 hashCode ）方法，通常优于手工实现它们，因为 IDE 不会 犯粗心的错误，但是程序员会犯错。</p>
<p>总而言之，不要轻易覆盖 equals 方法，除非迫不得已 。 因为在许多情况下，从 Object 处继承的实现正是你想要的 。 如果覆盖 equals ，一定要比较这个类的所有关键域，并且查看它们是否遵守 equals 合约的所有五个条款。</p>
<h2 id="第11条-覆盖-equals-时总要覆盖-hash-Code"><a href="#第11条-覆盖-equals-时总要覆盖-hash-Code" class="headerlink" title="第11条 覆盖 equals 时总要覆盖 hash Code"></a>第11条 覆盖 equals 时总要覆盖 hash Code</h2><p>在每个 覆盖了 equals 方法的类中，都 必须 覆盖 hashCode 方法。 如果不这样做的话，就会违反 hashCode 的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这类集合包括 HashMap 和 HashSet 。 下面是约定的内容，摘自 Object 规范：</p>
<ol>
<li><p>在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被 修改，那么对同一个对象的多次调用， hashCode 方法都必须始终返回同一个值。 在一个应用程序与另一个程序的执行过程中，执行 hashCode 方法所返回的值可以 不一致 。</p>
</li>
<li><p>如果两个对象根据 equals(Object ）方法比较是相等的，那么调用这两个对象中 的 hashCode 方法都必须产生同样的整数结果。</p>
</li>
<li><p>如果两个对象根据 equals(Object ）方法比较是不相等的，那么调用这两个对象中的 hashCode 方法，则不一定要求 hashCode 方法必须产生不同的结果 。 但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表（ hash table ）的性能。</p>
</li>
</ol>
<p>因没有覆盖 hashCode 而违反的关键约定是 第二条：相等的对象必须具有相等的散到码（ hash code ） 。 根据类的 equals 方法，两个截然不同的实例在逻辑上有可能是相等的， 但是根据 Object 类的 hashCode 方法，它们仅仅是两个没有任何共同之处的对象。 因此，对象的 hashCode 方法返回两个看起来是随机的整数，而不是根据第二个约定所要求的那 样，返回两个相等的整数 。</p>
<p>假设在 HashMap 中用第 10 条中出现过的 PhoneNur由er 类的实例作为键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;PhoneNumber, String&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>m.put(<span class="hljs-keyword">new</span> PhoneNumber(<span class="hljs-number">707</span>, <span class="hljs-number">867</span>, <span class="hljs-number">5309</span>), <span class="hljs-string">&quot;Jenny&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>此时，你可能期望 m . get (new PhoneNumber (707, 867 , 5309 ））会返回＂ Jenny ＂，但 它实际上返回的是川口 。 注意，这里涉及两个 PhoneNumber 实例 ： 第一个被插入 HashMap 中，第二个实例与第一个相等，用于从 Map 中根据 PhoneNumber 去获取用户名字 。 由于 Phone Number 类没有覆盖 hashCode 方法，从而导致两个相等的实例具有不相等的散列 码，违反了 hashCode 的约定 。 因此， put 方法把 电话号码对象存放在一个散列桶 （ hashbucket ）中，get 方法却在另一个散列桶中查找这个电话号码。即使这两个实例正好被放到同一个散列桶中，get 方法也必定会返回 null ，因为 HashMap 有一项优化，可以将与每个项相关联的散列码缓存起来，如果散列码不匹配，也就不再去检验对象的等同性 。</p>
<p>修正这个问题非常简单，只需为 PhoneNumber类提供一个适当的hashCode方法即可。那么， hashCode 方法应该是什么样的呢？编写一个合法但并不好用的 hashCode 方法没有任何价值。 例如，下面这个方法总是合法的，但是它永远都不应该被正式使用 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The worst possible legal hashCode imple『『1entation - never use!</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span> <span class="hljs-params">()</span>｛</span><br><span class="hljs-function">    return 42</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面这个 hashCode 方法是合法的，因为它确保了相等的对象总是具有同样的散列码 。但它也极为恶劣，因为它使得每个对象都具有同样的散列码 。 因此，每个对象都被映射到同 一个散列桶中，使散列表退化为链表（ linked list ） 。 它使得本该线性时间运行的程序变成了 以平方级时间在运行 。 对于规模很大的散列表而言，这会关系到散列表能否正常工作 。</p>
<p>一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码” 。 这正是 hashCode 约定中第 三条 的含义 。 理想情况下，散列函数应该把集合中不相等的实例均匀 地分布到所有可能的 int 值上 。 要想完全达到这种理想的情形是非常困难的 。 幸运的是， 相对接近这种理想情形则并不太困难。 下面给出一种简单的解决办法 ：</p>
<ol>
<li><p>声明一个 int 变量并命名为 result ，将它初始化为对象中第一个关键域的散列码 c ，如步骤 2.a 中计算所示（如第 10 条所述，关键域是指影响巳quals 比较的域） 。</p>
</li>
<li><p>对象中剩下的每一个关键域 f 都完成以下步骤：</p>
<ol>
<li>为该域计算 int 类型的散列码 C:<ul>
<li>如果该域是基本类型，则计算 Type. hashCode ( f ），这里的 Type 是装箱基 本类型的类，与 f 的类型相对应 。</li>
<li>如果该域是一个对象引用，并且该类的 equals 方法通过递归地调用 equals 的方式来比较这个域，则同样为这个域递归地调用 hashCode 。 如果需要更复 杂的比较，则为这个域计算一个“范式”（ canonical representation ），然后针对这个范式调用 hashCode 。 如果这个域的值为 null ，则 返回 0 （或者其他某个常数，但通常是 0 ） 。</li>
<li>如果该域是一个数组，则要把每一个元素当作单独的域来处理。 也就是说，递归地应用上述规则，对每个重要的元素计算 一个散列码，然后根据步骤 2.b 中的做法把这些散列值组合起来 。 如果数组域中没有重要的元素，可以使用 一个常量，但最好不要用 0。 如果数组域中的所有元素都很重要，可以使用Arrays . hashCode 方法 。</li>
</ul>
</li>
<li>按照下面的公式，把步骤 2 . a 中计算得到的散列码 c 合并到 result 中 ：<br> <code> result = 31 * result + c;</code></li>
</ol>
</li>
<li><p>返回result</p>
</li>
</ol>
<p>写完了 hashCode 方法之后，问问自己“相等的实例是否都具有相等的散列码” 。 要编 写单元测 试来验证你的推断（除非利用 AutoValue 生成 equals 和 hashCode 方法，这样 你就可 以放心地省略这些测试） 。 如果相等的实例有着不相等的散列码， 则要找出原因，并 修正错误。</p>
<p>在散列码的计算过程中，可 以把衍生域（ derived field ）排除在外 。 换句话说，如果一 个域的值可以根据参与计算的其他域值计算出来， 则可以把这样的域排除在外 。 <strong>必须排除 equals 比较计算中没有用到的任何域，否则很有可能违反 hashCode 约定的第二条</strong>。</p>
<p>步骤 2.b 中的乘法部分使得散列值依赖于域的顺序，如果一个类包含多个相似 的域，这 样的乘法运算就会产生一个更好的散列函数。 例如，如果 String 散列函数省｜略了这个乘法 部分，那么只是字母顺序不同的所有字符串将都会有相同的散列码。 之所以选择 31 ，是因为 它是一个奇素数。 如果乘数是偶数，并且乘法、溢出的话，信息就会丢失，因为与 2 相乘等价 于移位运算 。 使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果 。 3 1 有个 很好的特性，即用移位和减法来代替乘法，可以得到更好的性能 ： 31 女 i = = ( i &lt; &lt; 5 ) - i 。 现代的虚拟机可以自动完成这种优化 。</p>
<p>现在我们要把上述解决办法用到 PhoneNumber 类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Typical hashCode method </span><br><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = Short.hashCode(areaCode);<br><br>    result = <span class="hljs-number">31</span> * result + Short.hashCode(prefix);<br>    result = <span class="hljs-number">31</span> * result + Short.hashCode(lineNum);<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为这个方法返回的结果是一个简单、确定的计算结果，它的输入只是 PhoneNumber 实例中的三个关键域，因此相等的 PhoneNumber 实例显然都会有相等的散列码 。 实际上， 对于 PhoneNumber 的 hashCode 实现而言，上面这个方法是非常合理的，相当于 Java 平台类库中的实现。 它的做法非常简单，也相当快捷，恰当地把不相等的电话号码分散到不同 的散列桶中 。</p>
<p>虽然本条目中前面给出的 hashCode 实现方法能够获得相当好的散列函数，但它们并不是最先进的 。 它们的质量堪 比 Java 平台类库的值类型中提供的散列函数，这些方法对于 绝大多数应用程序而言已经足够了 。 如果执意想让散列函数尽可能地不会造成冲突，请参阅 Guava ’ s com.google.common.hash.Hashing [Guava］ 。</p>
<p>Objects 类有一个静态方法，它带有任意数量的对象，并为它们返回 一个散列码。 这 个方法名为 ha sh ， 是让你只需要编写一行代码的 hashCode 方法，与根据本条目前面介绍 过的解决方案编写出 来的 相比，它的质量是 与之相当的 。 遗憾的是，运行速度更慢一些， 因为它们会引发数组的创建，以便传入数目可变的参数， 如果参数中有基本类型，还需要 装箱和拆箱 。 建议只将这类散列函数用于不太注重性能的 情况 。 下面就是用这种方法为 PhoneNumber 编写 的散列 函数 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// One-line hashCode method - mediocre performance</span><br><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Object.hash(lineNum, prefix, areaCode);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果一个类是不可变的，并且计算散列码的开销也比较大 ， 就应该考虑把散列码缓存在 对象内部，而不是每次请求的时候都重新计算散列码。 如果你觉得这种类型的大多数对象会 被用作散列键（ hash keys ），就应该在创建实例的时候计算散列码。 否则，可以选择“延迟初 始化”（ lazily initialize ）散列码，即一直到 hashCode 被第一次调用的时候才初始化 （见第 83 条） 。 虽然我们的 PhoneNumber 类不值得这样处理，但是可以通过它来说明这种方法该如 何实现。 注意 hashCode 域的初始值（在本例中是 O ） 一般不能成为创建的实例的散列码：</p>
<p>! ……</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/05/17/Thread-AQS/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Thread-AQS</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/05/Effective-Java-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/">
                        <span class="hidden-mobile">Effective_Java_1_创建和销毁对象</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2021/05/05/Effective-Java-2-%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
