

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>设计模式-创建型模式 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="设计模式-创建型模式">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-12 20:40" pubdate>
        2021年9月12日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      60
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式-创建型模式</h1>
            
            <div class="markdown-body">
              <h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。</p>
<h2 id="工厂方法-FactoryMethod"><a href="#工厂方法-FactoryMethod" class="headerlink" title="工厂方法 FactoryMethod"></a>工厂方法 FactoryMethod</h2><p>在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。</p>
<p>又称：虚拟构造函数、Virtual Constructor、 Factory Method</p>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。</p>
<p>一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-50-05.png" srcset="/img/loading.gif"></p>
<p>这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。</p>
<p>最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-52-32.png" srcset="/img/loading.gif"></p>
<p><strong>乍看之下， 这种更改可能毫无意义</strong>： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型（这样好像意义也没有多大，个人拙见——LGW「意见一」）。</p>
<p>但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-59-38.png" srcset="/img/loading.gif"></p>
<p>举例来说，  卡车Truck和 轮船Ship类都必须实现 运输Trans­port接口， 该接口声明了一个名为 deliver交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  陆路运输Road­Logis­tics类中的工厂方法返回卡车对象， 而 海路运输Sea­Logis­tics类则返回轮船对象。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-00-33.png" srcset="/img/loading.gif"></p>
<p>调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-02-48.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>产品 （Prod­uct） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p>
</li>
<li><p>具体产品 （Con­crete Prod­ucts） 是产品接口的不同实现。</p>
</li>
<li><p>创建者 （Cre­ator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p>
<p>你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</p>
<p>注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p>
</li>
<li><p>具体创建者 （Con­crete Cre­ators） 将会重写基础工厂方法， 使其返回不同类型的产品。</p>
<p>注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p>
</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>以下示例演示了如何使用工厂方法开发跨平台 UI （用户界面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-06-11.png" srcset="/img/loading.gif"></p>
<p>基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Win­dows 系统中的按钮在 Linux 系统中仍然是按钮。</p>
<p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Win­dows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Win­dows 样式渲染按钮。</p>
<p>如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p>
<p><strong>你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。</strong></p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供</span><br><span class="hljs-comment">// 该方法的实现。</span><br><span class="hljs-keyword">class</span> Dialog <span class="hljs-keyword">is</span><br>  <span class="hljs-comment">// 创建者还可提供一些工厂方法的默认实现。</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button<br><br>  <span class="hljs-comment">// 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务</span><br>  <span class="hljs-comment">// 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方</span><br>  <span class="hljs-comment">// 法并使其返回不同类型的产品来间接修改业务逻辑。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 调用工厂方法创建一个产品对象。</span><br><span class="hljs-function">    <span class="hljs-title">Button</span> <span class="hljs-title">okButton</span> = <span class="hljs-title">createButton</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    // 现在使用产品。</span><br><span class="hljs-function">    <span class="hljs-title">okButton</span>.<span class="hljs-title">onClick</span><span class="hljs-params">(closeDialog)</span></span><br><span class="hljs-function">    <span class="hljs-title">okButton</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 具体创建者将重写工厂方法以改变其所返回的产品类型。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WindowsDialog</span> <span class="hljs-title">extends</span> <span class="hljs-title">Dialog</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> WindowsButton()<br><br><span class="hljs-keyword">class</span> WebDialog extends Dialog <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> HTMLButton()<br><br><br><span class="hljs-comment">// 产品接口中将声明所有具体产品都必须实现的操作。</span><br><span class="hljs-keyword">interface</span> Button <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 具体产品需提供产品接口的各种实现。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WindowsButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">render</span><span class="hljs-params">(a, b)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">Windows</span> 样式渲染按钮。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 绑定本地操作系统点击事件。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">HTMLButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">render</span><span class="hljs-params">(a, b)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 返回一个按钮的 <span class="hljs-title">HTML</span> 表述。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 绑定网络浏览器的点击事件。</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Application</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">dialog</span>:</span> Dialog<br><br>  <span class="hljs-comment">// 程序根据当前配置或环境设定选择创建者的类型。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">config</span> = <span class="hljs-title">readApplicationConfigFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Windows&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">dialog</span> = <span class="hljs-title">new</span> <span class="hljs-title">WindowsDialog</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Web&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">dialog</span> = <span class="hljs-title">new</span> <span class="hljs-title">WebDialog</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span></span><br><span class="hljs-function">      <span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-title">Exception</span><span class="hljs-params">(&quot;错误！未知的操作系统。&quot;)</span></span><br><span class="hljs-function">  // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口</span><br><span class="hljs-function">  // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子</span><br><span class="hljs-function">  // 类传递给客户端。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">initialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">dialog</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>




<h3 id="适用应用场景"><a href="#适用应用场景" class="headerlink" title="适用应用场景"></a>适用应用场景</h3><ol>
<li><p><strong>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</strong></p>
<p>工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。</p>
<p>例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。</p>
</li>
<li><p><strong>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</strong></p>
<p> 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？</p>
</li>
<li><p><strong>解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。</strong></p>
<p>让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 圆形按钮Round­But­ton子类来继承标准的 按钮But­ton类。 但是， 你需要告诉 UI框架UIFrame­work类使用新的子类按钮代替默认按钮。</p>
<p>为了实现这个功能， 你可以根据基础框架类开发子类 圆形按钮 UIUIWith­Round­But­tons ， 并且重写其 create­Button创建按钮方法。 基类中的该方法返回 按钮对象， 而你开发的子类返回 圆形按钮对象。 现在， 你就可以使用 圆形按钮 UI类代替 UI框架类。 就是这么简单！</p>
</li>
<li><p><strong>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。</strong></p>
<p>在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。</p>
<p>让我们思考复用现有对象的方法：</p>
<ul>
<li>首先， 你需要创建存储空间来存放所有已经创建的对象。</li>
<li>当他人请求一个对象时， 程序将在对象池中搜索可用对象。</li>
<li>…然后将其返回给客户端代码。</li>
<li>如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。</li>
</ul>
<p>这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。</p>
<p>可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实例。</p>
<p>因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。</p>
</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</p>
</li>
<li><p>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</p>
</li>
<li><p>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。</p>
<p>工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 switch分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。</p>
</li>
<li><p>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。</p>
</li>
<li><p>如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。</p>
<p>例如， 设想你有以下一些层次结构的类。 基类 邮件及其子类 航空邮件和 陆路邮件 ；  运输及其子类 飞机, 卡车和 火车 。  航空邮件仅使用 飞机对象， 而 陆路邮件则会同时使用 卡车和 火车对象。 你可以编写一个新的子类 （例如 火车邮件 ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 陆路邮件类传递一个参数， 用于控制其希望获得的产品。</p>
</li>
<li><p>如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。</p>
</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以避免创建者和具体产品之间的紧密耦合。</li>
<li>单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li>
<li>开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li>
</ol>
<p>缺点：</p>
<ol>
<li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li>
</ol>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>在许多设计工作的初期都会使用<strong>工厂方法</strong> （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用<strong>抽象工厂</strong>、 <strong>原型</strong>或<strong>生成器</strong> （更灵活但更加复杂）。</p>
</li>
<li><p><strong>抽象工厂</strong>模式通常基于一组工厂方法， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</p>
</li>
<li><p>你可以同时使用<strong>工厂方法</strong>和<strong>迭代器</strong>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p>
</li>
<li><p><strong>原型</strong>并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 <strong>工厂方法</strong>基于继承， 但是它不需要初始化步骤。</p>
</li>
<li><p><strong>工厂方法</strong>是<strong>模板方法</strong>的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。</p>
</li>
</ol>
<h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>工厂方法应用于如，不同风格的对话框使用不同风格的按钮，不同风格对话框具体使用何种风格按钮由其具体对话框自己决定。（意见同一）</p>
<h2 id="抽象工厂-AbstractFactory"><a href="#抽象工厂-AbstractFactory" class="headerlink" title="抽象工厂 AbstractFactory"></a>抽象工厂 AbstractFactory</h2><p>让你能够创建一系列相关的对象，而无需指定具体类。</p>
<h2 id="生成器-Builder"><a href="#生成器-Builder" class="headerlink" title="生成器 Builder"></a>生成器 Builder</h2><p>使你能够分步骤创建复杂对象。该模式允许使用相同的创建代码生成不同类型和形式的对象。</p>
<h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型 Prototype"></a>原型 Prototype</h2><p>让你能够复制已有对象，而又无需使用代码依赖他们所属的类。</p>
<h2 id="单例-Singleton"><a href="#单例-Singleton" class="headerlink" title="单例 Singleton"></a>单例 Singleton</h2><p>让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p>
<h3 id="问题提出-1"><a href="#问题提出-1" class="headerlink" title="问题提出"></a>问题提出</h3><p>单例模式同时解决了两个问题， 所以违反了_单一职责原则_：</p>
<ol>
<li><p><strong>保证一个类只有一个实例。</strong> 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</p>
<p>它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p>
<p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-44-54.png" srcset="/img/loading.gif"></p>
</li>
<li><p><strong>为该实例提供一个全局访问节点。</strong> 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p>
<p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p>
<p>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p>
</li>
</ol>
<p>如今， 单例模式已经变得非常流行， 以至于人们会将只解决上文描述中任意一个问题的东西称为单例。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>所有单例的实现都包含以下两个相同的步骤：</p>
<ul>
<li>将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。</li>
<li>新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ul>
<p>如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。</p>
<h3 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p>政府是单例模式的一个很好的示例。 一个国家只有一个官方政府。 不管组成政府的每个人的身份是什么，  “某政府” 这一称谓总是鉴别那些掌权者的全局访问节点。</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-51-03.png" srcset="/img/loading.gif"></p>
<ul>
<li>单例 （Sin­gle­ton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。</li>
<li>单例的构造函数必须对客户端 （Client） 代码隐藏（通过private）。 调用 获取实例方法必须是获取单例对象的唯一方式。</li>
</ul>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 数据库连接类即是一个单例。</p>
<p>该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处</span><br><span class="hljs-comment">// 都能访问相同的数据库连接实例。</span><br><span class="hljs-keyword">class</span> Database is<br>  <span class="hljs-comment">// 保存单例实例的成员变量必须被声明为静态类型。</span><br>  <span class="hljs-keyword">private</span> static field instance: Database<br><br>  <span class="hljs-comment">// 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构</span><br>  <span class="hljs-comment">// 造方法。</span><br>  <span class="hljs-keyword">private</span> constructor <span class="hljs-constructor">Database()</span> is<br>    <span class="hljs-comment">// 部分初始化代码（例如到数据库服务器的实际连接）。</span><br>    <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-comment">// 用于控制对单例实例的访问权限的静态方法。</span><br>  public static <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Instance()</span> is<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<span class="hljs-operator"> == </span>null) <span class="hljs-keyword">then</span><br>      acquire<span class="hljs-constructor">ThreadLock()</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">// 确保在该线程等待解锁时，其他线程没有初始化该实例。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<span class="hljs-operator"> == </span>null) <span class="hljs-keyword">then</span><br>          <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Database()</span><br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<br><br>  <span class="hljs-comment">// 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span><br>  public <span class="hljs-keyword">method</span> query(sql) is<br>    <span class="hljs-comment">// 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以</span><br>    <span class="hljs-comment">// 在这里添加限流或缓冲逻辑。</span><br>    <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> Application is<br>  <span class="hljs-keyword">method</span> main<span class="hljs-literal">()</span> is<br>    Database foo = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br>    foo.query(<span class="hljs-string">&quot;SELECT ...&quot;</span>)<br>    <span class="hljs-comment">// ...</span><br>    Database bar = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br>    bar.query(<span class="hljs-string">&quot;SELECT ...&quot;</span>)<br>    <span class="hljs-comment">// 变量 `bar` 和 `foo` 中将包含同一个对象。</span><br></code></pre></td></tr></table></figure>




<h3 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h3><p>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。</p>
<p>单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</p>
<p>如果你需要更加严格地控制全局变量， 可以使用单例模式。</p>
<p>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p>
<p>请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例方法， 即 getInstance 中的代码即可实现。</p>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>在类中添加一个私有静态成员变量用于保存单例实例。</p>
</li>
<li><p>声明一个公有静态构建方法用于获取单例实例。</p>
</li>
<li><p>在静态方法中实现”延迟初始化”（注意存在Check Than Act现象，注意线程安全问题）。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</p>
</li>
<li><p>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</p>
</li>
<li><p>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。</p>
</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以保证一个类只有一个实例。</li>
<li>你获得了一个指向该实例的全局访问节点。</li>
<li>仅在首次请求单例对象时对其进行初始化。</li>
</ol>
<p>缺点：</p>
<ol>
<li>违反了_单一职责原则_。 该模式同时解决了两个问题。</li>
<li>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li>
<li>该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li>
<li>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li>
</ol>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><strong>外观</strong>类通常可以转换为<strong>单例</strong>类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象， 那么<strong>享元</strong>就和<strong>单例</strong>类似了。 但这两个模式有两个根本性的不同。<ul>
<li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。 享元对象是不可变的。</li>
</ul>
</li>
<li>抽象工厂、 生成器和原型都可以用单例来实现。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/">
                        <span class="hidden-mobile">设计模式-结构性模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
