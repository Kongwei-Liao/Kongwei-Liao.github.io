

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>设计模式-创建型模式 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="设计模式-创建型模式">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-12 20:40" pubdate>
        2021年9月12日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      164
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式-创建型模式</h1>
            
            <div class="markdown-body">
              <h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。</p>
<h2 id="工厂方法-FactoryMethod"><a href="#工厂方法-FactoryMethod" class="headerlink" title="工厂方法 FactoryMethod"></a>工厂方法 FactoryMethod</h2><p>在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。</p>
<p>又称：虚拟构造函数、Virtual Constructor、 Factory Method</p>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。</p>
<p>一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-50-05.png" srcset="/img/loading.gif"></p>
<p>这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。</p>
<p>最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-52-32.png" srcset="/img/loading.gif"></p>
<p><strong>乍看之下， 这种更改可能毫无意义</strong>： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型（这样好像意义也没有多大，个人拙见——LGW「意见一」）。</p>
<p>但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-59-38.png" srcset="/img/loading.gif"></p>
<p>举例来说，  卡车Truck和 轮船Ship类都必须实现 运输Trans­port接口， 该接口声明了一个名为 deliver交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  陆路运输Road­Logis­tics类中的工厂方法返回卡车对象， 而 海路运输Sea­Logis­tics类则返回轮船对象。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-00-33.png" srcset="/img/loading.gif"></p>
<p>调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-02-48.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>产品 （Prod­uct） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p>
</li>
<li><p>具体产品 （Con­crete Prod­ucts） 是产品接口的不同实现。</p>
</li>
<li><p>创建者 （Cre­ator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p>
<p>你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</p>
<p>注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p>
</li>
<li><p>具体创建者 （Con­crete Cre­ators） 将会重写基础工厂方法， 使其返回不同类型的产品。</p>
<p>注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p>
</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>以下示例演示了如何使用工厂方法开发跨平台 UI （用户界面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-06-11.png" srcset="/img/loading.gif"></p>
<p>基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Win­dows 系统中的按钮在 Linux 系统中仍然是按钮。</p>
<p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Win­dows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Win­dows 样式渲染按钮。</p>
<p>如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p>
<p><strong>你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。</strong></p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供</span><br><span class="hljs-comment">// 该方法的实现。</span><br><span class="hljs-keyword">class</span> Dialog <span class="hljs-keyword">is</span><br>  <span class="hljs-comment">// 创建者还可提供一些工厂方法的默认实现。</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button<br><br>  <span class="hljs-comment">// 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务</span><br>  <span class="hljs-comment">// 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方</span><br>  <span class="hljs-comment">// 法并使其返回不同类型的产品来间接修改业务逻辑。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 调用工厂方法创建一个产品对象。</span><br><span class="hljs-function">    <span class="hljs-title">Button</span> <span class="hljs-title">okButton</span> = <span class="hljs-title">createButton</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    // 现在使用产品。</span><br><span class="hljs-function">    <span class="hljs-title">okButton</span>.<span class="hljs-title">onClick</span><span class="hljs-params">(closeDialog)</span></span><br><span class="hljs-function">    <span class="hljs-title">okButton</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 具体创建者将重写工厂方法以改变其所返回的产品类型。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WindowsDialog</span> <span class="hljs-title">extends</span> <span class="hljs-title">Dialog</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> WindowsButton()<br><br><span class="hljs-keyword">class</span> WebDialog extends Dialog <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> HTMLButton()<br><br><br><span class="hljs-comment">// 产品接口中将声明所有具体产品都必须实现的操作。</span><br><span class="hljs-keyword">interface</span> Button <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 具体产品需提供产品接口的各种实现。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WindowsButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">render</span><span class="hljs-params">(a, b)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">Windows</span> 样式渲染按钮。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 绑定本地操作系统点击事件。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">HTMLButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">render</span><span class="hljs-params">(a, b)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 返回一个按钮的 <span class="hljs-title">HTML</span> 表述。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 绑定网络浏览器的点击事件。</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Application</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">dialog</span>:</span> Dialog<br><br>  <span class="hljs-comment">// 程序根据当前配置或环境设定选择创建者的类型。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">config</span> = <span class="hljs-title">readApplicationConfigFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Windows&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">dialog</span> = <span class="hljs-title">new</span> <span class="hljs-title">WindowsDialog</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Web&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">dialog</span> = <span class="hljs-title">new</span> <span class="hljs-title">WebDialog</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span></span><br><span class="hljs-function">      <span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-title">Exception</span><span class="hljs-params">(&quot;错误！未知的操作系统。&quot;)</span></span><br><span class="hljs-function">  // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口</span><br><span class="hljs-function">  // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子</span><br><span class="hljs-function">  // 类传递给客户端。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">initialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">dialog</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>




<h3 id="适用应用场景"><a href="#适用应用场景" class="headerlink" title="适用应用场景"></a>适用应用场景</h3><ol>
<li><p><strong>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</strong></p>
<p>工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。</p>
<p>例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。</p>
</li>
<li><p><strong>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</strong></p>
<p> 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？</p>
</li>
<li><p><strong>解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。</strong></p>
<p>让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 圆形按钮Round­But­ton子类来继承标准的 按钮But­ton类。 但是， 你需要告诉 UI框架UIFrame­work类使用新的子类按钮代替默认按钮。</p>
<p>为了实现这个功能， 你可以根据基础框架类开发子类 圆形按钮 UIUIWith­Round­But­tons ， 并且重写其 create­Button创建按钮方法。 基类中的该方法返回 按钮对象， 而你开发的子类返回 圆形按钮对象。 现在， 你就可以使用 圆形按钮 UI类代替 UI框架类。 就是这么简单！</p>
</li>
<li><p><strong>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。</strong></p>
<p>在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。</p>
<p>让我们思考复用现有对象的方法：</p>
<ul>
<li>首先， 你需要创建存储空间来存放所有已经创建的对象。</li>
<li>当他人请求一个对象时， 程序将在对象池中搜索可用对象。</li>
<li>…然后将其返回给客户端代码。</li>
<li>如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。</li>
</ul>
<p>这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。</p>
<p>可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实例。</p>
<p>因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。</p>
</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</p>
</li>
<li><p>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</p>
</li>
<li><p>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。</p>
<p>工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 switch分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。</p>
</li>
<li><p>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。</p>
</li>
<li><p>如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。</p>
<p>例如， 设想你有以下一些层次结构的类。 基类 邮件及其子类 航空邮件和 陆路邮件 ；  运输及其子类 飞机, 卡车和 火车 。  航空邮件仅使用 飞机对象， 而 陆路邮件则会同时使用 卡车和 火车对象。 你可以编写一个新的子类 （例如 火车邮件 ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 陆路邮件类传递一个参数， 用于控制其希望获得的产品。</p>
</li>
<li><p>如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。</p>
</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以避免创建者和具体产品之间的紧密耦合。</li>
<li>单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li>
<li>开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li>
</ol>
<p>缺点：</p>
<ol>
<li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li>
</ol>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>在许多设计工作的初期都会使用<strong>工厂方法</strong> （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用<strong>抽象工厂</strong>、 <strong>原型</strong>或<strong>生成器</strong> （更灵活但更加复杂）。</p>
</li>
<li><p><strong>抽象工厂</strong>模式通常基于一组工厂方法， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</p>
</li>
<li><p>你可以同时使用<strong>工厂方法</strong>和<strong>迭代器</strong>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p>
</li>
<li><p><strong>原型</strong>并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 <strong>工厂方法</strong>基于继承， 但是它不需要初始化步骤。</p>
</li>
<li><p><strong>工厂方法</strong>是<strong>模板方法</strong>的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。</p>
</li>
</ol>
<h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>工厂方法应用于如，不同风格的对话框使用不同风格的按钮，不同风格对话框具体使用何种风格按钮由其具体对话框自己决定。（意见同一）</p>
<h2 id="抽象工厂-AbstractFactory"><a href="#抽象工厂-AbstractFactory" class="headerlink" title="抽象工厂 AbstractFactory"></a>抽象工厂 AbstractFactory</h2><p>让你能够创建一系列相关的对象，而无需指定具体类。</p>
<h3 id="问题提出-1"><a href="#问题提出-1" class="headerlink" title="问题提出"></a>问题提出</h3><p>假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：</p>
<ol>
<li><p>一系列相关产品， 例如 椅子Chair 、  沙发Sofa和 咖啡桌Cof­fee­Table 。</p>
</li>
<li><p>系列产品的不同变体。 例如， 你可以使用 现代Mod­ern 、  维多利亚Vic­to­ri­an 、  装饰风艺术Art­Deco等风格生成 椅子 、  沙发和 咖啡桌 。</p>
</li>
</ol>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-47-18.png" srcset="/img/loading.gif"></p>
<p>你需要设法单独生成每件家具对象， 这样才能确保其风格一致。 如果顾客收到的家具风格不一样， 他们可不会开心。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-48-15.png" srcset="/img/loading.gif"></p>
<p>此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 椅子接口； 所有风格的咖啡桌都实现 咖啡桌接口， 以此类推。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-49-47.png" srcset="/img/loading.gif"></p>
<p>接下来， 我们需要声明抽象工厂——包含系列中所有产品构造方法的接口。 例如 create­Chair创建椅子 、  create­Sofa创建沙发和 create­Coffee­Table创建咖啡桌 。 这些方法必须返回抽象产品类型， 即我们之前抽取的那些接口：  椅子 ，  沙发和 咖啡桌等等。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-51-11.png" srcset="/img/loading.gif" alt="每个具体工厂类都对应一个特定的产品变体"></p>
<p>那么该如何处理产品变体呢？ 对于系列产品的每个变体， 我们都将基于 抽象工厂接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如，  现代家具工厂Mod­ern­Fur­ni­ture­Fac­to­ry只能创建 现代椅子Mod­ern­Chair 、  现代沙发Mod­ern­Sofa和 现代咖啡桌Mod­ern­Cof­fee­Table对象。</p>
<p>客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-52-16.png" srcset="/img/loading.gif"></p>
<p>假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调用抽象 椅子接口就可以了。 这样一来， 客户端只需知道椅子以某种方式实现了 sit­On坐下方法就足够了。 此外， 无论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。</p>
<p>最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-53-45.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>抽象产品 （Abstract Prod­uct） 为构成系列产品的一组不同但相关的产品声明接口。</p>
</li>
<li><p>具体产品 （Con­crete Prod­uct） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。</p>
</li>
<li><p>抽象工厂 （Abstract Fac­to­ry） 接口声明了一组创建各种抽象产品的方法。</p>
</li>
<li><p>具体工厂 （Con­crete Fac­to­ry） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</p>
</li>
<li><p>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 客户端 （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。</p>
</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>下面例子通过应用抽象工厂模式， 使得客户端代码无需与具体 UI 类耦合， 就能创建跨平台的 UI 元素， 同时确保所创建的元素与指定的操作系统匹配。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-56-00.png" srcset="/img/loading.gif"></p>
<p>跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Win­dows 系统下运行的应用程序中显示 macOS 的控件。</p>
<p>抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。</p>
<p>其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。</p>
<p>使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。</p>
<p>这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。 </p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列</span><br><span class="hljs-comment">// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产</span><br><span class="hljs-comment">// 品可有多个变体，但不同变体的产品不能搭配使用。</span><br><span class="hljs-keyword">interface</span> GUIFactory <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button<br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createCheckbox</span><span class="hljs-params">()</span>:</span>Checkbox<br><br><br><span class="hljs-comment">// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配</span><br><span class="hljs-comment">// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进</span><br><span class="hljs-comment">// 行实例化。</span><br><span class="hljs-keyword">class</span> WinFactory <span class="hljs-keyword">implements</span> GUIFactory <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> WinButton()<br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createCheckbox</span><span class="hljs-params">()</span>:</span>Checkbox <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> WinCheckbox()<br><br><span class="hljs-comment">// 每个具体工厂中都会包含一个相应的产品变体。</span><br><span class="hljs-keyword">class</span> MacFactory <span class="hljs-keyword">implements</span> GUIFactory <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> MacButton()<br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createCheckbox</span><span class="hljs-params">()</span>:</span>Checkbox <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> MacCheckbox()<br><br><br><span class="hljs-comment">// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。</span><br><span class="hljs-keyword">interface</span> Button <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 具体产品由相应的具体工厂创建。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WinButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">Windows</span> 样式渲染按钮。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">MacButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">macOS</span> 样式渲染按钮</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产</span><br><span class="hljs-function">// 品之间才能够正确地进行交互。</span><br><span class="hljs-function"><span class="hljs-title">interface</span> <span class="hljs-title">Checkbox</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WinCheckbox</span> <span class="hljs-title">implements</span> <span class="hljs-title">Checkbox</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">Windows</span> 样式渲染复选框。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">MacCheckbox</span> <span class="hljs-title">implements</span> <span class="hljs-title">Checkbox</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">macOS</span> 样式渲染复选框。</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 客户端代码仅通过抽象类型（<span class="hljs-title">GUIFactory</span>、<span class="hljs-title">Button</span> 和 <span class="hljs-title">Checkbox</span>）使用工厂和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Application</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">private</span> <span class="hljs-title">field</span> <span class="hljs-title">factory</span>:</span> GUIFactory<br>  <span class="hljs-keyword">private</span> field button: Button<br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Application</span><span class="hljs-params">(factory: GUIFactory)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">factory</span> = <span class="hljs-title">factory</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">createUI</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">button</span> = <span class="hljs-title">factory</span>.<span class="hljs-title">createButton</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">button</span>.<span class="hljs-title">paint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初</span><br><span class="hljs-function">// 始化阶段）。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">ApplicationConfigurator</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">config</span> = <span class="hljs-title">readApplicationConfigFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Windows&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">factory</span> = <span class="hljs-title">new</span> <span class="hljs-title">WinFactory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Mac&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">factory</span> = <span class="hljs-title">new</span> <span class="hljs-title">MacFactory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span></span><br><span class="hljs-function">      <span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-title">Exception</span><span class="hljs-params">(&quot;错误！未知的操作系统。&quot;)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">Application</span> <span class="hljs-title">app</span> = <span class="hljs-title">new</span> <span class="hljs-title">Application</span><span class="hljs-params">(factory)</span></span><br></code></pre></td></tr></table></figure>


<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li><p>如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。</p>
<p>抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。</p>
</li>
<li><p>如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。</p>
<p>在设计良好的程序中， 每个类仅负责一件事。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。</p>
</li>
</ol>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>以不同的产品类型与产品变体为维度绘制矩阵；</p>
</li>
<li><p>为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口；</p>
</li>
<li><p>声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法；</p>
</li>
<li><p>为每种产品变体实现一个具体工厂类；</p>
</li>
<li><p>在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类；</p>
</li>
<li><p>找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。</p>
</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以确保同一工厂生成的产品相互匹配；</li>
<li>你可以避免客户端和具体产品代码的耦合；</li>
<li>单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护；</li>
<li>开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</li>
</ol>
<p>缺点</p>
<ol>
<li>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</li>
</ol>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>在许多设计工作的初期都会使用工厂方法 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂、 原型或生成器 （更灵活但更加复杂）。</p>
</li>
<li><p>生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。</p>
</li>
<li><p>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</p>
</li>
<li><p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观。</p>
</li>
<li><p>你可以将抽象工厂和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p>
</li>
<li><p>抽象工厂、 生成器和原型都可以用单例来实现。</p>
</li>
</ol>
<h2 id="生成器-Builder"><a href="#生成器-Builder" class="headerlink" title="生成器 Builder"></a>生成器 Builder</h2><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-45-54.png" srcset="/img/loading.gif"></p>
<p>使你能够分步骤创建复杂对象。该模式允许使用相同的创建代码生成不同类型和形式的对象。</p>
<h3 id="问题提出-2"><a href="#问题提出-2" class="headerlink" title="问题提出"></a>问题提出</h3><p>假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-47-54.png" srcset="/img/loading.gif"></p>
<p>例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？</p>
<p>最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。</p>
<p>另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-48-49.png" srcset="/img/loading.gif"></p>
<p>通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-50-09.png" srcset="/img/loading.gif"></p>
<p>“该模式会将对象构造过程划分为一组步骤， 比如 build­Walls创建墙壁和 build­Door创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。</p>
<p>当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。</p>
<p>在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-51-09.png" srcset="/img/loading.gif"></p>
<p>“例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但是， 只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。</p>
<p>主管：你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-52-20.png" srcset="/img/loading.gif"></p>
<p>严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。</p>
<p>此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-54-09.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</p>
</li>
<li><p>具体生成器 （Con­crete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</p>
</li>
<li><p>产品 （Prod­ucts） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</p>
</li>
<li><p>主管 （Direc­tor） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</p>
</li>
<li><p>客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</p>
</li>
</ol>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-56-05.png" srcset="/img/loading.gif"></p>
<p>汽车是一个复杂对象， 有数百种不同的制造方法。 我们没有在 汽车类中塞入一个巨型构造函数， 而是将汽车组装代码抽取到单独的汽车生成器类中。 该类中有一组方法可用来配置汽车的各种部件。</p>
<p>如果客户端代码需要组装一辆与众不同、 精心调教的汽车， 它可以直接调用生成器。 或者， 客户端可以将组装工作委托给主管类， 因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。</p>
<p>你或许会感到吃惊， 但确实每辆汽车都需要一本使用手册 （说真的， 谁会去读它们呢？）。 使用手册会介绍汽车的每一项功能， 因此不同型号的汽车， 其使用手册内容也不一样。 因此， 你可以复用现有流程来制造实际的汽车及其对应的手册。当然， 编写手册和制造汽车不是一回事， 所以我们需要另外一个生成器对象来专门编写使用手册。 该类与其制造汽车的兄弟类都实现了相同的制造方法， 但是其功能不是制造汽车部件， 而是描述每个部件。 将这些生成器传递给相同的主管对象， 我们就能够生成一辆汽车或是一本使用手册了。</p>
<p>最后一个部分是获取结果对象。 尽管金属汽车和纸质手册存在关联， 但它们却是完全不同的东西。 我们无法在主管类和具体产品类不发生耦合的情况下， 在主管类中提供获取结果对象的方法。 因此， 我们只能通过负责制造过程的生成器来获取结果对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。下面的两个</span><br><span class="hljs-comment">// 产品尽管没有同样的接口，但却相互关联。</span><br><span class="hljs-keyword">class</span> Car is<br>  <span class="hljs-comment">// 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车（</span><br>  <span class="hljs-comment">// 运动型轿车、SUV 和敞篷车）可能会安装或启用不同的功能。</span><br><br><span class="hljs-keyword">class</span> Manual is<br>  <span class="hljs-comment">// 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。</span><br><br><br><span class="hljs-comment">// 生成器接口声明了创建产品对象不同部件的方法。</span><br>interface Builder is<br>  <span class="hljs-keyword">method</span> reset<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Seats(<span class="hljs-operator">...</span>)</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Engine(<span class="hljs-operator">...</span>)</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">TripComputer(<span class="hljs-operator">...</span>)</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">GPS(<span class="hljs-operator">...</span>)</span><br><br><span class="hljs-comment">// 具体生成器类将遵循生成器接口并提供生成步骤的具体实现。你的程序中可能会</span><br><span class="hljs-comment">// 有多个以不同方式实现的生成器变体。</span><br><span class="hljs-keyword">class</span> CarBuilder implements Builder is<br>  <span class="hljs-keyword">private</span> field car:Car<br><br>  <span class="hljs-comment">// 一个新的生成器实例必须包含一个在后续组装过程中使用的空产品对象。</span><br>  constructor <span class="hljs-constructor">CarBuilder()</span> is<br>    this.reset<span class="hljs-literal">()</span><br>  <span class="hljs-comment">// reset（重置）方法可清除正在生成的对象。</span><br>  <span class="hljs-keyword">method</span> reset<span class="hljs-literal">()</span> is<br>    this.car = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Car()</span><br><br>  <span class="hljs-comment">// 所有生成步骤都会与同一个产品实例进行交互。</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Seats(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 设置汽车座位的数量。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Engine(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 安装指定的引擎。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">TripComputer(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 安装行车电脑。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">GPS(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 安装全球定位系统。</span><br><br>  <span class="hljs-comment">// 具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能</span><br>  <span class="hljs-comment">// 会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中</span><br>  <span class="hljs-comment">// 声明这些方法（至少在静态类型的编程语言中是这样的）。</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的</span><br>  <span class="hljs-comment">// 准备。因此生成器实例通常会在 `getProduct（获取产品）`方法主体末尾</span><br>  <span class="hljs-comment">// 调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确</span><br>  <span class="hljs-comment">// 调用重置方法后再去处理之前的结果。</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Product()</span>:Car is<br>    product = this.car<br>    this.reset<span class="hljs-literal">()</span><br>    return product<br><br><span class="hljs-comment">// 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。</span><br><span class="hljs-keyword">class</span> CarManualBuilder implements Builder is<br>  <span class="hljs-keyword">private</span> field manual:Manual<br><br>  constructor <span class="hljs-constructor">CarManualBuilder()</span> is<br>    this.reset<span class="hljs-literal">()</span><br><br>  <span class="hljs-keyword">method</span> reset<span class="hljs-literal">()</span> is<br>    this.manual = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Manual()</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Seats(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 添加关于汽车座椅功能的文档。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Engine(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 添加关于引擎的介绍。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">TripComputer(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 添加关于行车电脑的介绍。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">GPS(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 添加关于 GPS 的介绍。</span><br><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Product()</span>:Manual is<br>    <span class="hljs-comment">// 返回使用手册并重置生成器。</span><br><br><br><span class="hljs-comment">// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时</span><br><span class="hljs-comment">// 会很有帮助。由于客户端可以直接控制生成器，所以严格意义上来说，主管类并</span><br><span class="hljs-comment">// 不是必需的。</span><br><span class="hljs-keyword">class</span> Director is<br>  <span class="hljs-keyword">private</span> field builder:Builder<br><br>  <span class="hljs-comment">// 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通</span><br>  <span class="hljs-comment">// 过这种方式改变最新组装完毕的产品的最终类型。</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Builder(<span class="hljs-params">builder</span>:Builder)</span><br>    this.builder = builder<br><br>  <span class="hljs-comment">// 主管可使用同样的生成步骤创建多个产品变体。</span><br>  <span class="hljs-keyword">method</span> construct<span class="hljs-constructor">SportsCar(<span class="hljs-params">builder</span>: Builder)</span> is<br>    builder.reset<span class="hljs-literal">()</span><br>    builder.set<span class="hljs-constructor">Seats(2)</span><br>    builder.set<span class="hljs-constructor">Engine(<span class="hljs-params">new</span> SportEngine()</span>)<br>    builder.set<span class="hljs-constructor">TripComputer(<span class="hljs-params">true</span>)</span><br>    builder.set<span class="hljs-constructor">GPS(<span class="hljs-params">true</span>)</span><br><br>  <span class="hljs-keyword">method</span> construct<span class="hljs-constructor">SUV(<span class="hljs-params">builder</span>: Builder)</span> is<br>    <span class="hljs-comment">// ...</span><br><br><br><span class="hljs-comment">// 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果</span><br><span class="hljs-comment">// 将需要从生成器对象中获取。</span><br><span class="hljs-keyword">class</span> Application is<br><br>  <span class="hljs-keyword">method</span> make<span class="hljs-constructor">Car()</span> is<br>    director = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Director()</span><br><br>    CarBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CarBuilder()</span><br>    director.construct<span class="hljs-constructor">SportsCar(<span class="hljs-params">builder</span>)</span><br>    Car car = builder.get<span class="hljs-constructor">Product()</span><br><br>    CarManualBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CarManualBuilder()</span><br>    director.construct<span class="hljs-constructor">SportsCar(<span class="hljs-params">builder</span>)</span><br><br>    <span class="hljs-comment">// 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和</span><br>    <span class="hljs-comment">// 产品的存在，也不会对其产生依赖。</span><br>    Manual manual = builder.get<span class="hljs-constructor">Product()</span><br>    <br></code></pre></td></tr></table></figure>
<h3 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h3><p>1、使用生成器模式可避免 “重叠构造函数 （tele­scop­ic con­struc­tor）” 的出现。</p>
<p>假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Pizza &#123;<br>  <span class="hljs-constructor">Pizza(<span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span> &#123;<span class="hljs-operator"> ... </span>&#125;<br>  <span class="hljs-constructor">Pizza(<span class="hljs-params">int</span> <span class="hljs-params">size</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">cheese</span>)</span> &#123;<span class="hljs-operator"> ... </span>&#125;<br>  <span class="hljs-constructor">Pizza(<span class="hljs-params">int</span> <span class="hljs-params">size</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">cheese</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">pepperoni</span>)</span> &#123;<span class="hljs-operator"> ... </span>&#125;<br>  <span class="hljs-comment">// ...</span><br>  <br></code></pre></td></tr></table></figure>
<blockquote>
<p>只有在 C# 或 Java 等支持方法重载的编程语言中才能写出如此复杂的构造函数。</p>
</blockquote>
<p>生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。</p>
<p>2、当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。</p>
<p>如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。</p>
<p>基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。</p>
<p>3、使用生成器构造组合树或其他复杂对象。</p>
<p>生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。</p>
<p>生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li><p>清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。</p>
</li>
<li><p>在基本生成器接口中声明这些步骤。</p>
</li>
<li><p>为每个形式的产品创建具体生成器类， 并实现其构造步骤。</p>
<p>不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。</p>
</li>
<li><p>考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式。</p>
</li>
<li><p>客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。</p>
</li>
<li><p>只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。</p>
</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时， 你可以复用相同的制造代码。</li>
<li>单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ol>
<p>缺点：</p>
<ol>
<li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li>
</ol>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p>在许多设计工作的初期都会使用工厂方法 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂、 原型或生成器 （更灵活但更加复杂）。</p>
</li>
<li><p>生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。</p>
</li>
<li><p>你可以在创建复杂组合树时使用生成器， 因为这可使其构造步骤以递归的方式运行。</p>
</li>
<li><p>你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p>
</li>
<li><p>抽象工厂、 生成器和原型都可以用单例来实现。</p>
</li>
</ul>
<h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型 Prototype"></a>原型 Prototype</h2><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-56-05.png" srcset="/img/loading.gif"></p>
<p>让你能够复制已有对象，而又无需使用代码依赖他们所属的类。</p>
<h3 id="问题提出-3"><a href="#问题提出-3" class="headerlink" title="问题提出"></a>问题提出</h3><p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p>
<p>不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_20-54-49.png" srcset="/img/loading.gif"></p>
<p>直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。</p>
<p>所有的类对 克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p>
<p>支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_20-56-38.png" srcset="/img/loading.gif"></p>
<p>其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。</p>
<h3 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p>现实生活中， 产品在得到大规模生产前会使用原型进行各种测试。 但在这种情况下， 原型只是一种被动的工具， 不参与任何真正的生产活动。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_20-57-54.png" srcset="/img/loading.gif" alt="一个细胞的分裂。"></p>
<p>由于工业原型并不是真正意义上的自我复制， 因此细胞有丝分裂 （还记得生物学知识吗？） 或许是更恰当的类比。 有丝分裂会产生一对完全相同的细胞。 原始细胞就是一个原型， 它在复制体的生成过程中起到了推动作用。</p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_20-58-45.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>原型 （Pro­to­type） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。</p>
</li>
<li><p>具体原型 （Con­crete Pro­to­type） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</p>
</li>
<li><p>客户端 （Client） 可以复制实现了原型接口的任何对象。</p>
</li>
</ol>
<p>原型注册表实现</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_21-10-16.png" srcset="/img/loading.gif"></p>
<ol>
<li>原型注册表 （Pro­to­type Reg­istry） 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 名称 → 原型的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。</li>
</ol>
<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 原型模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_21-12-19.png" srcset="/img/loading.gif" alt="克隆一系列位于同一类层次结构中的对象"></p>
<p>所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// 基础原型。</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> Shape <span class="hljs-keyword">is</span><br>  field X: int<br>  field Y: int<br>  field color: <span class="hljs-keyword">string</span><br><br>  <span class="hljs-comment">// 常规构造函数。</span><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Shape</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// ...</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-comment">// 原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">Shape</span><span class="hljs-params">(source: Shape)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">X</span> = <span class="hljs-title">source</span>.<span class="hljs-title">X</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">Y</span> = <span class="hljs-title">source</span>.<span class="hljs-title">Y</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">color</span> = <span class="hljs-title">source</span>.<span class="hljs-title">color</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-comment">// clone（克隆）操作会返回一个形状子类。</span></span><br><span class="hljs-function">  <span class="hljs-title">abstract</span> <span class="hljs-title">method</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span>:</span>Shape<br><br><br><span class="hljs-comment">// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span><br><span class="hljs-comment">// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span><br><span class="hljs-comment">// 成的克隆对象。这可以保持克隆结果的一致。</span><br><span class="hljs-keyword">class</span> Rectangle extends Shape <span class="hljs-keyword">is</span><br>  field width: int<br>  field height: int<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(source: Rectangle)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 需要调用父构造函数来复制父类中定义的私有成员变量。</span></span><br><span class="hljs-function">    <span class="hljs-title">super</span><span class="hljs-params">(source)</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">width</span> = <span class="hljs-title">source</span>.<span class="hljs-title">width</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">height</span> = <span class="hljs-title">source</span>.<span class="hljs-title">height</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span>:</span>Shape <span class="hljs-keyword">is</span><br>    return new Rectangle(this)<br><br><br><span class="hljs-keyword">class</span> Circle extends Shape <span class="hljs-keyword">is</span><br>  field radius: int<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Circle</span><span class="hljs-params">(source: Circle)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">super</span><span class="hljs-params">(source)</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">radius</span> = <span class="hljs-title">source</span>.<span class="hljs-title">radius</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span>:</span>Shape <span class="hljs-keyword">is</span><br>    return new Circle(this)<br><br><span class="hljs-comment">// 客户端代码中的某个位置。</span><br><span class="hljs-keyword">class</span> Application <span class="hljs-keyword">is</span><br>  field shapes: <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> Shape<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Application</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">Circle</span> <span class="hljs-title">circle</span> = <span class="hljs-title">new</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">circle</span>.<span class="hljs-title">X</span> = 10</span><br><span class="hljs-function">    <span class="hljs-title">circle</span>.<span class="hljs-title">Y</span> = 10</span><br><span class="hljs-function">    <span class="hljs-title">circle</span>.<span class="hljs-title">radius</span> = 20</span><br><span class="hljs-function">    <span class="hljs-title">shapes</span>.<span class="hljs-title">add</span><span class="hljs-params">(circle)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">Circle</span> <span class="hljs-title">anotherCircle</span> = <span class="hljs-title">circle</span>.<span class="hljs-title">clone</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">shapes</span>.<span class="hljs-title">add</span><span class="hljs-params">(anotherCircle)</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 容完全一样。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">Rectangle</span> <span class="hljs-title">rectangle</span> = <span class="hljs-title">new</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">rectangle</span>.<span class="hljs-title">width</span> = 10</span><br><span class="hljs-function">    <span class="hljs-title">rectangle</span>.<span class="hljs-title">height</span> = 20</span><br><span class="hljs-function">    <span class="hljs-title">shapes</span>.<span class="hljs-title">add</span><span class="hljs-params">(rectangle)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">businessLogic</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 其完全相同的复制品。</span></span><br><span class="hljs-function">    <span class="hljs-title">Array</span> <span class="hljs-title">shapesCopy</span> = <span class="hljs-title">new</span> <span class="hljs-title">Array</span> <span class="hljs-title">of</span> <span class="hljs-title">Shapes</span>.</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-comment">// 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span><br><span class="hljs-function">    <span class="hljs-title">foreach</span> <span class="hljs-params">(s <span class="hljs-keyword">in</span> shapes)</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">      <span class="hljs-title">shapesCopy</span>.<span class="hljs-title">add</span><span class="hljs-params">(s.clone()</span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-comment">// `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 子元素的复制品。</span></span><br></code></pre></td></tr></table></figure>


<h3 id="适合应用场景-1"><a href="#适合应用场景-1" class="headerlink" title="适合应用场景"></a>适合应用场景</h3><ol>
<li><p>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</p>
<p>这一点考量通常出现在代码需要处理<strong>第三方代码通过接口传递过来的对象</strong>时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息（包括私有成员的信息）。</p>
<p>原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。</p>
</li>
<li><p>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</p>
<p>在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。</p>
<p>客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。</p>
</li>
</ol>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>创建原型接口， 并在其中声明 克隆方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。</p>
</li>
<li><p>原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。</p>
<p>如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。</p>
</li>
<li><p>克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 否则， 克隆方法可能会生成父类的对象。</p>
</li>
<li><p>你还可以创建一个中心化原型注册表， 用于存储常用原型。</p>
<p>你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。</p>
<p>最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</p>
</li>
</ol>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以克隆对象， 而无需与它们所属的具体类相耦合。</li>
<li>你可以克隆预生成原型， 避免反复运行初始化代码。</li>
<li>你可以更方便地生成复杂对象。</li>
<li>你可以用继承以外的方式来处理复杂对象的不同配置。</li>
</ol>
<p>缺点：</p>
<ol>
<li>克隆包含循环引用的复杂对象可能会非常麻烦。</li>
</ol>
<h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>在许多设计工作的初期都会使用工厂方法 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂、 原型或生成器 （更灵活但更加复杂）。</p>
</li>
<li><p>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</p>
</li>
<li><p>原型可用于保存命令的历史记录。</p>
</li>
<li><p>大量使用组合和装饰的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。”</p>
</li>
<li><p>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。</p>
</li>
<li><p>有时候原型可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</p>
</li>
<li><p>抽象工厂、 生成器和原型都可以用单例来实现。</p>
</li>
</ol>
<h2 id="单例-Singleton"><a href="#单例-Singleton" class="headerlink" title="单例 Singleton"></a>单例 Singleton</h2><p>让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p>
<h3 id="问题提出-4"><a href="#问题提出-4" class="headerlink" title="问题提出"></a>问题提出</h3><p>单例模式同时解决了两个问题， 所以违反了_单一职责原则_：</p>
<ol>
<li><p><strong>保证一个类只有一个实例。</strong> 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</p>
<p>它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p>
<p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-44-54.png" srcset="/img/loading.gif"></p>
</li>
<li><p><strong>为该实例提供一个全局访问节点。</strong> 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p>
<p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p>
<p>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p>
</li>
</ol>
<p>如今， 单例模式已经变得非常流行， 以至于人们会将只解决上文描述中任意一个问题的东西称为单例。</p>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>所有单例的实现都包含以下两个相同的步骤：</p>
<ul>
<li>将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。</li>
<li>新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ul>
<p>如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。</p>
<h3 id="真实世界类比-1"><a href="#真实世界类比-1" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p>政府是单例模式的一个很好的示例。 一个国家只有一个官方政府。 不管组成政府的每个人的身份是什么，  “某政府” 这一称谓总是鉴别那些掌权者的全局访问节点。</p>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-51-03.png" srcset="/img/loading.gif"></p>
<ul>
<li>单例 （Sin­gle­ton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。</li>
<li>单例的构造函数必须对客户端 （Client） 代码隐藏（通过private）。 调用 获取实例方法必须是获取单例对象的唯一方式。</li>
</ul>
<h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 数据库连接类即是一个单例。</p>
<p>该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处</span><br><span class="hljs-comment">// 都能访问相同的数据库连接实例。</span><br><span class="hljs-keyword">class</span> Database is<br>  <span class="hljs-comment">// 保存单例实例的成员变量必须被声明为静态类型。</span><br>  <span class="hljs-keyword">private</span> static field instance: Database<br><br>  <span class="hljs-comment">// 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构</span><br>  <span class="hljs-comment">// 造方法。</span><br>  <span class="hljs-keyword">private</span> constructor <span class="hljs-constructor">Database()</span> is<br>    <span class="hljs-comment">// 部分初始化代码（例如到数据库服务器的实际连接）。</span><br>    <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-comment">// 用于控制对单例实例的访问权限的静态方法。</span><br>  public static <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Instance()</span> is<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<span class="hljs-operator"> == </span>null) <span class="hljs-keyword">then</span><br>      acquire<span class="hljs-constructor">ThreadLock()</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">// 确保在该线程等待解锁时，其他线程没有初始化该实例。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<span class="hljs-operator"> == </span>null) <span class="hljs-keyword">then</span><br>          <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Database()</span><br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<br><br>  <span class="hljs-comment">// 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span><br>  public <span class="hljs-keyword">method</span> query(sql) is<br>    <span class="hljs-comment">// 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以</span><br>    <span class="hljs-comment">// 在这里添加限流或缓冲逻辑。</span><br>    <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> Application is<br>  <span class="hljs-keyword">method</span> main<span class="hljs-literal">()</span> is<br>    Database foo = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br>    foo.query(<span class="hljs-string">&quot;SELECT ...&quot;</span>)<br>    <span class="hljs-comment">// ...</span><br>    Database bar = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br>    bar.query(<span class="hljs-string">&quot;SELECT ...&quot;</span>)<br>    <span class="hljs-comment">// 变量 `bar` 和 `foo` 中将包含同一个对象。</span><br></code></pre></td></tr></table></figure>




<h3 id="适合应用场景-2"><a href="#适合应用场景-2" class="headerlink" title="适合应用场景"></a>适合应用场景</h3><p>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。</p>
<p>单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</p>
<p>如果你需要更加严格地控制全局变量， 可以使用单例模式。</p>
<p>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p>
<p>请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例方法， 即 getInstance 中的代码即可实现。</p>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>在类中添加一个私有静态成员变量用于保存单例实例。</p>
</li>
<li><p>声明一个公有静态构建方法用于获取单例实例。</p>
</li>
<li><p>在静态方法中实现”延迟初始化”（注意存在Check Than Act现象，注意线程安全问题）。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</p>
</li>
<li><p>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</p>
</li>
<li><p>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。</p>
</li>
</ol>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以保证一个类只有一个实例。</li>
<li>你获得了一个指向该实例的全局访问节点。</li>
<li>仅在首次请求单例对象时对其进行初始化。</li>
</ol>
<p>缺点：</p>
<ol>
<li>违反了_单一职责原则_。 该模式同时解决了两个问题。</li>
<li>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li>
<li>该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li>
<li>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li>
</ol>
<h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><strong>外观</strong>类通常可以转换为<strong>单例</strong>类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象， 那么<strong>享元</strong>就和<strong>单例</strong>类似了。 但这两个模式有两个根本性的不同。<ul>
<li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。 享元对象是不可变的。</li>
</ul>
</li>
<li>抽象工厂、 生成器和原型都可以用单例来实现。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/09/12/SQL-%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0%E6%8C%87%E5%8D%97/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SQL-开窗函数指南</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/">
                        <span class="hidden-mobile">设计模式-结构性模式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
