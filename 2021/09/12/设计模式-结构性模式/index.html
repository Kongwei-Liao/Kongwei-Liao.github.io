

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>设计模式-结构性模式 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="设计模式-结构性模式">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-12 10:29" pubdate>
        2021年9月12日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      139
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式-结构性模式</h1>
            
            <div class="markdown-body">
              <h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效</p>
<h2 id="适配器-Adapter"><a href="#适配器-Adapter" class="headerlink" title="适配器 Adapter"></a>适配器 Adapter</h2><p>让接口不兼容的对象能够相互合作</p>
<p>亦称：封装器模式、Wapper、Adapter</p>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>倘若你正在开发一款股票市场检测程序，它会从不同来源下载XML格式的股票数据，然后向用户呈现出美观的图表。在开发过程中，你决定在程序中整合使用一个第三方的智能分析函数库。但是现在遇到一个问题，那就是这个第三方的分析函数库只兼容JSON格式的数据。</p>
<p><img src="https://i.loli.net/2021/09/12/PU6lbR7SEVIiQY8.png" srcset="/img/loading.gif" alt="你无法 “直接” 使用分析函数库，因为它所需的输入数据格式与你的程序不兼容。 "></p>
<p>一种方式是，你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>你可以创建一个适配器。 这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。</p>
<p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。 例如， 你可以使用一个将所有数据转换为英制单位 （如英尺和英里） 的适配器封装运行于米和千米单位制中的对象。</p>
<p>适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：</p>
<ol>
<li>适配器实现与其中一个现有对象兼容的接口。</li>
<li>现有对象可以使用该接口安全地调用适配器方法。</li>
<li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li>
</ol>
<p>有时你甚至可以创建一个双向适配器来实现双向转换调用。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_10-57-06.png" srcset="/img/loading.gif"></p>
<p>回到股票市场程序。 为了解决数据格式不兼容的问题， 你可以为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器， 然后让客户端仅通过这些适配器来与函数库进行交流。 当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。</p>
<h3 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-01-20.png" srcset="/img/loading.gif" alt="出国旅行前后的旅行箱。"></p>
<p>如果你是第一次从美国到欧洲旅行， 那么在给笔记本充电时可能会大吃一惊。 不同国家的电源插头和插座标准不同。 美国插头和德国插座不匹配。 同时提供美国标准插座和欧洲标准插头的电源适配器可以解决你的难题。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-04-16.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>客户端 （Client） 是包含当前程序业务逻辑的类。</p>
</li>
<li><p>客户端接口 （Client Inter­face） 描述了其他类与客户端代码合作时必须遵循的协议。</p>
</li>
<li><p>服务 （Ser­vice） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。</p>
</li>
<li><p>适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</p>
</li>
</ol>
<p>客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>这一实现使用了继承机制： 适配器同时继承两个对象的接口。 <strong>请注意， 这种方式仅能在支持多重继承的编程语言中实现， 例如 C++。Java仅支持单继承</strong>”</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-10-27.png" srcset="/img/loading.gif"></p>
<p>类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。</p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>下面介绍一个适配器模式演示基于经典的“方钉和圆孔”问题。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-23-53.png" srcset="/img/loading.gif" alt="让方钉适配圆孔"></p>
<p>适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// 假设你有两个接口相互兼容的类：圆孔（RoundHole）和圆钉（RoundPeg）。</span><br><span class="hljs-keyword">class</span> RoundHole <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">RoundHole</span><span class="hljs-params">(radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回孔的半径。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">fits</span><span class="hljs-params">(peg: RoundPeg)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">this</span>.<span class="hljs-title">getRadius</span><span class="hljs-params">()</span> &gt;= <span class="hljs-title">peg</span>.<span class="hljs-title">getRadius</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">RoundPeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">RoundPeg</span><span class="hljs-params">(radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回钉子的半径。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 但还有一个不兼容的类：方钉（SquarePeg）。</span></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SquarePeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(width)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回方钉的宽度。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适配器对象作为圆钉。</span></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SquarePegAdapter</span> <span class="hljs-title">extends</span> <span class="hljs-title">RoundPeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-comment">// 在实际情况中，适配器中会包含一个 SquarePeg 类的实例。</span></span><br><span class="hljs-function">  <span class="hljs-title">private</span> <span class="hljs-title">field</span> <span class="hljs-title">peg</span>:</span> SquarePeg<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(peg: SquarePeg)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">peg</span> = <span class="hljs-title">peg</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 适配器会假扮为一个圆钉，其半径刚好能与适配器实际封装的方钉搭配起来。</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">peg</span>.<span class="hljs-title">getWidth</span><span class="hljs-params">()</span> * <span class="hljs-title">Math</span>.<span class="hljs-title">sqrt</span><span class="hljs-params">(2)</span> / 2</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 客户端代码中的某个位置。</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span> = <span class="hljs-title">new</span> <span class="hljs-title">RoundHole</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">rpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">RoundPeg</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(rpeg)</span> <span class="hljs-comment">// true</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">small_sqpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">large_sqpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(10)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(small_sqpeg)</span> <span class="hljs-comment">// 此处无法编译（类型不一致）。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">small_sqpeg_adapter</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(small_sqpeg)</span></span><br><span class="hljs-function"><span class="hljs-title">large_sqpeg_adapter</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(large_sqpeg)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(small_sqpeg_adapter)</span> <span class="hljs-comment">// true</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(large_sqpeg_adapter)</span> <span class="hljs-comment">// false</span></span><br></code></pre></td></tr></table></figure>




<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</p>
<p>适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</p>
<p>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>确保至少有两个类的接口不兼容：<ul>
<li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。</li>
<li>一个或多个将受益于使用服务类的客户端类。</li>
</ul>
</li>
<li>声明客户端接口，描述客户端与服务如何交互；</li>
<li>创建遵循客户端接口的适配器。所有方法暂时都为空；</li>
<li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li>
<li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li>
<li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>单一职责原则：你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li>
<li>开闭原则：只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li>
</ol>
<p>缺点：</p>
<ol>
<li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li>
</ol>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>桥接通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
</li>
<li><p>适配器可以对已有对象的接口进行修改， 装饰则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p>
</li>
<li><p>适配器能为被封装对象提供不同的接口， 代理能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p>
</li>
<li><p>外观为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p>
</li>
<li><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
</ol>
<h2 id="桥接-Bridge"><a href="#桥接-Bridge" class="headerlink" title="桥接 Bridge"></a>桥接 Bridge</h2><p>将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。</p>
<h3 id="问题提出-1"><a href="#问题提出-1" class="headerlink" title="问题提出"></a>问题提出</h3><p>假如你有一个几何 形状Shape类， 从它能扩展出两个子类：  圆形Cir­cle和 方形Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为 红色Red和 蓝色Blue的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如 蓝色圆形Blue­Cir­cle和 红色方形Red­Square 。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_12-54-47.png" srcset="/img/loading.gif" alt="所有组合类的数量将以几何倍数增长"></p>
<p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。 如此以往， 情况会越来越糟糕。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>问题的根本原因是我们试图在两个独立的维度——形状与颜色——上扩展形状类。 这在处理类继承时是很常见的问题。</p>
<p>桥接模式通过将继承改为组合的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_12-57-47.png" srcset="/img/loading.gif" alt="将一个类层次转化为多个相关的类层析，避免单个类层次的失控"> </p>
<p>根据该方法， 我们可以将颜色相关的代码抽取到拥有 红色和 蓝色两个子类的颜色类中， 然后在 形状类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 形状和 颜色之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。</p>
<h3 id="抽象部分与实现部分"><a href="#抽象部分与实现部分" class="headerlink" title="抽象部分与实现部分"></a>抽象部分与实现部分</h3><p>设计模式四人组的著作 在桥接定义中提出了抽象部分和实现部分两个术语。 我觉得这些术语过于学术了， 反而让模式看上去比实际情况更加复杂。 在介绍过形状和颜色的简单例子后， 我们来看看四人组著作中让人望而生畏的词语的含义。</p>
<p>抽象部分 （也被称为接口） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给实现部分层（亦称 平台 ）</p>
<p>注意， 这里提到的内容与编程语言中的接口或抽象类无关。 它们并不是一回事。</p>
<p>在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。</p>
<p>一般来说， 你可以在两个独立方向上扩展这种应用：</p>
<ul>
<li>开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置）</li>
<li>支持多个不同的 API （例如， 能够在 Win­dows、 Linux 和 macOS 上运行该程序）。</li>
</ul>
<p>在最糟糕的情况下， 程序可能会是一团乱麻， 其中包含数百种条件语句， 连接着代码各处不同种类的 GUI 和各种API。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-05-16.png" srcset="/img/loading.gif" alt="在庞杂的代码中， 即使是很小的改动都非常难以完成， 因为你必须要在整体上对代码有充分的理解。 而在较小且定义明确的模块中， 进行修改则要容易得多 "></p>
<p>你可以将特定接口-平台的组合代码抽取到独立的类中， 以在混乱中建立一些秩序。 但是， 你很快会发现这种类的数量很多。 类层次将以指数形式增长， 因为每次添加一个新的 GUI 或支持一种新的 API 都需要创建更多的类。</p>
<p>让我们试着用桥接模式来解决这个问题。 该模式建议将类拆分为两个类层次结构：</p>
<ul>
<li>抽象部分： 程序的 GUI 层。</li>
<li>实现部分： 操作系统的 API。</li>
</ul>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-09-29.png" srcset="/img/loading.gif" alt="创建跨平台应用程序的一种方法"></p>
<p>抽象对象控制程序的外观， 并将真实工作委派给连入的实现对象。 不同的实现只要遵循相同的接口就可以互换， 使同一 GUI 可在 Win­dows 和 Linux 下运行。</p>
<p>最后的结果是： 你无需改动与 API 相关的类就可以修改 GUI 类。 此外如果想支持一个新的操作系统， 只需在实现部分层次中创建一个子类即可。</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-12-17.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>抽象部分 （Abstrac­tion） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</p>
</li>
<li><p>实现部分 （Imple­men­ta­tion） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。</p>
</li>
<li><p>具体实现 （Con­crete Imple­men­ta­tions） 中包括特定于平台的代码。</p>
</li>
<li><p>精确抽象 （Refined Abstrac­tion） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</p>
</li>
<li><p>通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</p>
</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>示例演示了桥接模式如何拆分程序中同时管理设备及其遥控器的庞杂代码。  设备Device类作为实现部分， 而 遥控器Remote类则作为抽象部分。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-15-02.png" srcset="/img/loading.gif" alt="最初类层次结构被才分成两个部分：设备和遥控器"></p>
<p>遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。</p>
<p>你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。</p>
<p>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实</span><br><span class="hljs-comment">// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span><br><span class="hljs-keyword">class</span> RemoteControl is<br>  protected field device: Device<br>  constructor <span class="hljs-constructor">RemoteControl(<span class="hljs-params">device</span>: Device)</span> is<br>    this.device = device<br>  <span class="hljs-keyword">method</span> toggle<span class="hljs-constructor">Power()</span> is<br>    <span class="hljs-keyword">if</span> (device.is<span class="hljs-constructor">Enabled()</span>) <span class="hljs-keyword">then</span><br>      device.disable<span class="hljs-literal">()</span><br>    <span class="hljs-keyword">else</span><br>      device.enable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> volume<span class="hljs-constructor">Down()</span> is<br>    device.set<span class="hljs-constructor">Volume(<span class="hljs-params">device</span>.<span class="hljs-params">getVolume</span>()</span> - <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">method</span> volume<span class="hljs-constructor">Up()</span> is<br>    device.set<span class="hljs-constructor">Volume(<span class="hljs-params">device</span>.<span class="hljs-params">getVolume</span>()</span> + <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">method</span> channel<span class="hljs-constructor">Down()</span> is<br>    device.set<span class="hljs-constructor">Channel(<span class="hljs-params">device</span>.<span class="hljs-params">getChannel</span>()</span> - <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">method</span> channel<span class="hljs-constructor">Up()</span> is<br>    device.set<span class="hljs-constructor">Channel(<span class="hljs-params">device</span>.<span class="hljs-params">getChannel</span>()</span> + <span class="hljs-number">1</span>)<br><br><br><span class="hljs-comment">// 你可以独立于设备类的方式从抽象层中扩展类。</span><br><span class="hljs-keyword">class</span> AdvancedRemoteControl extends RemoteControl is<br>  <span class="hljs-keyword">method</span> mute<span class="hljs-literal">()</span> is<br>    device.set<span class="hljs-constructor">Volume(0)</span><br><br><br><span class="hljs-comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相</span><br><span class="hljs-comment">// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而</span><br><span class="hljs-comment">// 抽象接口则会基于这些操作定义较高层次的操作。</span><br>interface Device is<br>  <span class="hljs-keyword">method</span> is<span class="hljs-constructor">Enabled()</span><br>  <span class="hljs-keyword">method</span> enable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> disable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Volume()</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Volume(<span class="hljs-params">percent</span>)</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Channel()</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Channel(<span class="hljs-params">channel</span>)</span><br><br><br><span class="hljs-comment">// 所有设备都遵循相同的接口。</span><br><span class="hljs-keyword">class</span> Tv implements Device is<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> Radio implements Device is<br>  <span class="hljs-comment">// ...</span><br><br><br><span class="hljs-comment">// 客户端代码中的某个位置。</span><br>tv = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Tv()</span><br>remote = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RemoteControl(<span class="hljs-params">tv</span>)</span><br>remote.toggle<span class="hljs-constructor">Power()</span><br><br>radio = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Radio()</span><br>remote = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AdvancedRemoteControl(<span class="hljs-params">radio</span>)</span><br></code></pre></td></tr></table></figure>




<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p>
<p>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</p>
<p>2、如果你希望在几个独立维度上扩展一个类， 可使用该模式。</p>
<p>桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</p>
<p>3、如果你需要在运行时切换不同实现方法， 可使用桥接模式。</p>
<p>当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</p>
<p>顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。</p>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</p>
</li>
<li><p>了解客户端的业务需求， 并在抽象基类中定义它们。</p>
</li>
<li><p>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</p>
</li>
<li><p>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</p>
</li>
<li><p>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</p>
</li>
<li><p>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</p>
</li>
<li><p>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</p>
</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以创建与平台无关的类和程序。</li>
<li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li>
<li>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li>
<li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li>
</ol>
<p>缺点：</p>
<ol>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ol>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>桥接通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
</li>
<li><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li><p>你可以将抽象工厂和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p>
</li>
<li><p>你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p>
</li>
</ol>
<h2 id="组合-Composite"><a href="#组合-Composite" class="headerlink" title="组合 Composite"></a>组合 Composite</h2><p>可以使用该模式将对象组合成树状结构，并且能够像使用独立对象一样使用他们。</p>
<h3 id="问题提出-2"><a href="#问题提出-2" class="headerlink" title="问题提出"></a>问题提出</h3><p>如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。</p>
<p>例如， 你有两类对象：  产品 和 盒子 。 一个盒子中可以包含多个 产品或者几个较小的 盒子 。 这些小 盒子中同样可以包含一些 产品或更小的 盒子 ， 以此类推。</p>
<p>假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子……以及其他盒子。 此时你会如何计算每张订单的总价格呢？</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-08-16.png" srcset="/img/loading.gif"></p>
<p>你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后计算总价。 这在真实世界中或许可行， 但在程序中， 你并不能简单地使用循环语句来完成该工作。 你必须事先知道所有 产品和 盒子的类别， 所有盒子的嵌套层数以及其他繁杂的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>组合模式建议使用一个通用接口来与 产品和 盒子进行交互， 并且在该接口中声明一个计算总价的方法。</p>
<p>那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-10-43.png" srcset="/img/loading.gif"></p>
<p>该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。</p>
<h3 id="真实世界类比-1"><a href="#真实世界类比-1" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-12-18.png" srcset="/img/loading.gif"></p>
<p>大部分国家的军队都采用层次结构管理。 每支部队包括几个师， 师由旅构成， 旅由团构成， 团可以继续划分为排。 最后， 每个排由一小队实实在在的士兵组成。 军事命令由最高层下达， 通过每个层级传递， 直到每位士兵都知道自己应该服从的命令。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-14-17.png" srcset="/img/loading.gif"></p>
<p>1、组件 （Com­po­nent） 接口描述了树中简单项目和复杂项目所共有的操作。</p>
<p>2、叶节点 （Leaf） 是树的基本结构， 它不包含子项目。</p>
<p>一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p>
<p>3、容器 （Con­tain­er）——又名 “组合 （Com­pos­ite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。</p>
<p>容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</p>
<p>4、客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</p>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 我们将借助组合模式帮助你在图形编辑器中实现一系列的几何图形。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-17-26.png" srcset="/img/loading.gif"></p>
<p>组合图形Com­pound­Graph­ic是一个容器， 它可以由多个包括容器在内的子图形构成。 组合图形与简单图形拥有相同的方法。 但是， 组合图形自身并不完成具体工作， 而是将请求递归地传递给自己的子项目， 然后 “汇总” 结果。</p>
<p>通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 组件接口会声明组合中简单和复杂对象的通用操作。</span><br><span class="hljs-keyword">interface</span> Graphic <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象</span><br><span class="hljs-function">// 通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Dot</span> <span class="hljs-title">implements</span> <span class="hljs-title">Graphic</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">x</span>, <span class="hljs-title">y</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">Dot</span><span class="hljs-params">(x, y)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">x</span> += <span class="hljs-title">x</span>, <span class="hljs-title">this</span>.<span class="hljs-title">y</span> += <span class="hljs-title">y</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在坐标位置<span class="hljs-params">(X,Y)</span>处绘制一个点。</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 所有组件类都可以扩展其他组件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Circle</span> <span class="hljs-title">extends</span> <span class="hljs-title">Dot</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">radius</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">Circle</span><span class="hljs-params">(x, y, radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在坐标位置<span class="hljs-params">(X,Y)</span>处绘制一个半径为 <span class="hljs-title">R</span> 的圆。</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项</span><br><span class="hljs-function">// 目，然后“汇总”结果。 </span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">CompoundGraphic</span> <span class="hljs-title">implements</span> <span class="hljs-title">Graphic</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">children</span>:</span> <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> Graphic<br><br>  <span class="hljs-comment">// 组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">add</span><span class="hljs-params">(child: Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在子项目数组中添加一个子项目。</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">remove</span><span class="hljs-params">(child: Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 从子项目数组中移除一个子项目。</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">foreach</span> <span class="hljs-params">(child <span class="hljs-keyword">in</span> children)</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">      <span class="hljs-title">child</span>.<span class="hljs-title">move</span><span class="hljs-params">(x, y)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  // 组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和</span><br><span class="hljs-function">  // 汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，</span><br><span class="hljs-function">  // 最后组合将会完成整个对象树的遍历工作。</span><br><span class="hljs-function">    <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 1. 对于每个子部件：</span><br><span class="hljs-function">    //     - 绘制该部件。</span><br><span class="hljs-function">    //     - 更新边框坐标。</span><br><span class="hljs-function">    // 2. 根据边框坐标绘制一个虚线长方形。</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同</span><br><span class="hljs-function">// 时支持简单叶节点组件和复杂组件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">ImageEditor</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">all</span>:</span> CompoundGraphic<br><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span> = <span class="hljs-title">new</span> <span class="hljs-title">CompoundGraphic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Dot(1, 2)</span>)</span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Circle(5, 3, 10)</span>)</span><br><span class="hljs-function">    // ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">  // 将所需组件组合为复杂的组合组件。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">groupSelected</span><span class="hljs-params">(components: <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">group</span> = <span class="hljs-title">new</span> <span class="hljs-title">CompoundGraphic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">foreach</span> <span class="hljs-params">(component <span class="hljs-keyword">in</span> components)</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">      <span class="hljs-title">group</span>.<span class="hljs-title">add</span><span class="hljs-params">(component)</span></span><br><span class="hljs-function">      <span class="hljs-title">all</span>.<span class="hljs-title">remove</span><span class="hljs-params">(component)</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">group</span>)</span></span><br><span class="hljs-function">    // 所有组件都将被绘制。</span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>


<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、如果你需要实现树状对象结构， 可以使用组合模式。</p>
<p> 组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。</p>
<p> 2、如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p>
<p> 组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</p>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><p>1、确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p>
<p>2、声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p>
<p>3、创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p>
<p>4、创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p>
<p>实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p>
<p>5、最后， 在容器中定义添加和删除子元素的方法。</p>
<p>记住， 这些操作可在组件接口中声明。 这将会违反_接口隔离原则_， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<p>1、你可以利用多态和递归机制更方便地使用复杂树结构。</p>
<p>2、开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</p>
<p>缺点：</p>
<p>1、对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</p>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><p>1、桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
<p>2、你可以在创建复杂组合树时使用生成器， 因为这可使其构造步骤以递归的方式运行。</p>
<p>3、责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
<p>4、你可以使用迭代器来遍历组合树。</p>
<p>5、你可以使用访问者对整个组合树执行操作。</p>
<p>6、你可以使用享元实现组合树的共享叶节点以节省内存。</p>
<p>7、组合和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p>
<p>8、大量使用组合和装饰的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
<h2 id="装饰-Decorator"><a href="#装饰-Decorator" class="headerlink" title="装饰 Decorator"></a>装饰 Decorator</h2><p>允许通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设你正在开发一个提供通知功能的库， 其他程序可使用它向用户发送关于重要事件的通知。</p>
<p>库的最初版本基于 通知器Noti­fi­er类， 其中只有很少的几个成员变量， 一个构造函数和一个 send发送方法。 该方法可以接收来自客户端的消息参数， 并将该消息发送给一系列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作为客户端的第三方程序仅会创建和配置通知器对象一次， 然后在有重要事件发生时对其进行调用。</p>
<h2 id="外观-Facade"><a href="#外观-Facade" class="headerlink" title="外观 Facade"></a>外观 Facade</h2><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-10-07_22-44-26.png" srcset="/img/loading.gif"></p>
<p>能够为成序库、框架或者其他复杂类提供一个简单的接口。</p>
<h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。</p>
<p>最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。</p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却<u><strong>包含了客户端真正关心的功能</strong></u>。</p>
<p><strong>如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便</strong>，</p>
<p>例如， 上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库， 但它只需使用一个包含 encode­(filename, format)方法 （以文件名与文件格式为参数进行编码的方法） 的类即可。 在创建这个类并将其连接到视频转换库后， 你就拥有了自己的第一个外观。</p>
<h3 id="真实世界类比-2"><a href="#真实世界类比-2" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-10-07_22-47-56.png" srcset="/img/loading.gif"></p>
<p>当你通过电话给商店下达订单时， 接线员就是该商店的所有服务和部门的外观。 接线员为你提供了一个同购物系统、 支付网关和各种送货服务进行互动的简单语音接口。</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-10-07_22-52-20.png" srcset="/img/loading.gif"></p>
<ol>
<li><p><strong>外观</strong> （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p>
</li>
<li><p>创建<strong>附加外观</strong> （Addi­tion­al Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p>
</li>
<li><p><strong>复杂子系统</strong> （Com­plex Sub­sys­tem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p>
<p>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p>
</li>
<li><p>客户端 （Client） 使用外观代替对子系统对象的直接调用。</p>
</li>
</ol>
<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 外观模式简化了客户端与复杂视频转换框架之间的交互。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-10-07_23-01-17.png" srcset="/img/loading.gif"></p>
<p>你可以创建一个封装所需功能并隐藏其他代码的外观类， 从而无需使全部代码直接与数十个框架类进行交互。 该结构还能将未来框架升级或更换所造成的影响最小化， 因为你只需修改程序中外观方法的实现即可。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法</span><br><span class="hljs-comment">// 对其进行简化。</span><br><br><span class="hljs-keyword">class</span> VideoFile<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> OggCompressionCodec<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> MPEG4CompressionCodec<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> CodecFactory<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> BitrateReader<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> AudioMixer<br><span class="hljs-comment">// ...</span><br><br><br><span class="hljs-comment">// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在</span><br><span class="hljs-comment">// 功能性和简洁性之间做出的权衡。</span><br><span class="hljs-keyword">class</span> VideoConverter is<br>  <span class="hljs-keyword">method</span> convert(filename, format):File is<br>    file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">VideoFile(<span class="hljs-params">filename</span>)</span><br>    sourceCodec = <span class="hljs-keyword">new</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CodecFactory</span>.</span></span>extract(file)<br>    <span class="hljs-keyword">if</span> (format<span class="hljs-operator"> == </span><span class="hljs-string">&quot;mp4&quot;</span>)<br>      destinationCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MPEG4CompressionCodec()</span><br>    <span class="hljs-keyword">else</span><br>      destinationCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OggCompressionCodec()</span><br>    buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BitrateReader</span>.</span></span>read(filename, sourceCodec)<br>    result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BitrateReader</span>.</span></span>convert(buffer, destinationCodec)<br>    result = (<span class="hljs-keyword">new</span> <span class="hljs-constructor">AudioMixer()</span>).fix(result)<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">result</span>)</span><br><br><span class="hljs-comment">// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，</span><br><span class="hljs-comment">// 那只需重写外观类即可。</span><br><span class="hljs-keyword">class</span> Application is<br>  <span class="hljs-keyword">method</span> main<span class="hljs-literal">()</span> is<br>    convertor = <span class="hljs-keyword">new</span> <span class="hljs-constructor">VideoConverter()</span><br>    mp4 = convertor.convert(<span class="hljs-string">&quot;funny-cats-video.ogg&quot;</span>, <span class="hljs-string">&quot;mp4&quot;</span>)<br>    mp4.save<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure>
<h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li><p>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</p>
<blockquote>
<p>子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</p>
</blockquote>
</li>
<li><p>如果需要将子系统组织为多层结构， 可以使用外观。</p>
<blockquote>
<p>创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</p>
</blockquote>
</li>
</ul>
<p>让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与中介者模式非常相似。</p>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p><strong>考虑能否在现有子系统的基础上提供一个更简单的接口</strong>。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。</p>
</li>
<li><p><strong>在一个新的外观类中声明并实现该接口</strong>。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化， 也没有对其后续生命周期进行管理， 那么外观必须完成此类工作。</p>
</li>
<li><p>如果要充分发挥这一模式的优势， 你必须<strong>确保所有客户端代码仅通过外观来与子系统进行交互</strong>。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。</p>
</li>
<li><p><strong>如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。</strong></p>
</li>
</ol>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：你可以让自己的代码独立于复杂子系统。</p>
<p>缺点：外观可能成为与程序中所有类都耦合的上帝对象。</p>
<h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p><strong>外观</strong>为现有对象定义了一个新接口， <strong>适配器</strong>则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p>
</li>
<li><p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<strong>抽象工厂</strong>来代替<strong>外观</strong>。</p>
</li>
<li><p>享元展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。</p>
</li>
<li><p><strong>外观</strong>和<strong>中介者</strong>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。</p>
<ul>
<li>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li>
<li>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>
</ul>
</li>
<li><p><strong>外观类</strong>通常可以转换为<strong>单例类</strong>， 因为在大部分情况下一个外观对象就足够了。</p>
</li>
<li><p><strong>外观</strong>与<strong>代理</strong>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 <strong>代理</strong>与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>
</li>
</ul>
<h2 id="享元-Flaweight"><a href="#享元-Flaweight" class="headerlink" title="享元 Flaweight"></a>享元 Flaweight</h2><p>摒弃了在每个对象中保存数据的方式，通过共享多个对象所共有的相同状态，让你能够在有限的内存容量中载入更多对象。</p>
<h2 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h2><p>让我们能够提供对象的替代品或者占位符。代理控制着对于原对象的访问，并且允许在将请求提交给对象前后进行一些处理。</p>
<h3 id="问题提出-3"><a href="#问题提出-3" class="headerlink" title="问题提出"></a>问题提出</h3><p>为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-05-07.png" srcset="/img/loading.gif" alt="数据库查询有可能会非常缓慢。"></p>
<p>你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。</p>
<p>在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。</p>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-07-45.png" srcset="/img/loading.gif" alt="代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。"><br>这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。</p>
<h3 id="真实世界类比-3"><a href="#真实世界类比-3" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-09-56.png" srcset="/img/loading.gif"></p>
<p>信用卡是银行账户的代理， 银行账户则是一大捆现金的代理。 它们都实现了同样的接口， 均可用于进行支付。 消费者会非常满意， 因为不必随身携带大量现金； 商店老板同样会十分高兴， 因为交易收入能以电子化的方式进入商店的银行账户中， 无需担心存款时出现现金丢失或被抢劫的情况。</p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-10-53.png" srcset="/img/loading.gif"></p>
<ol>
<li><strong>服务接口</strong> （Ser­vice Inter­face） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</li>
<li><strong>服务</strong> （Ser­vice） 类提供了一些实用的业务逻辑。</li>
<li><strong>代理</strong> （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。</li>
<li><strong>客户端</strong> （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</li>
</ol>
<h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>本例演示如何使用代理模式在第三方腾讯视频 （Ten­centVideo， 代码示例中记为 TV） 程序库中添加延迟初始化和缓存。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-12-05.png" srcset="/img/loading.gif"></p>
<p>程序库提供了视频下载类。 但是该类的效率非常低。 如果客户端程序多次请求同一视频， 程序库会反复下载该视频， 而不会将首次下载的文件缓存下来复用。</p>
<p>代理类实现和原下载器相同的接口， 并将所有工作委派给原下载器。 不过， 代理类会保存所有的文件下载记录， 如果程序多次请求同一文件， 它会返回缓存的文件。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 远程服务接口。</span><br>interface ThirdPartyTVLib is<br>  <span class="hljs-keyword">method</span> <span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span><br>  <span class="hljs-keyword">method</span> download<span class="hljs-constructor">Video(<span class="hljs-params">id</span>)</span><br><br><span class="hljs-comment">// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于</span><br><span class="hljs-comment">// 用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息</span><br><span class="hljs-comment">// 一模一样，程序的速度依然会减慢。</span><br><span class="hljs-keyword">class</span> ThirdPartyTVClass implements ThirdPartyTVLib is<br>  <span class="hljs-keyword">method</span> <span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span> is<br>    <span class="hljs-comment">// 向腾讯视频发送一个 API 请求。</span><br><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span> is<br>    <span class="hljs-comment">// 获取某个视频的元数据。</span><br><br>  <span class="hljs-keyword">method</span> download<span class="hljs-constructor">Video(<span class="hljs-params">id</span>)</span> is<br>    <span class="hljs-comment">// 从腾讯视频下载一个视频文件。</span><br><br><span class="hljs-comment">// 为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无</span><br><span class="hljs-comment">// 法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签</span><br><span class="hljs-comment">// 名是`final（最终）`。因此我们会在一个实现了服务类接口的新代理类中放入</span><br><span class="hljs-comment">// 缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。</span><br><span class="hljs-keyword">class</span> CachedTVClass implements ThirdPartyTVLib is<br>  <span class="hljs-keyword">private</span> field service: ThirdPartyTVLib<br>  <span class="hljs-keyword">private</span> field listCache, videoCache<br>  field needReset<br><br>  constructor <span class="hljs-constructor">CachedTVClass(<span class="hljs-params">service</span>: ThirdPartyTVLib)</span> is<br>    this.service = service<br><br>  <span class="hljs-keyword">method</span> <span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span> is<br>    <span class="hljs-keyword">if</span> (listCache<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>needReset)<br>      listCache = service.<span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span><br>    return listCache<br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span> is<br>    <span class="hljs-keyword">if</span> (videoCache<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>needReset)<br>      videoCache = service.get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span><br>    return videoCache<br><br>  <span class="hljs-keyword">method</span> download<span class="hljs-constructor">Video(<span class="hljs-params">id</span>)</span> is<br>    <span class="hljs-keyword">if</span> (!download<span class="hljs-constructor">Exists(<span class="hljs-params">id</span>)</span><span class="hljs-operator"> || </span>needReset)<br>      service.download<span class="hljs-constructor">Video(<span class="hljs-params">id</span>)</span><br><br><span class="hljs-comment">// 之前直接与服务对象交互的 GUI 类不需要改变，前提是它仅通过接口与服务对</span><br><span class="hljs-comment">// 象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实</span><br><span class="hljs-comment">// 现了相同的接口。</span><br><span class="hljs-keyword">class</span> TVManager is<br>  protected field service: ThirdPartyTVLib<br><br>  constructor <span class="hljs-constructor">TVManager(<span class="hljs-params">service</span>: ThirdPartyTVLib)</span> is<br>    this.service = service<br><br>  <span class="hljs-keyword">method</span> render<span class="hljs-constructor">VideoPage(<span class="hljs-params">id</span>)</span> is<br>    info = service.get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span><br>    <span class="hljs-comment">// 渲染视频页面。</span><br><br>  <span class="hljs-keyword">method</span> render<span class="hljs-constructor">ListPanel()</span> is<br>    <span class="hljs-built_in">list</span> = service.<span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span><br>    <span class="hljs-comment">// 渲染视频缩略图列表。</span><br><br>  <span class="hljs-keyword">method</span> react<span class="hljs-constructor">OnUserInput()</span> is<br>    render<span class="hljs-constructor">VideoPage()</span><br>    render<span class="hljs-constructor">ListPanel()</span><br><br><span class="hljs-comment">// 程序可在运行时对代理进行配置。</span><br><span class="hljs-keyword">class</span> Application is<br>  <span class="hljs-keyword">method</span> init<span class="hljs-literal">()</span> is<br>    aTVService = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThirdPartyTVClass()</span><br>    aTVProxy = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CachedTVClass(<span class="hljs-params">aTVService</span>)</span><br>    manager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TVManager(<span class="hljs-params">aTVProxy</span>)</span><br>    manager.react<span class="hljs-constructor">OnUserInput()</span><br></code></pre></td></tr></table></figure>


<h3 id="适用应用场景"><a href="#适用应用场景" class="headerlink" title="适用应用场景"></a>适用应用场景</h3><p>使用代理模式的方式多种多样， 我们来看看最常见的几种。</p>
<ol>
<li><p>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</p>
<p>你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p>
</li>
<li><p>访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。</p>
<p>代理可仅在客户端凭据满足要求时将请求传递给服务对象。</p>
</li>
<li><p>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。</p>
<p>在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</p>
</li>
<li><p>记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</p>
<p>缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。</p>
<p>代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</p>
</li>
<li><p>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</p>
<p>代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。</p>
</li>
</ol>
<h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。</p>
</li>
<li><p>创建代理类， 其中必须包含一个存储指向服务的引用的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。</p>
</li>
<li><p>根据需求实现代理方法。 在大部分情况下， 代理在完成一些任务后应将工作委派给服务对象。</p>
</li>
<li><p>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。</p>
</li>
<li><p>可以考虑为服务对象实现延迟初始化。</p>
</li>
</ol>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p>
<ol>
<li>你可以在客户端毫无察觉的情况下控制服务对象。</li>
<li>如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。</li>
<li>即使服务对象还未准备好或不存在， 代理也可以正常工作。</li>
<li>开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。</li>
</ol>
<p>缺点</p>
<ol>
<li>代码可能会变得复杂， 因为需要新建许多类。</li>
<li>服务响应可能会延迟。</li>
</ol>
<h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>适配器能为被封装对象提供不同的接口， 代理能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p>
</li>
<li><p>外观与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>
</li>
<li><p>装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">设计模式-创建型模式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/11/%E7%89%9B%E5%AE%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98-MySQL/">
                        <span class="hidden-mobile">牛客数据库刷题-MySQL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
