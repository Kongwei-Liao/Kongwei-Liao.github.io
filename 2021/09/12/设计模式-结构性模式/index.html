

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>设计模式-结构性模式 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="设计模式-结构性模式">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-12 10:29" pubdate>
        2021年9月12日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      92
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式-结构性模式</h1>
            
            <div class="markdown-body">
              <h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效</p>
<h2 id="适配器-Adapter"><a href="#适配器-Adapter" class="headerlink" title="适配器 Adapter"></a>适配器 Adapter</h2><p>让接口不兼容的对象能够相互合作</p>
<p>亦称：封装器模式、Wapper、Adapter</p>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>倘若你正在开发一款股票市场检测程序，它会从不同来源下载XML格式的股票数据，然后向用户呈现出美观的图表。在开发过程中，你决定在程序中整合使用一个第三方的智能分析函数库。但是现在遇到一个问题，那就是这个第三方的分析函数库只兼容JSON格式的数据。</p>
<p><img src="https://i.loli.net/2021/09/12/PU6lbR7SEVIiQY8.png" srcset="/img/loading.gif" alt="你无法 “直接” 使用分析函数库，因为它所需的输入数据格式与你的程序不兼容。 "></p>
<p>一种方式是，你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>你可以创建一个适配器。 这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。</p>
<p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。 例如， 你可以使用一个将所有数据转换为英制单位 （如英尺和英里） 的适配器封装运行于米和千米单位制中的对象。</p>
<p>适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：</p>
<ol>
<li>适配器实现与其中一个现有对象兼容的接口。</li>
<li>现有对象可以使用该接口安全地调用适配器方法。</li>
<li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li>
</ol>
<p>有时你甚至可以创建一个双向适配器来实现双向转换调用。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_10-57-06.png" srcset="/img/loading.gif"></p>
<p>回到股票市场程序。 为了解决数据格式不兼容的问题， 你可以为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器， 然后让客户端仅通过这些适配器来与函数库进行交流。 当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。</p>
<h3 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-01-20.png" srcset="/img/loading.gif" alt="出国旅行前后的旅行箱。"></p>
<p>如果你是第一次从美国到欧洲旅行， 那么在给笔记本充电时可能会大吃一惊。 不同国家的电源插头和插座标准不同。 美国插头和德国插座不匹配。 同时提供美国标准插座和欧洲标准插头的电源适配器可以解决你的难题。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-04-16.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>客户端 （Client） 是包含当前程序业务逻辑的类。</p>
</li>
<li><p>客户端接口 （Client Inter­face） 描述了其他类与客户端代码合作时必须遵循的协议。</p>
</li>
<li><p>服务 （Ser­vice） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。</p>
</li>
<li><p>适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</p>
</li>
</ol>
<p>客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>这一实现使用了继承机制： 适配器同时继承两个对象的接口。 <strong>请注意， 这种方式仅能在支持多重继承的编程语言中实现， 例如 C++。Java仅支持单继承</strong>”</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-10-27.png" srcset="/img/loading.gif"></p>
<p>类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。</p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>下面介绍一个适配器模式演示基于经典的“方钉和圆孔”问题。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-23-53.png" srcset="/img/loading.gif" alt="让方钉适配圆孔"></p>
<p>适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// 假设你有两个接口相互兼容的类：圆孔（RoundHole）和圆钉（RoundPeg）。</span><br><span class="hljs-keyword">class</span> RoundHole <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">RoundHole</span><span class="hljs-params">(radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回孔的半径。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">fits</span><span class="hljs-params">(peg: RoundPeg)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">this</span>.<span class="hljs-title">getRadius</span><span class="hljs-params">()</span> &gt;= <span class="hljs-title">peg</span>.<span class="hljs-title">getRadius</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">RoundPeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">RoundPeg</span><span class="hljs-params">(radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回钉子的半径。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 但还有一个不兼容的类：方钉（SquarePeg）。</span></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SquarePeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(width)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回方钉的宽度。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适配器对象作为圆钉。</span></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SquarePegAdapter</span> <span class="hljs-title">extends</span> <span class="hljs-title">RoundPeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-comment">// 在实际情况中，适配器中会包含一个 SquarePeg 类的实例。</span></span><br><span class="hljs-function">  <span class="hljs-title">private</span> <span class="hljs-title">field</span> <span class="hljs-title">peg</span>:</span> SquarePeg<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(peg: SquarePeg)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">peg</span> = <span class="hljs-title">peg</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 适配器会假扮为一个圆钉，其半径刚好能与适配器实际封装的方钉搭配起来。</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">peg</span>.<span class="hljs-title">getWidth</span><span class="hljs-params">()</span> * <span class="hljs-title">Math</span>.<span class="hljs-title">sqrt</span><span class="hljs-params">(2)</span> / 2</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 客户端代码中的某个位置。</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span> = <span class="hljs-title">new</span> <span class="hljs-title">RoundHole</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">rpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">RoundPeg</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(rpeg)</span> <span class="hljs-comment">// true</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">small_sqpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">large_sqpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(10)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(small_sqpeg)</span> <span class="hljs-comment">// 此处无法编译（类型不一致）。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">small_sqpeg_adapter</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(small_sqpeg)</span></span><br><span class="hljs-function"><span class="hljs-title">large_sqpeg_adapter</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(large_sqpeg)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(small_sqpeg_adapter)</span> <span class="hljs-comment">// true</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(large_sqpeg_adapter)</span> <span class="hljs-comment">// false</span></span><br></code></pre></td></tr></table></figure>




<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</p>
<p>适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</p>
<p>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>确保至少有两个类的接口不兼容：<ul>
<li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。</li>
<li>一个或多个将受益于使用服务类的客户端类。</li>
</ul>
</li>
<li>声明客户端接口，描述客户端与服务如何交互；</li>
<li>创建遵循客户端接口的适配器。所有方法暂时都为空；</li>
<li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li>
<li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li>
<li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>单一职责原则：你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li>
<li>开闭原则：只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li>
</ol>
<p>缺点：</p>
<ol>
<li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li>
</ol>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>桥接通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
</li>
<li><p>适配器可以对已有对象的接口进行修改， 装饰则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p>
</li>
<li><p>适配器能为被封装对象提供不同的接口， 代理能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p>
</li>
<li><p>外观为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p>
</li>
<li><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
</ol>
<h2 id="桥接-Bridge"><a href="#桥接-Bridge" class="headerlink" title="桥接 Bridge"></a>桥接 Bridge</h2><p>将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。</p>
<h3 id="问题提出-1"><a href="#问题提出-1" class="headerlink" title="问题提出"></a>问题提出</h3><p>假如你有一个几何 形状Shape类， 从它能扩展出两个子类：  圆形Cir­cle和 方形Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为 红色Red和 蓝色Blue的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如 蓝色圆形Blue­Cir­cle和 红色方形Red­Square 。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_12-54-47.png" srcset="/img/loading.gif" alt="所有组合类的数量将以几何倍数增长"></p>
<p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。 如此以往， 情况会越来越糟糕。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>问题的根本原因是我们试图在两个独立的维度——形状与颜色——上扩展形状类。 这在处理类继承时是很常见的问题。</p>
<p>桥接模式通过将继承改为组合的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_12-57-47.png" srcset="/img/loading.gif" alt="将一个类层次转化为多个相关的类层析，避免单个类层次的失控"> </p>
<p>根据该方法， 我们可以将颜色相关的代码抽取到拥有 红色和 蓝色两个子类的颜色类中， 然后在 形状类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 形状和 颜色之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。</p>
<h3 id="抽象部分与实现部分"><a href="#抽象部分与实现部分" class="headerlink" title="抽象部分与实现部分"></a>抽象部分与实现部分</h3><p>设计模式四人组的著作 在桥接定义中提出了抽象部分和实现部分两个术语。 我觉得这些术语过于学术了， 反而让模式看上去比实际情况更加复杂。 在介绍过形状和颜色的简单例子后， 我们来看看四人组著作中让人望而生畏的词语的含义。</p>
<p>抽象部分 （也被称为接口） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给实现部分层（亦称 平台 ）</p>
<p>注意， 这里提到的内容与编程语言中的接口或抽象类无关。 它们并不是一回事。</p>
<p>在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。</p>
<p>一般来说， 你可以在两个独立方向上扩展这种应用：</p>
<ul>
<li>开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置）</li>
<li>支持多个不同的 API （例如， 能够在 Win­dows、 Linux 和 macOS 上运行该程序）。</li>
</ul>
<p>在最糟糕的情况下， 程序可能会是一团乱麻， 其中包含数百种条件语句， 连接着代码各处不同种类的 GUI 和各种API。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-05-16.png" srcset="/img/loading.gif" alt="在庞杂的代码中， 即使是很小的改动都非常难以完成， 因为你必须要在整体上对代码有充分的理解。 而在较小且定义明确的模块中， 进行修改则要容易得多 "></p>
<p>你可以将特定接口-平台的组合代码抽取到独立的类中， 以在混乱中建立一些秩序。 但是， 你很快会发现这种类的数量很多。 类层次将以指数形式增长， 因为每次添加一个新的 GUI 或支持一种新的 API 都需要创建更多的类。</p>
<p>让我们试着用桥接模式来解决这个问题。 该模式建议将类拆分为两个类层次结构：</p>
<ul>
<li>抽象部分： 程序的 GUI 层。</li>
<li>实现部分： 操作系统的 API。</li>
</ul>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-09-29.png" srcset="/img/loading.gif" alt="创建跨平台应用程序的一种方法"></p>
<p>抽象对象控制程序的外观， 并将真实工作委派给连入的实现对象。 不同的实现只要遵循相同的接口就可以互换， 使同一 GUI 可在 Win­dows 和 Linux 下运行。</p>
<p>最后的结果是： 你无需改动与 API 相关的类就可以修改 GUI 类。 此外如果想支持一个新的操作系统， 只需在实现部分层次中创建一个子类即可。</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-12-17.png" srcset="/img/loading.gif"></p>
<ol>
<li><p>抽象部分 （Abstrac­tion） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</p>
</li>
<li><p>实现部分 （Imple­men­ta­tion） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。</p>
</li>
<li><p>具体实现 （Con­crete Imple­men­ta­tions） 中包括特定于平台的代码。</p>
</li>
<li><p>精确抽象 （Refined Abstrac­tion） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</p>
</li>
<li><p>通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</p>
</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>示例演示了桥接模式如何拆分程序中同时管理设备及其遥控器的庞杂代码。  设备Device类作为实现部分， 而 遥控器Remote类则作为抽象部分。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-15-02.png" srcset="/img/loading.gif" alt="最初类层次结构被才分成两个部分：设备和遥控器"></p>
<p>遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。</p>
<p>你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。</p>
<p>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实</span><br><span class="hljs-comment">// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span><br><span class="hljs-keyword">class</span> RemoteControl is<br>  protected field device: Device<br>  constructor <span class="hljs-constructor">RemoteControl(<span class="hljs-params">device</span>: Device)</span> is<br>    this.device = device<br>  <span class="hljs-keyword">method</span> toggle<span class="hljs-constructor">Power()</span> is<br>    <span class="hljs-keyword">if</span> (device.is<span class="hljs-constructor">Enabled()</span>) <span class="hljs-keyword">then</span><br>      device.disable<span class="hljs-literal">()</span><br>    <span class="hljs-keyword">else</span><br>      device.enable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> volume<span class="hljs-constructor">Down()</span> is<br>    device.set<span class="hljs-constructor">Volume(<span class="hljs-params">device</span>.<span class="hljs-params">getVolume</span>()</span> - <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">method</span> volume<span class="hljs-constructor">Up()</span> is<br>    device.set<span class="hljs-constructor">Volume(<span class="hljs-params">device</span>.<span class="hljs-params">getVolume</span>()</span> + <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">method</span> channel<span class="hljs-constructor">Down()</span> is<br>    device.set<span class="hljs-constructor">Channel(<span class="hljs-params">device</span>.<span class="hljs-params">getChannel</span>()</span> - <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">method</span> channel<span class="hljs-constructor">Up()</span> is<br>    device.set<span class="hljs-constructor">Channel(<span class="hljs-params">device</span>.<span class="hljs-params">getChannel</span>()</span> + <span class="hljs-number">1</span>)<br><br><br><span class="hljs-comment">// 你可以独立于设备类的方式从抽象层中扩展类。</span><br><span class="hljs-keyword">class</span> AdvancedRemoteControl extends RemoteControl is<br>  <span class="hljs-keyword">method</span> mute<span class="hljs-literal">()</span> is<br>    device.set<span class="hljs-constructor">Volume(0)</span><br><br><br><span class="hljs-comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相</span><br><span class="hljs-comment">// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而</span><br><span class="hljs-comment">// 抽象接口则会基于这些操作定义较高层次的操作。</span><br>interface Device is<br>  <span class="hljs-keyword">method</span> is<span class="hljs-constructor">Enabled()</span><br>  <span class="hljs-keyword">method</span> enable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> disable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Volume()</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Volume(<span class="hljs-params">percent</span>)</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Channel()</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Channel(<span class="hljs-params">channel</span>)</span><br><br><br><span class="hljs-comment">// 所有设备都遵循相同的接口。</span><br><span class="hljs-keyword">class</span> Tv implements Device is<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> Radio implements Device is<br>  <span class="hljs-comment">// ...</span><br><br><br><span class="hljs-comment">// 客户端代码中的某个位置。</span><br>tv = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Tv()</span><br>remote = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RemoteControl(<span class="hljs-params">tv</span>)</span><br>remote.toggle<span class="hljs-constructor">Power()</span><br><br>radio = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Radio()</span><br>remote = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AdvancedRemoteControl(<span class="hljs-params">radio</span>)</span><br></code></pre></td></tr></table></figure>




<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p>
<p>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</p>
<p>2、如果你希望在几个独立维度上扩展一个类， 可使用该模式。</p>
<p>桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</p>
<p>3、如果你需要在运行时切换不同实现方法， 可使用桥接模式。</p>
<p>当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</p>
<p>顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。</p>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</p>
</li>
<li><p>了解客户端的业务需求， 并在抽象基类中定义它们。</p>
</li>
<li><p>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</p>
</li>
<li><p>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</p>
</li>
<li><p>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</p>
</li>
<li><p>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</p>
</li>
<li><p>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</p>
</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>你可以创建与平台无关的类和程序。</li>
<li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li>
<li>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li>
<li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li>
</ol>
<p>缺点：</p>
<ol>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ol>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol>
<li><p>桥接通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
</li>
<li><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li><p>你可以将抽象工厂和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p>
</li>
<li><p>你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p>
</li>
</ol>
<h2 id="组合-Composite"><a href="#组合-Composite" class="headerlink" title="组合 Composite"></a>组合 Composite</h2><p>可以使用该模式将对象组合成树状结构，并且能够像使用独立对象一样使用他们。</p>
<h3 id="问题提出-2"><a href="#问题提出-2" class="headerlink" title="问题提出"></a>问题提出</h3><p>如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。</p>
<p>例如， 你有两类对象：  产品 和 盒子 。 一个盒子中可以包含多个 产品或者几个较小的 盒子 。 这些小 盒子中同样可以包含一些 产品或更小的 盒子 ， 以此类推。</p>
<p>假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子……以及其他盒子。 此时你会如何计算每张订单的总价格呢？</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-08-16.png" srcset="/img/loading.gif"></p>
<p>你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后计算总价。 这在真实世界中或许可行， 但在程序中， 你并不能简单地使用循环语句来完成该工作。 你必须事先知道所有 产品和 盒子的类别， 所有盒子的嵌套层数以及其他繁杂的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>组合模式建议使用一个通用接口来与 产品和 盒子进行交互， 并且在该接口中声明一个计算总价的方法。</p>
<p>那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-10-43.png" srcset="/img/loading.gif"></p>
<p>该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。</p>
<h3 id="真实世界类比-1"><a href="#真实世界类比-1" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-12-18.png" srcset="/img/loading.gif"></p>
<p>大部分国家的军队都采用层次结构管理。 每支部队包括几个师， 师由旅构成， 旅由团构成， 团可以继续划分为排。 最后， 每个排由一小队实实在在的士兵组成。 军事命令由最高层下达， 通过每个层级传递， 直到每位士兵都知道自己应该服从的命令。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-14-17.png" srcset="/img/loading.gif"></p>
<p>1、组件 （Com­po­nent） 接口描述了树中简单项目和复杂项目所共有的操作。</p>
<p>2、叶节点 （Leaf） 是树的基本结构， 它不包含子项目。</p>
<p>一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p>
<p>3、容器 （Con­tain­er）——又名 “组合 （Com­pos­ite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。</p>
<p>容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</p>
<p>4、客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</p>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 我们将借助组合模式帮助你在图形编辑器中实现一系列的几何图形。</p>
<p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-17-26.png" srcset="/img/loading.gif"></p>
<p>组合图形Com­pound­Graph­ic是一个容器， 它可以由多个包括容器在内的子图形构成。 组合图形与简单图形拥有相同的方法。 但是， 组合图形自身并不完成具体工作， 而是将请求递归地传递给自己的子项目， 然后 “汇总” 结果。</p>
<p>通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 组件接口会声明组合中简单和复杂对象的通用操作。</span><br><span class="hljs-keyword">interface</span> Graphic <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象</span><br><span class="hljs-function">// 通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Dot</span> <span class="hljs-title">implements</span> <span class="hljs-title">Graphic</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">x</span>, <span class="hljs-title">y</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">Dot</span><span class="hljs-params">(x, y)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">x</span> += <span class="hljs-title">x</span>, <span class="hljs-title">this</span>.<span class="hljs-title">y</span> += <span class="hljs-title">y</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在坐标位置<span class="hljs-params">(X,Y)</span>处绘制一个点。</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 所有组件类都可以扩展其他组件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Circle</span> <span class="hljs-title">extends</span> <span class="hljs-title">Dot</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">radius</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">Circle</span><span class="hljs-params">(x, y, radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在坐标位置<span class="hljs-params">(X,Y)</span>处绘制一个半径为 <span class="hljs-title">R</span> 的圆。</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项</span><br><span class="hljs-function">// 目，然后“汇总”结果。 </span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">CompoundGraphic</span> <span class="hljs-title">implements</span> <span class="hljs-title">Graphic</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">children</span>:</span> <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> Graphic<br><br>  <span class="hljs-comment">// 组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">add</span><span class="hljs-params">(child: Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在子项目数组中添加一个子项目。</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">remove</span><span class="hljs-params">(child: Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 从子项目数组中移除一个子项目。</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">foreach</span> <span class="hljs-params">(child <span class="hljs-keyword">in</span> children)</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">      <span class="hljs-title">child</span>.<span class="hljs-title">move</span><span class="hljs-params">(x, y)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  // 组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和</span><br><span class="hljs-function">  // 汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，</span><br><span class="hljs-function">  // 最后组合将会完成整个对象树的遍历工作。</span><br><span class="hljs-function">    <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 1. 对于每个子部件：</span><br><span class="hljs-function">    //     - 绘制该部件。</span><br><span class="hljs-function">    //     - 更新边框坐标。</span><br><span class="hljs-function">    // 2. 根据边框坐标绘制一个虚线长方形。</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同</span><br><span class="hljs-function">// 时支持简单叶节点组件和复杂组件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">ImageEditor</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">all</span>:</span> CompoundGraphic<br><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span> = <span class="hljs-title">new</span> <span class="hljs-title">CompoundGraphic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Dot(1, 2)</span>)</span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Circle(5, 3, 10)</span>)</span><br><span class="hljs-function">    // ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">  // 将所需组件组合为复杂的组合组件。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">groupSelected</span><span class="hljs-params">(components: <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">group</span> = <span class="hljs-title">new</span> <span class="hljs-title">CompoundGraphic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">foreach</span> <span class="hljs-params">(component <span class="hljs-keyword">in</span> components)</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">      <span class="hljs-title">group</span>.<span class="hljs-title">add</span><span class="hljs-params">(component)</span></span><br><span class="hljs-function">      <span class="hljs-title">all</span>.<span class="hljs-title">remove</span><span class="hljs-params">(component)</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">group</span>)</span></span><br><span class="hljs-function">    // 所有组件都将被绘制。</span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>


<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、如果你需要实现树状对象结构， 可以使用组合模式。</p>
<p> 组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。</p>
<p> 2、如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p>
<p> 组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</p>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><p>1、确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p>
<p>2、声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p>
<p>3、创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p>
<p>4、创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p>
<p>实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p>
<p>5、最后， 在容器中定义添加和删除子元素的方法。</p>
<p>记住， 这些操作可在组件接口中声明。 这将会违反_接口隔离原则_， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<p>1、你可以利用多态和递归机制更方便地使用复杂树结构。</p>
<p>2、开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</p>
<p>缺点：</p>
<p>1、对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</p>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><p>1、桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
<p>2、你可以在创建复杂组合树时使用生成器， 因为这可使其构造步骤以递归的方式运行。</p>
<p>3、责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
<p>4、你可以使用迭代器来遍历组合树。</p>
<p>5、你可以使用访问者对整个组合树执行操作。</p>
<p>6、你可以使用享元实现组合树的共享叶节点以节省内存。</p>
<p>7、组合和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p>
<p>8、大量使用组合和装饰的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
<h2 id="装饰-Decorator"><a href="#装饰-Decorator" class="headerlink" title="装饰 Decorator"></a>装饰 Decorator</h2><p>允许通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设你正在开发一个提供通知功能的库， 其他程序可使用它向用户发送关于重要事件的通知。</p>
<p>库的最初版本基于 通知器Noti­fi­er类， 其中只有很少的几个成员变量， 一个构造函数和一个 send发送方法。 该方法可以接收来自客户端的消息参数， 并将该消息发送给一系列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作为客户端的第三方程序仅会创建和配置通知器对象一次， 然后在有重要事件发生时对其进行调用。</p>
<h2 id="外观-Facade"><a href="#外观-Facade" class="headerlink" title="外观 Facade"></a>外观 Facade</h2><p>能够为成序库、框架或者其他复杂类提供一个简单的接口。</p>
<h2 id="享元-Flaweight"><a href="#享元-Flaweight" class="headerlink" title="享元 Flaweight"></a>享元 Flaweight</h2><p>摒弃了在每个对象中保存数据的方式，通过共享多个对象所共有的相同状态，让你能够在有限的内存容量中载入更多对象。</p>
<h2 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h2><p>让我们能够提供对象的替代品或者占位符。代理控制着对于原对象的访问，并且允许在将请求提交给对象前后进行一些处理。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">设计模式-创建型模式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/11/%E7%89%9B%E5%AE%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98-MySQL/">
                        <span class="hidden-mobile">牛客数据库刷题-MySQL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
