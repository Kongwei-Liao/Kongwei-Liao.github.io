

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>11-AOP原理-切面类收集封装 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="11-AOP原理-切面类收集封装">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-17 09:21" pubdate>
        2022年4月17日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      58
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">11-AOP原理-切面类收集封装</h1>
            
            <div class="markdown-body">
              <h1 id="AOP原理-AOP是如何收集切面类并封装的"><a href="#AOP原理-AOP是如何收集切面类并封装的" class="headerlink" title="AOP原理-AOP是如何收集切面类并封装的"></a>AOP原理-AOP是如何收集切面类并封装的</h1><p>承接着上一章的思路，这一章咱主要研究两个大问题：</p>
<ol>
<li><code>Advisor</code> 是什么，它是怎么构建的</li>
<li><code>TargetSource</code> 是什么，SpringFramework 的 AOP 为什么要代理它而不是原始对象</li>
</ol>
<h2 id="1-Advisor与切面类的收集"><a href="#1-Advisor与切面类的收集" class="headerlink" title="1. Advisor与切面类的收集"></a>1. Advisor与切面类的收集</h2><p>在上一章中，咱有看到一个 <code>shouldSkip</code> 的跳过动作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AspectJAwareAdvisorAutoProxyCreator</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>    <span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;<br>        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;<br>                ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里面它会先获取到一些候选的增强器，而这个方法的底层，其实就是解析切面类，构造 <code>Advisor</code> 增强器的过程，咱深入研究一下。</p>
<p><code>findCandidateAdvisors</code> 方法的源码还算简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Add all the Spring advisors found according to superclass rules.</span><br>    <span class="hljs-comment">// 根据父类的规则添加所有找到的Spring原生的增强器</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">super</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// Build Advisors for all AspectJ aspects in the bean factory.</span><br>    <span class="hljs-comment">// 解析BeanFactory中所有的AspectJ切面，并构造增强器</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder != <span class="hljs-keyword">null</span>) &#123;<br>        advisors.addAll(<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总共两个步骤，分别代表切面的两个来源：<strong>SpringFramework 原生 AOP 的增强器</strong>，以及<strong>解析完 AspectJ 切面类构造的增强器</strong>。咱一个一个来看。</p>
<h3 id="1-1-super-findCandidateAdvisors"><a href="#1-1-super-findCandidateAdvisors" class="headerlink" title="1.1 super.findCandidateAdvisors"></a>1.1 super.findCandidateAdvisors</h3><p>来到父类 <code>AbstractAdvisorAutoProxyCreator</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> BeanFactoryAdvisorRetrievalHelper advisorRetrievalHelper;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>&#123;<br>    Assert.state(<span class="hljs-keyword">this</span>.advisorRetrievalHelper != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;No BeanFactoryAdvisorRetrievalHelper available&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现它委托了一个 <code>advisorRetrievalHelper</code> 来处理 SpringFramework 原生的 AOP 增强器。而它这个方法的篇幅就比较长了，咱拆解出核心的主干逻辑研究。</p>
<h4 id="1-1-1-检查现有的增强器bean"><a href="#1-1-1-检查现有的增强器bean" class="headerlink" title="1.1.1 检查现有的增强器bean"></a>1.1.1 检查现有的增强器bean</h4><p>注意看源码中的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">findAdvisorBeans</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Determine list of advisor bean names, if not cached already.</span><br>    <span class="hljs-comment">// 确定增强器bean名称的列表（如果尚未缓存）</span><br>    String[] advisorNames = <span class="hljs-keyword">this</span>.cachedAdvisorBeanNames;<br>    <span class="hljs-keyword">if</span> (advisorNames == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br>        <span class="hljs-comment">// uninitialized to let the auto-proxy creator apply to them!</span><br>        <span class="hljs-comment">// 不要在这里初始化FactoryBeans：</span><br>        <span class="hljs-comment">// 我们需要保留所有未初始化的常规bean，以使自动代理创建者对其应用</span><br>        advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<br>                <span class="hljs-keyword">this</span>.beanFactory, Advisor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">this</span>.cachedAdvisorBeanNames = advisorNames;<br>    &#125;<br>    <span class="hljs-comment">// 如果当前IOC容器中没有任何增强器类型的bean，直接返回</span><br>    <span class="hljs-keyword">if</span> (advisorNames.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这里的主要动作，是将 IOC 容器中所有类型为 <code>Advisor</code> 的实现类都找出来，看看到底有没有，如果没有，那就不用走下面的流程了。</p>
<p><code>BeanFactoryUtils</code> 的 <code>beanNamesForTypeIncludingAncestors</code> 方法，底层是用的 <code>getBeanNamesForType</code> 方法去找 bean 的名称（单纯的找 bean 的名称不会创建具体的 bean 对象，SpringFramework 在此做得很谨慎），感兴趣的小伙伴可以自己去看一下，小册在此就不展开了。</p>
<h4 id="1-1-2-初始化原生增强器"><a href="#1-1-2-初始化原生增强器" class="headerlink" title="1.1.2 初始化原生增强器"></a>1.1.2 初始化原生增强器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String name : advisorNames) &#123;<br>        <span class="hljs-keyword">if</span> (isEligibleBean(name)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;<br>                <span class="hljs-comment">// logger ......</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    advisors.add(<span class="hljs-keyword">this</span>.beanFactory.getBean(name, Advisor.class));<br>                &#125; <span class="hljs-comment">// catch ......</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面的源码蛮长的，不过这里咱只关心主干流程的重点，那无非就是 <code>beanFactory.getBean</code>了，非常常规的 bean 初始化的动作。只不过我们自始至终都没有讲过 SpringFramework 原生的增强器，因为编写它实在是太复杂了，主流的编写还是以 AspectJ 形式为主，所以咱这里知道一下就可以了。</p>
<p>至于中间省略的 catch 块，其实流程还挺复杂的，里面做了循环依赖的异常处理，由于涉及的内容过于复杂，而且咱前面也说过了，循环依赖的部分可以在 SpringBoot 小册的第 15 章完整的学习，所以咱这里就不多展开了。</p>
<p>通过 Debug ，也可以发现并没有原生的增强器被创建：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64841df0332c410f88b9eb86b91d5177~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<p>以上就是在父类 <code>AbstractAdvisorAutoProxyCreator</code> 中的 <code>findCandidateAdvisors</code> 方法的逻辑，下面咱来看另一部分的委托：<code>aspectJAdvisorsBuilder</code> 。</p>
<h3 id="1-2-aspectJAdvisorsBuilder-buildAspectJAdvisors"><a href="#1-2-aspectJAdvisorsBuilder-buildAspectJAdvisors" class="headerlink" title="1.2 aspectJAdvisorsBuilder.buildAspectJAdvisors"></a>1.2 aspectJAdvisorsBuilder.buildAspectJAdvisors</h3><p>从方法名上理解，它就是<strong>将 Aspect 切面类，转换为一个一个的增强器</strong>。这个方法也是长得很，咱分段来研究。</p>
<h4 id="1-2-1-逐个解析IOC容器中所有的bean类型"><a href="#1-2-1-逐个解析IOC容器中所有的bean类型" class="headerlink" title="1.2.1 逐个解析IOC容器中所有的bean类型"></a>1.2.1 逐个解析IOC容器中所有的bean类型</h4><p>这段源码一下子把缩进拉上去了，阅读观感可能不是特别好，不过好在逻辑不算复杂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">buildAspectJAdvisors</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;String&gt; aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;<br><br>    <span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;<br>            <span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) &#123;<br>                List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                aspectNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                <span class="hljs-comment">// 获取IOC容器中的所有bean</span><br>                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<br>                        <span class="hljs-keyword">this</span>.beanFactory, Object.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>                    <span class="hljs-keyword">if</span> (!isEligibleBean(beanName)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// We must be careful not to instantiate beans eagerly as in this case they</span><br>                    <span class="hljs-comment">// would be cached by the Spring container but would not have been weaved.</span><br>                    <span class="hljs-comment">// 我们必须小心，不要急于实例化bean，因为在这种情况下，IOC容器会缓存它们，但不会被织入增强器</span><br>                    Class&lt;?&gt; beanType = <span class="hljs-keyword">this</span>.beanFactory.getType(beanName);<br>                    <span class="hljs-keyword">if</span> (beanType == <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>可以发现，这一段的核心逻辑，是将 IOC 容器，以及它的父 IOC 容器中，所有的 bean 的名称全部取出（直接声明父类型为 <code>Object</code> ，显然是取所有），之后，它会逐个解析这些 bean 对应的 <code>Class</code> 。</p>
<p>Debug 中也发现，它真的把包括内部的一些 bean （ environment ）在内的所有 bean 的名称全部拿了出来：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72661fed4645415bba02a8934d6393bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<p>注意一个细节，框架在这里控制的很好，它借助 <code>BeanFactory</code> 去取 bean 的类型，而不是先 <code>getBean</code> 后再取类型，这样可以保证 bean 不会被提前创建。而没有初始化 bean 实例的前提下，要想获取 bean 的 <code>Class</code> ，那就只能靠 <code>BeanDefinition</code> 了，所以我们可以在 <code>AbstractBeanFactory</code> 的 <code>getType</code> 方法中看到合并 <code>RootBeanDefinition</code> 的动作，随后调用 <code>RootBeanDefinition</code> 的 <code>getBeanClass</code> 方法获取 bean 的 <code>Class</code> 类型。</p>
<h4 id="1-2-2-解析Aspect切面类，构造增强器"><a href="#1-2-2-解析Aspect切面类，构造增强器" class="headerlink" title="1.2.2 解析Aspect切面类，构造增强器"></a>1.2.2 解析Aspect切面类，构造增强器</h4><p>这段缩进实在是太大了，我给调小了一点，小伙伴们看着还舒服点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;<br>    <span class="hljs-comment">// 当前解析bean的所属类型是一个切面类</span><br>    aspectNames.add(beanName);<br>    AspectMetadata amd = <span class="hljs-keyword">new</span> AspectMetadata(beanType, beanName);<br>    <span class="hljs-comment">// 下面是单实例切面bean会走的流程</span><br>    <span class="hljs-keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;<br>        MetadataAwareAspectInstanceFactory factory =<br>                <span class="hljs-keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);<br>        <span class="hljs-comment">// 解析生成增强器</span><br>        List&lt;Advisor&gt; classAdvisors = <span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.advisorsCache.put(beanName, classAdvisors);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);<br>        &#125;<br>        advisors.addAll(classAdvisors);<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这一步就是判断当前解析的 bean 所属的 <code>Class</code> 是不是一个切面类了，如果是，则会进入到里面的结构体，把这个类中的通知方法都构造出来。</p>
<p>这两个小动作，咱拿出来解析一下。</p>
<h5 id="1-2-2-1-判断Class是通知类"><a href="#1-2-2-1-判断Class是通知类" class="headerlink" title="1.2.2.1 判断Class是通知类"></a>1.2.2.1 判断Class是通知类</h5><p>如何判断当前 Class 是不是通知类（切面类）呢？很简单，看看类上是不是有标注 <code>@Aspect</code>注解就完事了呗？但是源码中还多判断了一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAspect</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-comment">// @Aspect注解并且不是被ajc编译器编译的</span><br>    <span class="hljs-keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>请注意一点，它额外判断了是不是被 ajc 编译器编译，这是为什么呢？我们可以从文档注释中获取到一些信息：</p>
<blockquote>
<p>We consider something to be an AspectJ aspect suitable for use by the Spring AOP system if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test is that aspects written in the code-style (AspectJ language) also have the annotation present when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.</p>
<p>如果它有 @Aspect 注解，并且不是由 ajc 编译的，我们才认为这个 Class 类是适合 Spring AOP 系统使用的 AspectJ 切面。不用 ajc 编译的原因，是因为以代码风格（AspectJ 语言）编写的方面在由带有 -1.5 标志的 ajc 编译时也存在注解，但它们不能被 Spring AOP 使用。</p>
</blockquote>
<p>简单的理解来说，<strong>SpringFramework 的 AOP 有整合 AspectJ 的部分</strong>，而<strong>原生的 AspectJ 也可以编写 Aspect 切面</strong>，而<strong>这种切面在特殊的编译条件下，生成的字节码中类上也会标注 <code>@Aspect</code> 注解，但是 SpringFramework 并不能利用它</strong>，所以这里它做了一个额外的判断处理，避免了这种 Class 被误加载。</p>
<h5 id="1-2-2-2-advisorFactory-getAdvisors：构造增强器"><a href="#1-2-2-2-advisorFactory-getAdvisors：构造增强器" class="headerlink" title="1.2.2.2 advisorFactory.getAdvisors：构造增强器"></a>1.2.2.2 advisorFactory.getAdvisors：构造增强器</h5><p>这个方法又是好复杂呀，咱来到 <code>ReflectiveAspectJAdvisorFactory</code> 中来看：（注意标有注释的部分）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">getAdvisors</span><span class="hljs-params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// Aspect切面类的Class</span><br>    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<br>    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();<br>    <span class="hljs-comment">// 再次校验一下切面类上是不是标注了@Aspect注解</span><br>    validate(aspectClass);<br><br>    <span class="hljs-comment">// 此处利用Decorator装饰者模式，目的是保证Advisor增强器不会被多次实例化</span><br>    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =<br>            <span class="hljs-keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);<br><br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// 逐个解析通知方法，并封装为增强器</span><br>    <span class="hljs-keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;<br>        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, <span class="hljs-number">0</span>, aspectName);<br>        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-keyword">null</span>) &#123;<br>            advisors.add(advisor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If it&#x27;s a per target aspect, emit the dummy instantiating aspect.</span><br>    <span class="hljs-comment">// 通过在装饰者内部的开始加入SyntheticInstantiationAdvisor增强器，达到延迟初始化切面bean的目的</span><br>    <span class="hljs-keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;<br>        Advisor instantiationAdvisor = <span class="hljs-keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);<br>        advisors.add(<span class="hljs-number">0</span>, instantiationAdvisor);<br>    &#125;<br><br>    <span class="hljs-comment">// Find introduction fields.</span><br>    <span class="hljs-comment">// 对@DeclareParent注解功能的支持(AspectJ的引介)</span><br>    <span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;<br>        Advisor advisor = getDeclareParentsAdvisor(field);<br>        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-keyword">null</span>) &#123;<br>            advisors.add(advisor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整段源码阅读下来，思路倒是蛮明确，它果然与我们的推测一致，就是<strong>解析 Aspect 切面类中的通知方法</strong>，只不过它在上下文的逻辑中补充了一些额外的校验、处理等等逻辑。</p>
<p>重点关注这里面的两个小动作：1) 通知方法是怎么收集的；2) 增强器的创建都需要什么东西。</p>
<h5 id="1-2-2-3-切面类中通知方法的收集"><a href="#1-2-2-3-切面类中通知方法的收集" class="headerlink" title="1.2.2.3 切面类中通知方法的收集"></a>1.2.2.3 切面类中通知方法的收集</h5><p>进入到 <code>getAdvisorMethods</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Method&gt; <span class="hljs-title">getAdvisorMethods</span><span class="hljs-params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> List&lt;Method&gt; methods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;<br>        <span class="hljs-comment">// Exclude pointcuts</span><br>        <span class="hljs-keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == <span class="hljs-keyword">null</span>) &#123;<br>            methods.add(method);<br>        &#125;<br>    &#125;, ReflectionUtils.USER_DECLARED_METHODS);<br>    <span class="hljs-keyword">if</span> (methods.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        methods.sort(METHOD_COMPARATOR);<br>    &#125;<br>    <span class="hljs-keyword">return</span> methods;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实会发现，这个方法很简单的，它就是把咱们定义的<strong>切面类中除了通用的切入点表达式抽取以外的所有方法</strong>都取出来！并且取出来之后又做了一个排序的动作，而排序的原则就是按照 Unicode 编码来的，这个咱已经研究过了。</p>
<h5 id="1-2-2-4-增强器的创建"><a href="#1-2-2-4-增强器的创建" class="headerlink" title="1.2.2.4 增强器的创建"></a>1.2.2.4 增强器的创建</h5><p><code>getAdvisor</code> 方法就是创建 <code>Advisor</code> 增强器了，可能有的小伙伴会产生疑惑，上面的方法只是取出了自己定义的非 <code>@Pointcut</code> 方法，那对于没有声明切入点表达式的方法，它岂不是也一起返回了？不过没关系，其实它在这里又做了一次过滤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title">getAdvisor</span><span class="hljs-params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;<br>    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());<br><br>    AspectJExpressionPointcut expressionPointcut = getPointcut(<br>            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());<br>    <span class="hljs-comment">// 没有声明通知注解的方法也会被过滤</span><br>    <span class="hljs-keyword">if</span> (expressionPointcut == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,<br>            <span class="hljs-keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现框架还是做得滴水不漏的。注意看下面的构造方法中传入的关键参数，它们分别是：</p>
<ul>
<li>expressionPointcut ：AspectJ 切入点表达式的封装</li>
<li>candidateAdviceMethod ：通知方法本体</li>
<li>this ：当前的 <code>ReflectiveAspectJAdvisorFactory</code></li>
<li>aspectInstanceFactory ：上面的那个装饰者 <code>MetadataAwareAspectInstanceFactory</code></li>
</ul>
<p>刨去工厂本身，其实增强器的结构就是<strong>一个切入点表达式 + 一个通知方法</strong>，与之前的推测完全一致。</p>
<h5 id="1-2-2-5-解析通知注解上的切入点表达式"><a href="#1-2-2-5-解析通知注解上的切入点表达式" class="headerlink" title="1.2.2.5 解析通知注解上的切入点表达式"></a>1.2.2.5 解析通知注解上的切入点表达式</h5><p>到此为止其实增强器本身已经没有什么问题了，咱再来关注一下这个切入点表达式的解析，进入到 <code>getPointcut</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> AspectJExpressionPointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;<br>    <span class="hljs-comment">// 检索通知方法上的注解</span><br>    AspectJAnnotation&lt;?&gt; aspectJAnnotation =<br>            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);<br>    <span class="hljs-keyword">if</span> (aspectJAnnotation == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据注解的类型，构造切入点表达式模型</span><br>    AspectJExpressionPointcut ajexp =<br>            <span class="hljs-keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> Class&lt;?&gt;[<span class="hljs-number">0</span>]);<br>    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>) &#123;<br>        ajexp.setBeanFactory(<span class="hljs-keyword">this</span>.beanFactory);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ajexp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>步骤很简单，先去找通知方法上标注的注解，然后把切入点表达式提取出来，返回。很明显 <code>findAspectJAnnotationOnMethod</code> 的逻辑是相对重要的，咱进去看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;<br>        Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class&#125;;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : ASPECTJ_ANNOTATION_CLASSES) &#123;<br>        AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) clazz);<br>        <span class="hljs-keyword">if</span> (foundAnnotation != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> foundAnnotation;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>果然，它在 <code>AbstractAspectJAdvisorFactory</code> 中已经提前定义好了所有可以声明切入点表达式的注解，并在此处一一寻找，找到就返回。</p>
<p>在此 Debug 会发现它只是把切入点表达式的内容，以及参数等信息，封装到 <code>AspectJExpressionPointcut</code> 中了：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2866e666bfcc46208f90ea18dabccda2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<h4 id="1-2-3-原型切面bean的处理"><a href="#1-2-3-原型切面bean的处理" class="headerlink" title="1.2.3 原型切面bean的处理"></a>1.2.3 原型切面bean的处理</h4><p>上面我们只是看到了单实例切面 bean 的处理和解析，下面的 else 部分是原型切面 bean 的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">            <span class="hljs-comment">// ......</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Per target or per this.</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName +<br>                            <span class="hljs-string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);<br>                &#125;<br>                MetadataAwareAspectInstanceFactory factory =<br>                        <span class="hljs-keyword">new</span> PrototypeAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);<br>                <span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);<br>                <span class="hljs-comment">// 解析Aspect切面类，构造增强器</span><br>                advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.aspectBeanNames = aspectNames;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>可以发现，对于原型切面 bean 的解析，它的核心解析动作依然是 <code>advisorFactory.getAdvisors</code> 方法，只是这里面不会再用到 <code>advisorsCache</code> 这个缓存区了，这也说明原型切面 bean 的解析是多次执行的。</p>
<h4 id="1-2-4-增强器汇总"><a href="#1-2-4-增强器汇总" class="headerlink" title="1.2.4 增强器汇总"></a>1.2.4 增强器汇总</h4><p>最后一部分到了整理的环节了，前面已经把所有的切面类都解析完了，这里只需要把这些构造好的增强器都集中到一个 List 中，返回即可。源码很简单，小伙伴们扫一眼就好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">if</span> (aspectNames.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Collections.emptyList();<br>    &#125;<br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String aspectName : aspectNames) &#123;<br>        List&lt;Advisor&gt; cachedAdvisors = <span class="hljs-keyword">this</span>.advisorsCache.get(aspectName);<br>        <span class="hljs-keyword">if</span> (cachedAdvisors != <span class="hljs-keyword">null</span>) &#123;<br>            advisors.addAll(cachedAdvisors);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            MetadataAwareAspectInstanceFactory factory = <span class="hljs-keyword">this</span>.aspectFactoryCache.get(aspectName);<br>            advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>至此，切入点表达式也就解析完了，通知方法也有了，<code>Advisor</code> 增强器也就顺理的创建出来了。</p>
<p>Debug 返回的时候，可以发现 <code>Logger</code> 中的 5 个增强器都封装好了：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb810b6e37244b16b024ac43b494cc76~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<p>所有的增强器创建完成后，接下来的内容就是承接上一章的 bean 匹配，决定是否跳过 bean 的增强的步骤了。</p>
<h2 id="2-TargetSource"><a href="#2-TargetSource" class="headerlink" title="2. TargetSource"></a>2. TargetSource</h2><p>上一章咱简单的提了一嘴，<strong>AOP 的代理其实不是代理的目标对象本身，而是目标对象包装后的 <code>TargetSource</code> 对象</strong>，SpringFramework 为什么要这么做，这样做有什么好处，咱这里也来深入研究一下。</p>
<h3 id="2-1-TargetSource的设计"><a href="#2-1-TargetSource的设计" class="headerlink" title="2.1 TargetSource的设计"></a>2.1 TargetSource的设计</h3><p>之前在复习动态代理的时候，咱说代理对象中直接组合了原始对象，直观一点的理解，就可以是这样子：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3a8cd45f59a413bb7065a0fb79807e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<p>但是在 SpringFramework 的 AOP 中，代理对象并没有直接代理 Target ，而是给 Target 加了一个壳，而加的这个壳就是 <strong><code>TargetSource</code></strong> ，用图示理解就是这样：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a44f8b3f5bf141f0a900612743752d3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<p>是不是一下子就容易理解了呢？<code>TargetSource</code> 可以看做是目标对象 Target 的一个包装、容器，原本代理对象要执行 <code>method.invoke(target, args)</code> 这样的逻辑时，本来要拿到的是目标对象，但被 <code>TargetSource</code> 包装之后，就只能调用 <code>method.invoke(targetSource.getTarget(), args)</code> 这样的形式了。</p>
<h3 id="2-2-TargetSource的好处"><a href="#2-2-TargetSource的好处" class="headerlink" title="2.2 TargetSource的好处"></a>2.2 TargetSource的好处</h3><p>既然每次调用代理对象的方法，最终会调用到 <code>TargetSource</code> 的 <code>getTarget</code> 方法，而这个 <code>getTarget</code> 方法是 <code>TargetSource</code> 决定如何返回的，那这里面可就大有文章了。举个最简单的例子：每次 <code>getTarget</code> 的值可以不一样吧？每次 <code>getTarget</code> 的时候可以从一个对象池中取吧？哎，是不是突然想到了数据库连接池？其实 <code>TargetSource</code> 也有基于池的实现。</p>
<p>所以咱可以总结出来，让 AOP 代理 <code>TargetSource</code> 的好处，是<strong>可以控制每次方法调用时作用的具体对象实例，从而让方法的调用更加灵活</strong>。</p>
<h3 id="2-3-TargetSource的结构"><a href="#2-3-TargetSource的结构" class="headerlink" title="2.3 TargetSource的结构"></a>2.3 TargetSource的结构</h3><p>翻开 <code>TargetSource</code> 的源码，可以发现它是一个接口，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TargetSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TargetClassAware</span> </span>&#123;<br>	Class&lt;?&gt; getTargetClass();<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-function">Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseTarget</span><span class="hljs-params">(Object target)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现除了 <code>getTarget</code> 方法之外，还有一个 <code>releaseTarget</code> ，咱也能很快的猜到它的作用是交回 / 释放目标对象之类的操作，它也是用于那些基于对象池的 <code>TargetSource</code> ，在目标对象调用方法完成后，紧接着调用 <code>releaseTarget</code> 方法来释放目标对象的。</p>
<p>另外还有一个 <code>isStatic</code> 方法，可能小伙伴们会疑惑：bean 哪来的静态一说？对于 Java 来讲，<code>Class</code> 与 object 的作用域可以分出来静态和非静态（ <code>Class</code> 级别的成员是静态的，object 级别的成员是非静态的），那对于 SpringFramework 来讲，单实例 bean 与原型 bean 的作用域也可以划分出静态和非静态的概念：单实例 bean 是一个 <code>ApplicationContext</code> 中只有一个实例，原型 bean 是每次获取都会拿到一个全新的实例，所以<strong>单实例 bean 就可以划为 “静态 bean ”</strong>，原型 bean 则为非静态 bean 。</p>
<h3 id="2-4-SpringFramework中提供的TargetSource"><a href="#2-4-SpringFramework中提供的TargetSource" class="headerlink" title="2.4 SpringFramework中提供的TargetSource"></a>2.4 SpringFramework中提供的TargetSource</h3><p>SpringFramework 中针对不同场景不同需求，预设了几个 <code>TargetSource</code> 的实现，咱可以稍微了解一下：</p>
<ul>
<li><code>SingletonTargetSource</code> ：每次 <code>getTarget</code> 都返回同一个目标对象 bean （与直接代理 target 无任何区别）</li>
<li><code>PrototypeTargetSource</code> ：每次 <code>getTarget</code> 都会从 <code>BeanFactory</code> 中创建一个全新的 bean （被它包装的 bean 必须为原型 bean ）</li>
<li><code>CommonsPool2TargetSource</code> ：内部维护了一个对象池，每次 <code>getTarget</code> 时从对象池中取（底层使用 apache 的 <code>ObjectPool</code> ）</li>
<li><code>ThreadLocalTargetSource</code> ：每次 <code>getTarget</code> 都会从它所处的线程中取目标对象（由于每个线程都有一个 <code>TargetSource</code> ，所以被它包装的 bean 也必须是原型 bean ）</li>
<li><code>HotSwappableTargetSource</code> ：内部维护了一个可以热替换的目标对象引用，每次 <code>getTarget</code> 的时候都返回它（它提供了一个线程安全的 <code>swap</code> 方法，以热替换 <code>TargetSource</code> 中被代理的目标对象）</li>
</ul>
<p>这些设计在底层都不算复杂，小伙伴们可以自行翻一把源码看看，小册就不大张旗鼓的贴源码了。</p>
<p>【OK 了解一下这些前置的知识，接下来咱就该研究，bean 对象的创建时，<code>AnnotationAwareAspectJAutoProxyCreator</code> 是如何把 bean 对象包装为代理对象的】</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/17/12-AOP%E5%8E%9F%E7%90%86-Bean%E5%A6%82%E4%BD%95%E8%A2%ABAOP%E4%BB%A3%E7%90%86%E7%9A%84/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">12-AOP原理-Bean如何被AOP代理的</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/16/10-AOP%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/">
                        <span class="hidden-mobile">10-AOP原理-底层核心后置处理器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2022/04/17/11-AOP%E5%8E%9F%E7%90%86-%E5%88%87%E9%9D%A2%E7%B1%BB%E6%94%B6%E9%9B%86%E5%B0%81%E8%A3%85/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
