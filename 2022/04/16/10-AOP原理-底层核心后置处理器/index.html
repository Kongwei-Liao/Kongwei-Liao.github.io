

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>10-AOP原理-底层核心后置处理器 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="10-AOP原理-底层核心后置处理器">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-16 22:45" pubdate>
        2022年4月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      38
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">10-AOP原理-底层核心后置处理器</h1>
            
            <div class="markdown-body">
              <h1 id="AOP原理-AOP代理的底层核心后置处理器"><a href="#AOP原理-AOP代理的底层核心后置处理器" class="headerlink" title="AOP原理-AOP代理的底层核心后置处理器"></a>AOP原理-AOP代理的底层核心后置处理器</h1><h2 id="1-EnableAspectJAutoProxy的作用"><a href="#1-EnableAspectJAutoProxy的作用" class="headerlink" title="1. @EnableAspectJAutoProxy的作用"></a>1. @EnableAspectJAutoProxy的作用</h2><p>翻开 <code>@EnableAspectJAutoProxy</code> 注解的源码，可以发现它 <code>@Import</code> 了一个注册器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(AspectJAutoProxyRegistrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAspectJAutoProxy &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exposeProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-1-AspectJAutoProxyRegistrar与后置处理器"><a href="#1-1-AspectJAutoProxyRegistrar与后置处理器" class="headerlink" title="1.1 AspectJAutoProxyRegistrar与后置处理器"></a>1.1 AspectJAutoProxyRegistrar与后置处理器</h3><p>这个注册器还挺有来头，点进去看一眼它的文档注释，会发现它已经把核心的后置处理器给说出来了：</p>
<blockquote>
<p>Registers an AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry as appropriate based on a given @EnableAspectJAutoProxy annotation.</p>
<p>根据给定的 <code>@EnableAspectJAutoProxy</code> 注解，根据当前 <code>BeanDefinitionRegistry</code>在适当的位置注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> 。</p>
</blockquote>
<p>由此可知，AOP 的核心后置处理器是 <strong><code>AnnotationAwareAspectJAutoProxyCreator</code></strong> 。</p>
<p>先把它放在一边，咱先了解一下 <code>AspectJAutoProxyRegistrar</code> 是在什么时机下注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的。</p>
<h3 id="1-2-AspectJAutoProxyRegistrar注册后置处理器的时机"><a href="#1-2-AspectJAutoProxyRegistrar注册后置处理器的时机" class="headerlink" title="1.2 AspectJAutoProxyRegistrar注册后置处理器的时机"></a>1.2 AspectJAutoProxyRegistrar注册后置处理器的时机</h3><p>由于 <code>AspectJAutoProxyRegistrar</code> 实现了 <code>ImportBeanDefinitionRegistrar</code> 接口，所以我们可以直接找到 <code>registerBeanDefinitions</code> 方法，去寻找注册的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-comment">// 核心注册后置处理器的动作</span><br>    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br><br>    <span class="hljs-comment">// 解析@EnableAspectJAutoProxy的属性并配置</span><br>    AnnotationAttributes enableAspectJAutoProxy =<br>            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>    <span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;proxyTargetClass&quot;</span>)) &#123;<br>            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;exposeProxy&quot;</span>)) &#123;<br>            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第一句就明示了它要注册后置处理器，也就是代理的创建器了。而这个方法也指明了它要注册的 bean 的类型就是 <code>AnnotationAwareAspectJAutoProxyCreator</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> </span>&#123;<br>    <span class="hljs-comment">// 此处已指定类型</span><br>    <span class="hljs-keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再往下，就是根据这个类型，构造 <code>BeanDefinition</code> ，并注册进 <code>BeanDefinitionRegistry</code>的动作了，逻辑相对简单，小伙伴们扫一眼就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerOrEscalateApcAsRequired</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> </span>&#123;<br><br>    Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>        <span class="hljs-keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;<br>            <span class="hljs-keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());<br>            <span class="hljs-keyword">int</span> requiredPriority = findPriorityForClass(cls);<br>            <span class="hljs-keyword">if</span> (currentPriority &lt; requiredPriority) &#123;<br>                apcDefinition.setBeanClassName(cls.getName());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 构造BeanDefinition，注册进BeanDefinitionRegistry</span><br>    RootBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(cls);<br>    beanDefinition.setSource(source);<br>    beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);<br>    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<br>    <span class="hljs-keyword">return</span> beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>逻辑还是简单吧，经过 IOC 部分的洗礼，这些底层看起来是不是也就轻松许多了呢？</p>
<p>下面我们来着重研究这个核心的后置处理器，也就是代理对象的创建器 <strong><code>AnnotationAwareAspectJAutoProxyCreator</code></strong> 。</p>
<h2 id="2-AnnotationAwareAspectJAutoProxyCreator"><a href="#2-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="2. AnnotationAwareAspectJAutoProxyCreator"></a>2. AnnotationAwareAspectJAutoProxyCreator</h2><p>这么重要的 API ，javadoc 中一定有对它的描述吧，咱先来看一眼：</p>
<blockquote>
<p>AspectJAwareAdvisorAutoProxyCreator subclass that processes all AspectJ annotation aspects in the current application context, as well as Spring Advisors. Any AspectJ annotated classes will automatically be recognized, and their advice applied if Spring AOP’s proxy-based model is capable of applying it. This covers method execution joinpoints. If the <code>&lt;aop:include&gt;</code> element is used, only @AspectJ beans with names matched by an include pattern will be considered as defining aspects to use for Spring auto-proxying. Processing of Spring Advisors follows the rules established in org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.</p>
<p>它是 <code>AspectJAwareAdvisorAutoProxyCreator</code> 的子类，用于处理当前 ApplicationContext 中的所有基于 AspectJ 注解的切面，以及 Spring 原生的 <code>Advisor</code>。</p>
<p>如果 Spring AOP 基于代理的模型能够应用任何被 <code>@AspectJ</code> 注解标注的类，那么它们的增强方法将被自动识别。这涵盖了方法执行的切入点表达式。</p>
<p>如果使用 <code>&lt;aop:include&gt;</code> 元素，则只有名称与包含模式匹配的被 <code>@AspectJ</code> 标注的 bean 将被视为定义要用于 Spring 自动代理的方面。</p>
<p>Spring 中内置的 <code>Advisor</code> 的处理遵循 <code>AbstractAdvisorAutoProxyCreator</code> 中建立的规则。</p>
</blockquote>
<p>拆解看来，javadoc 中解释的核心内容是，<code>AnnotationAwareAspectJAutoProxyCreator</code> 它兼顾 AspectJ 风格的切面声明，以及 SpringFramework 原生的 AOP 编程。</p>
<h3 id="2-1-AnnotationAwareAspectJAutoProxyCreator的继承结构"><a href="#2-1-AnnotationAwareAspectJAutoProxyCreator的继承结构" class="headerlink" title="2.1 AnnotationAwareAspectJAutoProxyCreator的继承结构"></a>2.1 AnnotationAwareAspectJAutoProxyCreator的继承结构</h3><p>借助 IDEA ，可以很清楚的看到 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的继承结构，以及它其中的重要核心：</p>
<p><img src="/2022/04/16/10-AOP%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/img01.png" srcset="/img/loading.gif" alt="img"></p>
<p>注意看最顶层的接口，它实现了几个重要的接口：</p>
<ul>
<li><code>BeanPostProcessor</code> ：用于在 <code>postProcessAfterInitialization</code> 方法中生成代理对象</li>
<li><code>InstantiationAwareBeanPostProcessor</code> ：拦截 bean 的正常 <code>doCreateBean</code> 创建流程</li>
<li><code>SmartInstantiationAwareBeanPostProcessor</code> ：提前预测 bean 的类型、暴露 bean 的引用（ AOP 、循环依赖等，太过于复杂，此处不作解释）</li>
<li><code>AopInfrastructureBean</code> ：实现了该接口的 bean 永远不会被代理（防止套娃）</li>
</ul>
<p>除此之外，咱们一定要注意到它最开始的抽象实现类是 <strong><code>AbstractAutoProxyCreator</code></strong> ，它也是极度重要的！咱后面的不少源码分析中都会遇到它的。</p>
<h3 id="2-2-AnnotationAwareAspectJAutoProxyCreator的初始化时机"><a href="#2-2-AnnotationAwareAspectJAutoProxyCreator的初始化时机" class="headerlink" title="2.2 AnnotationAwareAspectJAutoProxyCreator的初始化时机"></a>2.2 AnnotationAwareAspectJAutoProxyCreator的初始化时机</h3><p>既然在 <code>AspectJAutoProxyRegistrar</code> 中已经把 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的 <code>BeanDefinition</code> 注册到 <code>BeanDefinitionRegistry</code> 中了，那么接下来的后置处理器初始化部分，它一定会被创建，而这个时机我们在前面 IOC 原理部分也讲过了，咱这里回顾一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-comment">// ......</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            postProcessBeanFactory(beanFactory);<br>            invokeBeanFactoryPostProcessors(beanFactory);<br>            <span class="hljs-comment">// 6. 注册、初始化BeanPostProcessor</span><br>            registerBeanPostProcessors(beanFactory);<br>            initMessageSource();<br>            initApplicationEventMulticaster();<br>            <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里面那个超级长的方法，还有印象吧！源码咱就不贴了，主要能让小伙伴们回忆起来就好。</p>
<p>注意一个小细节，<code>AnnotationAwareAspectJAutoProxyCreator</code> 实现了 <code>Ordered</code> 接口，它会提前于普通 <code>BeanPostProcessor</code> 创建，那是不是就代表着普通的 <code>BeanPostProcessor</code> 也会被 AOP 代理呢？答案是肯定的，小伙伴们可以自行测试一下。</p>
<h3 id="2-3-AnnotationAwareAspectJAutoProxyCreator的作用时机"><a href="#2-3-AnnotationAwareAspectJAutoProxyCreator的作用时机" class="headerlink" title="2.3 AnnotationAwareAspectJAutoProxyCreator的作用时机"></a>2.3 AnnotationAwareAspectJAutoProxyCreator的作用时机</h3><p>那既然 <code>ApplicationContext</code> 的 <code>refresh</code> 方法中，第 6 步 <code>registerBeanPostProcessors</code>方法把 <code>AnnotationAwareAspectJAutoProxyCreator</code> 初始化好了，接下来的 bean 就应该都会被它干预了。咱以 <code>com.linkedbear.spring.aop.b_aspectj</code> 中的示例来看，<code>FinanceService</code> 对象的创建流程中 <code>AnnotationAwareAspectJAutoProxyCreator</code> 如何插入干预的。</p>
<h4 id="2-3-1-getBean-→-doCreateBean"><a href="#2-3-1-getBean-→-doCreateBean" class="headerlink" title="2.3.1 getBean → doCreateBean"></a>2.3.1 getBean → doCreateBean</h4><p>bean 的创建流程咱前面 IOC 原理部分已经学过了，从 <code>getBean</code> 开始，依次是 <code>doGetBean</code>、<code>createBean</code> 、<code>doCreateBean</code> ，在 <code>doCreateBean</code> 方法中会真正的创建对象、属性赋值、依赖注入，以及初始化流程的执行。等 bean 本身的初始化流程全部执行完毕后，就该 <code>BeanPostProcessor</code> 的 <code>postProcessAfterIntialization</code> 方法了，这些咱都很熟悉。</p>
<p>不过，在这之前有一个小插曲，是 <code>createBean</code> 到 <code>doCreateBean</code> 这个动作中还有一个 <code>InstantiationAwareBeanPostProcessor</code> 的拦截初始化动作，咱需要来看一下。</p>
<h4 id="2-3-2-AnnotationAwareAspectJAutoProxyCreator-postProcessBeforeInstantiation"><a href="#2-3-2-AnnotationAwareAspectJAutoProxyCreator-postProcessBeforeInstantiation" class="headerlink" title="2.3.2 AnnotationAwareAspectJAutoProxyCreator#postProcessBeforeInstantiation"></a>2.3.2 AnnotationAwareAspectJAutoProxyCreator#postProcessBeforeInstantiation</h4><p>源码不是特别长，我们可以简单的来看一下这里面发生的核心动作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    Object cacheKey = getCacheKey(beanClass, beanName);<br><br>    <span class="hljs-comment">// 决定是否要提前增强当前bean</span><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>        <span class="hljs-comment">// 被增强过的bean不会再次被增强</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 基础类型的bean不会被提前增强、被跳过的bean不会被提前增强</span><br>        <span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 原型bean的额外处理：TargetSource</span><br>    <span class="hljs-comment">// 此处的设计与自定义TargetSource相关，单实例bean必定返回null</span><br>    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);<br>    <span class="hljs-keyword">if</span> (targetSource != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.targetSourcedBeans.add(beanName);<br>        &#125;<br>        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);<br>        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);<br>        <span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>纵读下来，这里面的逻辑其实并不复杂，甚至还蛮容易理解的，这里面涉及到几个小概念咱在这里解释一下。</p>
<h5 id="2-3-2-1-InfrastructureClass"><a href="#2-3-2-1-InfrastructureClass" class="headerlink" title="2.3.2.1 InfrastructureClass"></a>2.3.2.1 InfrastructureClass</h5><p>这个<strong>基础类型</strong>，可能小伙伴们不大理解这玩意是个啥，咱可以点进去看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">super</span>.isInfrastructureClass(beanClass) ||<br>            (<span class="hljs-keyword">this</span>.aspectJAdvisorFactory != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass)));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||<br>            Pointcut.class.isAssignableFrom(beanClass) ||<br>            Advisor.class.isAssignableFrom(beanClass) ||<br>            AopInfrastructureBean.class.isAssignableFrom(beanClass);<br>    <span class="hljs-comment">// logger ......</span><br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>得了，合着它说的这些<strong>基础类型，是切面、切入点、增强器等等的对象</strong>！那一切就解释的过去了，一个切入点的对象包装怎么会被 AOP 代理呢？它是作为 AOP 底层非常重要的组成成员，它不应该参与到具体的被增强对象中。</p>
<h5 id="2-3-2-2-被跳过的bean？"><a href="#2-3-2-2-被跳过的bean？" class="headerlink" title="2.3.2.2 被跳过的bean？"></a>2.3.2.2 被跳过的bean？</h5><p>这个被跳过的 bean ，似乎在之前我们学习 AOP 的过程中一直没有接触过，它是什么意思呢？咱可以先进到源码中看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AspectJAwareAdvisorAutoProxyCreator</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// 加载增强器</span><br>    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>    <span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;<br>        <span class="hljs-comment">// 逐个匹配，如果发现当前bean的名称与增强器的名称一致，则认为</span><br>        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;<br>                ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);<br>&#125;<br><br><span class="hljs-comment">// AbstractAutoProxyCreator</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查beanName代表的是不是原始对象(以.ORIGINAL结尾)</span><br>    <span class="hljs-keyword">return</span> AutoProxyUtils.isOriginalInstance(beanName, beanClass);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简单的用注释一标，小伙伴们也不难理解这段逻辑吧，它要看看<strong>当前对象的名称是不是有跟增强器的名称撞车的</strong>，或者说<strong>它是不是一个还没有经过任何代理的原始对象</strong>。对于一般情况而言，我们构造的 bean 根本就不可能带有 <code>.ORIGINAL</code> 的后缀，所以这个地方相当于判断当前创建的 bean 是否名称与增强器撞车。</p>
<p>这里咱简单说下增强器的概念。一个 <code>Advisor</code> 可以视为<strong>一个切入点 + 一个通知方法的结合体</strong>，对于 Aspect 切面类中定义的通知方法，<strong>方法体 + 方法上的通知注解</strong>就可以看做一个 <code>Advisor</code> 增强器。更多相关的解释，咱放到下一章再研究。</p>
<p>至于上面的 <code>findCandidateAdvisors</code> 方法，里面的逻辑有点复杂，咱也放到下一章再研究。</p>
<p>不过在此 Debug 的时候，可以发现 <code>findCandidateAdvisors</code> 方法执行完成后，获取到了 5 个增强器，也都是在 <code>Logger</code> 类中定义的那 5 个通知方法：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa955a366d1542d982d517d86c12b61d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<p>（最后一个名太长了，实际上是 afterThrowing 的通知，引用的通用切入点表达式罢了。。。）</p>
<h5 id="2-3-2-3-TargetSource？"><a href="#2-3-2-3-TargetSource？" class="headerlink" title="2.3.2.3 TargetSource？"></a>2.3.2.3 TargetSource？</h5><p>这个概念咱之前在 IOC 部分没有见到过，当然它也不是 IOC 的东西。。。这个概念咱也是放到下一章再解释吧，这里咱可以先简单说一下，<strong>AOP 的代理其实不是代理的目标对象本身，而是目标对象包装后的 <code>TargetSource</code> 对象</strong>。至于为什么它会这么做，咱下一章也会展开解释的。</p>
<h4 id="2-3-3-AnnotationAwareAspectJAutoProxyCreator-postProcessAfterInitialization"><a href="#2-3-3-AnnotationAwareAspectJAutoProxyCreator-postProcessAfterInitialization" class="headerlink" title="2.3.3 AnnotationAwareAspectJAutoProxyCreator#postProcessAfterInitialization"></a>2.3.3 AnnotationAwareAspectJAutoProxyCreator#postProcessAfterInitialization</h4><p>前面的拦截判断结束后，<code>AnnotationAwareAspectJAutoProxyCreator</code> 再发挥作用就要等到最后一步的 <code>postProcessAfterInitialization</code> 方法了，这里面就是真正的生成代理对象。方法的实现很简单，咱跳转进来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>        Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;<br>            <span class="hljs-comment">// 核心：构造代理</span><br>            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>小小的前戏后，最关键的动作是中间的 <code>wrapIfNecessary</code> 方法。</p>
<p>这个动作从方法名上就可以很容易的理解了，如果有必要的话，给这个对象包装生成代理对象。下面进入到源码的部分（小伙伴们只需要关注标注有注释的部分即可）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-keyword">this</span>.advisedBeans.get(cacheKey))) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;<br>        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// Create proxy if we have advice.</span><br>    <span class="hljs-comment">// 如果上面的判断都没有成立，则决定是否需要进行代理对象的创建</span><br>    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<br>        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<br>        <span class="hljs-comment">// 创建代理对象的动作</span><br>        Object proxy = createProxy(<br>                bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> SingletonTargetSource(bean));<br>        <span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以由此可见，创建代理对象的核心动作其实就三个步骤：</p>
<ol>
<li>判断决定是否是不会被增强的 bean</li>
<li>根据当前正在创建的 bean 去匹配增强器</li>
<li>如果有增强器，创建 bean 的代理对象</li>
</ol>
<p>这里咱只是简单地看一下流程，具体的创建代理对象的动作，咱放到第 50 章再研究。</p>
<p>【到这里咱先整体的对 AOP 中的核心注解，以及后置处理器 <code>AnnotationAwareAspectJAutoProxyCreator</code> 有一个整体的认识，小伙伴们先把这部分消化好吧。接下来的两章，咱就要来具体的研究几个重要的环节了】</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/16/09-AOP%E9%AB%98%E7%BA%A7-%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0AOP/">
                        <span class="hidden-mobile">09-AOP高级-尝试自己实现AOP</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2022/04/16/10-AOP%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
