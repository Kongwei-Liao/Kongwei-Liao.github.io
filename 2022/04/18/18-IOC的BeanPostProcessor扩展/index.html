

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>18-IOC的BeanPostProcessor扩展 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="18-IOC的BeanPostProcessor扩展">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-18 11:00" pubdate>
        2022年4月18日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      53
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">18-IOC的BeanPostProcessor扩展</h1>
            
            <div class="markdown-body">
              <h1 id="BeanPostProcessor-的扩展及作用时机"><a href="#BeanPostProcessor-的扩展及作用时机" class="headerlink" title="BeanPostProcessor 的扩展及作用时机"></a>BeanPostProcessor 的扩展及作用时机</h1><p>上一章，对 <code>BeanPostProcessor</code> 有一个大体的认识。这一章我们来研究 <code>BeanPostProcessor</code> 的扩展，内容难度会更高。</p>
<p>借助 IDEA ，发现 <code>BeanPostProcessor</code> 有如下的接口扩展：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f32dca851d1a41ffab629bb141fb97b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>这些接口，各自扩展出来的功能也都不同，下面我们逐个来研究。</p>
<h2 id="1-InstantiationAwareBeanPostProcessor【熟悉】"><a href="#1-InstantiationAwareBeanPostProcessor【熟悉】" class="headerlink" title="1. InstantiationAwareBeanPostProcessor【熟悉】"></a>1. InstantiationAwareBeanPostProcessor【熟悉】</h2><p>从类名上看，它与<strong>实例化</strong>有关系，而且它又带着一个 <strong>aware</strong> ，难道是在暗示我们又跟回调注入什么的相关吗？还是先看下文档注释吧。</p>
<h3 id="1-1-javadoc理解"><a href="#1-1-javadoc理解" class="headerlink" title="1.1 javadoc理解"></a>1.1 javadoc理解</h3><blockquote>
<p>Subinterface of BeanPostProcessor that adds a before-instantiation callback, and a callback after instantiation but before explicit properties are set or autowiring occurs. Typically used to suppress default instantiation for specific target beans, for example to create proxies with special TargetSources (pooling targets, lazily initializing targets, etc), or to implement additional injection strategies such as field injection. NOTE: This interface is a special purpose interface, mainly for internal use within the framework. It is recommended to implement the plain BeanPostProcessor interface as far as possible, or to derive from InstantiationAwareBeanPostProcessorAdapter in order to be shielded from extensions to this interface.</p>
<p><code>BeanPostProcessor</code> 的子接口，它添加了实例化之前的回调，以及在实例化之后但在设置显式属性或自动装配发生之前的回调。 </p>
<p>通常用于抑制特定目标 bean 的默认实例化，例如创建具有特殊 <code>TargetSource</code> 的代理（池目标，延迟初始化目标等），或实现其他注入策略，例如字段注入。 </p>
<p>注意：此接口是专用接口，主要供框架内部使用。建议尽可能实现普通的 <code>BeanPostProcessor</code> 接口，或从 <code>InstantiationAwareBeanPostProcessorAdapter</code> 派生，以免对该接口进行扩展。</p>
</blockquote>
<p>文档注释已经写得很明白了，它的作用有两个：</p>
<ul>
<li>拦截并替换 Bean 的默认实例化动作</li>
<li>拦截 Bean 的属性注入和自动装配，并在此之前扩展</li>
</ul>
<p>所以，我们是不是可以先试着猜想一波，它对 bean 的生命周期的干预应该是在这两个时机：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/519413e68253488a85c01fdc9c3a75d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>是不是真的这样，咱来看看 <code>InstantiationAwareBeanPostProcessor</code> 中定义了什么方法，从中获取信息来检验猜想是否正确。</p>
<h3 id="1-2-接口方法定义"><a href="#1-2-接口方法定义" class="headerlink" title="1.2 接口方法定义"></a>1.2 接口方法定义</h3><p><code>InstantialtionAwareBeanPostProcessor</code> 中定义了 4 个方法（ 5.1 之前是 3 个）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 已过时，被上面的方法代替</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-function"><span class="hljs-keyword">default</span> PropertyValues <span class="hljs-title">postProcessPropertyValues</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">return</span> pvs;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分别看这三个方法，它们的作用分别是：</p>
<ul>
<li><p>postProcessBeforeInstantiation：在 bean 的实例化之前处理，如果成功实例化并返回对象，会屏蔽postProcessProperties、属性赋值和组件注入阶段</p>
<ul>
<li>非常容易理解，它可以拦截 bean 原本的实例化方法，转为用这里的实例化</li>
</ul>
</li>
<li><p>postProcessAfterInstantiation：在 bean 的实例化之后处理</p>
<ul>
<li>这个方法比较奇怪，返回值是 boolean ，它有代表什么意思吗？</li>
<li>其实，它与下面的 <code>postProcessProperties</code> 方法有关，如果返回 false ，则 <code>postProcessProperties</code> 方法不会执行</li>
</ul>
</li>
<li><p>postProcessProperties：在设置属性时处理 ？？？（好像不大对劲）</p>
<ul>
<li>根据 javadoc 得知，这个方法是在属性赋值之前触发的，而 <code>PropertyValues</code> 又是一组 <code>field - value</code> 的键值对</li>
<li>由此可以断定，<code>postProcessProperties</code> 方法最终会返回一组属性和值的 <code>PropertyValues</code> ，让它参与 bean 的属性赋值环节</li>
</ul>
</li>
</ul>
<p>那加入 <code>InstantiationAwareBeanPostProcessor</code> 后的 bean 的生命周期就是这样子咯：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a7337c1733e4d10b78e4758eb8d2770~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>具体的操作，我们可以写几个 Demo 来验证一下，顺便体会一下 <code>InstantiationAwareBeanPostProcessor</code> 对 bean 的扩展。</p>
<h3 id="1-3-IABPP-拦截-bean-的实例化"><a href="#1-3-IABPP-拦截-bean-的实例化" class="headerlink" title="1.3 IABPP 拦截 bean 的实例化"></a>1.3 IABPP 拦截 bean 的实例化</h3><p>先来试一下第一个 <code>postProcessBeforeInstantiation</code> 方法吧，既然它能直接拦截 bean 的创建，那正常的 bean 里头的东西，或许被它一拦截，就没了吧（覆盖了属性赋值&amp;组件自动注入阶段的动作）。</p>
<h4 id="1-3-1-声明bean"><a href="#1-3-1-声明bean" class="headerlink" title="1.3.1 声明bean"></a>1.3.1 声明bean</h4><p>这次我们来玩个球，给球声明一个 id 的属性就够了：（不要忘记写 <code>toString</code> 方法，方便打印查看）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String id;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ball&#123;&quot;</span> + <span class="hljs-string">&quot;id=&#x27;&quot;</span> + id + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1-3-2-编写后置处理器"><a href="#1-3-2-编写后置处理器" class="headerlink" title="1.3.2 编写后置处理器"></a>1.3.2 编写后置处理器</h4><p>既然是拦截创建，那我就希望，能在后置处理器中单独创建一个球，不要配置声明的。于是后置处理器就可以这样编写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BallFactoryInstantiationProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ball&quot;</span>.equals(beanName)) &#123;<br>            <span class="hljs-comment">// 返回非null，代表拦截创建</span><br>            Ball ball = <span class="hljs-keyword">new</span> Ball();<br>            ball.setId(<span class="hljs-string">&quot;工厂球~&quot;</span>);<br>            <span class="hljs-keyword">return</span> ball;<br>        &#125;<br>        <span class="hljs-comment">// 默认直接返回null，代表不拦截</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里我在 <code>postProcessBeforeInstantiation</code> 中显式的 new 了一个球，这样回头如果真的走了这个分支，那将返回后置处理器创建的球。</p>
<h4 id="1-3-3-编写xml配置文件"><a href="#1-3-3-编写xml配置文件" class="headerlink" title="1.3.3 编写xml配置文件"></a>1.3.3 编写xml配置文件</h4><p>xml 配置文件中，要声明一个 <code>Ball</code> 的 bean ，同时把后置处理器也注册进去：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ball&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.postprocessor.e_instantiation.bean.Ball&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.postprocessor.e_instantiation.config.BallFactoryInstantiationProcessor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="1-3-4-测试运行"><a href="#1-3-4-测试运行" class="headerlink" title="1.3.4 测试运行"></a>1.3.4 测试运行</h4><p>好了，可以编写测试类来检验效果了，使用 xml 配置文件来驱动 IOC 容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstantiationAwareApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<br>                <span class="hljs-string">&quot;postprocessor/processor-instantiation.xml&quot;</span>);<br>        Ball ball = (Ball) ctx.getBean(<span class="hljs-string">&quot;ball&quot;</span>);<br>        System.out.println(ball);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 <code>main</code> 方法，控制台打印的是 “工厂球” ，证明 <code>BallFactoryInstantiationProcessor</code> 已经成功拦截了 xml 配置文件中声明的 <code>Ball</code> 的创建，转而使用后置处理器的逻辑创建了。<strong>覆盖了属性赋值阶段的动作，xml 声明的属性赋值失效。</strong></p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">Ball&#123;<span class="hljs-symbol">id</span>=<span class="hljs-string">&#x27;工厂球~&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-4-IABPP-给-bean做属性赋值"><a href="#1-4-IABPP-给-bean做属性赋值" class="headerlink" title="1.4 IABPP 给 bean做属性赋值"></a>1.4 IABPP 给 bean做属性赋值</h3><p>来试试如果不给 bean 的属性赋值，交由 <code>InstantiationAwareBeanPostProcessor</code> 来做，它真的能做到吗？</p>
<h4 id="1-4-1-扩展xml配置文件"><a href="#1-4-1-扩展xml配置文件" class="headerlink" title="1.4.1 扩展xml配置文件"></a>1.4.1 扩展xml配置文件</h4><p>再声明一个 <code>Ball</code> ，这次只创建对象，不给 id 赋值：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ball2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.postprocessor.e_instantiation.bean.Ball&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="1-4-2-扩展-BallFactoryInstantiationProcessor"><a href="#1-4-2-扩展-BallFactoryInstantiationProcessor" class="headerlink" title="1.4.2 扩展 BallFactoryInstantiationProcessor"></a>1.4.2 扩展 BallFactoryInstantiationProcessor</h4><p>这次要做属性赋值了，对应的接口方法是 <code>postProcessProperties</code> ，我们来重写它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ball2&quot;</span>.equals(beanName)) &#123;<br>        MutablePropertyValues values = <span class="hljs-keyword">new</span> MutablePropertyValues(pvs);<br>        values.addPropertyValue(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;拦截球~&quot;</span>);<br>        <span class="hljs-keyword">return</span> values;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>由于 <code>PropertyValues</code> 设计为接口且只暴露可读方法，此处选用实现类重新包装并添加 id 属性（强转也可以，但此种写法更稳妥）</p>
</blockquote>
<h4 id="1-4-3-测试运行"><a href="#1-4-3-测试运行" class="headerlink" title="1.4.3 测试运行"></a>1.4.3 测试运行</h4><p>修改测试代码，添加 ball2 的获取，并打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<br>            <span class="hljs-string">&quot;postprocessor/processor-instantiation.xml&quot;</span>);<br>    Ball ball = (Ball) ctx.getBean(<span class="hljs-string">&quot;ball&quot;</span>);<br>    System.out.println(ball);<br>    <br>    Ball ball2 = (Ball) ctx.getBean(<span class="hljs-string">&quot;ball2&quot;</span>);<br>    System.out.println(ball2);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，控制台打印出了 “拦截球” ，证明 <code>postProcessProperties</code> 方法的确能给 bean 注入属性。</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml">Ball&#123;<span class="hljs-symbol">id</span>=<span class="hljs-string">&#x27;工厂球~&#x27;</span>&#125;<br>Ball&#123;<span class="hljs-symbol">id</span>=<span class="hljs-string">&#x27;拦截球~&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1-4-4-postProcessProperties-不会影响-postProcessBeforeInstantiation"><a href="#1-4-4-postProcessProperties-不会影响-postProcessBeforeInstantiation" class="headerlink" title="1.4.4 postProcessProperties 不会影响 postProcessBeforeInstantiation"></a>1.4.4 postProcessProperties 不会影响 postProcessBeforeInstantiation</h4><p>突然意识到一个伏笔是吧，前面编写后置处理器的时候，一直都是拿 bean 的 name 做匹配。如果在 <code>postProcessBeforeInstantiation</code> 方法中，我们把判断条件改为所有 Ball 都拦截，那效果会怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">if</span> (Ball.class.equals(beanClass)) &#123;<br>        Ball ball = <span class="hljs-keyword">new</span> Ball();<br>        ball.setId(<span class="hljs-string">&quot;工厂球~&quot;</span>);<br>        <span class="hljs-keyword">return</span> ball;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>修改为上述代码后，重新运行 <code>main</code> 方法，控制台打印了两个工厂球：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml">Ball&#123;<span class="hljs-symbol">id</span>=<span class="hljs-string">&#x27;工厂球~&#x27;</span>&#125;<br>Ball&#123;<span class="hljs-symbol">id</span>=<span class="hljs-string">&#x27;工厂球~&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>说明 <code>postProcessBeforeInstantiation</code> 方法执行完毕后（这个方法怎么都执行完毕，这里指的意思是这个方法内做了实例化动作并返回了实例化对象，而不是 null ），并不会再执行 <code>postProcessProperties</code> 。换句话说，<code>postProcessProperties</code> 方法返回实例化后的对象后，就没有机会能再影响 <code>postProcessBeforeInstantiation</code> 方法创建出来的对象。</p>
<h3 id="1-5-postProcessAfterInstantiation的作用"><a href="#1-5-postProcessAfterInstantiation的作用" class="headerlink" title="1.5 postProcessAfterInstantiation的作用"></a>1.5 postProcessAfterInstantiation的作用</h3><p>上面的分析中我们也说了，<code>postProcessAfterInstantiation</code> 方法如果返回 false ，则 <code>postProcessProperties</code> 方法就不会执行，下面简单验证一下。</p>
<p>在 <code>BallFactoryInstantiationProcessor</code> 中加入 <code>postProcessAfterInstantiation</code> 方法的重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，发现 ball2 已经没有 id 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Ball&#123;id=<span class="hljs-string">&#x27;工厂球~&#x27;</span>&#125;<br>Ball&#123;id=<span class="hljs-string">&#x27;null&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-SmartInstantiationAwareBeanPostProcessor【了解】"><a href="#2-SmartInstantiationAwareBeanPostProcessor【了解】" class="headerlink" title="2. SmartInstantiationAwareBeanPostProcessor【了解】"></a>2. SmartInstantiationAwareBeanPostProcessor【了解】</h2><p>相较于 <code>InstantiationAwareBeanPostProcessor</code> 只多了一个 <strong>smart</strong> ，意思是它更聪明咯？</p>
<p>还真是，这个接口扩展了 3 个额外的方法，而且每个方法还都挺有用的，我们可以来简单的看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>predictBeanType</code> ：预测 bean 的类型（不能预测时返回 null ）</p>
</li>
<li><p><code>determineCandidateConstructors</code>：根据 bean 对应 Class 中的构造器定义，决定使用哪个构造器进行对象实例化</p>
<ul>
<li>这个方法很重要，如果 bean 没有声明任何构造器，则此处会拿到默认的无参构造器；如果声明了多个构造器，则该处会根据 IOC 容器中的 bean 和指定的策略，选择最适合的构造器</li>
</ul>
</li>
<li><p><code>getEarlyBeanReference</code> ：提早暴露出 bean 的对象引用（该方法与 bean 的循环依赖解决有关，在 SpringBoot 的小册 15 章有讲）</p>
</li>
</ul>
<p>看着这么高大上，但是讲真，这个接口在现阶段不是很好演示，而且它本身属于 SpringFramework 内部的接口，通常我们根本用不到，所以这个小伙伴们知道下就可以了，不要在这上面耗费太多的时间和精力。</p>
<p>到后面 IOC 原理中，bean 的完整生命周期会涉及 <code>SmartInstantiationAwareBeanPostProcessor</code> 的，小伙伴们可以到时候留意一下。</p>
<h2 id="3-DestructionAwareBeanPostProcessor【了解】"><a href="#3-DestructionAwareBeanPostProcessor【了解】" class="headerlink" title="3. DestructionAwareBeanPostProcessor【了解】"></a>3. DestructionAwareBeanPostProcessor【了解】</h2><p>顾名思义，它可以在 bean 的<strong>销毁</strong>前拦截处理。这个接口的方法定义也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeDestruction</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">requiresDestruction</span><span class="hljs-params">(Object bean)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很明显它就是一个回调的处理而已，没什么花里胡哨的。下面我们还是来简单的演示一下它的使用。</p>
<h3 id="3-1-DABPP-的使用"><a href="#3-1-DABPP-的使用" class="headerlink" title="3.1 DABPP 的使用"></a>3.1 DABPP 的使用</h3><h4 id="3-1-1-声明Bean"><a href="#3-1-1-声明Bean" class="headerlink" title="3.1.1 声明Bean"></a>3.1.1 声明Bean</h4><p>虽说是用那个 <code>Pen</code> ，不过在这个 Demo 中我们只需要它的销毁方法：（此处只声明了 <code>@PreDestroy</code> 与 <code>DisposableBean</code> ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DisposableBean</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Integer ink = <span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outwellInk</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Pen @PreDestroy 钢笔中的墨水都放干净了。。。&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Pen DisposableBean 写完字了。。。&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// getter setter</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-1-2-编写后置处理器"><a href="#3-1-2-编写后置处理器" class="headerlink" title="3.1.2 编写后置处理器"></a>3.1.2 编写后置处理器</h4><p>既然是在 bean 的销毁阶段回调，那我们可以在这里针对 Pen 给它放干墨水（模拟操作）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DestructionPenPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DestructionAwareBeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeDestruction</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Pen) &#123;<br>            System.out.println(<span class="hljs-string">&quot;DestructionPenPostProcessor postProcessBeforeDestruction run ......&quot;</span>);<br>            Pen pen = (Pen) bean;<br>            pen.setInk(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-1-3-测试运行"><a href="#3-1-3-测试运行" class="headerlink" title="3.1.3 测试运行"></a>3.1.3 测试运行</h4><p>编写测试代码，直接包扫描，驱动 IOC 容器。驱动完成后啥也不用干，直接销毁 IOC 容器就可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DestructionPostProcessorApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.linkedbear.spring.postprocessor.f_destruction&quot;</span>);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 <code>main</code> 方法，控制台打印如下信息：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">DestructionPenPostProcessor postProcessBeforeDestruction <span class="hljs-built_in">run</span> ......<br><span class="hljs-symbol">@PreDestroy</span> - 钢笔中的墨水都放干净了。。。<br>Pen DisposableBean 写完字了。。。<br></code></pre></td></tr></table></figure>
<p>由此可以体会到 <code>DestructionAwareBeanPostProcessor</code> 的使用。</p>
<h3 id="3-2-Spring-中的-DABPP"><a href="#3-2-Spring-中的-DABPP" class="headerlink" title="3.2 Spring 中的 DABPP"></a>3.2 Spring 中的 DABPP</h3><p>关于这个接口的使用，在 SpringFramework 中有个蛮经典的：</p>
<p><strong>监听器的引用释放回调</strong>：由于 <code>ApplicationContext</code> 中会注册一些 <code>ApplicationListener</code> ，而这些 <code>ApplicationListener</code> 与 <code>ApplicationContext</code> <strong>互相引用</strong>，所以在 IOC 容器销毁之前，就需要将这些引用断开，这样才可以进行对象的销毁和回收。</p>
<h2 id="4-MergedBeanDefinitionPostProcessor【了解】"><a href="#4-MergedBeanDefinitionPostProcessor【了解】" class="headerlink" title="4. MergedBeanDefinitionPostProcessor【了解】"></a>4. MergedBeanDefinitionPostProcessor【了解】</h2><p>在前面咱有学习 <code>BeanDefinition</code> 的合并，这个 <code>BeanDefinition</code> 合并的过程，在后置处理器中也有对应的拦截处理。</p>
<h3 id="4-1-回顾-BeanDefinition-的合并"><a href="#4-1-回顾-BeanDefinition-的合并" class="headerlink" title="4.1 回顾 BeanDefinition 的合并"></a>4.1 回顾 BeanDefinition 的合并</h3><p>回想一下，<code>BeanDefinition</code> 合并的意义是啥来着？是为了将父 bean 继承或者已经定义好的注入属性一块拿过来，这样就不用子 bean 再定义一次了吧！这种合并是一种情况，不过还有一种情况，它发生在基于注解的类继承上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Person person;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种情况下，向 IOC 容器注册 <code>Cat</code> 时，Spring 在底层也会把 person 需要注入的定义信息合并进去，并标注它需要自动注入处理。</p>
<h3 id="4-2-接口方法定义"><a href="#4-2-接口方法定义" class="headerlink" title="4.2 接口方法定义"></a>4.2 接口方法定义</h3><p>再来看 <code>MergedBeanDefinitionPostProcessor</code> 的接口，它只定义了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span></span>;<br></code></pre></td></tr></table></figure>
<p>（ 5.1 后又定义了一个 <code>resetBeanDefinition</code> 方法，仅用于清除 <code>BeanFactory</code> 内部缓存，此处不对此展开）</p>
<p>这个方法的 javadoc 出奇的少，甚至都没给什么有用的信息，那这咋研究呢？得了，我们写个 Demo 测一下吧。</p>
<h3 id="4-3-MBDPP的使用"><a href="#4-3-MBDPP的使用" class="headerlink" title="4.3 MBDPP的使用"></a>4.3 MBDPP的使用</h3><h4 id="4-3-1-声明bean"><a href="#4-3-1-声明bean" class="headerlink" title="4.3.1 声明bean"></a>4.3.1 声明bean</h4><p>声明的 bean 就是上面的一个 <code>Animal</code> ，一个 <code>Cat</code> ，当然还得有 <code>Person</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Person person;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">getPerson</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> person;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPerson</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.person = person;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Value(&quot;咪咪&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat &#123;person: &quot;</span> + <span class="hljs-keyword">this</span>.getPerson() + <span class="hljs-string">&quot;, name: &quot;</span> + name + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-3-2-编写后置处理器"><a href="#4-3-2-编写后置处理器" class="headerlink" title="4.3.2 编写后置处理器"></a>4.3.2 编写后置处理器</h4><p>后置处理器里面不用写什么花里胡哨的结构，先拦截一下就好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeDefinitionPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MergedBeanDefinitionPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Cat.class.equals(beanType)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;MergeDefinitionPostProcessor postProcessMergedBeanDefinition run......&quot;</span>);<br>            System.out.println(beanDefinition);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>此处稍微停一下，思考一下此处 <code>postProcessMergedBeanDefinition</code> 的参数列表中为什么只有 beanDefinition 和 beanType ？难道 bean 还没有创建吗？</p>
</blockquote>
<h4 id="4-3-3-测试运行"><a href="#4-3-3-测试运行" class="headerlink" title="4.3.3 测试运行"></a>4.3.3 测试运行</h4><p>测试的代码也很简单，还是直接使用注解 IOC 容器扫描包即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeDefinitionPostProcessorApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.linkedbear.spring.postprocessor.g_mergedefinition&quot;</span>);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 <code>main</code> 方法，控制台有打印 <code>Cat</code> 的 <code>BeanDefinition</code> 信息，说明确实拦截到 Cat 的定义信息合并了。可是上面的问题呢？此时 bean 被创建了吗？</p>
<h4 id="4-3-4-给Cat添加无参构造器"><a href="#4-3-4-给Cat添加无参构造器" class="headerlink" title="4.3.4 给Cat添加无参构造器"></a>4.3.4 给Cat添加无参构造器</h4><p>重写 Cat 的无参构造器，让它在控制台打印一句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Cat constructor run ......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，发现是先创建的 <code>Cat</code> 后打印的后置处理器执行：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Cat <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">run</span> ......</span><br><span class="hljs-function"><span class="hljs-title">MergeDefinitionPostProcessor</span> <span class="hljs-title">postProcessMergedBeanDefinition</span> <span class="hljs-title">run</span>......</span><br></code></pre></td></tr></table></figure>
<p>这个设计是为什么呢？既然创建出了 bean ，为什么后置处理器的回调中没有把 bean 传给我们呢？</p>
<h4 id="4-3-5-调整Animal的自动注入位置"><a href="#4-3-5-调整Animal的自动注入位置" class="headerlink" title="4.3.5 调整Animal的自动注入位置"></a>4.3.5 调整Animal的自动注入位置</h4><p>问题思考不出来没关系，我们来调整一点代码，让 <code>Animal</code> 中的 <code>person</code> 使用 setter 的自动注入，并在控制台打印一句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPerson</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Animal setPerson run ......&quot;</span>);<br>    <span class="hljs-keyword">this</span>.person = person;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再次运行 <code>main</code> 方法，发现 setter 方法的自动注入在最后才打印：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Cat <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">run</span> ......</span><br><span class="hljs-function"><span class="hljs-title">MergeDefinitionPostProcessor</span> <span class="hljs-title">postProcessMergedBeanDefinition</span> <span class="hljs-title">run</span>......</span><br><span class="hljs-function"><span class="hljs-title">Animal</span> <span class="hljs-title">setPerson</span> <span class="hljs-title">run</span> ......</span><br></code></pre></td></tr></table></figure>
<p>由此可以得出结论了吧：<code>postProcessMergedBeanDefinition</code> 方法发生在 <strong>bean 的实例化之后，属性赋值和自动注入之前</strong>。而这个设计，就是为了<strong>在属性赋值和自动注入之前，把要注入的属性都收集好</strong>，这样才能顺利的向下执行注入的逻辑。</p>
<p>而实例化好的 bean 没有传入接口中的原因，其实也很好解释：<strong>人家是合并 <code>BeanDefinition</code> 的，跟 bean 的实例有什么关系呢</strong>（<strong>最少知道原则</strong>）？</p>
<h3 id="4-4-Spring-中的-MBDPP"><a href="#4-4-Spring-中的-MBDPP" class="headerlink" title="4.4 Spring 中的 MBDPP"></a>4.4 Spring 中的 MBDPP</h3><p>在 SpringFramework 中，一个非常重要的 <code>MergeBeanDefinitionPostProcessor</code> 的实现，就是 <code>AutowiredAnnotationBeanPostProcessor</code> ，它负责给 bean 实现注解的自动注入，而注入的依据就是 <code>postProcessMergedBeanDefinition</code> 后整理的标记（这个标记会在 IOC 原理的 bean 完整生命周期中提及）。</p>
<blockquote>
<p>当然，通常 <code>MergedBeanDefinitionPostProcessor</code> 这个后置处理器也不会在开发中使用，仅仅用于 SpringFramework 的内部，小伙伴们知道下就好，不要在这上面耗费太长时间和精力。</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                      <a class="hover-with-bg" href="/tags/IOC/">IOC</a>
                    
                      <a class="hover-with-bg" href="/tags/BeanPostProcessor/">BeanPostProcessor</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/18/19-IOC%E7%9A%84BeanFactoryPostProcessor%E4%BB%8B%E7%BB%8D/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">19-IOC的BeanFactoryPostProcessor介绍</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/18/17-IOC%E7%9A%84BeanPostProcessor%E4%BB%8B%E7%BB%8D/">
                        <span class="hidden-mobile">17-IOC的BeanPostProcessor介绍</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2022/04/18/18-IOC%E7%9A%84BeanPostProcessor%E6%89%A9%E5%B1%95/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
