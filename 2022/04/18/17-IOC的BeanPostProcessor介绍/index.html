

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>17-IOC的BeanPostProcessor介绍 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="17-IOC的BeanPostProcessor介绍">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-18 11:00" pubdate>
        2022年4月18日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      58
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">17-IOC的BeanPostProcessor介绍</h1>
            
            <div class="markdown-body">
              <h1 id="后置处理器入门与使用"><a href="#后置处理器入门与使用" class="headerlink" title="后置处理器入门与使用"></a>后置处理器入门与使用</h1><p>后置处理器这部分的难度实在是有点高，而且属于比较高阶的用法，所以就放在 IOC 高级部分讲解了。另外，后置处理器可以影响的并不只是 <code>bean</code> ，<code>BeanFactory</code> 、<code>BeanDefinition</code> 也都可以影响，需要这些前置知识都搞定，小伙伴们再学后置处理器的时候才不至于磕绊。</p>
<h2 id="1-BeanPostProcessor概述【理解】"><a href="#1-BeanPostProcessor概述【理解】" class="headerlink" title="1. BeanPostProcessor概述【理解】"></a>1. BeanPostProcessor概述【理解】</h2><h3 id="1-1-官方文档"><a href="#1-1-官方文档" class="headerlink" title="1.1 官方文档"></a>1.1 官方文档</h3><p>官方文档的 <code>1.8 Container Extension Points (容器扩展点)</code> 章节中，专门拿出了一个小节讲解 <code>BeanPostProcessor</code> 的使用。由于这段内容比较长，小册将其拆解开解释。</p>
<p><a href="https://link.juejin.cn/?target=https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/core.html%23beans-factory-extension-bpp">docs.spring.io/spring/docs…</a></p>
<h4 id="1-1-1-BPP-是一个容器扩展点"><a href="#1-1-1-BPP-是一个容器扩展点" class="headerlink" title="1.1.1 BPP 是一个容器扩展点"></a>1.1.1 BPP 是一个容器扩展点</h4><blockquote>
<p>The BeanPostProcessor interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom BeanPostProcessor implementations.</p>
<p><code>BeanPostProcessor</code> 接口定义了回调方法，您可以实现这些回调方法以提供自己的（或覆盖容器默认的）实例化逻辑、依赖处理 / 解析逻辑等。</p>
<p>如果您想在 IOC 容器完成实例化、配置、初始化 bean 之后实现一些自定义逻辑，则可以注册一个或多个自定义的 <code>BeanPostProcessor</code> 实现。</p>
</blockquote>
<p>这段话已经解释的非常清楚了，<code>BeanPostProcessor</code> 是一个回调机制的扩展点，它的核心工作点是在 <strong>bean 的初始化前后</strong> 做一些额外的处理（预初始化 bean 的属性值、注入特定的依赖，甚至扩展生成代理对象等）。</p>
<h4 id="1-1-2-BPP-的执行可以指定先后顺序"><a href="#1-1-2-BPP-的执行可以指定先后顺序" class="headerlink" title="1.1.2 BPP 的执行可以指定先后顺序"></a>1.1.2 BPP 的执行可以指定先后顺序</h4><blockquote>
<p>You can configure multiple BeanPostProcessor instances, and you can control the order in which these BeanPostProcessor instances run by setting the order property. You can set this property only if the BeanPostProcessor implements the Ordered interface. If you write your own BeanPostProcessor, you should consider implementing the Ordered interface, too.</p>
<p>您可以配置多个 <code>BeanPostProcessor</code> 实例，并且可以通过设置 order 属性来控制这些 <code>BeanPostProcessor</code> 实例的运行顺序。</p>
<p>仅当 <code>BeanPostProcessor</code> 实现 <code>Ordered</code> 接口时，才可以设置此属性。如果您编写自己的 <code>BeanPostProcessor</code> ，则也应该考虑实现 <code>Ordered</code> 接口。</p>
</blockquote>
<p>与监听器一样，后置处理器也可以指定多个，并且可以通过实现 <code>Ordered</code> 接口，指定后置处理器工作的先后顺序。这看上去似乎不是特别有必要，小册举一个比较简单的例子：</p>
<p>如果有两个后置处理器，分别处理 IOC 容器中的 Service 层实现类，一个负责注入 Dao 层的接口，一个负责统一控制事务，那这个时候就需要先让注入 Dao 接口的后置处理器先工作，让控制事务的后置处理器往后稍稍。</p>
<blockquote>
<p>多提一嘴，控制事务的底层原理是使用了 <strong>AOP</strong> ，生成了<strong>代理对象</strong>，后面 AOP 篇和 Dao 编程篇会讲解事务控制及其原理。</p>
</blockquote>
<h4 id="1-1-3-BPP-在IOC容器间互不影响"><a href="#1-1-3-BPP-在IOC容器间互不影响" class="headerlink" title="1.1.3 BPP 在IOC容器间互不影响"></a>1.1.3 BPP 在IOC容器间互不影响</h4><blockquote>
<p>BeanPostProcessor instances operate on bean (or object) instances. That is, the Spring IoC container instantiates a bean instance and then BeanPostProcessor instances do their work. BeanPostProcessor instances are scoped per-container. This is relevant only if you use container hierarchies. If you define a BeanPostProcessor in one container, it post-processes only the beans in that container. In other words, beans that are defined in one container are not post-processed by a BeanPostProcessor defined in another container, even if both containers are part of the same hierarchy. To change the actual bean definition (that is, the blueprint that defines the bean), you instead need to use a BeanFactoryPostProcessor, as described in Customizing Configuration Metadata with a BeanFactoryPostProcessor.</p>
<p><code>BeanPostProcessor</code> 在 bean（或对象）实例上运行：</p>
<p>也就是说，Spring 的 IOC 容器会实例化出一个 bean 的对象实例，然后 <code>BeanPostProcessor</code> 完成它的工作。</p>
<p><code>BeanPostProcessor</code> 是按容器划分作用域的（仅在使用容器层次结构时，这种设定才有意义）。</p>
<p>如果在一个容器中定义 <code>BeanPostProcessor</code> ，它将仅对该容器中的 bean 进行后置处理。</p>
<p>换句话说，一个容器中定义的 bean 不会由另一个容器中定义的 <code>BeanPostProcessor</code> 进行后处理，即使这两个容器是同一层次结构的一部分。 </p>
<p>要更改实际的 <code>BeanDefinition</code> 信息，您需要使用 <code>BeanFactoryPostProcessor</code> ，如使用 <code>BeanFactoryPostProcessor</code> 自定义配置元数据中的信息。</p>
</blockquote>
<p>从这一长串文档中，提取出几个关键信息：</p>
<ol>
<li><code>BeanPostProcessor</code> 作用于 bean 对象的创建后<strong>；</strong></li>
<li>不同 IOC 容器中的 <code>BeanPostProcessor</code> 不会互相起作用。这些特性，在下面的演示中都会有体现，小伙伴们无需着急。</li>
<li>另外，最后一句话它提到了，如果要处理 <code>BeanDefinition</code> ，要使用 <code>BeanFactoryPostProcessor</code> 这也是上一章我们用的那个陌生的 API 了，它的使用，小册放到下一章来讲解，本章只讲解 <code>BeanPostProcessor</code> 的使用。</li>
</ol>
<h3 id="1-2-javadoc"><a href="#1-2-javadoc" class="headerlink" title="1.2 javadoc"></a>1.2 javadoc</h3><p>翻看 <code>BeanPostProcessor</code> 的 javadoc ，发现它的篇幅也很长，小册只摘取总体描述的部分来阅读。</p>
<blockquote>
<p>Factory hook that allows for custom modification of new bean instances — for example, checking for marker interfaces or wrapping beans with proxies. Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization, while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization.</p>
<p><code>BeanPostProcessor</code> 是一种工厂的回调钩子，它允许对 bean 实例进行自定义修改（例如检查 bean 实现的标记接口，或使用代理包装 bean ）。 </p>
<p>通常，通过<strong>标记接口</strong>等填充 bean 的后置处理器将实现 <code>postProcessBeforeInitialization</code> 方法，而使用<strong>代理包装</strong> bean （FactoryBean）的后置处理器通常将实现 <code>postProcessAfterInitialization</code> 方法。</p>
</blockquote>
<p>JAVADOC 更倾向于教我们怎么用，它也说了，<code>BeanPostProcessor</code> 提供了两个回调时机：<strong>bean 的初始化之前</strong>和 <strong>bean 的初始化之后</strong>，它们分别适合做<strong>填充</strong>和<strong>代理</strong>的工作。</p>
<p>下面咱结合 <code>BeanPostProcessor</code> 的接口设计来看看。</p>
<h3 id="1-3-BPP-的设计"><a href="#1-3-BPP-的设计" class="headerlink" title="1.3 BPP 的设计"></a>1.3 BPP 的设计</h3><p><code>BeanPostProcessor</code> 是一个接口，它只定义了两个方法，也就是上面 javadoc 中提到的两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>SpringFramework 5.x 之前由于最低支持 Java 6 ，此处并没有默认的方法实现。</p>
</blockquote>
<p>这两个方法的文档注释也写的非常完善：</p>
<ol>
<li><code>postProcessBeforeInitialization</code> 方法会在任何 bean 的<strong>初始化回调（例如 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 或自定义 <code>init-method</code> ）之前执行</strong>，</li>
<li>而 <code>postProcessAfterInitialization</code> 方法会在任何 bean 的<strong>初始化回调（例如 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 或自定义 <code>init-method</code> ）之后</strong>。</li>
</ol>
<p>此外，对于 <code>postProcessAfterInitialization</code> 方法，还可以对那些 <code>FactoryBean</code> 创建出来的真实对象进行后置处理，这个我们下面也会有演示。</p>
<p>最后，还是老样子，咱试着总结一下面试中如何概述 <code>BeanPostProcessor</code> 。</p>
<h3 id="1-4-【面试题】面试中如何概述BeanPostProcessor"><a href="#1-4-【面试题】面试中如何概述BeanPostProcessor" class="headerlink" title="1.4 【面试题】面试中如何概述BeanPostProcessor"></a>1.4 【面试题】面试中如何概述BeanPostProcessor</h3><p>以下答案仅供参考，可根据自己的理解调整回答内容：</p>
<ol>
<li><code>BeanPostProcessor</code> 是一个容器的扩展点，它可以在 bean 的生命周期过程中，初始化阶段前后添加自定义处理逻辑，</li>
<li>并且不同 IOC 容器间的 <code>BeanPostProcessor</code> 不会相互干预。</li>
</ol>
<h2 id="2-BeanPostProcessor-的使用【掌握】"><a href="#2-BeanPostProcessor-的使用【掌握】" class="headerlink" title="2. BeanPostProcessor 的使用【掌握】"></a>2. BeanPostProcessor 的使用【掌握】</h2><h3 id="2-1-快速体会使用"><a href="#2-1-快速体会使用" class="headerlink" title="2.1 快速体会使用"></a>2.1 快速体会使用</h3><p>先从最简单的开始，我们不编写任何逻辑，只是注册进去，看看能不能拦截到 bean 的初始化就好。</p>
<blockquote>
<p>本小节源码位置：<code>com.example.spring.postprocessor.a_quickstart</code></p>
</blockquote>
<h4 id="2-1-1-声明几个bean"><a href="#2-1-1-声明几个bean" class="headerlink" title="2.1.1 声明几个bean"></a>2.1.1 声明几个bean</h4><p>最初的案例不需要太花里胡哨的 bean ，就简单整两个吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-1-2-编写后置处理器"><a href="#2-1-2-编写后置处理器" class="headerlink" title="2.1.2 编写后置处理器"></a>2.1.2 编写后置处理器</h4><p>声明一个 <code>AnimalBeanPostProcessor</code> ，让它实现 <code>BeanPostProcessor</code> ，然后啥也不干，只打印语句就好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimalBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;拦截到Bean的初始化之前：&quot;</span> + beanName);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;拦截到Bean的初始化之后：&quot;</span> + beanName);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里注意一个非常重要的设计：它的入参有一个 <strong>bean</strong> ，类型是 <strong><code>Object</code></strong> ，返回值也是 <strong><code>Object</code></strong> ，似乎有暗示返回的 bean 可以任意替换的意思了，是不是这样呢，我们过会可以试一试。</p>
<h4 id="2-1-3-测试运行"><a href="#2-1-3-测试运行" class="headerlink" title="2.1.3 测试运行"></a>2.1.3 测试运行</h4><p>使用注解驱动 IOC 容器，直接扫描包即可。由于我们只是测试后置处理器的功能，所以在初始化 IOC 容器后不需要做任何操作，那就顺手关掉吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanPostProcessorQuickstartApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.example.spring.postprocessor.a_quickstart&quot;</span>);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 <code>main</code> 方法，控制台的打印也说明，cat 和 dog 的初始化被 <code>AnimalBeanPostProcessor</code> 监测到了。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">拦截到<span class="hljs-keyword">Bean的初始化之前：cat</span><br><span class="hljs-keyword">拦截到Bean的初始化之后：cat</span><br><span class="hljs-keyword">拦截到Bean的初始化之前：dog</span><br><span class="hljs-keyword">拦截到Bean的初始化之后：dog</span><br></code></pre></td></tr></table></figure>
<h4 id="2-1-4-修改后置处理器的返回值为任意"><a href="#2-1-4-修改后置处理器的返回值为任意" class="headerlink" title="2.1.4 修改后置处理器的返回值为任意"></a>2.1.4 修改后置处理器的返回值为任意</h4><p>既然 <code>BeanPostProcessor</code> 的两个后置处理方法都可以返回任意 <code>Object</code> ，那我们就搞几个特殊的情况试一试。</p>
<h5 id="2-1-4-1-返回-null-的兜底"><a href="#2-1-4-1-返回-null-的兜底" class="headerlink" title="2.1.4.1 返回 null 的兜底"></a>2.1.4.1 返回 null 的兜底</h5><p>修改 <code>AnimalBeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法，让返回值改为 null ，并在 <code>postProcessAfterInitialization</code> 中打印 bean 的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;拦截到Bean的初始化之前：&quot;</span> + bean);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;拦截到Bean的初始化之后：&quot;</span> + bean);<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，发现 <code>postProcessAfterInitialization</code> 中并没有打印 null ，而是打印了与 <code>postProcessBeforeInitialization</code> 方法中一样的对象：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">拦截到Bean的初始化之前：com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.postprocessor</span><span class="hljs-selector-class">.a_quickstart</span><span class="hljs-selector-class">.bean</span>.Cat@<span class="hljs-number">60285225</span><br>拦截到Bean的初始化之后：com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.postprocessor</span><span class="hljs-selector-class">.a_quickstart</span><span class="hljs-selector-class">.bean</span>.Cat@<span class="hljs-number">60285225</span><br>拦截到Bean的初始化之前：com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.postprocessor</span><span class="hljs-selector-class">.a_quickstart</span><span class="hljs-selector-class">.bean</span>.Dog@<span class="hljs-number">7113</span>b13f<br>拦截到Bean的初始化之后：com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.postprocessor</span><span class="hljs-selector-class">.a_quickstart</span><span class="hljs-selector-class">.bean</span>.Dog@<span class="hljs-number">7113</span>b13f<br></code></pre></td></tr></table></figure>
<p>为什么会是这样呢？我都返回了 null 了，你咋又给我找回来了呢？这里面的原理，可以向上追溯一层方法调用。</p>
<p>借助 IDEA ，发现 SpringFramework 调用 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法，是在 <code>AbstractAutowireCapableBeanFactory</code> 中的，这里面有一个兜底保护：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    Object result = existingBean;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        Object current = processor.postProcessBeforeInitialization(result, beanName);<br>        <span class="hljs-comment">// 兜底保护</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可见框架都帮我们做好了，如果真的返回了 null ，那框架就会认为：<strong>你这是一个误操作，我当你没发生过</strong>，于是就把原来的 bean 又找回来了。</p>
<h5 id="2-1-4-2-返回其它类型的对象"><a href="#2-1-4-2-返回其它类型的对象" class="headerlink" title="2.1.4.2 返回其它类型的对象"></a>2.1.4.2 返回其它类型的对象</h5><p>既然不能返回 null ，那你传 <code>Cat</code> 的时候我换个 <code>Dog</code> 行不？哎，有点意思了哈，我们也来试试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;拦截到Bean的初始化之前：&quot;</span> + bean);<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Cat) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，发现 <code>Cat</code> 真的变成了 <code>Dog</code> ！</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">拦截到Bean的初始化之前：com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.postprocessor</span><span class="hljs-selector-class">.a_quickstart</span><span class="hljs-selector-class">.bean</span>.Cat@<span class="hljs-number">60285225</span><br>拦截到Bean的初始化之后：com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.postprocessor</span><span class="hljs-selector-class">.a_quickstart</span><span class="hljs-selector-class">.bean</span>.Dog@<span class="hljs-number">7113</span>b13f<br></code></pre></td></tr></table></figure>
<p>所以由这个设计，是不是有一点慌呢？万一真返回错了类型，那岂不是出大问题？</p>
<p>但是话又说回来，谁会搞这种操作呢，所以这个担心是多余的，如果真的要限制住 <code>BeanPostProcessor</code> 的类型控制，我们可以在后面尝试搞一个简单的扩展，小伙伴可以到时候一起写一写，体会一下简单的框架再封装。</p>
<h3 id="2-2-修改-bean-的属性"><a href="#2-2-修改-bean-的属性" class="headerlink" title="2.2 修改 bean 的属性"></a>2.2 修改 bean 的属性</h3><p>既然能拿到 bean 的本体了，那获取 、修改属性这种操作也就很简单啦，咱们也来简单的写一下。</p>
<h4 id="2-2-1-修改bean"><a href="#2-2-1-修改bean" class="headerlink" title="2.2.1 修改bean"></a>2.2.1 修改bean</h4><p>给 <code>Cat</code> 添加一个 <code>name</code> 属性，并添加上 getter 、setter 、<code>toString</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&#123;&quot;</span> + <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-2-编写后置处理器"><a href="#2-2-2-编写后置处理器" class="headerlink" title="2.2.2 编写后置处理器"></a>2.2.2 编写后置处理器</h4><p>这次我们在后置处理器中添加对属性的操作，可以在后置处理之前修改一下属性，看修改之后是否生效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CatBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Cat) &#123;<br>            Cat cat = (Cat) bean;<br>            System.out.println(<span class="hljs-string">&quot;初始化之前，cat的name为：&quot;</span> + cat.getName());<br>            cat.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Cat) &#123;<br>            Cat cat = (Cat) bean;<br>            System.out.println(<span class="hljs-string">&quot;初始化之后，cat的name为：&quot;</span> + cat.getName());<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-2-3-测试运行"><a href="#2-2-3-测试运行" class="headerlink" title="2.2.3 测试运行"></a>2.2.3 测试运行</h4><p>测试运行类的写法与上面完全一致，不多解释啦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostProcessorGetPropertyApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.example.spring.postprocessor.b_getproperty&quot;</span>);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 <code>main</code> 方法，控制台打印出修改前后的属性，说明后置处理器确实在 bean 的初始化阶段修改属性。</p>
<h3 id="2-3-执行时机探究"><a href="#2-3-执行时机探究" class="headerlink" title="2.3 执行时机探究"></a>2.3 执行时机探究</h3><p>既然文档和 javadoc 中说了，它分别在 bean 的初始化阶段前后执行，具体又是什么样呢？咱也来探究一下。</p>
<blockquote>
<p>现有的知识中，我们知道的 bean 的生命周期应该是这样的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/919de3d6b79b4bde92902392ea2a0c81~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>本小节源码位置：<code>com.example.spring.postprocessor.c_executetime</code></p>
</blockquote>
<h4 id="2-3-1-声明bean"><a href="#2-3-1-声明bean" class="headerlink" title="2.3.1 声明bean"></a>2.3.1 声明bean</h4><p>像之前研究 bean 的生命周期那样，搞一个三种初始化方法都带的 <code>Dog</code> 出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;initMethod ...&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postConstruct</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;PostConstruct ...&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;InitializingBean ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-3-2-编写后置处理器"><a href="#2-3-2-编写后置处理器" class="headerlink" title="2.3.2 编写后置处理器"></a>2.3.2 编写后置处理器</h4><p>后置处理器里就不搞花里胡哨了，只打印一下执行时机就好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecuteTimeBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>            System.out.println(<span class="hljs-string">&quot;postProcessBeforeInitialization ...&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Dog) &#123;<br>            System.out.println(<span class="hljs-string">&quot;postProcessAfterInitialization ...&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-3-3-编写xml配置文件"><a href="#2-3-3-编写xml配置文件" class="headerlink" title="2.3.3 编写xml配置文件"></a>2.3.3 编写xml配置文件</h4><p>在三种初始化方式都需要的时候，就不能直接声明 <code>@Component</code> 来注册 bean 了，只能通过配置类 / 配置文件的方式来实现。之前在 13 章我们使用了注解配置类的方式注册，这次我们换用 xml 配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.postprocessor.c_executetime.bean.Dog&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.postprocessor.c_executetime.config.ExecuteTimeBeanPostProcessor&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 记得开注解配置，否则@PostConstruct不生效 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="2-3-4-测试运行"><a href="#2-3-4-测试运行" class="headerlink" title="2.3.4 测试运行"></a>2.3.4 测试运行</h4><p>既然用了 xml 配置文件，那就不要再用注解驱动的 IOC 容器啦，要换用 <code>ClassPathXmlApplicationContext</code> 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanPostProcessorExecuteTimeApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<br>                <span class="hljs-string">&quot;postprocessor/processor-executetime.xml&quot;</span>);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>操作是一样的，初始化好就不用管了，直接关闭就好。运行 <code>main</code> 方法，控制台打印如下信息：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span> ...<br><span class="hljs-function"><span class="hljs-title">PostConstruct</span></span> ...<br><span class="hljs-function"><span class="hljs-title">InitializingBean</span></span> ...<br><span class="hljs-function"><span class="hljs-title">initMethod</span></span> ...<br><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span> ...<br></code></pre></td></tr></table></figure>
<p>由此可以总结出 bean 的初始化阶段的全流程：</p>
<ol>
<li><code>BeanPostProcessor#postProcessBeforeInitialization</code> → </li>
<li><code>@PostConstruct</code> →</li>
<li><code>InitializingBean</code> → </li>
<li><code>init-method</code> → </li>
<li><code>BeanPostProcessor#postProcessAfterInitialization</code></li>
</ol>
<p>也就是下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d6cafe27f6441c793a82dbfa5d32308~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<h3 id="2-4-FactoryBean-的影响"><a href="#2-4-FactoryBean-的影响" class="headerlink" title="2.4 FactoryBean 的影响"></a>2.4 FactoryBean 的影响</h3><p>对于那些 <code>FactoryBean</code> ，我们都是只拿它里面创建的真实对象，不要 <code>FactoryBean</code> 本身的，这种情况 <code>BeanPostProcessor</code> 能一起考虑进去吗？我们也来试一下。</p>
<h4 id="2-4-1-声明Bean-FactoryBean"><a href="#2-4-1-声明Bean-FactoryBean" class="headerlink" title="2.4.1 声明Bean + FactoryBean"></a>2.4.1 声明Bean + FactoryBean</h4><p>这次我们搞一个比较符合场景的写法：母鸡下蛋，让 <strong>Hen</strong> 去生产 <strong>Egg</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Egg</span> </span>&#123;<br>    <br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Egg</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Egg <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Egg();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Class&lt;Egg&gt; <span class="hljs-title">getObjectType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Egg.class;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样只把母鸡塞进 IOC 容器，我们就可以得到鸡蛋了。</p>
<h4 id="2-4-2-编写后置处理器"><a href="#2-4-2-编写后置处理器" class="headerlink" title="2.4.2 编写后置处理器"></a>2.4.2 编写后置处理器</h4><p>后置处理器里面不打算搞花里胡哨的操作了，只打印 bean 的初始化拦截触发就好啦：（与 2.1.2 节一致）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;拦截到Bean的初始化之前：&quot;</span> + bean);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;拦截到Bean的初始化之后：&quot;</span> + bean);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-3-测试运行"><a href="#2-4-3-测试运行" class="headerlink" title="2.4.3 测试运行"></a>2.4.3 测试运行</h4><p>与前面一样，只初始化 IOC 容器，不干别的事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryBeanPostProcessorApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.example.spring.postprocessor.d_factorybean&quot;</span>);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 <code>main</code> 方法，发现控制台只打印了 <code>Hen</code> 的拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">拦截到Bean的初始化之前：com.example.spring.postprocessor.d_factorybean.bean.Hen@12cdcf4<br>拦截到Bean的初始化之后：com.example.spring.postprocessor.d_factorybean.bean.Hen@12cdcf4<br></code></pre></td></tr></table></figure>
<p>咦？为什么没有 Egg 的初始化触发呢？**<code>FactoryBean</code> 的生命周期与 IOC 容器一致，而 <code>FactoryBean</code> 生产 bean 的时机是延迟创建的**。</p>
<h4 id="2-4-4-修改测试"><a href="#2-4-4-修改测试" class="headerlink" title="2.4.4 修改测试"></a>2.4.4 修改测试</h4><p>既然没产出来，那我们就手动 get 一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>        <span class="hljs-string">&quot;com.example.spring.postprocessor.d_factorybean&quot;</span>);<br>    Egg egg = ctx.getBean(Egg.class);<br>    System.out.println(egg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，这次控制台打印出来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">拦截到Bean的初始化之前：com.example.spring.postprocessor.d_factorybean.bean.Hen@12cdcf4<br>拦截到Bean的初始化之后：com.example.spring.postprocessor.d_factorybean.bean.Hen@12cdcf4<br>拦截到Bean的初始化之后：com.example.spring.postprocessor.d_factorybean.bean.Egg<span class="hljs-meta">@a74868d</span><br>com.example.spring.postprocessor.d_factorybean.bean.Egg<span class="hljs-meta">@a74868d</span><br></code></pre></td></tr></table></figure>
<p>注意哦，这里<strong>只打印了初始化之后，并没有初始化之前</strong>的动作，这也就回应了上面 <code>BeanPostProcessor</code> 的 javadoc 内容。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                      <a class="hover-with-bg" href="/tags/IOC/">IOC</a>
                    
                      <a class="hover-with-bg" href="/tags/BeanPostProcessor/">BeanPostProcessor</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/18/18-IOC%E7%9A%84BeanPostProcessor%E6%89%A9%E5%B1%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">18-IOC的BeanPostProcessor扩展</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/18/16-IOC%E4%B8%ADBeanDefinitionRegister/">
                        <span class="hidden-mobile">16-IOC中BeanDefinitionRegister</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2022/04/18/17-IOC%E7%9A%84BeanPostProcessor%E4%BB%8B%E7%BB%8D/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
