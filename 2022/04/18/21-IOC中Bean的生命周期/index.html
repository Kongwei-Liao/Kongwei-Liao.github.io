

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>21-IOC中Bean的生命周期 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="21-IOC中Bean的生命周期">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-18 11:35" pubdate>
        2022年4月18日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      34.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      466
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">21-IOC中Bean的生命周期</h1>
            
            <div class="markdown-body">
              <h1 id="一、IOC原理-Bean完整的生命周期概述"><a href="#一、IOC原理-Bean完整的生命周期概述" class="headerlink" title="一、IOC原理-Bean完整的生命周期概述"></a>一、IOC原理-Bean完整的生命周期概述</h1><p>进入可能难度最高的部分了，IOC 的原理部分，我们主要讲解一个 bean 在 SpringFramework 中的完整生命周期。</p>
<p>通过对 bean 的完整生命周期的研究，希望小伙伴能够对 Spring 中的重要组件、设计机制等，都有一个更加清晰深刻的认识。</p>
<h2 id="1-如何全面理解bean的生命周期"><a href="#1-如何全面理解bean的生命周期" class="headerlink" title="1. 如何全面理解bean的生命周期"></a>1. 如何全面理解bean的生命周期</h2><p>在 IOC 基础，我们有讲过 bean 的生命周期大概是这样的：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f3fa4d3f03b44f2949202911b3386f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>如果这只是一个普通的 java 的对象，那这个图示完全成立、合理。不过在 SpringFramework 中，这个流程就不够完整了，我们来回忆一下前面学习的内容。</p>
<h3 id="1-1-bean-的创建之前先注册的-BeanDefination"><a href="#1-1-bean-的创建之前先注册的-BeanDefination" class="headerlink" title="1.1 bean 的创建之前先注册的 BeanDefination"></a>1.1 bean 的创建之前先注册的 BeanDefination</h3><p>在 bean 的创建之前，是以 <code>BeanDefinition</code> 的方式被描述和注册在 <code>BeanFactory</code> 的，准确的说是注册在 <code>BeanDefinitionRegistry</code> 中）。</p>
<p>这个时候虽然 bean 还没有被创建，但是 <code>BeanFactory</code> 中已经存有 bean 对应的 <code>BeanDefinition</code> 了，所以在 bean 的实例化之前，还应该有 <code>BeanDefinition</code> 阶段。</p>
<h3 id="1-2-BeanDefinition来自配置文件或配置类"><a href="#1-2-BeanDefinition来自配置文件或配置类" class="headerlink" title="1.2 BeanDefinition来自配置文件或配置类"></a>1.2 BeanDefinition来自配置文件或配置类</h3><p><code>BeanDefinition</code> 也不是凭空出现的，要么是解析了配置文件，要么是解析了配置类，要么有人编程式的注入了 <code>BeanDefinition</code> ，所以如果纵观整个 bean 的生命周期，在 <code>BeanDefinition</code> 阶段之前，还应该有声明 <code>BeanDefinition</code> 数据源的加载和解析阶段。</p>
<h3 id="1-3-小册讲解的生命周期阶段"><a href="#1-3-小册讲解的生命周期阶段" class="headerlink" title="1.3 小册讲解的生命周期阶段"></a>1.3 小册讲解的生命周期阶段</h3><p>不能再往上捋了，再往上就该 IOC 容器的生命周期了，咱到此打住。结合前面的内容，以及上面的梳理，这一章的 IOC 原理探究，就以 <strong>【单实例 bean 】</strong> 的全生命周期为主线讨论，具体包含以下部分：</p>
<ul>
<li>BeanDefinition 注册部分<ul>
<li><code>BeanDefinition</code> 的解析</li>
<li><code>BeanDefinition</code> 的注册</li>
</ul>
</li>
<li>bean 实例部分<ul>
<li>bean 的实例化</li>
<li>bean 的属性赋值 + 依赖注入</li>
<li>bean 的初始化流程</li>
<li>bean 的启动与停止</li>
<li>bean 的销毁</li>
</ul>
</li>
</ul>
<blockquote>
<p>有关整体 IOC 容器的生命周期内部原理，在 SpringBoot 小册中已经有讲过啦，小伙伴们可以参考那里面的内容 <a target="_blank" rel="noopener" href="https://juejin.im/book/6844733814560784397">戳此跳转</a></p>
</blockquote>
<h2 id="2-BeanDefinition-注册阶段的主要工作"><a href="#2-BeanDefinition-注册阶段的主要工作" class="headerlink" title="2. BeanDefinition 注册阶段的主要工作"></a>2. BeanDefinition 注册阶段的主要工作</h2><h3 id="2-1-BeanDefinition的解析来源"><a href="#2-1-BeanDefinition的解析来源" class="headerlink" title="2.1 BeanDefinition的解析来源"></a>2.1 BeanDefinition的解析来源</h3><p>bean 的实例化需要先有 <code>BeanDefinition</code> 的信息，所以 <code>BeanDefinition</code> 都是怎么来的呢？这里我们来理一下。</p>
<ul>
<li><p>配置类声明式注入 <code>BeanDefinition</code></p>
<ul>
<li><p><code>@Configuration</code> + <code>@Bean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickstartConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><code>@Component</code> + <code>@ComponentScan</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.annotation.c_scan&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentScanConfiguration</span></span><br></code></pre></td></tr></table></figure></li>
<li><p><code>@Import</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Boss.class, BartenderConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTavern<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置文件声明式注入 <code>BeanDefinition</code></p>
<ul>
<li><p><code>&lt;bean&gt;</code> 标签声明</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.basic_dl.a_quickstart_byname.bean.Person&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编程式注入 <code>BeanDefinition</code></p>
<ul>
<li><p><code>ImportBeanDefinitionRegistrar</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaiterRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;waiter&quot;</span>, <span class="hljs-keyword">new</span> RootBeanDefinition(Waiter.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>手动构造 <code>BeanDefinition</code> 注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>    <br>BeanDefinition personDefinition = BeanDefinitionBuilder.rootBeanDefinition(Person.class)<br>        .addPropertyValue(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>).getBeanDefinition();<br>ctx.registerBeanDefinition(<span class="hljs-string">&quot;person&quot;</span>, personDefinition);<br>    <br>ctx.refresh();<br></code></pre></td></tr></table></figure></li>
<li><p>借助 <code>BeanDefinitionRegistryPostProcessor</code> 注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    registry.registerBeanDefinition(<span class="hljs-string">&quot;animalNameSetterPostProcessor&quot;</span>, <br>            <span class="hljs-keyword">new</span> RootBeanDefinition(AnimalNameSetterPostProcessor.class));<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h3 id="2-2-BeanDefinition的后置处理"><a href="#2-2-BeanDefinition的后置处理" class="headerlink" title="2.2 BeanDefinition的后置处理"></a>2.2 BeanDefinition的后置处理</h3><p> <code>BeanDefinition</code> 都构造好之后，是不会立即注册到 <code>BeanFactory</code> 的，这中间有一步执行 <code>BeanDefinitionRegistryPostProcessor</code> 的动作。</p>
<p>等这些 <code>BeanDefinitionRegistryPostProcessor</code> 都执行完 <code>postProcessBeanDefinitionRegistry</code> 方法后，<code>BeanDefinition</code> 才会注册到 <code>BeanFactory</code> 。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f830cec313a947418ca6c3d06427a6db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<hr>
<p>这个动作之后，下一步则是执行 <code>BeanFactoryPostProcessor</code> 的 <code>postProcessBeanFactory</code> 方法了，这个阶段可以给 <code>BeanDefinition</code> 修改配置信息，添加注入的依赖项，给属性赋值等操作。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4daac20328c04451ba637228d0752b81~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>这一步执行完毕后，<code>BeanDefinition</code> 就不会再动了，<code>BeanDefinition</code> 的阶段也就算结束了。</p>
<h2 id="3-Bean-实例阶段的内容"><a href="#3-Bean-实例阶段的内容" class="headerlink" title="3. Bean 实例阶段的内容"></a>3. Bean 实例阶段的内容</h2><p>从 <code>AbstractApplicationContext</code> 的 <code>refresh</code> 方法中找到执行步骤，其中第 11 步 <code>finishBeanFactoryInitialization</code> 方法就是初始化 bean 实例的动作了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        prepareRefresh();<br>        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>        prepareBeanFactory(beanFactory);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            postProcessBeanFactory(beanFactory);<br>            invokeBeanFactoryPostProcessors(beanFactory);<br>            registerBeanPostProcessors(beanFactory);<br>            initMessageSource();<br>            initApplicationEventMulticaster();<br>            onRefresh();<br>            registerListeners();<br>            <span class="hljs-comment">// 11. 初始化剩余的单实例bean</span><br>            finishBeanFactoryInitialization(beanFactory);<br>            finishRefresh();<br>        &#125;<br>        <span class="hljs-comment">// catch ......</span><br>        <span class="hljs-keyword">finally</span> &#123;<br>            resetCommonCaches();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这一步的动作非常多，它会将<strong>所有还没有实例化的、非延迟加载的单实例 bean</strong> 都创建出来。而创建一个 bean 的流程也是非常多且复杂，总体可以分为以下几个步骤。</p>
<h3 id="3-1-BeanDefinition-的合并"><a href="#3-1-BeanDefinition-的合并" class="headerlink" title="3.1 BeanDefinition 的合并"></a>3.1 BeanDefinition 的合并</h3><p>对，bean 的实例化阶段，第一步并不是直接创建对象哦，还记得之前的 <code>BeanDefinition</code> 合并那个特性吗？</p>
<p>如果一个 <code>&lt;bean&gt;</code> 有继承另外一个 <code>&lt;bean&gt;</code> 定义，则会形成父子定义。这种情况下，创建 bean 的时候就需要读取父 bean 的定义，合并为<strong>最终</strong>的 <code>**RootBeanDefinition**</code> 。</p>
<h3 id="3-2-Bean-的实例化"><a href="#3-2-Bean-的实例化" class="headerlink" title="3.2 Bean 的实例化"></a>3.2 Bean 的实例化</h3><p>合并完 <code>BeanDefinition</code> ，下一步才是真正的实例化 bean ，不过这里要注意下面一系列问题：</p>
<ol>
<li>如果 bean 是一个 <code>FactoryBean</code> ，这里该如何处理呢？</li>
<li>是只创建 <code>FactoryBean</code> 本身？</li>
<li>还是连 <code>FactoryBean</code> 创建的真实对象一起创建？</li>
</ol>
<p>这个问题此处先不作回答，小伙伴们带着问题进入源码中会更有助于思考哦。</p>
<p>除了考虑 <code>FactoryBean</code> 之外，还有一个要考虑的因素是缓存问题。咱在一开始学 IOC 的由来时，就知道 <code>BeanFactory</code> 中可以缓存单实例 bean ，那么在 Spring 中是如何处理单实例 bean 在实例化后的缓存呢？这个问题也应该考虑在内吧。</p>
<h3 id="3-3-属性赋值-依赖注入"><a href="#3-3-属性赋值-依赖注入" class="headerlink" title="3.3 属性赋值 + 依赖注入"></a>3.3 属性赋值 + 依赖注入</h3><p>bean 对象实例化完成后，里面所有的成员都是空的，接下来的步骤就是属性赋值和依赖注入了。由于这部分逻辑属于 bean 实例已经创建，所以小册在这里将该步骤划到下面的 bean 初始化部分。</p>
<p>在这个环节，最重要的是如何处理 <code>&lt;bean&gt;</code> 中的 <code>&lt;property&gt;</code> 标签、bean 中的 <code>@Value</code> 、<code>@Autowired</code> 等自动注入的注解。小伙伴们不妨先自行思考一下，以目前已经学过的所有知识，有没有一些机制，能在 bean 的初始化阶段之前完成这部分工作的？</p>
<p><code>BeanPostProcessor</code> 的扩展 <code>InstantiationAwareBeanPostProcessor</code> 可以在 bean 的实例化之后、初始化之前执行 <code>postProcessAfterInstantiation</code> 方法，以及 <code>postProcessProperties</code> ( <code>postProcessPropertyValues</code> ) 方法完成属性赋值！</p>
<p>所以我们就可以断定，这个环节一定是 <code>InstantiationAwareBeanPostProcessor</code> 在工作咯。</p>
<h3 id="3-4-Bean-的初始化"><a href="#3-4-Bean-的初始化" class="headerlink" title="3.4 Bean 的初始化"></a>3.4 Bean 的初始化</h3><p>这个阶段相信小伙伴们都非常熟悉了，这才是前面章章节讲的 bean 的生命周期，这部分咱就不多啰嗦了吧，后面直接翻源码看看底层原理就完事了。</p>
<h3 id="3-5-Bean-的-Lifecycle-start"><a href="#3-5-Bean-的-Lifecycle-start" class="headerlink" title="3.5 Bean 的 Lifecycle.start()"></a>3.5 Bean 的 Lifecycle.start()</h3><p>之前在 bean 的生命周期中没有提到一个接口：<code>Lifecycle</code> ，之所以没有在那儿提，是考虑到 <code>Lifecycle</code> 的执行是依照 <code>ApplicationContext</code> 的生命周期而来，两者是相互关联的，所以小册把 <code>Lifecycle</code> 接口的讲解安排到了这里。</p>
<p>先简单说说 <code>Lifecycle</code> 的触发时机吧。往上翻一翻 <code>refresh</code> 方法的 try 块最后一行：<code>finishRefresh</code> ，它在里面会找出所有实现了 <code>Lifecycle</code> 接口的 bean ，并调用它们的 <code>start</code> 方法（所以是不是回想起了第 16 章的 <code>ContextStartedEvent</code> 事件）。</p>
<p>注意此时所有实现了 <code>Lifecycle</code> 的非延迟加载的单实例 bean 都<strong>已经加载完成</strong>了，是可以正常调用 <code>start</code> 方法的。</p>
<blockquote>
<p>一般实现 <code>Lifecycle</code> 的 <code>start</code> 方法多用于<strong>建立连接</strong>、<strong>加载资源</strong>等等操作，以备程序的运行期使用。</p>
<p>so ，这个阶段 <code>ApplicationContext</code> 就会完成所有 <code>Lifecycle</code> 类型的 bean 的 <code>start</code> 方法调用，对于一个 bean 的生命周期而言，就已经到了正常存活期了。</p>
</blockquote>
<hr>
<p>说完了 bean 的加载和初始化，当 <code>ApplicationContext</code> 关闭时，这些 bean 也是需要销毁的，而这个销毁流程我们也要来研究一下。</p>
<h2 id="4-Bean-销毁阶段的内容"><a href="#4-Bean-销毁阶段的内容" class="headerlink" title="4. Bean 销毁阶段的内容"></a>4. Bean 销毁阶段的内容</h2><p>相比较于 bean 的创建和初始化，销毁部分就变得比较简单了，我们可以先对整个 <code>ApplicationContext</code> 的关闭有一个整体的了解。</p>
<p>关闭 <code>ApplicationContext</code> 会顺序执行以下几步：</p>
<ol>
<li>广播容器关闭事件<ul>
<li>第 16 章学过的 <code>ContextClosedEvent</code> 事件</li>
</ul>
</li>
<li>通知所有实现了 <code>Lifecycle</code> 的 bean 回调 <code>close</code> 方法</li>
<li>销毁所有 bean</li>
<li>关闭 BeanFactory</li>
<li>标记本身为不可用，</li>
</ol>
<p>而这里面有关 bean 的销毁，就只包含 2 、3 两步，下面分述。</p>
<h3 id="4-1-bean的Lifecycle-close"><a href="#4-1-bean的Lifecycle-close" class="headerlink" title="4.1 bean的Lifecycle.close()"></a>4.1 bean的Lifecycle.close()</h3><p>与上面的 bean 启动一致，如果一个 bean 实现了 <code>Lifecycle</code> 接口，此处会回调 bean 的 <code>close</code> 方法。由于此时 bean 的销毁回调方法还没有执行，所以在销毁阶段，<code>Lifecycle</code> 的执行时机是最靠前的。</p>
<p>一般实现 <code>Lifecycle</code> 的 <code>close</code> 方法多用来关闭连接、释放资源等操作，因为程序终止了，这些资源也就没必要持有了。</p>
<h3 id="4-2-Bean的销毁回调"><a href="#4-2-Bean的销毁回调" class="headerlink" title="4.2 Bean的销毁回调"></a>4.2 Bean的销毁回调</h3><p>bean “停止” 后，接下来就是对应于 bean 初始化阶段的三种生命周期回调的销毁部分了。不过这里面有一个不同点：<code>BeanPostProcessor</code> 的回调包含 bean 的初始化之前和初始化之后，但 <code>DestructionAwareBeanPostProcessor</code> 只包含 bean 销毁回调之前的动作，没有之后。</p>
<hr>
<h2 id="5-Debug-测试代码编写"><a href="#5-Debug-测试代码编写" class="headerlink" title="5. Debug 测试代码编写"></a>5. Debug 测试代码编写</h2><p>下面，我们把这次 bean 完整生命周期研究的测试代码先编写出来，后面的 4 章我们全部使用该代码来测试和研究 bean 的完整生命周期。</p>
<h3 id="5-1-声明bean"><a href="#5-1-声明bean" class="headerlink" title="5.1 声明bean"></a>5.1 声明bean</h3><p>测试的 bean 中，我们选择前面反复多次学习的 <code>Person</code> 与 <code>Cat</code> 为测试模型，其中给 <code>Person</code> 实现全生命周期的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span>, <span class="hljs-title">Lifecycle</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> state = <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person constructor run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postConstruct</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person @PostConstruct run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person InitializingBean run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person initMethod run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preDestory</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person @PreDestroy run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person DisposableBean run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person destroyMethod run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person 睡醒起床了 ......&quot;</span>);<br>        <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person 睡觉去了 ......&quot;</span>);<br>        <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <br>    <span class="hljs-comment">// getter setter toString</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>给 Cat 使用 <code>@Component</code> 标注，并自动注入 <code>Person</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Value(&quot;miaomiao&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Person master;<br>    <br>    <span class="hljs-comment">// getter setter toString</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-2-编写后置处理器"><a href="#5-2-编写后置处理器" class="headerlink" title="5.2 编写后置处理器"></a>5.2 编写后置处理器</h3><p>为了能体现出后置处理器的回调，需要编写一个 <code>BeanPostProcessor</code> ，一个 <code>DestructionAwareBeanPostProcessor</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleNameReadPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Person) &#123;<br>            Person person = (Person) bean;<br>            System.out.println(<span class="hljs-string">&quot;LifecycleNameReadPostProcessor ------&gt; &quot;</span> + person.getName());<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br><br>-----------------------------------------------------------------------------------------------------------<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleDestructionPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DestructionAwareBeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeDestruction</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Cat) &#123;<br>            Cat cat = (Cat) bean;<br>            System.out.println(cat.getName() + <span class="hljs-string">&quot;被放走了 ......&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-3-编写xml配置文件"><a href="#5-3-编写xml配置文件" class="headerlink" title="5.3 编写xml配置文件"></a>5.3 编写xml配置文件</h3><p>Debug 的测试代码，小册打算分 xml 和注解两种形式都讲解，所以咱来分别编写 xml 配置文件，以及注解配置类咯。</p>
<p>xml 配置文件中，需要注册 person 、cat 、两个后置处理器，以及开启注解驱动（不然 JSR 250 规范的注解不会生效）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.lifecycle.e_source.bean.Person&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.lifecycle.e_source.bean.Cat&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mimi&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;master&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;person&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.lifecycle.e_source.config.LifecycleNameReadPostProcessor&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.lifecycle.e_source.config.LifecycleDestructionPostProcessor&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="5-4-编写注解配置类"><a href="#5-4-编写注解配置类" class="headerlink" title="5.4 编写注解配置类"></a>5.4 编写注解配置类</h3><p>注解配置类中，不需要注册后置处理器，只需要注册 Person ，以及组件扫描即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.lifecycle.e_source.bean&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleSourceConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean(initMethod = &quot;initMethod&quot;, destroyMethod = &quot;destroyMethod&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span> </span>&#123;<br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        person.setName(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        <span class="hljs-keyword">return</span> person;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-5-编写xml测试启动类"><a href="#5-5-编写xml测试启动类" class="headerlink" title="5.5 编写xml测试启动类"></a>5.5 编写xml测试启动类</h3><p>启动类中，只需要加载 xml 配置文件即可。不过为了能直观的在运行结果中体现出每个环节的动作，可以在测试启动类中适当的位置添加控制台打印，就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleSourceXmlApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext();<br>        ctx.setConfigLocation(<span class="hljs-string">&quot;lifecycle/bean-source.xml&quot;</span>);<br>    <br>        System.out.println(<span class="hljs-string">&quot;================准备刷新IOC容器==================&quot;</span>);<br>    <br>        ctx.refresh();<br>    <br>        System.out.println(<span class="hljs-string">&quot;================IOC容器刷新完毕==================&quot;</span>);<br>    <br>        ctx.start();<br>    <br>        System.out.println(<span class="hljs-string">&quot;================IOC容器启动完成==================&quot;</span>);<br>    <br>        Person person = ctx.getBean(Person.class);<br>        System.out.println(person);<br>        Cat cat = ctx.getBean(Cat.class);<br>        System.out.println(cat);<br>    <br>        System.out.println(<span class="hljs-string">&quot;================准备停止IOC容器==================&quot;</span>);<br>    <br>        ctx.stop();<br>    <br>        System.out.println(<span class="hljs-string">&quot;================IOC容器停止成功==================&quot;</span>);<br>    <br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-6-编写注解测试启动类"><a href="#5-6-编写注解测试启动类" class="headerlink" title="5.6 编写注解测试启动类"></a>5.6 编写注解测试启动类</h3><p>注解测试启动类中，下面的部分与 xml 方式的一模一样，唯一不同的是声明的 ApplicationContext 类型不同，以及需要把配置类、后置处理器注册到 IOC 容器中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleSourceAnnotationApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>        ctx.register(LifecycleSourceConfiguration.class);<br>        ctx.register(LifecycleNameReadPostProcessor.class);<br>        ctx.register(LifecycleDestructionPostProcessor.class);<br>    <br>        <span class="hljs-comment">// 与上面一致，不再重复贴出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样，所有的测试代码就写好了，下一章我们就开始测试和研究。</p>
<p>【 OK 到此为止，我们对 bean 的完整生命周期有一个完整的认识了，接下来的 4 章，我们会深入源码中，来研究 bean 是如何从配置类 / 配置文件，封装为 <code>BeanDefinition</code> ，再到 bean 实例，最后销毁的全过程。】</p>
<h1 id="二、Bean的生命周期-BeanDefinition阶段"><a href="#二、Bean的生命周期-BeanDefinition阶段" class="headerlink" title="二、Bean的生命周期-BeanDefinition阶段"></a>二、Bean的生命周期-BeanDefinition阶段</h1><p>好我们开始来研究 bean 完整生命周期的 <code>BeanDefinition</code> 阶段了，这一阶段主要发生了以下几件事情：</p>
<ul>
<li>加载配置文件、配置类</li>
<li>解析配置文件、配置类并封装为 <code>BeanDefinition</code></li>
<li>编程式注入额外的 <code>BeanDefinition</code></li>
<li><code>BeanDefinition</code> 的后置处理</li>
</ul>
<p>下面我们深入源码。由于小伙伴初次接触源码可能会晕头转向，小册会预先告诉小伙伴接下来的原理会涉及哪些类的哪些地方，小伙伴们可以提前预备好，不至于 “惊慌失措” 。</p>
<h2 id="1-加载解析xml配置文件"><a href="#1-加载解析xml配置文件" class="headerlink" title="1. 加载解析xml配置文件"></a>1. 加载解析xml配置文件</h2><p>来，跟着小册来到 <code>LifecycleSourceXmlApplication</code> 的测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext();<br>    ctx.setConfigLocation(<span class="hljs-string">&quot;lifecycle/bean-source.xml&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="1-1-保存配置文件路径"><a href="#1-1-保存配置文件路径" class="headerlink" title="1.1 保存配置文件路径"></a>1.1 保存配置文件路径</h3><p>这里 xml 配置文件的加载会使用 <code>ClassPathXmlApplicationContext</code> 的 <code>setConfigLocation</code> 方法，点进去可以发现它只是在 <code>AbstractRefreshableConfigApplicationContext</code> 中，给 <code>configLocations</code> 设置了配置文件的路径存放而已。</p>
<p>通过源码，也能看出来最终是将传入的路径切分，并顺序存入 <code>configLocations</code> 中：（关键注释已标注在源码中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个配置文件路径</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigLocation</span><span class="hljs-params">(String location)</span> </span>&#123;<br>    <span class="hljs-comment">// 切分配置文件路径</span><br>    setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));<br>&#125;<br><br><span class="hljs-comment">// 多个配置文件路径</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigLocations</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String... locations)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (locations != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// assert ......</span><br>        <span class="hljs-keyword">this</span>.configLocations = <span class="hljs-keyword">new</span> String[locations.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; locations.length; i++) &#123;<br>            <span class="hljs-comment">// 存入ApplicationContext中</span><br>            <span class="hljs-keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.configLocations = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Debug 时，也能发现，它最终把测试代码中设置的 xml 配置文件的路径都保存了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/581e666880154a87bf94e678d6c73f8c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<h3 id="1-2-加载配置文件并解析"><a href="#1-2-加载配置文件并解析" class="headerlink" title="1.2 加载配置文件并解析"></a>1.2 加载配置文件并解析</h3><p>当执行 <code>ApplicationContext</code> 的 <code>refresh</code> 方法后，会开始刷新（初始化）IOC 容器，这里面有 13 个步骤，前面已经看过不少次了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        prepareRefresh();<br>        <span class="hljs-comment">// 2. 初始化BeanFactory</span><br>        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>        prepareBeanFactory(beanFactory);<br>        <br>        <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里面我把第 2 步 <code>obtainFreshBeanFactory</code> 方法标注出来了，加载配置文件并解析的动作就在这里面，我们可以来研究一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title">obtainFreshBeanFactory</span><span class="hljs-params">()</span> </span>&#123;<br>    refreshBeanFactory();<br>    <span class="hljs-keyword">return</span> getBeanFactory();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法只有两个动作：刷新 <code>BeanFactory</code> ，然后获取它。</p>
<p>毫无疑问，刷新的动作中包含配置文件的加载和解析，我们继续往里看。</p>
<p><code>refreshBeanFactory</code> 方法是 <code>AbstractApplicationContext</code> 定义的抽象方法，很明显这里又是<strong>模板方法模式</strong>的体现了。</p>
<p>由于当前我们正在研究的是基于 xml 配置文件的 <code>ApplicationContext</code> ，所以要进入 <code>AbstractRefreshableApplicationContext</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-comment">// 存在BeanFactory则先销毁</span><br>    <span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>        destroyBeans();<br>        closeBeanFactory();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建BeanFactory</span><br>        DefaultListableBeanFactory beanFactory = createBeanFactory();<br>        beanFactory.setSerializationId(getId());<br>        customizeBeanFactory(beanFactory);<br>        <span class="hljs-comment">// 【1.3】加载配置文件</span><br>        loadBeanDefinitions(beanFactory);<br>        <span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>    &#125; <span class="hljs-comment">// catch ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>看一下源码的大体流程，<strong>基于 xml 配置文件的 <code>ApplicationContext</code> 可以反复刷新加载 IOC 容器</strong>，所以此处有已经存在的判断：</p>
<blockquote>
<p>如果当前 <code>ApplicationContext</code> 中组合的 <code>BeanFactory</code> 已经存在，则销毁原来的 <code>BeanFactory</code> ，并重新创建。</p>
</blockquote>
<p>关注重点，这里面加载配置文件的动作是 <code>loadBeanDefinitions</code> 。这个方法相当复杂且困难，小册会选取最重要的部分来解析。</p>
<h3 id="1-3-loadBeanDefinitions"><a href="#1-3-loadBeanDefinitions" class="headerlink" title="1.3 loadBeanDefinitions"></a>1.3 loadBeanDefinitions</h3><p>点进去，发现 <code>loadBeanDefinitions</code> 又是一个抽象方法，在 <code>AbstractXmlApplicationContext</code> 中可以找到对应的实现：（关键注释已标注在源码中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;<br>    <span class="hljs-comment">// xml配置文件由XmlBeanDefinitionReader解析</span><br>    XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);<br><br>    <span class="hljs-comment">// 配置上下文环境、资源加载器等</span><br>    beanDefinitionReader.setEnvironment(<span class="hljs-keyword">this</span>.getEnvironment());<br>    beanDefinitionReader.setResourceLoader(<span class="hljs-keyword">this</span>);<br>    beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> ResourceEntityResolver(<span class="hljs-keyword">this</span>));<br><br>    initBeanDefinitionReader(beanDefinitionReader);<br>    <span class="hljs-comment">// 使用xml解析器 解析xml配置文件</span><br>    loadBeanDefinitions(beanDefinitionReader);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意这里面，它创建了一个 <code>XmlBeanDefinitionReader</code> ，小伙伴们一定不陌生吧，它在第 14 章就出现过，我们说它就是加载和解析 xml 配置文件的核心 API 。直接看最底下吧，它把这个 <code>XmlBeanDefinitionReader</code> 作为参数传入重载的 <code>loadBeanDefinitions</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;<br>    Resource[] configResources = getConfigResources();<br>    <span class="hljs-keyword">if</span> (configResources != <span class="hljs-keyword">null</span>) &#123;<br>        reader.loadBeanDefinitions(configResources);<br>    &#125;<br>    String[] configLocations = getConfigLocations();<br>    <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 【1.4】加载配置文件资源路径的xml配置文件</span><br>        reader.loadBeanDefinitions(configLocations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意这段逻辑分两部分，一个是处理已经加载好的现成的 <code>Resource</code> ，一个是处理指定好的配置文件资源路径。由于测试代码中并没有直接指定 Resource ，故此处主要研究第 8 行的 <code>loadBeanDefinitions(configLocations)</code> 。</p>
<p>Debug 至此处，同样也能发现 <code>reader</code> 与 <code>configLocations</code> 都准备好了：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5db01da6650f4a3694951d5e4e9f7b21~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<h3 id="1-4-XmlBeanDefinitionReader加载配置文件"><a href="#1-4-XmlBeanDefinitionReader加载配置文件" class="headerlink" title="1.4 XmlBeanDefinitionReader加载配置文件"></a>1.4 XmlBeanDefinitionReader加载配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    <span class="hljs-comment">// assert ......</span><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (String location : locations) &#123;<br>        count += loadBeanDefinitions(location);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>点进来，发现它传入的是一组配置文件，那自然就会循环一个个的加载咯。循环自然不是重点，我们进入内部的 <code>loadBeanDefinitions(location)</code> 中：（源码篇幅略长，不过逻辑比较简单）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    <span class="hljs-keyword">return</span> loadBeanDefinitions(location, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location, <span class="hljs-meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    ResourceLoader resourceLoader = getResourceLoader();<br>    <span class="hljs-keyword">if</span> (resourceLoader == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// throw ex ......</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (resourceLoader <span class="hljs-keyword">instanceof</span> ResourcePatternResolver) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 根据传入的路径规则，匹配所有符合的xml配置文件</span><br>            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>            <span class="hljs-keyword">int</span> count = loadBeanDefinitions(resources);<br>            <span class="hljs-keyword">if</span> (actualResources != <span class="hljs-keyword">null</span>) &#123;<br>                Collections.addAll(actualResources, resources);<br>            &#125;<br>            <span class="hljs-comment">// logger ......</span><br>            <span class="hljs-keyword">return</span> count;<br>        &#125; <span class="hljs-comment">// catch ......</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 每次只能解析一个xml配置文件</span><br>        Resource resource = resourceLoader.getResource(location);<br>        <span class="hljs-comment">// 【解析】</span><br>        <span class="hljs-keyword">int</span> count = loadBeanDefinitions(resource);<br>        <span class="hljs-keyword">if</span> (actualResources != <span class="hljs-keyword">null</span>) &#123;<br>            actualResources.add(resource);<br>        &#125;<br>        <span class="hljs-comment">// logger ......</span><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现，这里的核心逻辑只有两个动作：</p>
<ol>
<li><strong>根据传入的资源路径，获取 xml 配置文件</strong>；</li>
<li><strong>解析 xml 配置文件</strong>。</li>
</ol>
<p>其余的动作都是保证程序正常执行的代码，咱就不研究了，还是核心关注 <code>loadBeanDefinitions</code> 的方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> EncodedResource(resource));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这一步给原有的 xml 配置文件的 <code>Resource</code> 封装包装了一层编码而已，没啥需要关注的，继续往里看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    <span class="hljs-comment">// assert logger ......</span><br>    Set&lt;EncodedResource&gt; currentResources = <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.get();<br>    <span class="hljs-keyword">if</span> (!currentResources.add(encodedResource)) &#123;<br>        <span class="hljs-comment">// throw ex ......</span><br>    &#125;<br><br>    <span class="hljs-keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;<br>        InputSource inputSource = <span class="hljs-keyword">new</span> InputSource(inputStream);<br>        <span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-keyword">null</span>) &#123;<br>            inputSource.setEncoding(encodedResource.getEncoding());<br>        &#125;<br>        <span class="hljs-comment">// 【真正干活的】</span><br>        <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>    &#125; <span class="hljs-comment">// catch ......</span><br>    <span class="hljs-keyword">finally</span> &#123;<br>        currentResources.remove(encodedResource);<br>        <span class="hljs-keyword">if</span> (currentResources.isEmpty()) &#123;<br>            <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法逻辑看上去很复杂，但是抛开细枝末节，最核心的动作还是那个以 <strong>do</strong> 开头的 <code>doLoadBeanDefinitions</code> ，它才是真正干活的，所以看它就完事了。</p>
<h3 id="1-5-doLoadBeanDefinitions-读取配置文件"><a href="#1-5-doLoadBeanDefinitions-读取配置文件" class="headerlink" title="1.5 doLoadBeanDefinitions - 读取配置文件"></a>1.5 doLoadBeanDefinitions - 读取配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Document doc = doLoadDocument(inputSource, resource);<br>        <span class="hljs-keyword">int</span> count = registerBeanDefinitions(doc, resource);<br>        <span class="hljs-comment">// logger ......</span><br>        <span class="hljs-keyword">return</span> count;<br>    &#125; <span class="hljs-comment">// catch ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>一上来又是一个 <strong>do</strong> 开头的方法，得了，我就看你。。。诶等一下，<code>doLoadDocument</code> 这很明显是解析文档吧，这我们也没必要看吧（也看不懂），重点是下面的那句 <code>registerBeanDefinitions</code> ，这才是我们最关心的吧！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br>    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<br>    <span class="hljs-keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();<br>    <span class="hljs-comment">// 【解析】</span><br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，此处构造了一个 <code>DefaultBeanDefinitionDocumentReader</code> ，然后调用它的 <code>registerBeanDefinitions</code> 方法（不再是 <code>XmlBeanDefinitionReader</code> 的方法了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.readerContext = readerContext;<br>    doRegisterBeanDefinitions(doc.getDocumentElement());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>又又又是这个套路！<strong>xxx 方法最终调 doXxx 方法干活</strong>，得了那咱继续往里走：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> </span>&#123;<br>    BeanDefinitionParserDelegate parent = <span class="hljs-keyword">this</span>.delegate;<br>    <span class="hljs-keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;<br>        <span class="hljs-comment">// 取&lt;beans&gt;上的profile属性</span><br>        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;<br>            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(<br>                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>            <span class="hljs-keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;<br>                <span class="hljs-comment">// logger ......</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    preProcessXml(root);<br>    <span class="hljs-comment">// 【解析xml】</span><br>    parseBeanDefinitions(root, <span class="hljs-keyword">this</span>.delegate);<br>    postProcessXml(root);<br><br>    <span class="hljs-keyword">this</span>.delegate = parent;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意看这段源码，上面它会先把 xml 配置文件中声明的 <strong>profile</strong> 取出来，并根据 <code>Environment</code> 中配置好的 <strong>profile</strong> 决定是否继续解析（ profile 的过滤）.</p>
<p>接下来，后面就是 xml 配置文件的解析动作了，在这前后有一个预处理和后处理动作，不过默认情况下这里是没有实现的（模板方法罢了），所以我们只需要看 <code>parseBeanDefinitions</code> 就可以。</p>
<h3 id="1-6-parseBeanDefinitions-解析xml"><a href="#1-6-parseBeanDefinitions-解析xml" class="headerlink" title="1.6 parseBeanDefinitions - 解析xml"></a>1.6 parseBeanDefinitions - 解析xml</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;<br>        NodeList nl = root.getChildNodes();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>            Node node = nl.item(i);<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;<br>                Element ele = (Element) node;<br>                <span class="hljs-comment">// 解析&lt;beans&gt;中的元素</span><br>                <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<br>                    parseDefaultElement(ele, delegate);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 解析其它命名空间中的元素</span><br>                    delegate.parseCustomElement(ele);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        delegate.parseCustomElement(root);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Spring 如何解析 xml ，我们不关心，但是<strong>如何从解析完的 xml 中获取关键信息，以及封装 <code>BeanDefinition</code></strong> ，这才是我们要关注的。</p>
<p>这个方法一进来的时候，我们在此 Debug 停一下，可以发现它已经是解析并封装成 <code>Element</code> 的形式了，而且根节点是 <code>&lt;beans&gt;</code> ，它还有几个默认属性等等，我们都比较熟悉了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2053e0faafd4cb7b71d31ed7d76d0c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>OK ，继续回到源码，源码中可以看到，每次循环出来的 <code>Node</code> 都会尝试着转成 <code>Element</code> 去解析，而解析的动作主要是 <code>parseDefaultElement</code> ，它会解析 <code>&lt;beans&gt;</code> 标签下的 xml 元素。马上就要水落石出了，我们点进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;<br>        importBeanDefinitionResource(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;<br>        processAliasRegistration(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<br>        processBeanDefinition(ele, delegate);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<br>        <span class="hljs-comment">// recurse</span><br>        doRegisterBeanDefinitions(ele);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>终于看到真实的面貌了！！！这里它会解析 <code>&lt;import&gt;</code> 标签、<code>&lt;alias&gt;</code> 标签、<code>&lt;bean&gt;</code> 标签，以及递归解析嵌套的 <code>&lt;beans&gt;</code> 标签！</p>
<h3 id="1-7-processBeanDefinition-解析-lt-bean-gt-标签"><a href="#1-7-processBeanDefinition-解析-lt-bean-gt-标签" class="headerlink" title="1.7 processBeanDefinition - 解析 &lt;bean&gt; 标签"></a>1.7 processBeanDefinition - 解析 <code>&lt;bean&gt;</code> 标签</h3><p>既然我们还是在研究 <code>BeanDefinition</code> ，那我们就研究 <code>processBeanDefinition</code> 方法啦，翻开源码，可以发现逻辑还是比较简单的：（关键注释已标注在源码中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<br>    <span class="hljs-comment">// 解析xml元素为BeanDefinition</span><br>    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<br>    <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 解析&lt;bean&gt;中嵌套的自定义标签</span><br>        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// BeanDefinition注册到BeanDefinitionRegistry</span><br>            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>        &#125; <span class="hljs-comment">// catch ......</span><br>        <span class="hljs-comment">// Send registration event.</span><br>        getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现，整个动作一气呵成，其中第一个步骤会把 xml 元素封装为 <code>BeanDefinitionHolder</code> ，且不说 holder 是干嘛用，只从名字上就能知道，它内部肯定组合了一个 <code>BeanDefinition</code> 。</p>
<p>Debug 至此，可以发现，这个 <code>Element</code> 中已经包含了一个 <code>&lt;bean&gt;</code> 标签中定义的那些属性了：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca1baea2d556471ab36cffe0e9f492cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>不过源码是如何将 xml 元素封装为 <code>BeanDefinitionHolder</code> 的呢？我们还是进去看看为好。（以下源码篇幅略长，只关注有注释的部分即可）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> parseBeanDefinitionElement(ele, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;<br>    <span class="hljs-comment">// 取出bean的id</span><br>    String id = ele.getAttribute(ID_ATTRIBUTE);<br>    <span class="hljs-comment">// 取出bean的name</span><br>    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);<br><br>    <span class="hljs-comment">// 取出bean的alias</span><br>    List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;<br>        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>        aliases.addAll(Arrays.asList(nameArr));<br>    &#125;<br>    <span class="hljs-comment">// 如果没有给bean赋name，则第一个alias视为name</span><br>    String beanName = id;<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;<br>        beanName = aliases.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// logger ......</span><br>    &#125;<br><br>    <span class="hljs-comment">// 检查bean的name是否有重复</span><br>    <span class="hljs-keyword">if</span> (containingBean == <span class="hljs-keyword">null</span>) &#123;<br>        checkNameUniqueness(beanName, aliases, ele);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析其余的bean标签元素属性</span><br>    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);<br>    <span class="hljs-keyword">if</span> (beanDefinition != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 如果没有给bean赋name，且没有alias，则生成默认的name</span><br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (containingBean != <span class="hljs-keyword">null</span>) &#123;<br>                    beanName = BeanDefinitionReaderUtils.generateBeanName(<br>                            beanDefinition, <span class="hljs-keyword">this</span>.readerContext.getRegistry(), <span class="hljs-keyword">true</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    beanName = <span class="hljs-keyword">this</span>.readerContext.generateBeanName(beanDefinition);<br>                    String beanClassName = beanDefinition.getBeanClassName();<br>                    <span class="hljs-keyword">if</span> (beanClassName != <span class="hljs-keyword">null</span> &amp;&amp;<br>                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;<br>                            !<span class="hljs-keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;<br>                        aliases.add(beanClassName);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// logger ......</span><br>            &#125; <span class="hljs-comment">// catch ......</span><br>        &#125;<br>        String[] aliasesArray = StringUtils.toStringArray(aliases);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽说源码篇幅比较长，但总体还是比较容易理解和接受的，而且每一步干的活也都容易看明白。不过看完这段源码之后，小伙伴们可能会疑惑：只有 <code>id</code> 和 <code>name</code> ，<code>class</code> 呢？<code>scope</code> 呢？<code>lazy-init</code> 呢？莫慌，看到中间还有一个封装好的 <code>parseBeanDefinitionElement</code> 方法了吧，这些属性的封装都在这里可以找得到，我们继续往里进。同样的，这段源码篇幅较长，只需要关注带注释的即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Element ele, String beanName, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.parseState.push(<span class="hljs-keyword">new</span> BeanEntry(beanName));<br><br>    <span class="hljs-comment">// 解析class的全限定名</span><br>    String className = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;<br>        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();<br>    &#125;<br>    <span class="hljs-comment">// 解析parent的definition名称</span><br>    String parent = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;<br>        parent = ele.getAttribute(PARENT_ATTRIBUTE);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 构造BeanDefinition</span><br>        AbstractBeanDefinition bd = createBeanDefinition(className, parent);<br><br>        <span class="hljs-comment">// 解析其余的&lt;bean&gt;标签属性</span><br>        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br>        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));<br><br>        <span class="hljs-comment">// 解析property属性</span><br>        parseMetaElements(ele, bd);<br>        <span class="hljs-comment">// 解析其它的属性 ......</span><br><br>        bd.setResource(<span class="hljs-keyword">this</span>.readerContext.getResource());<br>        bd.setSource(extractSource(ele));<br><br>        <span class="hljs-keyword">return</span> bd;<br>    &#125; <span class="hljs-comment">// catch finally ......</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从这部分，我们终于看到了最最底层的操作：调用 <code>createBeanDefinition</code> 方法创建了一个 <code>BeanDefinition</code> （它的底层就是第 24 章提到的 <code>BeanDefinitionReaderUtils.createBeanDefinition</code> 方法），之后把 <code>&lt;bean&gt;</code> 标签中的其它属性、<code>&lt;bean&gt;</code> 的子标签的内容都封装起来，而封装 <code>&lt;bean&gt;</code> 其它属性的 <code>parseBeanDefinitionAttributes</code> 方法中，已经把这些内容都解析到位了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBeanDefinition <span class="hljs-title">parseBeanDefinitionAttributes</span><span class="hljs-params">(Element ele, String beanName,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean, AbstractBeanDefinition bd)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 解析scope</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;<br>        error(<span class="hljs-string">&quot;Old 1.x &#x27;singleton&#x27; attribute in use - upgrade to &#x27;scope&#x27; declaration&quot;</span>, ele);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;<br>        bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (containingBean != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Take default from containing bean in case of an inner bean definition.</span><br>        bd.setScope(containingBean.getScope());<br>    &#125;<br><br>    <span class="hljs-comment">// 解析abstract属性</span><br>    <span class="hljs-keyword">if</span> (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;<br>        bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));<br>    &#125;<br><br>    <span class="hljs-comment">// 省略部分相似的封装属性的动作 ......</span><br>    <span class="hljs-keyword">return</span> bd;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里，xml 配置文件中的 <code>&lt;bean&gt;</code> 标签就可以转换为 <code>BeanDefinition</code> 了。</p>
<h4 id="1-7-1-BeanDefinitionHolder的意义"><a href="#1-7-1-BeanDefinitionHolder的意义" class="headerlink" title="1.7.1 BeanDefinitionHolder的意义"></a>1.7.1 BeanDefinitionHolder的意义</h4><p>最后补充一下前面略过的 <code>BeanDefinitionHolder</code> ，我们说它是持有 <code>BeanDefinition</code> 的一个包装而已，不过它除了持有之外，还包含了另外的重要信息：<strong>bean 的名称</strong>。</p>
<p>翻看 <code>BeanDefinitionHolder</code> 的源码结构，可以发现这里面还组合了 bean 的 <strong>name</strong> 和 alias ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinitionHolder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanMetadataElement</span> </span>&#123;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BeanDefinition beanDefinition;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String beanName;<br><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] aliases;<br></code></pre></td></tr></table></figure>
<p>是不是突然回过神了，<code>BeanDefinition</code> 的结构中是没有 name 的！所以才需要这样一个 holder 帮它持有。</p>
<h3 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h3><p>简单总结一下这个流程吧：</p>
<ol>
<li>首先 <code>ClassPathXmlApplicationContext</code> 在 <code>refresh</code> 之前，会指定传入的 xml 配置文件的路径；</li>
<li>执行 <code>refresh</code> 方法时，会初始化 <code>BeanFactory</code> ，触发 xml 配置文件的读取、加载和解析：<ol>
<li>其中 xml 的读取需要借助 <code>XmlBeanDefinitionReader</code> ；</li>
<li>解析 xml 配置文件则使用 <code>DefaultBeanDefinitionDocumentReader</code> ，最终解析 xml 中的元素，封装出 <code>BeanDefinition</code> 。</li>
</ol>
</li>
<li>最后注册到 <code>BeanDefinitionRegistry</code> 。</li>
</ol>
<hr>
<h2 id="2-加载解析注解配置类"><a href="#2-加载解析注解配置类" class="headerlink" title="2. 加载解析注解配置类"></a>2. 加载解析注解配置类</h2><p>相比较于 xml 配置文件，注解配置类的加载时机会晚一些，它用到了一个至关重要的 <code>BeanDefinitionRegistryPostProcessor</code> ，而且无论如何，这个后置处理器都是最最优先执行的，它就是 <strong><code>ConfigurationClassPostProcessor</code></strong> 。</p>
<p>下面我们还是通过实例来研究注解配置类的加载机制（注意此处要换用 <code>LifecycleSourceAnnotationApplication</code> 了哦）。</p>
<h3 id="2-1-BeanDefinitionRegistryPostProcessor的调用时机"><a href="#2-1-BeanDefinitionRegistryPostProcessor的调用时机" class="headerlink" title="2.1 BeanDefinitionRegistryPostProcessor的调用时机"></a>2.1 BeanDefinitionRegistryPostProcessor的调用时机</h3><p>还是回到 <code>AbstractApplicationContext</code> 的 <code>refresh</code> 方法中，这次我们要看的是 <code>BeanFactoryPostProcessor</code> 和 <code>BeanDefinitionRegistryPostProcessor</code> 的执行时机，而它们的执行都在下面所示的第 5 步 <code>invokeBeanFactoryPostProcessors</code> 中执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-comment">// ......</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            postProcessBeanFactory(beanFactory);<br>          <br>            <span class="hljs-comment">// 5. 执行BeanFactoryPostProcessor</span><br>            invokeBeanFactoryPostProcessors(beanFactory);<br>          <br>            registerBeanPostProcessors(beanFactory);<br>            <span class="hljs-comment">// ......</span><br>        &#125;<br>        <span class="hljs-comment">// catch finally .....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>进来这个方法，发现核心的方法就一句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// 交给代理执行</span><br>    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());<br><br>    <span class="hljs-comment">// 下面是支持AOP的部分（暂时不读）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>好吧，它又是交给一个 <strong>Delegate</strong> 执行，那就进去看这个方法的实现吧。</p>
<h3 id="2-2-PostProcessorRegistrationDelegate的实现"><a href="#2-2-PostProcessorRegistrationDelegate的实现" class="headerlink" title="2.2 PostProcessorRegistrationDelegate的实现"></a>2.2 PostProcessorRegistrationDelegate的实现</h3><p><strong>前方高能</strong>！<code>invokeBeanFactoryPostProcessors</code> 方法的篇幅实在太长了！！！小册只截取关键的部分吧。。。（只关注有注释的部分即可）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;<br><br>    Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) &#123;<br>        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;<br>        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 该部分会将BeanFactoryPostProcessor与BeanDefinitionRegistryPostProcessor分离开</span><br>        <span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;<br>            <span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;<br>                BeanDefinitionRegistryPostProcessor registryProcessor =<br>                        (BeanDefinitionRegistryPostProcessor) postProcessor;<br>                registryProcessor.postProcessBeanDefinitionRegistry(registry);<br>                registryProcessors.add(registryProcessor);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                regularPostProcessors.add(postProcessor);<br>            &#125;<br>        &#125;<br>        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 首先，执行实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessors</span><br>        String[] postProcessorNames =<br>                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>            <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>                processedBeans.add(ppName);<br>            &#125;<br>        &#125;<br>        sortPostProcessors(currentRegistryProcessors, beanFactory);<br>        registryProcessors.addAll(currentRegistryProcessors);<br>        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>        currentRegistryProcessors.clear();<br><br>        <span class="hljs-comment">// 接下来，执行实现了Ordered接口的BeanDefinitionRegistryPostProcessors</span><br>        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>            <span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>                processedBeans.add(ppName);<br>            &#125;<br>        &#125;<br>        sortPostProcessors(currentRegistryProcessors, beanFactory);<br>        registryProcessors.addAll(currentRegistryProcessors);<br>        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>        currentRegistryProcessors.clear();<br><br>        <span class="hljs-comment">// 最后，执行所有其他BeanDefinitionRegistryPostProcessor</span><br>        <span class="hljs-keyword">boolean</span> reiterate = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">while</span> (reiterate) &#123;<br>            reiterate = <span class="hljs-keyword">false</span>;<br>            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>            <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>                <span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;<br>                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>                    processedBeans.add(ppName);<br>                    reiterate = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>            sortPostProcessors(currentRegistryProcessors, beanFactory);<br>            registryProcessors.addAll(currentRegistryProcessors);<br>            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>            currentRegistryProcessors.clear();<br>        &#125;<br><br>        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);<br>        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);<br>    &#125;<br><br>    <span class="hljs-keyword">else</span> &#123;<br>        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行BeanFactoryPostProcessor ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>用简单的语言概括，这个方法的执行机制如下：</p>
<ol>
<li><p>执行 <code>BeanDefinitionRegistryPostProcessor</code> 的 <code>postProcessBeanDefinitionRegistry</code> 方法</p>
<ol>
<li>执行实现了 <code>PriorityOrdered</code> 接口的 <code>BeanDefinitionRegistryPostProcessor</code></li>
<li>执行实现了 <code>Ordered</code> 接口的 <code>BeanDefinitionRegistryPostProcessor</code></li>
<li>执行普通的 <code>BeanDefinitionRegistryPostProcessor</code></li>
</ol>
</li>
<li><p>执行 <code>BeanDefinitionRegistryPostProcessor</code> 的 <code>postProcessBeanFactory</code> 方法</p>
<p>同上</p>
</li>
<li><p>执行<code>BeanFactoryPostProcessor</code> 的 <code>postProcessBeanFactory</code> 方法</p>
<p>同上</p>
</li>
</ol>
<blockquote>
<p>这个方法的更详细解读，可参考<a target="_blank" rel="noopener" href="https://juejin.im/book/6844733814560784397/section/6844733814615310350">《SpringBoot 小册》第 12 章 5.1 节</a>，那里面解释的更加详细呦。</p>
</blockquote>
<p>在这个长长的方法中，第一个环节它会执行所有实现了 <code>PriorityOrdered</code> 接口的 <code>BeanDefinitionRegistryPostProcessor</code> ，这里面第一个执行的处理器就是 <code>ConfigurationClassPostProcessor</code> ，咱跟过去看一看。</p>
<h3 id="2-3-ConfigurationClassPostProcessor的处理"><a href="#2-3-ConfigurationClassPostProcessor的处理" class="headerlink" title="2.3 ConfigurationClassPostProcessor的处理"></a>2.3 ConfigurationClassPostProcessor的处理</h3><p>直接定位到 <code>postProcessBeanDefinitionRegistry</code> 方法吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> registryId = System.identityHashCode(registry);<br>    <span class="hljs-comment">// check throw ex ......</span><br>    <span class="hljs-keyword">this</span>.registriesPostProcessed.add(registryId);<br><br>    <span class="hljs-comment">// 【解析配置类】</span><br>    processConfigBeanDefinitions(registry);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现，在这个方法的最后一行，就是解析配置类中定义的 bean ，并封装为 <code>BeanDefinition</code> 。</p>
<blockquote>
<p>进入超难领域前的 “按摩” 提醒：<code>processConfigBeanDefinitions</code> 方法的内容超级复杂哦（不亚于上面的 xml 配置文件加载），考虑到前面的 SpringBoot 小册中对该部分流程<strong>没有全部剖析</strong>（ <strong>boot 的小册</strong>中对于 IOC <strong>更注重整体应用和容器的生命周期</strong>），所以我们在这里<strong>完整的研究一遍配置类的加载原理</strong>。</p>
</blockquote>
<p>进入 <code>processConfigBeanDefinitions</code> 方法，来吧，超级长的源码又出现了：（小伙伴们还是只关注有注释的源码段落即可）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;<br>    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    String[] candidateNames = registry.getBeanDefinitionNames();<br><br>    <span class="hljs-comment">// 筛选出所有的配置类</span><br>    <span class="hljs-keyword">for</span> (String beanName : candidateNames) &#123;<br>        BeanDefinition beanDef = registry.getBeanDefinition(beanName);<br>        <span class="hljs-comment">// full configuration的解释可参考boot小册12章5.2.1.1节</span><br>        <span class="hljs-keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||<br>                ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;<br>            <span class="hljs-comment">// logger ......</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>            configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Return immediately if no @Configuration classes were found</span><br>    <span class="hljs-keyword">if</span> (configCandidates.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 配置类排序</span><br>    configCandidates.sort((bd1, bd2) -&gt; &#123;<br>        <span class="hljs-keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());<br>        <span class="hljs-keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());<br>        <span class="hljs-keyword">return</span> Integer.compare(i1, i2);<br>    &#125;);<br><br>    <span class="hljs-comment">// 构造默认的BeanNameGenerator bean的名称生成器</span><br>    SingletonBeanRegistry sbr = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (registry <span class="hljs-keyword">instanceof</span> SingletonBeanRegistry) &#123;<br>        sbr = (SingletonBeanRegistry) registry;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.localBeanNameGeneratorSet) &#123;<br>            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);<br>            <span class="hljs-keyword">if</span> (generator != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator = generator;<br>                <span class="hljs-keyword">this</span>.importBeanNameGenerator = generator;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.environment = <span class="hljs-keyword">new</span> StandardEnvironment();<br>    &#125;<br><br>    <span class="hljs-comment">// 真正解析配置类的组件：ConfigurationClassParser</span><br>    ConfigurationClassParser parser = <span class="hljs-keyword">new</span> ConfigurationClassParser(<br>            <span class="hljs-keyword">this</span>.metadataReaderFactory, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.environment,<br>            <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator, registry);<br><br>    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);<br>    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(configCandidates.size());<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 【解析配置类】</span><br>        parser.parse(candidates);<br>        parser.validate();<br><br>        Set&lt;ConfigurationClass&gt; configClasses = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());<br>        configClasses.removeAll(alreadyParsed);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reader == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinitionReader(<br>                    registry, <span class="hljs-keyword">this</span>.sourceExtractor, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.environment,<br>                    <span class="hljs-keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());<br>        &#125;<br>        <span class="hljs-comment">// 【加载配置类的内容】</span><br>        <span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(configClasses);<br>        alreadyParsed.addAll(configClasses);<br>        <br>        <span class="hljs-comment">// 一些额外的处理动作</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (!candidates.isEmpty());<br><br>    <span class="hljs-comment">// 一些额外的处理 ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实如果小伙伴从上往下看的话，应该可以意识到，其实也没那么难吧（当然没那么难，难的在 <code>parse</code> 和 <code>loadBeanDefinitions</code> 里头）。不过这里面的前置动作还是要注意一下，它初始化了一个 <code>ConfigurationClassParser</code> ，这个家伙是用来解析注解配置类的核心 API 。</p>
<p>一大堆前戏都做足了，下面就可以进入 <code>ConfigurationClassParser</code> 的 <code>parse</code> 方法了。</p>
<h3 id="2-4-ConfigurationClassParser-parse-解析注解配置类"><a href="#2-4-ConfigurationClassParser-parse-解析注解配置类" class="headerlink" title="2.4 ConfigurationClassParser#parse - 解析注解配置类"></a>2.4 ConfigurationClassParser#parse - 解析注解配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;<br>        BeanDefinition bd = holder.getBeanDefinition();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 注解配置类</span><br>            <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());<br>            &#125;<br>            <span class="hljs-comment">// 编程式注入配置类</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;<br>                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());<br>            &#125;<br>            <span class="hljs-comment">// 其他情况</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                parse(bd.getBeanClassName(), holder.getBeanName());<br>            &#125;<br>        &#125; <span class="hljs-comment">// catch ......</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 回调特殊的ImportSelector</span><br>    <span class="hljs-keyword">this</span>.deferredImportSelectorHandler.process();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先整体看一下这个方法的内容哈。上面的 for 循环中，它会把配置类的全限定名拿出来，扔进重载的 <code>parse</code> 方法中（注意无论是执行 if-else-if 的哪个分支，最终都是执行重载的 <code>parse</code> 方法）；for 循环调用完成后，最底下会让 <code>deferredImportSelectorHandler</code> 执行 <code>process</code> 方法，这个东西我们完全没见过，这里有必要说明一下。</p>
<h4 id="2-4-1-ImportSelector的扩展"><a href="#2-4-1-ImportSelector的扩展" class="headerlink" title="2.4.1 ImportSelector的扩展"></a>2.4.1 ImportSelector的扩展</h4><p>在 SpringFramework 4.0 中，<code>ImportSelector</code> 多了一个子接口：<code>DeferredImportSelector</code> ，它的执行时机比 <code>ImportSelector</code> 更晚，它会在注解配置类的所有解析工作完成后才执行（其实上面的源码就已经解释了这个原理）。</p>
<p>一般情况下，<code>DeferredImportSelector</code> 会跟 <code>@Conditional</code> 注解配合使用，完成<strong>条件装配</strong>。</p>
<h4 id="2-4-2-deferredImportSelectorHandler的处理逻辑"><a href="#2-4-2-deferredImportSelectorHandler的处理逻辑" class="headerlink" title="2.4.2 deferredImportSelectorHandler的处理逻辑"></a>2.4.2 deferredImportSelectorHandler的处理逻辑</h4><p>进入 <code>DeferredImportSelectorHandler</code> 的 <code>process</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;DeferredImportSelectorHolder&gt; deferredImports = <span class="hljs-keyword">this</span>.deferredImportSelectors;<br>    <span class="hljs-keyword">this</span>.deferredImportSelectors = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (deferredImports != <span class="hljs-keyword">null</span>) &#123;<br>            DeferredImportSelectorGroupingHandler handler = <span class="hljs-keyword">new</span> DeferredImportSelectorGroupingHandler();<br>            deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);<br>            deferredImports.forEach(handler::register);<br>            handler.processGroupImports();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">this</span>.deferredImportSelectors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现这个处理逻辑还是很简单的，它会取出所有解析中存储好的 <code>DeferredImportSelector</code> ，并依次执行。由于 <code>DeferredImportSelector</code> 的执行时机比较晚，对于 <code>@Conditional</code> 条件装配的处理也会更有利，所以这个设计还是不错的。</p>
<h3 id="2-5-parse解析配置类"><a href="#2-5-parse解析配置类" class="headerlink" title="2.5 parse解析配置类"></a>2.5 parse解析配置类</h3><p>回到正题上，上面的 <code>ConfigurationClassParser</code> 中最终都会把配置类传入重载的 <code>parse</code> 方法中，参数类型注意是 <code>ConfigurationClass</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(AnnotationMetadata metadata, String beanName)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    processConfigurationClass(<span class="hljs-keyword">new</span> ConfigurationClass(metadata, beanName));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ConfigurationClass existingClass = <span class="hljs-keyword">this</span>.configurationClasses.get(configClass);<br>    <span class="hljs-keyword">if</span> (existingClass != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 如果配置类已经被@Import过了，则跳过</span><br>        <span class="hljs-keyword">if</span> (configClass.isImported()) &#123;<br>            <span class="hljs-keyword">if</span> (existingClass.isImported()) &#123;<br>                existingClass.mergeImportedBy(configClass);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.configurationClasses.remove(configClass);<br>            <span class="hljs-keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);<br>        &#125;<br>    &#125;<br><br>    SourceClass sourceClass = asSourceClass(configClass);<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 【真正干活的】</span><br>        sourceClass = doProcessConfigurationClass(configClass, sourceClass);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (sourceClass != <span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-keyword">this</span>.configurationClasses.put(configClass, configClass);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>好吧，底下又是调 <strong><code>doXXX</code></strong> 方法了，那就废话不多说，直接莽进去就完事了。</p>
<h3 id="2-6-doProcessConfigurationClass-解析配置类"><a href="#2-6-doProcessConfigurationClass-解析配置类" class="headerlink" title="2.6 doProcessConfigurationClass - 解析配置类"></a>2.6 doProcessConfigurationClass - 解析配置类</h3><p>又高能！这个方法又是好长呀！不过这里面的部分几乎都有大用途哦，我们分解着来看吧。</p>
<h4 id="2-6-1-处理-Component注解"><a href="#2-6-1-处理-Component注解" class="headerlink" title="2.6.1 处理@Component注解"></a>2.6.1 处理@Component注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;<br>        processMemberClasses(configClass, sourceClass);<br>    &#125;<br>    <span class="hljs-comment">// .............</span><br></code></pre></td></tr></table></figure>
<p>一上来，它就会判断这个类是否有标注 <code>@Component</code> 注解。因为所有的 <code>@Configuration</code> 类必定是 <code>@Component</code> ，所以该逻辑必进。而内部执行的 <code>processMemberClasses</code> 方法如下：（只需要看有注释的源码段落即可哈）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processMemberClasses</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass,</span></span><br><span class="hljs-function"><span class="hljs-params">        Predicate&lt;String&gt; filter)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 获取配置类中的所有内部类</span><br>    Collection&lt;SourceClass&gt; memberClasses = sourceClass.getMemberClasses();<br>    <span class="hljs-keyword">if</span> (!memberClasses.isEmpty()) &#123;<br>        List&lt;SourceClass&gt; candidates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(memberClasses.size());<br>        <span class="hljs-comment">// 循环解析内部类</span><br>        <span class="hljs-keyword">for</span> (SourceClass memberClass : memberClasses) &#123;<br>            <span class="hljs-comment">// 如果内部类也是配置类，则它们也会被解析</span><br>            <span class="hljs-keyword">if</span> (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &amp;&amp;<br>                    !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) &#123;<br>                candidates.add(memberClass);<br>            &#125;<br>        &#125;<br>        OrderComparator.sort(candidates);<br>        <span class="hljs-keyword">for</span> (SourceClass candidate : candidates) &#123;<br>            <span class="hljs-comment">// 防止循环@Import的处理：如果两个配置类互相@Import，则视为错误</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.importStack.contains(configClass)) &#123;<br>                <span class="hljs-keyword">this</span>.problemReporter.error(<span class="hljs-keyword">new</span> CircularImportProblem(configClass, <span class="hljs-keyword">this</span>.importStack));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">this</span>.importStack.push(configClass);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 递归解析内部的配置类</span><br>                    processConfigurationClass(candidate.asConfigClass(configClass), filter);<br>                &#125;<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">this</span>.importStack.pop();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>哦 ~ 合计着这个方法是处理内部类的啊，而且还是递归处理，这个套路很像上面 <code>&lt;beans&gt;</code> 的 xml 递归解析哦。那好吧，这里面的逻辑也不复杂，扫一眼过去就得了，不要浪费太多时间。</p>
<h4 id="2-6-2-处理-PropertySource注解"><a href="#2-6-2-处理-PropertySource注解" class="headerlink" title="2.6.2 处理@PropertySource注解"></a>2.6.2 处理@PropertySource注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ............</span><br><span class="hljs-comment">// Process any @PropertySource annotations</span><br><span class="hljs-keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(<br>        sourceClass.getMetadata(), PropertySources.class,<br>        org.springframework.context.annotation.PropertySource.class)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment <span class="hljs-keyword">instanceof</span> ConfigurableEnvironment) &#123;<br>        processPropertySource(propertySource);<br>    &#125;<br>    <span class="hljs-comment">// else logger ......</span><br>&#125;<br><span class="hljs-comment">// ............</span><br></code></pre></td></tr></table></figure>
<p>接下来是处理 <code>@PropertySource</code> 注解了，可以发现借助 <code>AnnotationConfigUtils</code> 可以很容易的取出配置类上标注的所有注解信息，然后筛选出指定的注解属性即可。而内部的 <code>processPropertySource</code> 方法就在真正的封装 <code>PropertySource</code> 导入的资源文件：（不太重要的源码已省略）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processPropertySource</span><span class="hljs-params">(AnnotationAttributes propertySource)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 解析@PropertySource注解的属性</span><br>    String name = propertySource.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(name)) &#123;<br>        name = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    String encoding = propertySource.getString(<span class="hljs-string">&quot;encoding&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(encoding)) &#123;<br>        encoding = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    String[] locations = propertySource.getStringArray(<span class="hljs-string">&quot;value&quot;</span>);<br>    <span class="hljs-comment">// ......</span><br><br>    <span class="hljs-keyword">for</span> (String location : locations) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 处理路径，加载资源文件，并添加进Environment中</span><br>            String resolvedLocation = <span class="hljs-keyword">this</span>.environment.resolveRequiredPlaceholders(location);<br>            Resource resource = <span class="hljs-keyword">this</span>.resourceLoader.getResource(resolvedLocation);<br>            addPropertySource(factory.createPropertySource(name, <span class="hljs-keyword">new</span> EncodedResource(resource, encoding)));<br>        &#125; <span class="hljs-comment">// catch ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前面的一大堆操作都是拿 <code>@PropertySource</code> 的一些属性等等，最后的 for 循环中才是封装资源文件，存放进 <code>Environment</code> 的部分，整体逻辑也是比较简单的，咱就不深入研究咯（主要关注 bean 相关的东西哈）。</p>
<h4 id="2-6-3-处理-ComponentScan注解"><a href="#2-6-3-处理-ComponentScan注解" class="headerlink" title="2.6.3 处理@ComponentScan注解"></a>2.6.3 处理@ComponentScan注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ............</span><br><span class="hljs-comment">// Process any @ComponentScan annotations</span><br>Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(<br>        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);<br><span class="hljs-keyword">if</span> (!componentScans.isEmpty() &amp;&amp;<br>        !<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;<br>    <span class="hljs-comment">// 如果有@ComponentScans，则要取出里面所有的@ComponentScan依次扫描</span><br>    <span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;<br>        <span class="hljs-comment">// 【复杂】借助ComponentScanAnnotationParser扫描</span><br>        Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =<br>                <span class="hljs-keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());<br>        <span class="hljs-comment">// 是否扫描到了其它的注解配置类</span><br>        <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;<br>            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();<br>            <span class="hljs-keyword">if</span> (bdCand == <span class="hljs-keyword">null</span>) &#123;<br>                bdCand = holder.getBeanDefinition();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>                <span class="hljs-comment">// 如果扫描到了，递归解析</span><br>                parse(bdCand.getBeanClassName(), holder.getBeanName());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ............</span><br></code></pre></td></tr></table></figure>
<p>接下来的部分是处理 <code>@ComponentScan</code> 注解了，整个流程也不复杂。注意一点：<code>@ComponentScan</code> 可以标注多个，并且 Spring 4.3 后多了一个 <code>@ComponentScans</code> 注解，它可以组合多个 <code>@ComponentScan</code> 注解，所以这里是 for 循环解析 <code>@ComponentScan</code> 。</p>
<p>中间的部分，它使用 <code>ComponentScanAnnotationParser</code> 来委托处理包扫描的工作，可能会有小伙伴产生疑惑：不是包扫描的组件是 <code>ClassPathBeanDefinitionScanner</code> 吗？它是谁？先别着急，我们进到 <code>ComponentScanAnnotationParser</code> 的 <code>parse</code> 方法中，看一看内部的实现：（嗯，第一行就把 <code>ClassPathBeanDefinitionScanner</code> 创建出来了 ~ ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">parse</span><span class="hljs-params">(AnnotationAttributes componentScan, <span class="hljs-keyword">final</span> String declaringClass)</span> </span>&#123;<br>    <span class="hljs-comment">// 构造ClassPathBeanDefinitionScanner</span><br>    ClassPathBeanDefinitionScanner scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword">this</span>.registry,<br>            componentScan.getBoolean(<span class="hljs-string">&quot;useDefaultFilters&quot;</span>), <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader);<br><br>    <span class="hljs-comment">// 解析@ComponentScan中的属性 ......</span><br>    Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(<span class="hljs-string">&quot;nameGenerator&quot;</span>);<br><br>    <span class="hljs-comment">// 整理要扫描的basePackages</span><br>    Set&lt;String&gt; basePackages = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br>    String[] basePackagesArray = componentScan.getStringArray(<span class="hljs-string">&quot;basePackages&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String pkg : basePackagesArray) &#123;<br>        String[] tokenized = StringUtils.tokenizeToStringArray(<span class="hljs-keyword">this</span>.environment.resolvePlaceholders(pkg),<br>                ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);<br>        Collections.addAll(basePackages, tokenized);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="hljs-string">&quot;basePackageClasses&quot;</span>)) &#123;<br>        basePackages.add(ClassUtils.getPackageName(clazz));<br>    &#125;<br>    <span class="hljs-comment">// 没有声明basePackages，则当前配置类所在的包即为根包</span><br>    <span class="hljs-keyword">if</span> (basePackages.isEmpty()) &#123;<br>        basePackages.add(ClassUtils.getPackageName(declaringClass));<br>    &#125;<br><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// 【扫描】执行包扫描动作</span><br>    <span class="hljs-keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>顺序走下来，大概这个方法只干了三件事情：</p>
<ol>
<li>构造 <code>ClassPathBeanDefinitionScanner</code> ，并封装 <code>@ComponentScan</code> 注解中的属性</li>
<li>整理要进行包扫描的 <code>basePackages</code> ，以及 include 和 exclude 的过滤器</li>
<li>执行包扫描的动作</li>
</ol>
<p>前面两个步骤都是准备动作，真正的包扫描那还得看 <code>ClassPathBeanDefinitionScanner</code> ，来吧，咱直接进到最底下的 <code>doScan</code> 方法中：（关键注释已标注在源码中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">doScan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;<br>    <span class="hljs-comment">// assert ......</span><br>    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;<br>        <span class="hljs-comment">// 【真正的包扫描动作在这里】</span><br>        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);<br>        <span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) &#123;<br>            <span class="hljs-comment">// 处理scope（默认情况下是singleton）</span><br>            ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);<br>            candidate.setScope(scopeMetadata.getScopeName());<br>            <span class="hljs-comment">// 生成bean的名称</span><br>            String beanName = <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-keyword">this</span>.registry);<br>            <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);<br>            &#125;<br>            <span class="hljs-comment">// 处理bean中的@Lazy、@Primary等注解</span><br>            <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123;<br>                BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(candidate, beanName);<br>                <span class="hljs-comment">// 设置AOP相关的属性（如果支持的话）</span><br>                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>                beanDefinitions.add(definitionHolder);<br>                <span class="hljs-comment">// 注册进BeanDefinitionRegistry</span><br>                registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> beanDefinitions;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上往下的逻辑条理还是很清晰的，只要扫描到了符合的类（默认被 <code>@Component</code> 注解标注的类），就会包装为 <code>BeanDefinition</code> ，然后对这些 <code>BeanDefinition</code> 进行一些额外的处理，最终注册进 <code>BeanDefinitionRegistry</code> 。不过核心的扫描方法还是封装方法了，咱进入 for 循环的第一句 <code>findCandidateComponents</code> 方法中： （只标注了关键部分的源码注释）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;BeanDefinition&gt; <span class="hljs-title">findCandidateComponents</span><span class="hljs-params">(String basePackage)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.componentsIndex != <span class="hljs-keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;<br>        <span class="hljs-keyword">return</span> addCandidateComponentsFromIndex(<span class="hljs-keyword">this</span>.componentsIndex, basePackage);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> scanCandidateComponents(basePackage);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Set&lt;BeanDefinition&gt; <span class="hljs-title">scanCandidateComponents</span><span class="hljs-params">(String basePackage)</span> </span>&#123;<br>    Set&lt;BeanDefinition&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处可处理 [/**/service/*Service.class] 这样的表达式</span><br>        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +<br>                resolveBasePackage(basePackage) + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-keyword">this</span>.resourcePattern;<br>        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);<br>        <span class="hljs-keyword">for</span> (Resource resource : resources) &#123;<br>            <span class="hljs-keyword">if</span> (resource.isReadable()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 加载.class字节码</span><br>                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);<br>                    <span class="hljs-comment">// 如果符合匹配规则，则封装为ScannedGenericBeanDefinition</span><br>                    <span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) &#123;<br>                        ScannedGenericBeanDefinition sbd = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);<br>                        sbd.setSource(resource);<br>                        <span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) &#123;<br>                            candidates.add(sbd);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-comment">// catch .......</span><br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">// catch ......</span><br>    <span class="hljs-keyword">return</span> candidates;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整体逻辑还是简单的很：它会将带有通配符的 <strong>Ant</strong> 风格（诸如 <code>/xxx/**/*.class</code> ）的路径解析出来，并加载到对应的类，封装为 <code>ScannedGenericBeanDefinition</code> ，完事。</p>
<p>到这里，包扫描的处理就完成了，<code>@ComponentScan</code> 的处理也就结束了。</p>
<h4 id="2-6-4-处理-Import注解"><a href="#2-6-4-处理-Import注解" class="headerlink" title="2.6.4 处理@Import注解"></a>2.6.4 处理@Import注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ............</span><br><span class="hljs-comment">// Process any @Import annotations</span><br>processImports(configClass, sourceClass, getImports(sourceClass), <span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// ............</span><br></code></pre></td></tr></table></figure>
<p>嚯，就一句话啊，那咱直接点进去吧：（篇幅比较长，只关注标有注释的部分即可哦）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processImports</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="hljs-function"><span class="hljs-params">        Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> checkForCircularImports)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (importCandidates.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 防止循环@Import导入</span><br>    <span class="hljs-keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;<br>        <span class="hljs-keyword">this</span>.problemReporter.error(<span class="hljs-keyword">new</span> CircularImportProblem(configClass, <span class="hljs-keyword">this</span>.importStack));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.importStack.push(configClass);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (SourceClass candidate : importCandidates) &#123;<br>                <span class="hljs-comment">// 处理ImportSelector</span><br>                <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;<br>                    Class&lt;?&gt; candidateClass = candidate.loadClass();<br>                    ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,<br>                            <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.registry);<br>                    Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();<br>                    <span class="hljs-keyword">if</span> (selectorFilter != <span class="hljs-keyword">null</span>) &#123;<br>                        exclusionFilter = exclusionFilter.or(selectorFilter);<br>                    &#125;<br>                    <span class="hljs-comment">// DeferredImportSelector的执行时机后延</span><br>                    <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> DeferredImportSelector) &#123;<br>                        <span class="hljs-keyword">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 执行ImportSelector的selectImports方法，并注册导入的类</span><br>                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());<br>                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);<br>                        processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, <span class="hljs-keyword">false</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 处理ImportBeanDefinitionRegistrar</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;<br>                    Class&lt;?&gt; candidateClass = candidate.loadClass();<br>                    ImportBeanDefinitionRegistrar registrar =<br>                            ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,<br>                                    <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.registry);<br>                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 导入普通类 / 配置类</span><br>                    <span class="hljs-keyword">this</span>.importStack.registerImport(<br>                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());<br>                    processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-comment">// catch ......</span><br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">this</span>.importStack.pop();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现，整体逻辑非常有序，它分别对 <code>ImportSelector</code> 、<code>ImportBeanDefinitionRegistrar</code> 、普通类 / 配置类都做了处理，并递归解析其中存在的配置类，整体并不复杂，小伙伴们看一看有个印象即可，重要的是记住它们处理的位置，以便日后出现问题时排错定位。</p>
<h4 id="2-6-5-处理-ImportResource注解"><a href="#2-6-5-处理-ImportResource注解" class="headerlink" title="2.6.5 处理@ImportResource注解"></a>2.6.5 处理@ImportResource注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ............</span><br><span class="hljs-comment">// Process any @ImportResource annotations</span><br>AnnotationAttributes importResource =<br>        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);<br><span class="hljs-keyword">if</span> (importResource != <span class="hljs-keyword">null</span>) &#123;<br>    String[] resources = importResource.getStringArray(<span class="hljs-string">&quot;locations&quot;</span>);<br>    Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="hljs-string">&quot;reader&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String resource : resources) &#123;<br>        String resolvedResource = <span class="hljs-keyword">this</span>.environment.resolveRequiredPlaceholders(resource);<br>        configClass.addImportedResource(resolvedResource, readerClass);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ............</span><br></code></pre></td></tr></table></figure>
<p>前面我们学过了，在注解配置类上标注 <code>@ImportResource</code> 可以导入 xml 配置文件，而解析这些 <code>@ImportResource</code> 的逻辑就在这里。不过看源码的套路中，怎么只是把配置文件的路径放入了 <code>configClass</code> 而已呢？咋不解析呀？莫慌，我们之前看 <code>ConfigurationClassPostProcessor</code> 的后置处理 <code>processConfigBeanDefinitions</code> 方法中，不是在 <code>parse</code> 方法下面还有个 <code>loadBeanDefinitions</code> 方法嘛，过会我们看看它就知道了。</p>
<h4 id="2-6-6-处理-Bean注解"><a href="#2-6-6-处理-Bean注解" class="headerlink" title="2.6.6 处理@Bean注解"></a>2.6.6 处理@Bean注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ............</span><br><span class="hljs-comment">// Process individual @Bean methods</span><br>Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);<br><span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;<br>    configClass.addBeanMethod(<span class="hljs-keyword">new</span> BeanMethod(methodMetadata, configClass));<br>&#125;<br><span class="hljs-comment">// ............</span><br></code></pre></td></tr></table></figure>
<p>合着 <code>@Bean</code> 的处理也只是存起来呗？那它啥时候处理啊？不会跟上面的 <code>@ImportResource</code> 放在一块处理吧？哎，想法可以保留，过会我们往下看到了自然就揭晓了。不过它是如何把这些 <code>@Bean</code> 方法都拿出来的，我们还得去看看 <code>retrieveBeanMethodMetadata</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Set&lt;MethodMetadata&gt; <span class="hljs-title">retrieveBeanMethodMetadata</span><span class="hljs-params">(SourceClass sourceClass)</span> </span>&#123;<br>    AnnotationMetadata original = sourceClass.getMetadata();<br>    <span class="hljs-comment">// 获取被@Bean注解标注的方法</span><br>    Set&lt;MethodMetadata&gt; beanMethods = original.getAnnotatedMethods(Bean.class.getName());<br>    <span class="hljs-keyword">if</span> (beanMethods.size() &gt; <span class="hljs-number">1</span> &amp;&amp; original <span class="hljs-keyword">instanceof</span> StandardAnnotationMetadata) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            AnnotationMetadata asm =<br>                    <span class="hljs-keyword">this</span>.metadataReaderFactory.getMetadataReader(original.getClassName()).getAnnotationMetadata();<br>            Set&lt;MethodMetadata&gt; asmMethods = asm.getAnnotatedMethods(Bean.class.getName());<br>            <span class="hljs-keyword">if</span> (asmMethods.size() &gt;= beanMethods.size()) &#123;<br>                Set&lt;MethodMetadata&gt; selectedMethods = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(asmMethods.size());<br>                <span class="hljs-comment">// 筛选每个方法</span><br>                <span class="hljs-keyword">for</span> (MethodMetadata asmMethod : asmMethods) &#123;<br>                    <span class="hljs-keyword">for</span> (MethodMetadata beanMethod : beanMethods) &#123;<br>                        <span class="hljs-keyword">if</span> (beanMethod.getMethodName().equals(asmMethod.getMethodName())) &#123;<br>                            selectedMethods.add(beanMethod);<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (selectedMethods.size() == beanMethods.size()) &#123;<br>                    beanMethods = selectedMethods;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-comment">// catch ......</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> beanMethods;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一上来我们就看到 <code>@Bean</code> 注解的方法过滤了，经过这个过滤之后，就只会得到配置类中被 <code>@Bean</code> 注解标注的方法。</p>
<p>Debug 到这里，可以发现此处确实把配置类中的 <code>person()</code> 方法取了出来：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53a882320f584862a621524b721fa66b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>不过这里可能会有小伙伴产生疑惑：明明反射就可以拿到这些被 <code>@Bean</code> 注解标注的方法，但是中间的读取部分都把 ASM （读取字节码的技术）搬出来了，为什么要如此的大动干戈呢？哎，这里我们要多解释一个点了:<strong>使用 JVM 的标准反射，在不同的 JVM 、或者同一个 JVM 上的不同应用中，返回的方法列表顺序可能是不同的。</strong>简言之，<strong>JVM 的标准反射不保证方法列表返回的顺序一致</strong>。所以，想要保证程序在任何 JVM 上、任何应用中，加载同一个 .class 文件的方法列表都返回相同的顺序，那就只能读取字节码了，而读取字节码的技术，Spring 选择了 ASM 。</p>
<p>所以，这里 <strong>Spring 使用 ASM 读取字节码的目的，是为了保证加载配置类中 <code>@Bean</code> 方法的从上到下的顺序与源文件 .java 中一致</strong>。</p>
<h4 id="2-6-7-处理父接口"><a href="#2-6-7-处理父接口" class="headerlink" title="2.6.7 处理父接口"></a>2.6.7 处理父接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ............</span><br><span class="hljs-comment">// Process default methods on interfaces</span><br>processInterfaces(configClass, sourceClass);<br><span class="hljs-comment">// ............</span><br></code></pre></td></tr></table></figure>
<p>又是一个一句话方法，咱点进去看一看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processInterfaces</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">for</span> (SourceClass ifc : sourceClass.getInterfaces()) &#123;<br>        <span class="hljs-comment">// 寻找接口中标注了@Bean的方法</span><br>        Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(ifc);<br>        <span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;<br>            <span class="hljs-keyword">if</span> (!methodMetadata.isAbstract()) &#123;<br>                configClass.addBeanMethod(<span class="hljs-keyword">new</span> BeanMethod(methodMetadata, configClass));<br>            &#125;<br>        &#125;<br>        processInterfaces(configClass, ifc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意看这段逻辑，它会把配置类实现的所有接口都拿出来，并且遍历所有标注了 <code>@Bean</code> 的方法，并添加到 bean 的注册信息中。跟上面一样，它只是存起来，并没有封装为 <code>BeanDefinition</code> ，所以这里只是解析动作而已。</p>
<h4 id="2-6-8-父类的返回"><a href="#2-6-8-父类的返回" class="headerlink" title="2.6.8 父类的返回"></a>2.6.8 父类的返回</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ............</span><br>    <span class="hljs-comment">// Process superclass, if any</span><br>    <span class="hljs-keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;<br>        String superclass = sourceClass.getMetadata().getSuperClassName();<br>        <span class="hljs-keyword">if</span> (superclass != <span class="hljs-keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="hljs-string">&quot;java&quot;</span>) &amp;&amp;<br>                !<span class="hljs-keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;<br>            <span class="hljs-keyword">this</span>.knownSuperclasses.put(superclass, configClass);<br>            <span class="hljs-keyword">return</span> sourceClass.getSuperClass();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>终于看到最后一部分了，因为上面的解析处理逻辑都看完了，还剩下最后一个部分。如果配置类存在父类的话，父类也应该一起加载，所以这里会取到配置类的父类，并继续递归处理。逻辑相对的不算复杂，咱就不深入研究了。</p>
<h3 id="2-7-loadBeanDefinitions-加载BeanDefinition"><a href="#2-7-loadBeanDefinitions-加载BeanDefinition" class="headerlink" title="2.7 loadBeanDefinitions - 加载BeanDefinition"></a>2.7 loadBeanDefinitions - 加载BeanDefinition</h3><p>到这里，配置类的解析就完成了，回到 <code>ConfigurationClassPostProcessor</code> 中，解析完那些 <code>@Bean</code> 后还要注册为 <code>BeanDefinition</code> 呢，而这个方法的核心在 <code>loadBeanDefinitions</code> 中，我们也来研究。</p>
<p><code>this.reader.loadBeanDefinitions(configClasses);</code> 的执行会来到 <code>ConfigurationClassBeanDefinitionReader</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;<br>    TrackedConditionEvaluator trackedConditionEvaluator = <span class="hljs-keyword">new</span> TrackedConditionEvaluator();<br>    <span class="hljs-keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;<br>        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>又是循环，来吧，直接进到 <code>loadBeanDefinitionsForConfigurationClass</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForConfigurationClass</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;<br>    <span class="hljs-comment">// 与条件装配有关</span><br>    <span class="hljs-keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;<br>        String beanName = configClass.getBeanName();<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.registry.removeBeanDefinition(beanName);<br>        &#125;<br>        <span class="hljs-keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前配置类是被@Import的，要把自己注册进BeanFactory</span><br>    <span class="hljs-keyword">if</span> (configClass.isImported()) &#123;<br>        registerBeanDefinitionForImportedConfigurationClass(configClass);<br>    &#125;<br>    <span class="hljs-comment">// 注册@Bean注解方法</span><br>    <span class="hljs-keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;<br>        loadBeanDefinitionsForBeanMethod(beanMethod);<br>    &#125;<br><br>    <span class="hljs-comment">// 注册来自xml配置文件的bean</span><br>    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());<br>    <span class="hljs-comment">// 注册来自ImportBeanDefinitionRegistrar的bean</span><br>    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里面的逻辑分为 4 个部分，咱还是分别来看。</p>
<h4 id="2-7-1-registerBeanDefinitionForImportedConfigurationClass"><a href="#2-7-1-registerBeanDefinitionForImportedConfigurationClass" class="headerlink" title="2.7.1 registerBeanDefinitionForImportedConfigurationClass"></a>2.7.1 registerBeanDefinitionForImportedConfigurationClass</h4><p>第一个步骤是将配置类自身注册进 <code>BeanFactory</code> 。按照包扫描的原则来看，只要是 <code>@Configuration</code> ，那就必然也是 <code>@Component</code> ，就应该一起注册到 <code>BeanFactory</code> 中。但如果配置类是通过 <code>@Import</code> 的方式导入的，那就不会主动将自己注册进 <code>BeanFactory</code> ，所以在这里，它需要将那些被 <code>@Import</code> 进去的配置类，也全部注册到 <code>BeanFactory</code> 中。</p>
<p>从源码实现上看，这就是一个最最普通的 <code>BeanDefinition</code> 的注册，没有任何额外的花里胡哨的操作，所以这个我们也没必要深查了，看一下就好咯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitionForImportedConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass)</span> </span>&#123;<br>    AnnotationMetadata metadata = configClass.getMetadata();<br>    <span class="hljs-comment">// 构造BeanDefinition</span><br>    AnnotatedGenericBeanDefinition configBeanDef = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(metadata);<br><br>    ScopeMetadata scopeMetadata = scopeMetadataResolver.resolveScopeMetadata(configBeanDef);<br>    configBeanDef.setScope(scopeMetadata.getScopeName());<br>    String configBeanName = <span class="hljs-keyword">this</span>.importBeanNameGenerator.generateBeanName(configBeanDef, <span class="hljs-keyword">this</span>.registry);<br>    AnnotationConfigUtils.processCommonDefinitionAnnotations(configBeanDef, metadata);<br><br>    <span class="hljs-comment">// 包装BeanDefinitionHolder</span><br>    BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(configBeanDef, configBeanName);<br>    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>    <span class="hljs-comment">// 注册进BeanDefinitionRegistry</span><br>    <span class="hljs-keyword">this</span>.registry.registerBeanDefinition(definitionHolder.getBeanName(), definitionHolder.getBeanDefinition());<br>    configClass.setBeanName(configBeanName);<br>    <span class="hljs-comment">// logger ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-7-2-loadBeanDefinitionsForBeanMethod"><a href="#2-7-2-loadBeanDefinitionsForBeanMethod" class="headerlink" title="2.7.2 loadBeanDefinitionsForBeanMethod"></a>2.7.2 loadBeanDefinitionsForBeanMethod</h4><p>这个步骤就是加载刚才处理过的那些 <code>@Bean</code> 方法了，咱来看看它怎么处理。（又是一段很长的源码，这里只截取关键的部分，小伙伴们看看关键流程即可）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForBeanMethod</span><span class="hljs-params">(BeanMethod beanMethod)</span> </span>&#123;<br>    ConfigurationClass configClass = beanMethod.getConfigurationClass();<br>    MethodMetadata metadata = beanMethod.getMetadata();<br>    String methodName = metadata.getMethodName();<br><br>    <span class="hljs-comment">// 如果条件装配将其跳过，则该@Bean标注的方法，对应的BeanDefinition不会注册进BeanDefinitionRegistry</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;<br>        configClass.skippedBeanMethods.add(methodName);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (configClass.skippedBeanMethods.contains(methodName)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查方法上真的有@Bean注解吗</span><br>    AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);<br>    <span class="hljs-comment">// assert ......</span><br><br>    <span class="hljs-comment">// 如果bean指定了多个name，则第1个为唯一标识，其余的都是alias别名</span><br>    List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="hljs-string">&quot;name&quot;</span>)));<br>    String beanName = (!names.isEmpty() ? names.remove(<span class="hljs-number">0</span>) : methodName);<br>    <span class="hljs-comment">// Register aliases even when overridden</span><br>    <span class="hljs-keyword">for</span> (String alias : names) &#123;<br>        <span class="hljs-keyword">this</span>.registry.registerAlias(beanName, alias);<br>    &#125;<br><br>    <span class="hljs-comment">// 注解中配置了@Bean，与xml中的bean撞车了，会抛出异常</span><br>    <span class="hljs-keyword">if</span> (isOverriddenByExistingDefinition(beanMethod, beanName)) &#123;<br>        <span class="hljs-keyword">if</span> (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) &#123;<br>            <span class="hljs-comment">// throw ex ......</span><br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 构造BeanDefinition</span><br>    ConfigurationClassBeanDefinition beanDef = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinition(configClass, metadata);<br>    beanDef.setSource(<span class="hljs-keyword">this</span>.sourceExtractor.extractSource(metadata, configClass.getResource()));<br><br>    <span class="hljs-comment">// 【复杂】解析@Bean所在方法的修饰符</span><br>    <span class="hljs-keyword">if</span> (metadata.isStatic()) &#123;<br>        <span class="hljs-comment">// static @Bean method</span><br>        <span class="hljs-keyword">if</span> (configClass.getMetadata() <span class="hljs-keyword">instanceof</span> StandardAnnotationMetadata) &#123;<br>            beanDef.setBeanClass(((StandardAnnotationMetadata) configClass.getMetadata()).getIntrospectedClass());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            beanDef.setBeanClassName(configClass.getMetadata().getClassName());<br>        &#125;<br>        beanDef.setUniqueFactoryMethodName(methodName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// instance @Bean method</span><br>        beanDef.setFactoryBeanName(configClass.getBeanName());<br>        beanDef.setUniqueFactoryMethodName(methodName);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理@Bean的属性(name、initMethod等)、额外的注解(@Lazy、@DependsOn等) ......</span><br><br>    <span class="hljs-comment">// 注册进BeanDefinitionRegistry</span><br>    <span class="hljs-keyword">this</span>.registry.registerBeanDefinition(beanName, beanDefToRegister);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一样标准的套路：检查 → 构造 <code>BeanDefinition</code> → 封装信息 → 注册进 <code>BeanDefinitionRegistry</code> 。最下面的部分，那些处理 <code>@Bean</code> 的属性、额外的注解解析都比较简单了，小伙伴们可以自行借助 IDE 去看看，小册就不展开解释了。</p>
<p>不过这里面有一个还蛮关键的部分，要给小伙伴们解释一下，就是上面的这个 <code>metadata.isStatic()</code> ，它的判断逻辑下面，会给 <code>BeanDefinition</code> 封装两个属性：<code>setBeanClassName</code> / <code>setFactoryBeanName</code> 、<code>setUniqueFactoryMethodName</code> ，它们俩分别指定了当前 <code>@Bean</code> 方法所在的配置类，以及方法名。小伙伴们可以先猜想一下，封装它的作用是什么呢？</p>
<p>回想一下前面 <code>@Component</code> 注解标注的类形成的 <code>BeanDefinition</code> ，以及 xml 配置文件转换出来的 <code>BeanDefinition</code> 有个什么特点？它们<strong>都指定了 bean 的全限定名、属性注入等</strong>，而且最终创建的对象一定是通过<strong>反射</strong>创建。而在注解配置类中的 <code>@Bean</code> 方法是<strong>有实际的代码执行</strong>，属于<strong>编程式创建</strong>，无法使用（也不适合用）反射创建 bean 对象，所以<strong>为了在后面能正常创建出 bean 对象，此处就需要记录该 bean 的定义源（包含注解配置类和方法名），以保证在创建 bean 对象时，能够使用反射调用该注解配置类的方法，生成 bean 对象并返回</strong>。</p>
<h4 id="2-7-3-loadBeanDefinitionsFromImportedResources"><a href="#2-7-3-loadBeanDefinitionsFromImportedResources" class="headerlink" title="2.7.3 loadBeanDefinitionsFromImportedResources"></a>2.7.3 loadBeanDefinitionsFromImportedResources</h4><p>这部分是解析从注解配置类上取到的 xml 配置文件的路径，有了前面的分析，我们马上就能猜到，它又要用 XmlBeanDefinitionReader 那一套来搞了，点开源码，发现果然如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsFromImportedResources</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Map&lt;String, Class&lt;? extends BeanDefinitionReader&gt;&gt; importedResources)</span> </span>&#123;<br><br>    Map&lt;Class&lt;?&gt;, BeanDefinitionReader&gt; readerInstanceCache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    importedResources.forEach((resource, readerClass) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (BeanDefinitionReader.class == readerClass) &#123;<br>            <span class="hljs-keyword">if</span> (StringUtils.endsWithIgnoreCase(resource, <span class="hljs-string">&quot;.groovy&quot;</span>)) &#123;<br>                readerClass = GroovyBeanDefinitionReader.class;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 创建XmlBeanDefinitionReader，以备下面的解析</span><br>                readerClass = XmlBeanDefinitionReader.class;<br>            &#125;<br>        &#125;<br><br>        BeanDefinitionReader reader = readerInstanceCache.get(readerClass);<br>        <span class="hljs-comment">// reader的缓存等等</span><br><br>        <span class="hljs-comment">// 调用XmlBeanDefinitionReader解析资源文件</span><br>        reader.loadBeanDefinitions(resource);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很容易理解了吧，里面的套路想必不用小册多解释，小伙伴们自己就已经有很清楚的认识了吧。</p>
<h4 id="2-7-4-loadBeanDefinitionsFromRegistrars"><a href="#2-7-4-loadBeanDefinitionsFromRegistrars" class="headerlink" title="2.7.4 loadBeanDefinitionsFromRegistrars"></a>2.7.4 loadBeanDefinitionsFromRegistrars</h4><p>最后一部分是执行 <code>ImportBeanDefinitionRegistrar</code> ，这个就更简单了，既然是接口，那执行它们的话，只需要调用 <code>registerBeanDefinitions</code> 方法就可以吧，进到方法内部，发现真就是这么简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsFromRegistrars</span><span class="hljs-params">(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars)</span> </span>&#123;<br>    registrars.forEach((registrar, metadata) -&gt;<br>            registrar.registerBeanDefinitions(metadata, <span class="hljs-keyword">this</span>.registry, <span class="hljs-keyword">this</span>.importBeanNameGenerator));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>OK ，那到此为止，注解配置类中 <code>BeanDefinition</code> 的注册也就全部理清楚了，顺便我们把整个注解配置类的解析流程和逻辑也都研究了一遍，小伙伴们要做好笔记呀。</p>
<h3 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h3><p>同样总结一下注解配置类的加载与解析过程：<strong>注解配置类的解析发生在 <code>BeanDefinitionRegistryPostProcessor</code> 的执行阶段，它对应的核心后置处理器是 <code>ConfigurationClassPostProcessor</code> ，它主要负责两个步骤三件事情：解析配置类、注册 <code>BeanDefinition</code> 。三件事情包括：1) 解析 <code>@ComponentScan</code> 并进行包扫描，实际进行包扫描的组件是 <code>ClassPathBeanDefinitionScanner</code> ；2) 解析配置类中的注解（如 <code>@Import</code> 、<code>@ImportResource</code> 、<code>@PropertySource</code> 等）并处理，工作的核心组件是 <code>ConfigurationClassParser</code> ；3) 解析配置类中的 <code>@Bean</code> 并封装 <code>BeanDefinition</code> ，实际解析的组件是 <code>ConfigurationClassBeanDefinitionReader</code></strong> 。</p>
<h2 id="3-BeanDefinition的后置处理"><a href="#3-BeanDefinition的后置处理" class="headerlink" title="3. BeanDefinition的后置处理"></a>3. BeanDefinition的后置处理</h2><p>执行完 <code>ConfigurationClassPostProcessor</code> 之后，在 xml 和配置类中定义的 <code>BeanDefinition</code> 就都解析和准备好了，但是还没有加载进 <code>BeanDefinitionRegistry</code> 中。下面还会有 <code>BeanDefinitionRegistryPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 的执行，而它们的执行时机还是上面的 <code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</code> 方法中（嗯，还是那个死老长的方法）。</p>
<p>至于这些处理的机制，咱在前面的 28 章 <code>BeanFactoryPostProcessor</code> 章节都讲解过了，如果忘记的小伙伴们记得回去复习哦。</p>
<p>执行完这些后置处理器之后，<code>BeanDefinition</code> 的后置处理也就算结束了。</p>
<hr>
<h2 id="面试如何回答BeanDefinition部分的生命周期"><a href="#面试如何回答BeanDefinition部分的生命周期" class="headerlink" title="面试如何回答BeanDefinition部分的生命周期"></a>面试如何回答BeanDefinition部分的生命周期</h2><p>以下答案<strong>仅供参考</strong>，可根据个人理解进行实际调整：</p>
<p><strong>首先，bean 的生命周期分为 <code>BeanDefinition</code> 阶段和 bean 实例阶段。</strong></p>
<blockquote>
<p>这里多提醒一句，能在 bean 的生命周期中回答出 <code>BeanDefinition</code> 相当重要且关键！</p>
</blockquote>
<p><code>BeanDefinition</code> 阶段分为加载 xml 配置文件、解析注解配置类、编程式构造 <code>BeanDefinition</code> 、<code>BeanDefinition</code> 的后置处理，一共四个部分。</p>
<ol>
<li><strong>加载 xml 配置文件</strong> 发生在基于 xml 配置文件的 <code>ApplicationContext</code> 中 <code>refresh</code> 方法的 <code>BeanFactory</code> 初始化阶段，此时 <code>BeanFactory</code> 刚刚构建完成，它会借助 <code>XmlBeanDefinitionReader</code> 来加载 xml 配置文件，并使用 <code>DefaultBeanDefinitionDocumentReader</code> 解析 xml 配置文件，封装声明的 <code>&lt;bean&gt;</code> 标签内容并转换为 <code>BeanDefinition</code> 。</li>
<li><strong>解析注解配置类</strong> 发生在 <code>ApplicationContext</code> 中 <code>refresh</code> 方法的 <code>BeanDefinitionRegistryPostProcessor</code> 执行阶段，该阶段首先会执行 <code>ConfigurationClassPostProcessor</code> 的 <code>postProcessBeanDefinitionRegistry</code> 方法。<code>ConfigurationClassPostProcessor</code> 中会找出所有的配置类，排序后依次解析，并借助 <code>ClassPathBeanDefinitionScanner</code> 实现包扫描的 <code>BeanDefinition</code> 封装，借助 <code>ConfigurationClassBeanDefinitionReader</code> 实现 <code>@Bean</code> 注解方法的 <code>BeanDefinition</code> 解析和封装。</li>
<li><strong>编程式构造 <code>BeanDefinition</code></strong> 也是发生在 <code>ApplicationContext</code> 中 <code>refresh</code> 方法的 <code>BeanDefinitionRegistryPostProcessor</code> 执行阶段，由于 <code>BeanDefinitionRegistryPostProcessor</code> 中包含 <code>ConfigurationClassPostProcessor</code> ，而 <code>ConfigurationClassPostProcessor</code> 会执行 <code>ImportBeanDefinitionRegistrar</code> 的逻辑，从而达到编程式构造 <code>BeanDefinition</code> 并注入到 <code>BeanDefinitionRegistry</code> 的目的；另外，实现了 <code>BeanDefinitionRegistryPostProcessor</code> 的类也可以编程式构造 <code>BeanDefinition</code> ，注入 <code>BeanDefinitionRegistry</code> 。</li>
</ol>
<h1 id="三、Bean的生命周期-Bean的实例化阶段"><a href="#三、Bean的生命周期-Bean的实例化阶段" class="headerlink" title="三、Bean的生命周期-Bean的实例化阶段"></a>三、Bean的生命周期-Bean的实例化阶段</h1><p>上一章，我们对 <code>BeanDefinition</code> 阶段的加载、解析、注册都有了一个清晰的了解和深入研究，本章我们要研究的，是在 bean 的初始化阶段，bean 的实例化过程。</p>
<p>本章主要会涉及到的原理部分：</p>
<ul>
<li><code>BeanPostProcessor</code> 的注册</li>
<li>bean 的实例化动作及方式</li>
</ul>
<p>好，下面我们进入源码分析。上一章我们说过了，**<code>refresh</code>** 方法承载了 <code>ApplicationContext</code> 的整体初始化动作，而这里面初始化 bean 的逻辑在第 11 步。不过在此之前，还有一个非常重要的部分，它就是 <code>BeanPostProcessor</code> 的注册动作，这两个动作在 <code>refresh</code> 方法中的位置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        prepareRefresh();<br>        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>        prepareBeanFactory(beanFactory);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            postProcessBeanFactory(beanFactory);<br>            invokeBeanFactoryPostProcessors(beanFactory);<br>            <span class="hljs-comment">// 6. 注册BeanPostProcessor</span><br>            registerBeanPostProcessors(beanFactory);<br>            initMessageSource();<br>            initApplicationEventMulticaster();<br>            onRefresh();<br>            registerListeners();<br>            <span class="hljs-comment">// 11. 初始化剩余的单实例Bean</span><br>            finishBeanFactoryInitialization(beanFactory);<br>            finishRefresh();<br>        &#125;<br>        <span class="hljs-comment">// catch ......</span><br>        <span class="hljs-keyword">finally</span> &#123;<br>            resetCommonCaches();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面我们先来解析 <code>registerBeanPostProcessors</code> 动作。</p>
<h2 id="1-注册BeanPostProcessor"><a href="#1-注册BeanPostProcessor" class="headerlink" title="1. 注册BeanPostProcessor"></a>1. 注册BeanPostProcessor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>又是走了 <code>PostProcessorRegistrationDelegate</code> 的方法，那我们就跳转过去看看吧：（前方又是一大篇源码，每个小代码节都标注了注释，请注意分辨源码中相同与不同的部分）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;<br><br>    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br><br>    <span class="hljs-comment">// Register BeanPostProcessorChecker that logs an info message when</span><br>    <span class="hljs-comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span><br>    <span class="hljs-comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span><br>    <span class="hljs-comment">// 1.1 此处会先注册一个BeanPostProcessorChecker</span><br>    <span class="hljs-keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="hljs-number">1</span> + postProcessorNames.length;<br>    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));<br><br>    <span class="hljs-comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span><br>    <span class="hljs-comment">// Ordered, and the rest.</span><br>    <span class="hljs-comment">// 根据排序规则，给所有的后置处理器分类</span><br>    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>        <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>            <span class="hljs-comment">// 1.2 注意此处，PriorityOrdered类型的后置处理器被提前初始化了</span><br>            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>            priorityOrderedPostProcessors.add(pp);<br>            <span class="hljs-comment">// MergedBeanDefinitionPostProcessor要额外筛出来</span><br>            <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>                internalPostProcessors.add(pp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>            orderedPostProcessorNames.add(ppName);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            nonOrderedPostProcessorNames.add(ppName);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span><br>    <span class="hljs-comment">// 首先，注册所有实现了PriorityOrdered接口的后置处理器</span><br>    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br>    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);<br><br>    <span class="hljs-comment">// Next, register the BeanPostProcessors that implement Ordered.</span><br>    <span class="hljs-comment">// 其次，注册所有实现了Ordered接口的后置处理器</span><br>    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());<br>    <span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;<br>        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>        orderedPostProcessors.add(pp);<br>        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>            internalPostProcessors.add(pp);<br>        &#125;<br>    &#125;<br>    sortPostProcessors(orderedPostProcessors, beanFactory);<br>    registerBeanPostProcessors(beanFactory, orderedPostProcessors);<br><br>    <span class="hljs-comment">// Now, register all regular BeanPostProcessors.</span><br>    <span class="hljs-comment">// 最后，注册所有普通的后置处理器</span><br>    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());<br>    <span class="hljs-keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;<br>        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>        nonOrderedPostProcessors.add(pp);<br>        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>            internalPostProcessors.add(pp);<br>        &#125;<br>    &#125;<br>    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);<br><br>    <span class="hljs-comment">// Finally, re-register all internal BeanPostProcessors.</span><br>    <span class="hljs-comment">// 1.3 注意此处，所有MergedBeanDefinitionPostProcessor又被注册了一次</span><br>    sortPostProcessors(internalPostProcessors, beanFactory);<br>    registerBeanPostProcessors(beanFactory, internalPostProcessors);<br><br>    <span class="hljs-comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span><br>    <span class="hljs-comment">// moving it to the end of the processor chain (for picking up proxies etc).</span><br>    <span class="hljs-comment">// 最后又注册了一个ApplicationListenerDetector（27章3.2节）</span><br>    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(applicationContext));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>来，理一下这个方法的整体逻辑脉络：首先它会先获取到 IOC 容器中已经有的 <code>BeanPostProcessor</code> 的 name ，获取到之后先不处理，先注册一个 <strong><code>BeanPostProcessorChecker</code></strong> ，然后才是处理那些 <code>BeanPostProcessor</code> 。<strong>处理 <code>BeanPostProcessor</code> 的过程跟 <code>BeanFactoryPostProcessor</code> 部分十分相似</strong>，不过对比起这三个逻辑处理，<strong>实现了 <code>PriorityOrdered</code> 接口的后置处理器似乎有 “特权”</strong> ，它们会<strong>在所有的 <code>BeanPostProcessor</code> 注册之前先初始化好</strong>。当这三种后置处理器都注册完成后，它<strong>又将所有的 <code>MergedBeanDefinitionPostProcessor</code> 类型的后置处理器重新注册了一遍</strong>，最后又注册了一个 <strong><code>ApplicationListenerDetector</code></strong> 。</p>
<p>整个逻辑倒是清晰，但这里面的操作实在是很迷惑，这些经过设计的动作究竟是为何呢，下面咱一一解释。</p>
<h3 id="1-1-BeanPostProcessorChecker"><a href="#1-1-BeanPostProcessorChecker" class="headerlink" title="1.1 BeanPostProcessorChecker"></a>1.1 BeanPostProcessorChecker</h3><p>从类名上看，它是一个后置处理器的<strong>检查器</strong>，可它本身也是个后置处理器，那它检查个啥咧？咱先试着从 javadoc 中获取一点信息吧：</p>
<blockquote>
<p>BeanPostProcessor that logs an info message when a bean is created during BeanPostProcessor instantiation, i.e. when a bean is not eligible for getting processed by all BeanPostProcessors.</p>
<p>它是一个 <code>BeanPostProcessor</code> ，当在 <code>BeanPostProcessor</code> 实例化期间创建 Bean 时，即当某个 Bean 不能被所有 <code>BeanPostProcessor</code> 处理时，它会记录一条信息。</p>
</blockquote>
<p>原来如此，它的作用是<strong>检查 <code>BeanPostProcessor</code> 的初始化阶段中是否有 bean 的意外创建</strong>。注意这个 “意外创建” ，其实它不意外，如果在 <code>BeanPostProcessor</code> 中<strong>有注入其它的普通 bean</strong> ，根据依赖注入的原则，会<strong>在 <code>BeanPostProcessor</code> 的创建之前，先把这些注入的普通 bean 先初始化出来</strong>，又因为当前阶段 <strong><code>BeanPostProcessor</code> 还没有初始化完毕</strong>，这些<strong>普通 bean 还没有来得及被 <code>BeanPostProcessor</code> 处理</strong>，导致出现 bean 的 “<strong>残缺不全</strong>” 。<code>BeanPostProcessorChecker</code> 的作用，就是用来提醒我们开发者对该问题引起注意。</p>
<p>其实，如果有用过 Spring 的小伙伴，在开发时遇到这种日志：<code>xxxxxx is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)</code> ，这就意味着你的 <code>BeanPostProcessor</code> 中有注入普通 bean 了，需要给代码作出调整。</p>
<p>从源码的角度上分析，注意看 <code>PostProcessorRegistrationDelegate</code> 的 <code>registerBeanPostProcessors</code> 方法中，它将所有的 <code>BeanPostProcessor</code> 都取出来，随后计算出了所有的 <code>BeanPostProcessor</code> 的数量是 <code>beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length</code> ，即<strong>所有的后置处理器数量 + 1</strong>。</p>
<p>另外，在 <code>BeanPostProcessorChecker</code> 的 <code>postProcessAfterInitialization</code> 方法中，它会检查当前 <code>BeanFactory</code> 中的后置处理器数量是否少于一开始计算的预计后置处理器数量，如果少了，那就代表有 bean 被提前创建了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// 此处判断是否有普通bean被提前创建</span><br>    <span class="hljs-keyword">if</span> (!(bean <span class="hljs-keyword">instanceof</span> BeanPostProcessor) &amp;&amp; !isInfrastructureBean(beanName) &amp;&amp;<br>            <span class="hljs-keyword">this</span>.beanFactory.getBeanPostProcessorCount() &lt; <span class="hljs-keyword">this</span>.beanPostProcessorTargetCount) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>            logger.info(<span class="hljs-string">&quot;Bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; of type [&quot;</span> + bean.getClass().getName() +<br>                    <span class="hljs-string">&quot;] is not eligible for getting processed by all BeanPostProcessors &quot;</span> +<br>                    <span class="hljs-string">&quot;(for example: not eligible for auto-proxying)&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-2-PriorityOrdered类型的后置处理器被提前创建的目的"><a href="#1-2-PriorityOrdered类型的后置处理器被提前创建的目的" class="headerlink" title="1.2 PriorityOrdered类型的后置处理器被提前创建的目的"></a>1.2 PriorityOrdered类型的后置处理器被提前创建的目的</h3><p>我们仔细看一下这段代码的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>    <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>        <span class="hljs-comment">// 实现了PriorityOrdered接口的BeanPostProcessor被提前初始化了</span><br>        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>        priorityOrderedPostProcessors.add(pp);<br>        <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>            internalPostProcessors.add(pp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>        orderedPostProcessorNames.add(ppName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        nonOrderedPostProcessorNames.add(ppName);<br>    &#125;<br>&#125;<br><br>sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br>registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);<br><br>List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());<br><span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;<br>    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>    orderedPostProcessors.add(pp);<br>    <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>        internalPostProcessors.add(pp);<br>    &#125;<br>&#125;<br>sortPostProcessors(orderedPostProcessors, beanFactory);<br>registerBeanPostProcessors(beanFactory, orderedPostProcessors);<br></code></pre></td></tr></table></figure>
<p>这段源码中很明显可以看懂，实现了 <code>PriorityOrdered</code> 接口的 <code>BeanPostProcessor</code> 被提前初始化了，这是为什么呢？</p>
<p>这里先不解释原因，我们先对这段源码做两次变式，看看如果修改逻辑之后会出现什么问题。</p>
<h4 id="1-2-1-变式一：如果循环过程中顺便初始化"><a href="#1-2-1-变式一：如果循环过程中顺便初始化" class="headerlink" title="1.2.1 变式一：如果循环过程中顺便初始化"></a>1.2.1 变式一：如果循环过程中顺便初始化</h4><p>如果说先把后置处理器的全限定名都取出来，再实例化出来是多此一举，那每次循环的时候直接初始化出来不好吗？就像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>     <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>         <span class="hljs-comment">// 初始化实现了PriorityOrdered接口的后置处理器</span><br>         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>         priorityOrderedPostProcessors.add(pp);<br>         <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>             internalPostProcessors.add(pp);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>         <span class="hljs-comment">// 初始化实现了Ordered接口的后置处理器</span><br>         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>         orderedPostProcessors.add(pp);<br>         <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>             internalPostProcessors.add(pp);<br>         &#125;<br>     &#125;<br>     <span class="hljs-comment">// else ......</span><br> &#125;<br></code></pre></td></tr></table></figure>
<p>这样会有什么问题呢？我们可以假想一个故事场景来演绎一下。</p>
<blockquote>
<p>注：该故事仅为虚拟场景的情节演绎，小伙伴们切勿模仿该行为！！！！！！</p>
</blockquote>
<p>现在有三个 “黑社会” 熊猫（代指三个后置处理器），他们仨常蹲在路口边上打劫收保护费，他们平常 “作案” 的流程是这样的：老大负责恐吓威胁路人，把路人吓唬住了就带到老二那边收保护费，如果路人不交保护费，则老三直接上去一个酒瓶子把路人抡倒，就像这样：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf80349238ae4533ba055868cb8ca45c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<blockquote>
<p>解释一下这个场景的一些要素哈：此处我们假定老大实现了 <code>PriorityOrdered</code> 接口，老二和老三实现了 <code>Ordered</code> 接口。按理讲，老大的出手时机一定比老二和老三早（ <code>PriorityOrdered</code> 接口的处理时机比 <code>Ordered</code> 早）。</p>
<p>老大威胁路人的行为在此处比作正常的 bean 初始化阶段的 <code>postProcessBeforeInitialization</code> 方法回调，老三拿酒瓶子抡路人的行为在此处比作 bean 初始化阶段的 <code>postProcessAfterInitialization</code> 方法回调。所以我们在这里虚拟的场景是这样：每个路人是一个普通的 bean ，在 bean 执行初始化阶段的回调之前会有 <code>BeanPostProcessor</code> 去拦截一下 bean 并作额外处理（也就是收路人的保护费）。</p>
</blockquote>
<p>平常每天都是老大先找准了蹲点的地方，埋伏好了之后老二和老三就赶过来，就这样哥仨一直靠收路人的保护费混日子。不过这个场景在某天出现了意外，那天<strong>老三</strong>喝多了，大清早的天还没亮就<strong>带着老二先出发了</strong>，随便找了一个点就埋伏好了，等路人经过就去收他钱。好巧不巧，这天<strong>老大就路过了老三所在的这个点</strong>，老三喝多了啊，连自己老大都不认识了，就去叫老二去收保护费，本来就是天还没亮就被老三叫起来，老二也睡眼惺忪的，就让他老大交钱。老大也懵了啊，我去不会这片地儿还有另一派黑恶势力？可是昨天我刚跟我那两个兄弟喝酒了啊，没钱了咋整。这就尴尬了，老二没看清是老大，就让老三上去收拾了，结果老三一个酒瓶子下去，把老大敲懵了。。。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc5f8b9182a942edad8312a5997f77d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<blockquote>
<p>好，故事到这里停一下，咱讲讲这个情节对应的代码实现。在这种意外场景下，由于<strong>老二和老三在所有 <code>BeanPostProcessor</code> 列表的前置位</strong>，导致它们（这两个实现了 <code>Ordered</code> 接口的后置处理器）先被读取。如果此时初始化后置处理器的代码逻辑是上面的变式，则上面的故事情景就会发生：老二和老三先注册到了 <code>ApplicationContext</code> 中，它们已经开始起作用了。之后即便再来老大（实现了 <code>PriorityOrdered</code> 接口的后置处理器）的时候，老二和老三把老大当普通路人看待了（即 被后置处理器处理了），于是就把老大揍了，导致结果出现意外（程序出现错误）。</p>
</blockquote>
<p>所以到这里，小伙伴们是否理解了为什么不能在循环中顺便初始化 <code>BeanPostProcessor</code> 了吧，咱简单总结一下：</p>
<p><strong>如果 <code>BeanPostProcessor</code> 的初始化逻辑是一边循环一边初始化，则可能会导致优先级低的 <code>BeanPostProcessor</code> 干预了优先级高的 <code>BeanPostProcessor</code> ，从而引发程序的运行情况异常。而正确的做法就是只初始化最高优先级的 <code>BeanPostProcessor</code> ，其余的都只是记录下全限定名，等所有最高优先级的 <code>BeanPostProcessor</code> 都初始化完成后，再依次初始化低优先级的 <code>BeanPostProcessor</code> （优先级低的 <code>BeanPostProcessor</code> 可能也需要被优先级高的 <code>BeanPostProcessor</code> 处理）。</strong></p>
<h4 id="1-2-2-变式二：如果循环过程中不初始化"><a href="#1-2-2-变式二：如果循环过程中不初始化" class="headerlink" title="1.2.2 变式二：如果循环过程中不初始化"></a>1.2.2 变式二：如果循环过程中不初始化</h4><p>既然不能一边循环一边初始化，那为什么不先循环完事了，再依次初始化呢，就像这样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;String&gt; priorityOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>    <span class="hljs-comment">// 只循环，不初始化</span><br>    <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>        priorityOrderedPostProcessorNames.add(ppName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>        orderedPostProcessorNames.add(ppName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        nonOrderedPostProcessorNames.add(ppName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 此处再依次初始化实现了PriorityOrdered接口的BeanPostProcessor</span><br>List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span> (String ppName : priorityOrderedPostProcessorNames) &#123;<br>    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>    priorityOrderedPostProcessors.add(pp);<br>    <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>        internalPostProcessors.add(pp);<br>    &#125;<br>&#125;<br>sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br>registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);<br><br><span class="hljs-comment">// 初始化实现了Ordered接口的BeanPostProcessor</span><br>List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());<br><span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;<br>    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);<br>    orderedPostProcessors.add(pp);<br>    <span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;<br>        internalPostProcessors.add(pp);<br>    &#125;<br>&#125;<br>sortPostProcessors(orderedPostProcessors, beanFactory);<br>registerBeanPostProcessors(beanFactory, orderedPostProcessors);<br></code></pre></td></tr></table></figure>
<p>这样写有问题吗？当然没问题，但是我想请小伙伴们看一下<strong>这个过程中创建的 <code>List</code> 集合有几个</strong>，跟源代码的比较如何？</p>
<p>很明显，它多创建了一个 <code>priorityOrderedPostProcessorNames</code> 吧！但是增加这一个 <code>List</code> 后并没有给整体代码的时间复杂度带来有效降低，反而还增加了一轮循环（遍历 <code>priorityOrderedPostProcessorNames</code> 集合），所以 SpringFramework 的开发者将此处实现了 <code>PriorityOrdered</code> 接口的 <code>BeanPostProcessor</code> 提前初始化好了，这样<strong>不光节省了内存消耗（降低空间复杂度），还少了一轮循环（降低时间复杂度）</strong>。由此我们不得不佩服这些写框架的大佬，他们对代码的优化实在是高！</p>
<h4 id="1-2-3-PriorityOrdered接口到底都有啥"><a href="#1-2-3-PriorityOrdered接口到底都有啥" class="headerlink" title="1.2.3 PriorityOrdered接口到底都有啥"></a>1.2.3 PriorityOrdered接口到底都有啥</h4><p>既然 SpringFramework 中要这么干，那看来 <code>PriorityOrdered</code> 这个接口是很重要且关键的吧！那问题就来了，这些实现了 <code>PriorityOrdered</code> 接口的后置处理器都是些干啥的呢？小册来随便列举两个，小伙伴们一看便知：</p>
<ul>
<li><code>AutowiredAnnotationBeanPostProcessor</code> —— 处理 <code>@Autowired</code> 注解</li>
<li><code>CommonAnnotationBeanPostProcessor</code> —— 处理 JSR250 规范的注解</li>
</ul>
<p>得，看来确实很关键了，如果这两个后置处理器不先初始化好的话，后面的东西就别想用咱平常用的 <code>@Autowired</code> 、<code>@PostConstruct</code> 等等的注解了。所以说这些实现了 <code>PriorityOrdered</code> 接口的组件通常都是些<strong>内置的核心组件</strong>，SpringFramework 为了保证功能的正常运转，就必须要让这些核心组件都正常到位才可以。</p>
<h3 id="1-3-MergedBeanDefinitionPostProcessor被重复注册"><a href="#1-3-MergedBeanDefinitionPostProcessor被重复注册" class="headerlink" title="1.3 MergedBeanDefinitionPostProcessor被重复注册"></a>1.3 MergedBeanDefinitionPostProcessor被重复注册</h3><p>在整个方法的接近最后部分，这里有一句很迷的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Finally, re-register all internal BeanPostProcessors.</span><br>sortPostProcessors(internalPostProcessors, beanFactory);<br><span class="hljs-comment">// 重复注册了一次？？？</span><br>registerBeanPostProcessors(beanFactory, internalPostProcessors);<br></code></pre></td></tr></table></figure>
<p>不是，这些后置处理器不是在前面初始化完成了，一起注册了吗？咋这里又重新注册一遍？不怕重复了吗？</p>
<p>哎，伙计，你都想到了，你觉得写框架的那些大佬会想不到吗？咱进入 <code>registerBeanPostProcessors</code> 方法中看一眼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;<br>        beanFactory.addBeanPostProcessor(postProcessor);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBeanPostProcessor</span><span class="hljs-params">(BeanPostProcessor beanPostProcessor)</span> </span>&#123;<br>    Assert.notNull(beanPostProcessor, <span class="hljs-string">&quot;BeanPostProcessor must not be null&quot;</span>);<br>    <span class="hljs-comment">// Remove from old position, if any</span><br>    <span class="hljs-comment">// 如果后置处理器已经存在，则移除</span><br>    <span class="hljs-keyword">this</span>.beanPostProcessors.remove(beanPostProcessor);<br>    <span class="hljs-comment">// Track whether it is instantiation/destruction aware</span><br>    <span class="hljs-keyword">if</span> (beanPostProcessor <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;<br>        <span class="hljs-keyword">this</span>.hasInstantiationAwareBeanPostProcessors = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (beanPostProcessor <span class="hljs-keyword">instanceof</span> DestructionAwareBeanPostProcessor) &#123;<br>        <span class="hljs-keyword">this</span>.hasDestructionAwareBeanPostProcessors = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// Add to end of list</span><br>    <span class="hljs-comment">// 添加至后置处理器列表的末尾</span><br>    <span class="hljs-keyword">this</span>.beanPostProcessors.add(beanPostProcessor);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>喔原来如此，它是将这些 <code>MergedBeanDefinitionPostProcessor</code> 类型的后置处理器<strong>都放到了整个后置处理器列表的最后</strong>了！仅此而已。</p>
<h4 id="1-3-1-MergedBeanDefinitionPostProcessor后置的目的"><a href="#1-3-1-MergedBeanDefinitionPostProcessor后置的目的" class="headerlink" title="1.3.1 MergedBeanDefinitionPostProcessor后置的目的"></a>1.3.1 MergedBeanDefinitionPostProcessor后置的目的</h4><p>还记得之前第 27 章中讲到的 <code>MergedBeanDefinitionPostProcessor</code> 应用吗？<code>AutowiredAnnotationBeanPostProcessor</code> 会根据 merge 后的 <code>BeanDefinition</code> ，给 bean 对象进行依赖注入。这个策略是 SpringFramework 内置的既定策略，过会在下面依赖注入的部分我们会讲到。</p>
<hr>
<p>到这里，<code>BeanPostProcessor</code> 就初始化好了，下面就可以进入到 <code>refresh</code> 方法的第 11 步，<code>finishBeanFactoryInitialization</code> 方法中了，我们以测试代码中的 Cat 为例，来跟踪它的实例化过程。</p>
<h2 id="2-finishBeanFactoryInitialization"><a href="#2-finishBeanFactoryInitialization" class="headerlink" title="2. finishBeanFactoryInitialization"></a>2. finishBeanFactoryInitialization</h2><p>整个方法中，唯一处理单实例 bean 初始化的动作是最后一行，其余的部分我们不关心：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// ......</span><br><br>    <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>    beanFactory.preInstantiateSingletons();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>来到 <code>DefaultListableBeanFactory</code> 中，看看 <code>preInstantiateSingletons</code> 的实现：（只关心关键的实例化部分即可，可跟随源码中的注释一起看）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-comment">// logger ......</span><br><br>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);<br><br>    <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><br>    <span class="hljs-comment">// 此处循环初始化剩余的非延迟加载的单实例bean</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-comment">// 先合并BeanDefinition</span><br>        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);<br>        <span class="hljs-comment">// 不是抽象的、不是延迟加载的单实例bean要初始化</span><br>        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>            <span class="hljs-comment">// FactoryBean默认不立即初始化，除非指定isEagerInit=true</span><br>            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br>                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);<br>                <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<br>                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<br>                    <span class="hljs-keyword">boolean</span> isEagerInit;<br>                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;<br>                        isEagerInit = AccessController.doPrivileged(<br>                                (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,<br>                                getAccessControlContext());<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;<br>                                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>                        getBean(beanName);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 普通的初始化，就是getBean方法</span><br>                getBean(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化的最后阶段 ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>纵观整段源码，可以发现处理思路还是蛮清晰的，这里面最最关键的初始化 bean 的动作，就是我们从一开始学习 SpringFramework 就用的 <strong><code>getBean</code></strong> 方法！！！</p>
<h3 id="2-1-getBean-→-doGetBean"><a href="#2-1-getBean-→-doGetBean" class="headerlink" title="2.1 getBean → doGetBean"></a>2.1 getBean → doGetBean</h3><p>进入 <code>getBean</code> 方法，发现它直接调用了 <code>doGetBean</code> 方法（好嘛，又是老套路。。。）：</p>
<p><strong>前方高能</strong>！源码篇幅非常长，小伙伴们注意看注释呀！！！这段源码小册不打算拆解开一段一段的讲解了，我们只关心最重要的部分即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-comment">// 处理bean的alias</span><br>    String beanName = transformedBeanName(name);<br>    Object bean;<br><br>    <span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span><br>    <span class="hljs-comment">// 循环依赖的探测（boot小册第15章专门有讲）</span><br>    Object sharedInstance = getSingleton(beanName);<br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// logger ......</span><br>        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Fail if we&#x27;re already creating this bean instance:</span><br>        <span class="hljs-comment">// We&#x27;re assumably within a circular reference.</span><br>        <span class="hljs-comment">// 如果原型bean之间互相依赖，则一定会引发无限循环，此处会抛出循环依赖的异常</span><br>        <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);<br>        &#125;<br><br>        <span class="hljs-comment">// Check if bean definition exists in this factory.</span><br>        <span class="hljs-comment">// 如果本地不存在当前bean的定义信息，则尝试让父容器实例化bean</span><br>        <span class="hljs-comment">// 此举可以保证每个BeanFactory持有它应该有的bean，而不是所有的bean都集中在某一个BeanFactory中</span><br>        BeanFactory parentBeanFactory = getParentBeanFactory();<br>        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-comment">// Not found -&gt; check parent.</span><br>            String nameToLookup = originalBeanName(name);<br>            <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>                <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(<br>                        nameToLookup, requiredType, args, typeCheckOnly);<br>            &#125;<br>            <span class="hljs-comment">// else if parentBeanFactory.getBean ......</span><br>        &#125;<br><br>        <span class="hljs-comment">// 标记当前bean已经开始被创建了</span><br>        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>            markBeanAsCreated(beanName);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此处会合并BeanDefinition，并检查是否为抽象类(abstract则会抛出无法实例化的异常)</span><br>            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);<br>            checkMergedBeanDefinition(mbd, beanName, args);<br><br>            <span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span><br>            <span class="hljs-comment">// 此处会处理</span><br>            String[] dependsOn = mbd.getDependsOn();<br>            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>                    <span class="hljs-comment">// 循环依赖的检查：如果两个bean互相显式依赖，也会引发循环依赖的问题</span><br>                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<br>                                <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    &#125;<br>                    registerDependentBean(dep, beanName);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 迫切初始化显式依赖的bean</span><br>                        getBean(dep);<br>                    &#125; <span class="hljs-comment">// catch ......</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Create bean instance.</span><br>            <span class="hljs-comment">// 单实例bean的初始化，最终调用createBean</span><br>            <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>                sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                    &#125; <span class="hljs-comment">// catch ......</span><br>                &#125;);<br>                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>            &#125;<br>            <span class="hljs-comment">// 原型bean的初始化，直接调用createBean</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>                <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>                Object prototypeInstance = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    beforePrototypeCreation(beanName);<br>                    prototypeInstance = createBean(beanName, mbd, args);<br>                &#125;<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    afterPrototypeCreation(beanName);<br>                &#125;<br>                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>            &#125;<br>            <span class="hljs-comment">// 处理自定义的scope ......</span><br>        &#125;<br>        <span class="hljs-comment">// catch ......</span><br>    &#125;<br><br>    <span class="hljs-comment">// 类型强转前的检查 ......</span><br>    <span class="hljs-keyword">return</span> (T) bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>好长的源码是吧，这还是修剪过一部分的了。这部分前面的部分小伙伴们在现阶段只需要知道流程就好啊（感兴趣的可以深入看一看，但一定不要扎进去出不来了），对于 bean 的生命周期来讲，最重要的部分是中间的 <code>getMergedLocalBeanDefinition</code> 合并 <code>BeanDefinition</code> ，以及下面的 <code>createBean</code> 方法。下面我们分述这两个重要的方法。</p>
<h4 id="2-1-1-getMergedLocalBeanDefinition"><a href="#2-1-1-getMergedLocalBeanDefinition" class="headerlink" title="2.1.1 getMergedLocalBeanDefinition"></a>2.1.1 getMergedLocalBeanDefinition</h4><p>合并 <code>BeanDefinition</code> ，这是之前在第 25 章就了解过的知识了，这里我们简单看一下合并 <code>BeanDefinition</code> 的底层实现方式。</p>
<p>进入到 <code>getMergedLocalBeanDefinition</code> 方法中，发现它又是在折腾重载的方法，最终调用的是三参数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> RootBeanDefinition <span class="hljs-title">getMergedLocalBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-comment">// Quick check on the concurrent map first, with minimal locking.</span><br>    RootBeanDefinition mbd = <span class="hljs-keyword">this</span>.mergedBeanDefinitions.get(beanName);<br>    <span class="hljs-keyword">if</span> (mbd != <span class="hljs-keyword">null</span> &amp;&amp; !mbd.stale) &#123;<br>        <span class="hljs-keyword">return</span> mbd;<br>    &#125;<br>    <span class="hljs-keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> RootBeanDefinition <span class="hljs-title">getMergedBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition bd)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br><br>    <span class="hljs-keyword">return</span> getMergedBeanDefinition(beanName, bd, <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的设计相当简单，只是在最上面的调用位置上做了一个缓存的获取动作（由此可见合并后的 <code>BeanDefinition</code> 也是会缓存在 <code>BeanFactory</code> 中的），接下来就是这个最复杂的的三参数重载的方法了：（只需要注意标有注释的代码部分即可）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> RootBeanDefinition <span class="hljs-title">getMergedBeanDefinition</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        String beanName, BeanDefinition bd, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBd)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.mergedBeanDefinitions) &#123;<br>        RootBeanDefinition mbd = <span class="hljs-keyword">null</span>;<br>        RootBeanDefinition previous = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// Check with full lock now in order to enforce the same merged instance.</span><br>        <span class="hljs-keyword">if</span> (containingBd == <span class="hljs-keyword">null</span>) &#123;<br>            mbd = <span class="hljs-keyword">this</span>.mergedBeanDefinitions.get(beanName);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || mbd.stale) &#123;<br>            previous = mbd;<br>            <span class="hljs-comment">// 此处会判断BeanDefinition是否没有父定义（即独立的GenericBeanDefinition或RootBeanDefinition）</span><br>            <span class="hljs-keyword">if</span> (bd.getParentName() == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// Use copy of given root bean definition.</span><br>                <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> RootBeanDefinition) &#123;<br>                    mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mbd = <span class="hljs-keyword">new</span> RootBeanDefinition(bd);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Child bean definition: needs to be merged with parent.</span><br>                <span class="hljs-comment">// 否则，此处需要合并BeanDefinition了</span><br>                BeanDefinition pbd;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    String parentBeanName = transformedBeanName(bd.getParentName());<br>                    <span class="hljs-keyword">if</span> (!beanName.equals(parentBeanName)) &#123;<br>                        pbd = getMergedBeanDefinition(parentBeanName);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        BeanFactory parent = getParentBeanFactory();<br>                        <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> ConfigurableBeanFactory) &#123;<br>                            <span class="hljs-comment">// 此处会递归合并</span><br>                            pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);<br>                        &#125; <span class="hljs-comment">// else throw ex ......</span><br>                    &#125;<br>                &#125; <span class="hljs-comment">// catch ......</span><br>                <span class="hljs-comment">// Deep copy with overridden values.</span><br>                <span class="hljs-comment">// 合并完成后，生成一个新的RootBeanDefinition</span><br>                mbd = <span class="hljs-keyword">new</span> RootBeanDefinition(pbd);<br>                mbd.overrideFrom(bd);<br>            &#125;<br><br>            <span class="hljs-comment">// Set default singleton scope, if not configured before.</span><br>            <span class="hljs-comment">// 配置scope（如果自己和父定义都没有定义scope，则此处默认singleton）</span><br>            <span class="hljs-keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;<br>                mbd.setScope(SCOPE_SINGLETON);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (containingBd != <span class="hljs-keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;<br>                mbd.setScope(containingBd.getScope());<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (containingBd == <span class="hljs-keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;<br>                <span class="hljs-keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;<br>            copyRelevantMergedBeanDefinitionCaches(previous, mbd);<br>        &#125;<br>        <span class="hljs-keyword">return</span> mbd;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>抓住里面的核心逻辑：它会<strong>自下而上递归</strong>寻找父 <code>BeanDefinition</code> ，再<strong>从上到下合并</strong>获得最终的 <code>BeanDefinition</code> 。这里面的合并细节，如果小伙伴们感兴趣，可以稍微看一下，小册不作过多深入了。</p>
<h4 id="2-1-2-createBean的调用区别"><a href="#2-1-2-createBean的调用区别" class="headerlink" title="2.1.2 createBean的调用区别"></a>2.1.2 createBean的调用区别</h4><p>这个 <strong><code>createBean</code></strong> 方法又是 bean 的实例化中巨重要的方法了，但此处没有把标题级别往上调，是想先让小伙伴有一个初步的感觉。注意看单实例 bean 跟原型 bean 对于 <code>createBean</code> 方法的调用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Create bean instance.</span><br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>    sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>        &#125; <span class="hljs-comment">// catch ......</span><br>    &#125;);<br>    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>&#125;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>    <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>    Object prototypeInstance = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        beforePrototypeCreation(beanName);<br>        prototypeInstance = createBean(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        afterPrototypeCreation(beanName);<br>    &#125;<br>    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>单实例 bean 的调用，是在 <code>getSingleton</code> 方法的 lambda 参数中调用的，而这个 lambda表达式的底层是一个 <code>ObjectFactory</code> 。小伙伴们可以先想一下，为什么单实例 bean 会有一个额外的操作，而原型 bean 不需要考虑那么多，直接 <code>createBean</code> 就好呢？</p>
<p>很简单，<strong>原型 bean 没有缓存的必要</strong>，每次获取必定会创建新的 bean 对象出来；而<strong>单实例 bean 只能创建一次</strong>，第二次再获取就需要从缓存中获取了，所以这里会多一步操作。</p>
<p>那么新的问题又来了：<code>getSingleton</code> 方法中都干了什么呢？那必然是要深入方法中看呀，来咱们点进去瞅瞅。</p>
<h4 id="2-1-3-getSingleton"><a href="#2-1-3-getSingleton" class="headerlink" title="2.1.3 getSingleton"></a>2.1.3 getSingleton</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;<br>    Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>        <span class="hljs-comment">// 加锁后再查一次单实例bean的缓存</span><br>        Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.singletonsCurrentlyInDestruction) &#123;<br>                <span class="hljs-comment">// throw ex ......</span><br>            &#125;<br>            <span class="hljs-comment">// ......</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 【createBean】如果单实例bean的缓存中真的没有，那就创建对象</span><br>                singletonObject = singletonFactory.getObject();<br>                newSingleton = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-comment">// catch finally ......</span><br>            <br>            <span class="hljs-comment">// 新创建的单实例bean要存入单实例bean的缓存中</span><br>            <span class="hljs-keyword">if</span> (newSingleton) &#123;<br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singletonObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实这段源码一点也不神秘哈，无非就是加锁之后再判断一次单例（<strong>双检锁</strong>的设计），如果没有，那就调用 <code>ObjectFactory</code> 的 <code>getObject</code> 方法，而这个 <code>ObjectFactory</code> 就是前面看到的 lambda 表达式。</p>
<p>所以由此就可以得知，无论怎样，只要是创建 bean ，一定会走 <strong><code>createBean</code></strong> 方法就对了。好，那下面我们就进入 createBean 方法中。</p>
<h3 id="2-2-createBean"><a href="#2-2-createBean" class="headerlink" title="2.2 createBean"></a>2.2 createBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;<br>    <span class="hljs-comment">// logger ......</span><br>    RootBeanDefinition mbdToUse = mbd;<br><br>    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br>    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-keyword">null</span>) &#123;<br>        mbdToUse = <span class="hljs-keyword">new</span> RootBeanDefinition(mbd);<br>        mbdToUse.setBeanClass(resolvedClass);<br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 前置校验，不重要</span><br>        mbdToUse.prepareMethodOverrides();<br>    &#125; <span class="hljs-comment">// catch ......</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br>        <span class="hljs-comment">// 【后置处理器拦截创建bean】</span><br>        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br>    &#125; <span class="hljs-comment">// catch ......</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 【真正的创建bean】</span><br>        Object beanInstance = doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-comment">// logger ......</span><br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125; <span class="hljs-comment">// catch ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，这个 <code>createBean</code> 的方法中，除了最底下的 <code>doCreateBean</code> 真正创建 bean 之外，在上面还有一步：**<code>resolveBeforeInstantiation</code>** ，而且看注释也能获得这句代码的关键用途：<code>Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</code> （<strong>给后置处理器一个机会来创建代理 bean 而不是目标 bean 实例</strong>）。跟前面咱学过的 <code>InstantiationAwareBeanPostProcessor</code> 联系起来，这里自然就可以想到，它是会让这些 <code>InstantiationAwareBeanPostProcessor</code> 先试着实例化当前要创建的 bean 。好，那咱进入 <code>resolveBeforeInstantiation</code> 方法中一探究竟。</p>
<h4 id="2-2-1-resolveBeforeInstantiation"><a href="#2-2-1-resolveBeforeInstantiation" class="headerlink" title="2.2.1 resolveBeforeInstantiation"></a>2.2.1 resolveBeforeInstantiation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveBeforeInstantiation</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;<br>    Object bean = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;<br>        <span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span><br>        <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);<br>            <span class="hljs-keyword">if</span> (targetType != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 执行所有InstantiationAwareBeanPostProcessor</span><br>                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);<br>                <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果成功创建出了bean，则执行BeanPostProcessor的后置初始化</span><br>                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<br>                &#125;<br>            &#125;<br>        &#125;<br>        mbd.beforeInstantiationResolved = (bean != <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>        <span class="hljs-comment">// 循环找出所有的InstantiationAwareBeanPostProcessor</span><br>        <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;<br>            <span class="hljs-comment">// 调用它们的postProcessBeforeInstantiation尝试实例化bean对象</span><br>            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<br>            Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);<br>            <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看，这里的核心动作就是调用 <code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessBeforeInstantiation</code> 方法了，接下来的逻辑就很简单了吧。</p>
<p>不过这里面有一个细节哦，小伙伴们可以思考一下：如果 <code>postProcessBeforeInstantiation</code> 方法真的实例化出来了 bean 对象，为什么还需要回调 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 呢？</p>
<p>回想一下刚开始学 <code>BeanPostProcessor</code> 的时候，我们说 <code>postProcessAfterInitialization</code> 方法的一个关键的作用是<strong>生成代理对象</strong>，如果一个 <strong>bean 被 <code>InstantiationAwareBeanPostProcessor</code> 提前创建出 bean 了，但又需要创建代理对象</strong>，这个时候就必须要回调 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法了。</p>
<p>不过从咱写的两个测试 Demo 中，都没有涉及到这部分的内容，感兴趣的小伙伴可以自己修改一下测试 Demo 的代码，添加一个 <code>InstantiationAwareBeanPostProcessor</code> 来测试效果。</p>
<h3 id="2-3-doCreateBean"><a href="#2-3-doCreateBean" class="headerlink" title="2.3 doCreateBean"></a>2.3 doCreateBean</h3><p>进入到这个方法，那就相当于要真实的中规中矩的创建 bean 对象了！这个方法中共有三个大步骤：</p>
<ol>
<li>实例化 bean 对象（此时 bean 中所有属性均为空）</li>
<li>属性赋值 &amp; 依赖注入</li>
<li>bean 对象的初始化（执行完该步骤后 bean 已经完整）</li>
</ol>
<p>本章只会讲解这三大步骤的第一步 <strong>实例化 bean 对象</strong> ，而这部分的源码还是很简单的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;<br><br>    <span class="hljs-comment">// Instantiate the bean.</span><br>    BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 处理FactoryBean的小细节问题</span><br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 【真正的bean对象创建】</span><br>        instanceWrapper = createBeanInstance(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-comment">// 得到真实的bean对象引用</span><br>    Object bean = instanceWrapper.getWrappedInstance();<br>    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br>    <span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;<br>        mbd.resolvedTargetType = beanType;<br>    &#125;<br>    <span class="hljs-comment">// ...... ...... ......</span><br></code></pre></td></tr></table></figure>
<p>这里面的最核心步骤是 <strong><code>createBeanInstance</code></strong> ，它会把真正的 bean 对象实例化出来，不过在此之前有一个小细节的处理：<code>this.factoryBeanInstanceCache.remove(beanName)</code> ，它是干什么的呢？</p>
<h4 id="2-3-1-factoryBeanInstanceCache的作用"><a href="#2-3-1-factoryBeanInstanceCache的作用" class="headerlink" title="2.3.1 factoryBeanInstanceCache的作用"></a>2.3.1 factoryBeanInstanceCache的作用</h4><p>借助 IDEA ，观察 <code>factoryBeanInstanceCache</code> 的使用位置，唯一可以找到的 <code>put</code> 方法调用是在 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>getSingletonFactoryBeanForTypeCheck</code> 方法末尾部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">FactoryBean&lt;?&gt; fb = getFactoryBean(beanName, instance);<br><span class="hljs-keyword">if</span> (bw != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.put(beanName, bw);<br>&#125;<br><span class="hljs-keyword">return</span> fb;<br></code></pre></td></tr></table></figure>
<p>且不管这个操作是干什么用，借助 IDEA 继续向上找 <code>getSingletonFactoryBeanForTypeCheck</code> 方法的调用，可以发现进入到 <code>getTypeForFactoryBean</code> 中了。不需要深挖这个方法是干嘛用，且看方法名，就可以知道，它可以<strong>获取到 <code>FactoryBean</code> 中生成的 bean 的类型</strong>！可是你获取就获取呗，直接取泛型不好吗？哎，这还真不行，小伙伴们思考一下为什么？</p>
<p>因为。。。泛型可以写抽象类或者接口呀。如果真的这么写，回头框架拿泛型的时候，只能取到接口级别，但具体的实现类可拿不到呀。所以，<code>FactoryBean</code> 中还设计了一个方法：<code>getObjectType</code> ，它可以编程式的返回最终创建出来的对象的类型。不过想要调用 <code>getObjectType</code> 方法，就需要先把 <code>FactoryBean</code> 创建出来。这里面就产生新的问题了：一旦 <code>FactoryBean</code> 被预先创建出来了，而且这个 <code>FactoryBean</code> 还是单实例的 bean ，那原则上讲就不能再创建第二次了。</p>
<p>基于这个原则，SpringFramework 给出的解决方案是：如果提前调用了 <code>getTypeForFactoryBean</code> 确认 <code>FactoryBean</code> 中生成的 bean 的类型，则它会把这个 <code>FactoryBean</code> 本身先存在一个 <code>factoryBeanInstanceCache</code> 中（注意此时的 <code>FactoryBean</code> 只会利用 <code>getObjectType</code> 方法，不会调用 <code>getObject</code> 创建 bean ）；等后续真的需要由 <code>FactoryBean</code> 生成 bean 的时候，它会直接从 <code>factoryBeanInstanceCache</code> 中取出刚才已经实例化的 <code>FactoryBean</code> ，继续执行 bean 的初始化动作（属性赋值、依赖注入等）。</p>
<blockquote>
<p>对于这个 <code>factoryBeanInstanceCache</code> 的设计，小伙伴们没必要太深入探究，只需要对这个设计的思想有一个大概的认识即可，也体会一下 SpringFramework 对于 bean 对象控制的滴水不漏。</p>
</blockquote>
<h3 id="2-4-createBeanInstance"><a href="#2-4-createBeanInstance" class="headerlink" title="2.4 createBeanInstance"></a>2.4 createBeanInstance</h3><p>经过前面的动作，正常情况下第一次执行 <code>doCreateBean</code> 时，一定会走 <code>createBeanInstance</code> 方法的。而这个方法又是好复杂呀！小册还是把这个方法拆解开解释吧：</p>
<h4 id="2-4-1-解析bean类型"><a href="#2-4-1-解析bean类型" class="headerlink" title="2.4.1 解析bean类型"></a>2.4.1 解析bean类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 解析出bean的类型</span><br>    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);<br><br>    <span class="hljs-comment">// bean无法被访问，则抛出异常</span><br>    <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<br>                <span class="hljs-string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());<br>    &#125;<br>    <br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>第一步倒是很简单了，它会把当前即将实例化的 bean 的类型先确定出来。确定出来之后有一个校验（要是 bean 的类型本身就没办法被 SpringFramework 访问，那还实例化个锤子。。。），校验完成就可以进行下一步了。</p>
<h4 id="2-4-2-工厂方法创建"><a href="#2-4-2-工厂方法创建" class="headerlink" title="2.4.2 工厂方法创建"></a>2.4.2 工厂方法创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// SpringFramework5的新特性</span><br>Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();<br><span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);<br>&#125;<br><br><span class="hljs-comment">// 【工厂方法创建】</span><br><span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这两段源码，本质都是干一件事：如果在 <code>BeanDefinition</code> 中指定了工厂类型的创建逻辑，则直接走工厂创建。注意这里面的工厂包含两种情况，咱一一解释。</p>
<h5 id="2-4-2-1-InstanceSupplier"><a href="#2-4-2-1-InstanceSupplier" class="headerlink" title="2.4.2.1 InstanceSupplier"></a>2.4.2.1 InstanceSupplier</h5><p>这个设计来自于 <code>AbstractBeanDefinition</code> 中，是 SpringFramework 5.0 之后出现的新 API 。jdk 8 之后多了几个很重要很实用的 lambda ，其中之一就是 <code>Supplier</code> ，它是一个生产型接口。跟工厂的思路类似，<code>Supplier</code> 也可以完成构造 bean 的工作，所以在 <code>BeanDefinition</code> 中加入了这样一个设计，作为 <code>factory-method</code> 的一个替代方案。不过一般情况下我们也不会操纵 <code>BeanDefinition</code> ，所以这个东西我们也用不大到，小伙伴们知道一下就好了。</p>
<h5 id="2-4-2-2-factoryMethod"><a href="#2-4-2-2-factoryMethod" class="headerlink" title="2.4.2.2 factoryMethod"></a>2.4.2.2 factoryMethod</h5><p>真正与我们接触比较多的，是这个 <code>factoryMethod</code> ，除了在 xml 配置文件中定义的 <code>factory-method</code> 之外，注解配置类中被 <code>@Bean</code> 标注的方法，本质上也是一个工厂方法（还记得上一章 2.7.2 节中说的 <code>setFactoryBeanName</code> 、<code>setUniqueFactoryMethodName</code> 方法吧）。源码中它会执行 <code>instantiateUsingFactoryMethod</code> 方法来触发这个 factoryMethod ，由于这个方法实在是太长了！！！（200+行）所以小册在这里帮小伙伴们简单概括一下吧：它会根据工厂名称，找到对应的静态工厂 / 实例工厂 / 注解配置类对象（如果是注解配置类的话，还需要解析 <code>@Bean</code> 方法上的参数列表，注入对应的依赖），随后反射执行工厂方法，生成 bean 对象。</p>
<h4 id="2-4-3-为原型bean的小优化"><a href="#2-4-3-为原型bean的小优化" class="headerlink" title="2.4.3 为原型bean的小优化"></a>2.4.3 为原型bean的小优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Shortcut when re-creating the same bean...</span><br><span class="hljs-comment">// 这一步是为原型Bean的一个小优化</span><br><span class="hljs-keyword">boolean</span> resolved = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">boolean</span> autowireNecessary = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">if</span> (args == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<br>        <span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-keyword">null</span>) &#123;<br>            resolved = <span class="hljs-keyword">true</span>;<br>            autowireNecessary = mbd.constructorArgumentsResolved;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (resolved) &#123;<br>    <span class="hljs-keyword">if</span> (autowireNecessary) &#123;<br>        <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这部分为什么说它是一个优化呢？注意看后半部分：<code>if (resolved)</code> ，这个判断如果成立，会立即执行注入 / 实例化 bean 的动作（尽管下面还有一些代码没有执行）。那这个部分的设计缘由是什么呢？来我们考虑一个小小的问题：原型 bean 的创建过程中，每次的执行流程都是一样一样的吧！既然是每次都一样，那这些准备动作就没必要每次都执行一遍吧！执行一次之后，把这个过程中一些需要的东西都缓存起来就 OK 吧！所以，这个逻辑中，会把 bean 中需要的一些信息都保存起来，以备后续再创建该 bean 时可以直接拿这些信息，去创建 bean 对象。</p>
<blockquote>
<p>这部分缓存的数据主要是解析好的构造器，以及工厂方法。</p>
</blockquote>
<h4 id="2-4-4-实例化bean"><a href="#2-4-4-实例化bean" class="headerlink" title="2.4.4 实例化bean"></a>2.4.4 实例化bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// Candidate constructors for autowiring?</span><br>    <span class="hljs-comment">// 当满足任一条件，就会执行基于构造器的实例化</span><br>    <span class="hljs-comment">// 1. 通过SmartInstantiationAwareBeanPostProcessor找到了构造器</span><br>    <span class="hljs-comment">// 2. 配置了注入方式是AUTOWIRE_CONSTRUCTOR</span><br>    <span class="hljs-comment">// 3. 定义bean的时候指定了constructor-arg</span><br>    <span class="hljs-comment">// 4. 构造bean时传入了args参数</span><br>    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<br>    <span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||<br>            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;<br>        <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);<br>    &#125;<br><br>    <span class="hljs-comment">// Preferred constructors for default construction?</span><br>    ctors = mbd.getPreferredConstructors();<br>    <span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// No special handling: simply use no-arg constructor.</span><br>    <span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这部分就是解析构造器、给构造器参数注入，以及反射实例化 bean 的步骤了。首先它会解析实例化 bean 需要的构造器，如果 bean 中有显式的声明非空参数的构造器，则会依次解析构造器参数列表，并进行注入，最后反射创建 bean 对象。如果没有声明，则会调用最后一行的 <code>instantiateBean</code> 方法，使用默认空参构造器反射创建 bean 对象。</p>
<p>简单地来看，最后一行的 <code>instantiateBean</code> 方法中，最终会借助 <code>InstantiationStrategy</code> ，调用 <code>BeanUtils.instantiateClass</code> 方法反射实例化 bean 对象，涉及到的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">instantiateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object beanInstance;<br>        <span class="hljs-keyword">final</span> BeanFactory parent = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">if</span> <span class="hljs-comment">// ......</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 借助InstantiationStrategy</span><br>            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);<br>        &#125;<br>        BeanWrapper bw = <span class="hljs-keyword">new</span> BeanWrapperImpl(beanInstance);<br>        initBeanWrapper(bw);<br>        <span class="hljs-keyword">return</span> bw;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>autowireConstructor</code> 方法中涉及的解析逻辑比较复杂且源码很长，相比较于整体逻辑来看，这个细节的研究性价比不高，小册在此不再深入展开，感兴趣的小伙伴们可以自行深入浏览一下（但不要陷入其中啊啊啊啊）。</p>
<p>当 <code>createBeanInstance</code> 方法执行完之后，就可以得到一个光秃秃的 bean 对象了，bean 的实例化过程也就完成了。下面来总结一下这个阶段发生的内容吧：</p>
<h2 id="面试如何回答bean实例化部分的生命周期"><a href="#面试如何回答bean实例化部分的生命周期" class="headerlink" title="面试如何回答bean实例化部分的生命周期"></a>面试如何回答bean实例化部分的生命周期</h2><p>以下答案<strong>仅供参考</strong>，可根据个人理解进行实际调整：</p>
<p><strong>bean 实例阶段的生命周期包含三大步骤：</strong></p>
<ol>
<li><strong>bean 的实例化</strong></li>
<li><strong>属性赋值 + 依赖注入</strong></li>
<li><strong>bean 的初始化生命周期回调</strong></li>
<li><strong>bean 实例的销毁</strong></li>
</ol>
<p><strong>在所有非延迟加载的单实例 bean 初始化之前，会先初始化所有的 <code>BeanPostProcessor</code> 。</strong></p>
<p><strong>在 <code>ApplicationContext</code> 的 <code>refresh</code> 方法中，<code>finishBeanFactoryInitialization</code> 步骤会初始化所有的非延迟加载的单实例 bean 。实例化 bean 的入口是 <code>getBean</code> → <code>doGetBean</code> ，该阶段会合并 <code>BeanDefinition</code> ，并根据 bean 的 scope 选择实例化 bean 的策略。</strong></p>
<p><strong>创建 bean 的逻辑会走 <code>createBean</code> 方法，该方法中会先执行所有 <code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessBeforeInstantiation</code> 方法尝试创建 bean 实例，如果成功创建，则会直接调用 <code>postProcessAfterInitialization</code> 方法初始化 bean 后返回；如果 <code>InstantiationAwareBeanPostProcessor</code> 没有创建 bean 实例，则会调用 <code>doCreateBean</code> 方法创建 bean 实例。在 <code>doCreateBean</code> 方法中，会先根据 bean 的 <code>Class</code> 中的构造器定义，决定如何实例化 bean ，如果没有定义构造器，则会使用无参构造器，反射创建 bean 对象。</strong></p>
<p>bean 对象创建完成后，就会执行属性赋值 + 依赖注入的步骤。（下一章继续）</p>
<h1 id="四、Bean的生命周期-Bean的初始化阶段"><a href="#四、Bean的生命周期-Bean的初始化阶段" class="headerlink" title="四、Bean的生命周期-Bean的初始化阶段"></a>四、Bean的生命周期-Bean的初始化阶段</h1><p>上一章，我们从后置处理器的初始化开始，了解了 bean 在实例化前的一些处理，以及实例化过程中的一些逻辑。bean 对象实例化出来之后，下一步就要给 bean 的属性赋值，以及组件的依赖注入了。</p>
<p>本章主要会涉及到的原理部分：</p>
<ul>
<li>bean 的属性赋值 &amp; 组件依赖注入</li>
<li>bean 的初始化方法回调</li>
<li>重要的 <code>BeanPostProcessor</code> 功能解析</li>
</ul>
<h2 id="1-doCreateBean-书接上文"><a href="#1-doCreateBean-书接上文" class="headerlink" title="1. doCreateBean - 书接上文"></a>1. doCreateBean - 书接上文</h2><p>上一章中我们只解析了 <code>doCreateBean</code> 方法中的第一小段，接下来我们继续往下读。</p>
<h3 id="1-1-回调MergedBeanDefinitionPostProcessor"><a href="#1-1-回调MergedBeanDefinitionPostProcessor" class="headerlink" title="1.1 回调MergedBeanDefinitionPostProcessor"></a>1.1 回调MergedBeanDefinitionPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span><br><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<br>    <span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>        &#125;<br>        <span class="hljs-comment">// catch ......</span><br>        mbd.postProcessed = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这个阶段它会回调所有的 <code>MergedBeanDefinitionPostProcessor</code> ，这个阶段本身没什么好解释的，不过这里面有几个关键的 <code>MergedBeanDefinitionPostProcessor</code> 实现，咱在这里还是有必要展开讲一下的。</p>
<h4 id="1-1-1-InitDestroyAnnotationBeanPostProcessor"><a href="#1-1-1-InitDestroyAnnotationBeanPostProcessor" class="headerlink" title="1.1.1 InitDestroyAnnotationBeanPostProcessor"></a>1.1.1 InitDestroyAnnotationBeanPostProcessor</h4><p>顾名思义，它是处理初始化和销毁注解的后置处理器，它的核心处理逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;<br>    LifecycleMetadata metadata = findLifecycleMetadata(beanType);<br>    metadata.checkConfigMembers(beanDefinition);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很明显，<code>findLifecycleMetadata</code> 方法是查找 bean 的生命周期元信息，进入到该方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> LifecycleMetadata <span class="hljs-title">findLifecycleMetadata</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lifecycleMetadataCache == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Happens after deserialization, during destruction...</span><br>        <span class="hljs-keyword">return</span> buildLifecycleMetadata(clazz);<br>    &#125;<br>    <span class="hljs-comment">// 构建缓存 ......</span><br>    <span class="hljs-keyword">return</span> metadata;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里又是用缓存机制，把 bean 的初始化和销毁注解信息都保存到 <code>lifecycleMetadataCache</code> 里了。咱主要关注的是 <code>buildLifecycleMetadata</code> 方法，看它都是怎么搞的。（下面的源码中已去掉日志打印的部分）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> LifecycleMetadata <span class="hljs-title">buildLifecycleMetadata</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, Arrays.asList(<span class="hljs-keyword">this</span>.initAnnotationType, <span class="hljs-keyword">this</span>.destroyAnnotationType))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emptyLifecycleMetadata;<br>    &#125;<br><br>    List&lt;LifecycleElement&gt; initMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;LifecycleElement&gt; destroyMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Class&lt;?&gt; targetClass = clazz;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">final</span> List&lt;LifecycleElement&gt; currInitMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">final</span> List&lt;LifecycleElement&gt; currDestroyMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 反射所有的public方法</span><br>        ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;<br>            <span class="hljs-comment">// 寻找所有被初始化注解标注的方法</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.initAnnotationType != <span class="hljs-keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="hljs-keyword">this</span>.initAnnotationType)) &#123;<br>                LifecycleElement element = <span class="hljs-keyword">new</span> LifecycleElement(method);<br>                currInitMethods.add(element);<br>            &#125;<br>            <span class="hljs-comment">// 寻找所有被销毁注解标注的方法</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyAnnotationType != <span class="hljs-keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="hljs-keyword">this</span>.destroyAnnotationType)) &#123;<br>                currDestroyMethods.add(<span class="hljs-keyword">new</span> LifecycleElement(method));<br>            &#125;<br>        &#125;);<br><br>        initMethods.addAll(<span class="hljs-number">0</span>, currInitMethods);<br>        destroyMethods.addAll(currDestroyMethods);<br>        targetClass = targetClass.getSuperclass();<br>    &#125; <span class="hljs-comment">// 依次向上寻找父类</span><br>    <span class="hljs-keyword">while</span> (targetClass != <span class="hljs-keyword">null</span> &amp;&amp; targetClass != Object.class);<br><br>    <span class="hljs-keyword">return</span> (initMethods.isEmpty() &amp;&amp; destroyMethods.isEmpty() ? <span class="hljs-keyword">this</span>.emptyLifecycleMetadata :<br>            <span class="hljs-keyword">new</span> LifecycleMetadata(clazz, initMethods, destroyMethods));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段源码还是比较容易理解的，它会寻找这个 bean 所属的 <code>Class</code> 中是否有包含初始化注解和销毁注解的方法。而初始化注解、销毁注解分别是啥呢？在子类 <code>CommonAnnotationBeanPostProcessor</code> 中有指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">setInitAnnotationType(PostConstruct.class);<br>setDestroyAnnotationType(PreDestroy.class);<br></code></pre></td></tr></table></figure>
<p>好吧，果然还是 JSR 250 的那一套。。。那合着说，**<code>InitDestroyAnnotationBeanPostProcessor</code> 就是收集标注了 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解的后置处理器**呗。</p>
<h4 id="1-1-2-CommonAnnotationBeanPostProcessor"><a href="#1-1-2-CommonAnnotationBeanPostProcessor" class="headerlink" title="1.1.2 CommonAnnotationBeanPostProcessor"></a>1.1.2 CommonAnnotationBeanPostProcessor</h4><p>呦，马上就到这个子类了，咱看看这个类里有什么扩展：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用InitDestroyAnnotationBeanPostProcessor</span><br>    <span class="hljs-keyword">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);<br>    <span class="hljs-comment">// 收集注入相关的信息</span><br>    InjectionMetadata metadata = findResourceMetadata(beanName, beanType, <span class="hljs-keyword">null</span>);<br>    metadata.checkConfigMembers(beanDefinition);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>除了调用父类 <code>InitDestroyAnnotationBeanPostProcessor</code> 的收集动作之外，它在这里还要收集有关注入的注解信息。与上面的 <code>findLifecycleMetadata</code> 方法类似，它也是设置有缓存的机制，我们直接看实际干活的方法了：（只贴出了核心部分的源码节选）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (webServiceRefClass != <span class="hljs-keyword">null</span> &amp;&amp; field.isAnnotationPresent(webServiceRefClass)) &#123;<br>            <span class="hljs-keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;@WebServiceRef annotation is not supported on static fields&quot;</span>);<br>            &#125;<br>            currElements.add(<span class="hljs-keyword">new</span> WebServiceRefElement(field, field, <span class="hljs-keyword">null</span>));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ejbClass != <span class="hljs-keyword">null</span> &amp;&amp; field.isAnnotationPresent(ejbClass)) &#123;<br>            <span class="hljs-keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;@EJB annotation is not supported on static fields&quot;</span>);<br>            &#125;<br>            currElements.add(<span class="hljs-keyword">new</span> EjbRefElement(field, field, <span class="hljs-keyword">null</span>));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field.isAnnotationPresent(Resource.class)) &#123;<br>            <span class="hljs-keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;@Resource annotation is not supported on static fields&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.ignoredResourceTypes.contains(field.getType().getName())) &#123;<br>                currElements.add(<span class="hljs-keyword">new</span> ResourceElement(field, field, <span class="hljs-keyword">null</span>));<br>            &#125;<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p>由这段节选的源码可见，它还能支持 JAVA EE 规范中的 <code>@WebServiceRef</code> 、<code>@EJB</code> 、<code>@Resource</code> 注解，并封装对应的注解信息。由于我们已经对 EJB 等家伙不关注了，所以这里小伙伴们只需要知道它相当于额外收集了 <code>@Resource</code> 注解的信息即可。</p>
<h4 id="1-1-3-AutowiredAnnotationBeanPostProcessor"><a href="#1-1-3-AutowiredAnnotationBeanPostProcessor" class="headerlink" title="1.1.3 AutowiredAnnotationBeanPostProcessor"></a>1.1.3 AutowiredAnnotationBeanPostProcessor</h4><p>有了前面两个后置处理器的知识，这个后置处理器的功能不用看也就能猜得到了吧：它应该是<strong>收集自动注入的注解信息</strong>的。底层的原理与前两者的逻辑设计一模一样，小册就不重复贴出了，这里重点说一下它支持的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AutowiredAnnotationBeanPostProcessor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);<br>    <span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add(Value.class);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)<br>                ClassUtils.forName(<span class="hljs-string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>可以发现，<code>AutowiredAnnotationBeanPostProcessor</code> 在构造方法中，就已经指定好它默认支持 <code>@Autowired</code> 注解、<code>@Value</code> 注解，如果 classpath 下有来自 JSR 330 的 <code>@Inject</code> 注解，也会一并支持。</p>
<h4 id="1-1-4-注解后置处理器小结"><a href="#1-1-4-注解后置处理器小结" class="headerlink" title="1.1.4 注解后置处理器小结"></a>1.1.4 注解后置处理器小结</h4><p>从这几个后置处理器中，我们就可以发现，可以支持 bean 中标注的注解的后置处理器，它们的处理方式都是<strong>先收集注解标注的信息，保存到缓存中，随后再处理时，只需要从缓存中取就可以</strong>了。</p>
<h3 id="1-2-早期bean对象引用的获取与缓存"><a href="#1-2-早期bean对象引用的获取与缓存" class="headerlink" title="1.2 早期bean对象引用的获取与缓存"></a>1.2 早期bean对象引用的获取与缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;<br>        isSingletonCurrentlyInCreation(beanName));<br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>    <span class="hljs-comment">// logger ......</span><br>    <span class="hljs-comment">// 处理循环依赖的问题</span><br>    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这里有一个获取早期 bean 对象引用的动作，这一步是为了解决 bean 之间的循环依赖问题。这里我们只是说一下这个早期 bean 对象的引用是个什么东西。</p>
<p>从前面的逻辑中，bean 被实例化出来之后还没有进行属性赋值和组件的依赖注入，但此时的 <strong>bean 对象已经实实在在的存在了</strong>。如果在此期间，有另外的 bean 又需要创建它时，就<strong>不应该再创建同样的一个 bean 对象，而是直接拿到该引用</strong>即可，这个设计就是为了解决 bean 之间的循环依赖而用（从 <code>getEarlyBeanReference</code> 方法的 javadoc 上也能看到）。</p>
<blockquote>
<p><strong>有关 bean 的循环依赖，在本小册中不会有涉及，在我的<a target="_blank" rel="noopener" href="https://juejin.im/book/6844733814560784397/section/6844733814615326733">《SpringBoot 小册》第 15 章</a> 有完整的讲过 SpringFramework 解决循环依赖的全流程，有需要的小伙伴们可以跳转过去学习哦。</strong></p>
</blockquote>
<h3 id="1-3-populateBean-属性赋值-依赖注入"><a href="#1-3-populateBean-属性赋值-依赖注入" class="headerlink" title="1.3 populateBean - 属性赋值+依赖注入"></a>1.3 populateBean - 属性赋值+依赖注入</h3><p>接下来的两步是挨着的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Initialize the bean instance.</span><br>Object exposedObject = bean;<br><span class="hljs-keyword">try</span> &#123;<br>    populateBean(beanName, mbd, instanceWrapper);<br>    exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这里我们先看 <code>populateBean</code> 这一步，由于这个方法中的内容还是比较多，我们拆解开来看。</p>
<h4 id="1-3-1-检查bean-amp-准备"><a href="#1-3-1-检查bean-amp-准备" class="headerlink" title="1.3.1 检查bean&amp;准备"></a>1.3.1 检查bean&amp;准备</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bw == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mbd.hasPropertyValues()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>                    mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Cannot apply property values to null instance&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Skip property population phase for null instance.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这个地方仅仅是为了检查 <code>BeanWrapper</code> 中是否存在而已，没什么好说的。</p>
<h4 id="1-3-2-回调InstantiationAwareBeanPostProcessor"><a href="#1-3-2-回调InstantiationAwareBeanPostProcessor" class="headerlink" title="1.3.2 回调InstantiationAwareBeanPostProcessor"></a>1.3.2 回调InstantiationAwareBeanPostProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span><br><span class="hljs-comment">// state of the bean before properties are set. This can be used, for example,</span><br><span class="hljs-comment">// to support styles of field injection.</span><br><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>        <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;<br>            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<br>            <span class="hljs-keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这个部分很明显就是回调所有的 <code>InstantiationAwareBeanPostProcessor</code> 而已，不过这上面有好长一段注释，我们来看看它讲了些啥：</p>
<blockquote>
<p>Give any InstantiationAwareBeanPostProcessors the opportunity to modify the state of the bean before properties are set. This can be used, for example, to support styles of field injection.</p>
<p>在设置属性之前，让任何 <code>InstantiationAwareBeanPostProcessor</code> 都有机会修改 bean 的状态，例如支持属性字段的注入。</p>
</blockquote>
<p>哦，合着 <code>postProcessAfterInstantiation</code> 方法也是干预 bean 的属性等东西的呀。而且有一个小细节注意一下，<code>postProcessAfterInstantiation</code> 方法返回的是 boolean 类型，当 <code>postProcessAfterInstantiation</code> 返回 <strong>false</strong> 时，会直接 <strong>return</strong> 出去，<strong>不再执行下面的属性赋值 + 组件依赖注入的逻辑</strong>！（通常这个方法一定是返回 true 的，底层默认也是返回 true ）</p>
<p>可能会有小伙伴产生疑惑，那这个回调有什么可以利用的吗？注意思考，当 bean 的创建来到这个位置的时候，此时 bean 的状态如何？还是所有属性都为空吧，而且还都没有执行任何初始化的逻辑吧。所以这个回调的位置，就是让咱<strong>在 bean 已经初始化好，但还没有开始属性赋值和依赖注入时切入自定义逻辑</strong>。</p>
<h4 id="1-3-3-自动注入支持"><a href="#1-3-3-自动注入支持" class="headerlink" title="1.3.3 自动注入支持"></a>1.3.3 自动注入支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br>PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment">// 解析出当前bean支持的自动注入模式</span><br><span class="hljs-keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();<br><span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;<br>    MutablePropertyValues newPvs = <span class="hljs-keyword">new</span> MutablePropertyValues(pvs);<br>    <span class="hljs-comment">// Add property values based on autowire by name if applicable.</span><br>    <span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;<br>        autowireByName(beanName, mbd, bw, newPvs);<br>    &#125;<br>    <span class="hljs-comment">// Add property values based on autowire by type if applicable.</span><br>    <span class="hljs-keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;<br>        autowireByType(beanName, mbd, bw, newPvs);<br>    &#125;<br>    pvs = newPvs;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这一部分的逻辑是支撑 <strong>“自动注入模式”</strong> 功能的，我们在第 24 章已经简单的讲过了，这里我们简单地看一下源码的实现就好了。</p>
<p>在上面先把当前正在创建的 bean 的自动注入模式解析出来，之后根据自动注入模式，执行对应的逻辑。这里我们以 <code>byName</code> 为例看一下它里面的实现。（源码中去除了日志打印）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">autowireByName</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;<br>    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);<br>    <span class="hljs-keyword">for</span> (String propertyName : propertyNames) &#123;<br>        <span class="hljs-comment">// 存在bean，就获取出来，添加依赖关系</span><br>        <span class="hljs-keyword">if</span> (containsBean(propertyName)) &#123;<br>            Object bean = getBean(propertyName);<br>            pvs.add(propertyName, bean);<br>            registerDependentBean(propertyName, beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现，这个逻辑是相当的简单吧！就仅仅是<strong>查出来，添加上依赖关系，就完事了</strong>，没有任何的多余动作，这部分的逻辑也没什么好说的咯。</p>
<p>另外留意一点！在这段代码执行完毕后，有 <code>pvs = newPvs;</code> 的步骤，它将这个过程中需要组件依赖注入的信息也都封装进了 <code>PropertyValues</code> 中了，所以<strong>此时 <code>pvs</code> 中就应该有一开始封装的信息，以及通过自动注入封装好的依赖信息</strong>。</p>
<h4 id="1-3-4-又回调InstantiationAwareBeanPostProcessor"><a href="#1-3-4-又回调InstantiationAwareBeanPostProcessor" class="headerlink" title="1.3.4 又回调InstantiationAwareBeanPostProcessor"></a>1.3.4 又回调InstantiationAwareBeanPostProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();<br><span class="hljs-keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);<br><br>PropertyDescriptor[] filteredPds = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<br>    <span class="hljs-keyword">if</span> (pvs == <span class="hljs-keyword">null</span>) &#123;<br>        pvs = mbd.getPropertyValues();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>        <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;<br>            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;<br>            <span class="hljs-comment">// 【核心】回调postProcessProperties</span><br>            PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);<br>            <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;<br>                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>                &#125;<br>                pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<br>                <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            pvs = pvsToUse;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这一段源码又在取那些 <code>InstantiationAwareBeanPostProcessor</code> 了，不过注意这次回调的方法是 <strong><code>postProcessProperties</code></strong> 和 <code>postProcessPropertyValues</code> 方法了（ <code>postProcessPropertyValues</code> 方法在 SpringFramework 5.1 之后被废弃了）。注意 <code>postProcessProperties</code> 方法会传入 <code>PropertyValues</code> ，也会返回 <code>PropertyValues</code> ，所以<strong>这个过程相当于反复给 <code>PropertyValues</code> 封装数据</strong>。那这个封装的过程我们是有必要了解一下的。</p>
<p>之前在第 27 章我们已经知道，这个时机的回调是属性赋值和组件依赖注入的核心时机，所以我们需要关注这里面一个非常重要的后置处理器：**<code>AutowiredAnnotationBeanPostProcessor</code>** 。</p>
<h5 id="1-3-4-1-AutowiredAnnotationBeanPostProcessor-postProcessProperties"><a href="#1-3-4-1-AutowiredAnnotationBeanPostProcessor-postProcessProperties" class="headerlink" title="1.3.4.1 AutowiredAnnotationBeanPostProcessor#postProcessProperties"></a>1.3.4.1 AutowiredAnnotationBeanPostProcessor#postProcessProperties</h5><p><code>AutowiredAnnotationBeanPostProcessor</code> 的 <code>postProcessProperties</code> 方法的实现，看上去还蛮简单的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;<br>    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);<br>    <span class="hljs-keyword">try</span> &#123;<br>        metadata.inject(bean, beanName, pvs);<br>    &#125; <span class="hljs-comment">// catch ......</span><br>    <span class="hljs-keyword">return</span> pvs;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>嗯，看到 <code>findAutowiringMetadata</code> 方法，是不是又想到了前面那个一模一样的套路呢？又是收集所有标注了 <code>@Autowired</code> 、<code>@Value</code>、<code>@Inject</code> 注解的信息，返回回来。不过这里不只是收集了，它要<strong>真正的给 bean 对象的属性赋值</strong>！</p>
<p>到这里，小伙伴是否有回想起在第 30 章中，我们说过的，在 <code>BeanFactoryPostProcessor</code> 或者 <code>BeanDefinitionRegistryPostProcessor</code> 中无法直接使用 <code>@Autowired</code> 直接注入 SpringFramework 中的内部组件（如 <code>Environment</code> ）？现在是否明白这个问题的答案了吗？<strong>当 <code>BeanDefinitionRegistryPostProcessor</code> 在初始化的阶段，还不存在 <code>BeanPostProcessor</code> 呢，所以那些用于支持依赖注入的后置处理器（ <code>AutowiredAnnotationBeanPostProcessor</code> ）还没有被初始化，自然也就没办法支持注入了。正确的做法是借助 <code>Aware</code> 接口的回调注入。</strong></p>
<h5 id="1-3-4-2-metadata-inject"><a href="#1-3-4-2-metadata-inject" class="headerlink" title="1.3.4.2 metadata.inject"></a>1.3.4.2 metadata.inject</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Object target, <span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    Collection&lt;InjectedElement&gt; checkedElements = <span class="hljs-keyword">this</span>.checkedElements;<br>    <span class="hljs-comment">// 收集所有要注入的信息</span><br>    Collection&lt;InjectedElement&gt; elementsToIterate =<br>            (checkedElements != <span class="hljs-keyword">null</span> ? checkedElements : <span class="hljs-keyword">this</span>.injectedElements);<br>    <span class="hljs-keyword">if</span> (!elementsToIterate.isEmpty()) &#123;<br>        <span class="hljs-comment">// 迭代，依次注入</span><br>        <span class="hljs-keyword">for</span> (InjectedElement element : elementsToIterate) &#123;<br>            <span class="hljs-comment">// logger ......</span><br>            element.inject(target, beanName, pvs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整体逻辑还是非常简单的哈，给一个 bean 进行注入，就相当于给这个 bean 中需要注入的元素依次注入。</p>
<p>继续往下进入到 <code>element.inject</code> 方法，这里面就比较复杂了（因为它有两个重写的复杂方法），我们只需要看一下它的核心工作机制就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Object target, <span class="hljs-meta">@Nullable</span> String requestingBeanName, <span class="hljs-meta">@Nullable</span> PropertyValues pvs)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isField) &#123;<br>        <span class="hljs-comment">// 反射注入字段</span><br>        Field field = (Field) <span class="hljs-keyword">this</span>.member;<br>        ReflectionUtils.makeAccessible(field);<br>        field.set(target, getResourceToInject(target, requestingBeanName));<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (checkPropertySkipping(pvs)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 反射调用setter方法</span><br>            Method method = (Method) <span class="hljs-keyword">this</span>.member;<br>            ReflectionUtils.makeAccessible(method);<br>            method.invoke(target, getResourceToInject(target, requestingBeanName));<br>        &#125; <span class="hljs-comment">// catch ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>嚯，这也太简单了吧，就仅仅是反射注入 / 调用呗？当然啦，太复杂的是这个方法重写的两个子类 <code>AutowiredFieldElement</code> 和 <code>AutowiredMethodElement</code> ，但它们处理的逻辑大同小异，只是处理步骤复杂了好多而已。小伙伴们没有必要深追这里面的实现细节，能对这个步骤的底层基本实现心领神会即可。</p>
<h4 id="1-3-5-属性赋值"><a href="#1-3-5-属性赋值" class="headerlink" title="1.3.5 属性赋值"></a>1.3.5 属性赋值</h4><p>到这里为止，<code>PropertyValues</code> 的内容都封装好了，来看最后一段源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">if</span> (needsDepCheck) &#123;<br>        <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-keyword">null</span>) &#123;<br>            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>        &#125;<br>        checkDependencies(beanName, mbd, filteredPds, pvs);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pvs != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 将PropertyValues应用给bean</span><br>        applyPropertyValues(beanName, mbd, bw, pvs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>核心动作就只有 <code>applyPropertyValues</code> 这一个动作，而从方法名上就能 get 到，这个 <code>applyPropertyValues</code> 方法的作用，就是<strong>把前面准备好的 <code>PropertyValues</code> 对象封装的内容，应用到当前正在创建的 bean 实例上</strong>。</p>
<p>接下来咱进入到 <code>applyPropertyValues</code> 方法中一探究竟。。。呃，这个方法实在是太长了，我们依然是拆解来看吧/</p>
<h5 id="1-3-5-1-预检查和准备"><a href="#1-3-5-1-预检查和准备" class="headerlink" title="1.3.5.1 预检查和准备"></a>1.3.5.1 预检查和准备</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyPropertyValues</span><span class="hljs-params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pvs.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; bw <span class="hljs-keyword">instanceof</span> BeanWrapperImpl) &#123;<br>        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());<br>    &#125;<br><br>    MutablePropertyValues mpvs = <span class="hljs-keyword">null</span>;<br>    List&lt;PropertyValue&gt; original;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这段很简单啦，如果直接没有要应用的 bean 属性，则直接返回就好，否则它就要准备处理 <code>PropertyValues</code> 了。</p>
<h5 id="1-3-5-2-重复解析的提前返回"><a href="#1-3-5-2-重复解析的提前返回" class="headerlink" title="1.3.5.2 重复解析的提前返回"></a>1.3.5.2 重复解析的提前返回</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">if</span> (pvs <span class="hljs-keyword">instanceof</span> MutablePropertyValues) &#123;<br>    mpvs = (MutablePropertyValues) pvs;<br>    <span class="hljs-comment">// 判断PropertyValues是否已经解析过了</span><br>    <span class="hljs-keyword">if</span> (mpvs.isConverted()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bw.setPropertyValues(mpvs);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-comment">// catch ......</span><br>    &#125;<br>    original = mpvs.getPropertyValueList();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    original = Arrays.asList(pvs.getPropertyValues());<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这部分很明显是一个提前返回的动作，<code>if (mpvs.isConverted())</code> 的动作很明显是检查 <code>PropertyValues</code> 是否已经解析过了，如果已经解析过，则直接应用就行，不需要重复解析。</p>
<h5 id="1-3-5-3-初始化BeanDefinitionValueResolver"><a href="#1-3-5-3-初始化BeanDefinitionValueResolver" class="headerlink" title="1.3.5.3 初始化BeanDefinitionValueResolver"></a>1.3.5.3 初始化BeanDefinitionValueResolver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br>TypeConverter converter = getCustomTypeConverter();<br><span class="hljs-keyword">if</span> (converter == <span class="hljs-keyword">null</span>) &#123;<br>    converter = bw;<br>&#125;<br>BeanDefinitionValueResolver valueResolver = <span class="hljs-keyword">new</span> BeanDefinitionValueResolver(<span class="hljs-keyword">this</span>, beanName, mbd, converter);<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这一段非常短，但这个 <code>BeanDefinitionValueResolver</code> 却很重要！<code>BeanDefinitionValueResolver</code> 的初始化需要传入一个 <code>TypeConverter</code> ，而这个 <code>TypeConverter</code> 是 SpringFramework 中内部用于类型转换的核心 API 。简单的来说，<strong>使用 <code>TypeConverter</code> 可以将一个 String 类型的数据，转换为特定的所需要的类型的数据</strong>。而 <code>BeanDefinitionValueResolver</code> 就利用 <code>TypeConverter</code> ，完成对 bean 实例中需要注入的属性值进行解析，并适配为 bean 属性所需要的类型（如 String → int ，依赖 bean 的名称转为实际 bean 的引用）。</p>
<h5 id="1-3-5-4-类型转换"><a href="#1-3-5-4-类型转换" class="headerlink" title="1.3.5.4 类型转换"></a>1.3.5.4 类型转换</h5><p>这一部分小册就<strong>不着重解释了</strong>，类型转换不属于我们重点关心的东西，小册在源码的关键位置留了注释，小伙伴们看看就得了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Create a deep copy, resolving any references for values.</span><br>List&lt;PropertyValue&gt; deepCopy = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(original.size());<br><span class="hljs-keyword">boolean</span> resolveNecessary = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 迭代逐个解析PropertyValue</span><br><span class="hljs-keyword">for</span> (PropertyValue pv : original) &#123;<br>    <span class="hljs-comment">// 已经解析过的直接添加</span><br>    <span class="hljs-keyword">if</span> (pv.isConverted()) &#123;<br>        deepCopy.add(pv);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        String propertyName = pv.getName();<br>        <span class="hljs-comment">// 此处取出的值是未经过转换的原始value</span><br>        Object originalValue = pv.getValue();<br>        <span class="hljs-comment">// 此处是 5.2 的一个扩展，如果编程式使用BeanDefinitionBuilder添加自动注入的属性时，</span><br>        <span class="hljs-comment">// 会使用类似于自动注入支持的方式处理该属性</span><br>        <span class="hljs-keyword">if</span> (originalValue == AutowiredPropertyMarker.INSTANCE) &#123;<br>            Method writeMethod = bw.getPropertyDescriptor(propertyName).getWriteMethod();<br>            <span class="hljs-keyword">if</span> (writeMethod == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Autowire marker for property without write method: &quot;</span> + pv);<br>            &#125;<br>            originalValue = <span class="hljs-keyword">new</span> DependencyDescriptor(<span class="hljs-keyword">new</span> MethodParameter(writeMethod, <span class="hljs-number">0</span>), <span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-comment">// 根据originalValue的类型，解析出bean依赖的属性值</span><br>        <span class="hljs-comment">// 此处如果是bean的名称，则最终解析出来的是真正的bean对象</span><br>        Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);<br>        Object convertedValue = resolvedValue;<br>        <span class="hljs-keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;<br>                !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);<br>        <span class="hljs-keyword">if</span> (convertible) &#123;<br>            convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);<br>        &#125;<br>        <span class="hljs-comment">// 此处要对解析前和解析后的数据进行对比</span><br>        <span class="hljs-comment">// 如果解析之前与解析之后的值完全一致，则代表不需要解析，或已经解析过了，直接保存</span><br>        <span class="hljs-keyword">if</span> (resolvedValue == originalValue) &#123;<br>            <span class="hljs-keyword">if</span> (convertible) &#123;<br>                pv.setConvertedValue(convertedValue);<br>            &#125;<br>            deepCopy.add(pv);<br>        &#125;<br>        <span class="hljs-comment">// 如果String类型转为其他类型（除了集合或数组），则认为它也不需要再解析了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (convertible &amp;&amp; originalValue <span class="hljs-keyword">instanceof</span> TypedStringValue &amp;&amp;<br>                !((TypedStringValue) originalValue).isDynamic() &amp;&amp;<br>                !(convertedValue <span class="hljs-keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;<br>            pv.setConvertedValue(convertedValue);<br>            deepCopy.add(pv);<br>        &#125;<br>        <span class="hljs-comment">// 否则，该字段认定为每次都需要重新解析</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            resolveNecessary = <span class="hljs-keyword">true</span>;<br>            deepCopy.add(<span class="hljs-keyword">new</span> PropertyValue(pv, convertedValue));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 如果所有字段都解析完毕，则当前PropertyValues可以标记为已经解析完成，后续不需要重复解析</span><br><span class="hljs-keyword">if</span> (mpvs != <span class="hljs-keyword">null</span> &amp;&amp; !resolveNecessary) &#123;<br>    mpvs.setConverted();<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>实际在测试代码中，这个方法压根就没走，都被 <code>AutowiredAnnotationBeanPostProcessor</code> 处理完了，所以这个地方我们一带而过得了。</p>
<h5 id="1-3-5-5-PropertyValues应用到bean"><a href="#1-3-5-5-PropertyValues应用到bean" class="headerlink" title="1.3.5.5 PropertyValues应用到bean"></a>1.3.5.5 PropertyValues应用到bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// Set our (possibly massaged) deep copy.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        bw.setPropertyValues(<span class="hljs-keyword">new</span> MutablePropertyValues(deepCopy));<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(<br>                mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Error setting property values&quot;</span>, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后一个步骤，这里要把 <code>PropertyValues</code> 中的属性值全部应用到 bean 对象中了。这一部分来回调的源码比较多，最终的落地在 <code>org.springframework.beans.AbstractNestablePropertyAccessor.PropertyHandler#setValue</code> 中，它的其中一个实现类 <code>FieldPropertyHandler</code> 的方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object value)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ReflectionUtils.makeAccessible(<span class="hljs-keyword">this</span>.field);<br>        <span class="hljs-keyword">this</span>.field.set(getWrappedInstance(), value);<br>    &#125;<br>    <span class="hljs-comment">// catch ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>简直简单的不要再简单，反射赋值，简单粗暴。so 这个步骤也就很好理解咯。</p>
<p>到这里，整个 <code>populateBean</code> 的属性赋值动作就全部完成了。</p>
<h3 id="1-4-initializeBean"><a href="#1-4-initializeBean" class="headerlink" title="1.4 initializeBean"></a>1.4 initializeBean</h3><p>当 bean 的创建过程走到 <code>initializeBean</code> 方法时，此时 bean 中的属性都是齐全的了，但生命周期的回调都还没有回调，接下来我们研究这个部分。</p>
<p>先总体概览一下源码，这里面包含 4 个步骤，均在源码中加以标注：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// ......</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 1.4.1 执行Aware回调</span><br>        invokeAwareMethods(beanName, bean);<br>    &#125;<br><br>    Object wrappedBean = bean;<br>    <span class="hljs-comment">// 1.4.2 执行BeanPostProcessor的前置回调</span><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1.4.3 执行生命周期回调</span><br>        invokeInitMethods(beanName, wrappedBean, mbd);<br>    &#125;<br>    <span class="hljs-comment">// catch ......</span><br>    <span class="hljs-comment">// 1.4.4 执行BeanPostProcessor的后置回调</span><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面我们分述这几个步骤。</p>
<h4 id="1-4-1-invokeAwareMethods-执行Aware回调"><a href="#1-4-1-invokeAwareMethods-执行Aware回调" class="headerlink" title="1.4.1 invokeAwareMethods - 执行Aware回调"></a>1.4.1 invokeAwareMethods - 执行Aware回调</h4><p><code>invokeAwareMethods(beanName, bean);</code> 这个方法中的定义相当简单，只是判断接口的定义，以及强转后的接口方法调用而已，非常容易理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareMethods</span><span class="hljs-params">(String beanName, Object bean)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>        <span class="hljs-comment">// 如果bean实现了BeanNameAware，则强转后调用setBeanName方法注入bean的名称</span><br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware) &#123;<br>            ((BeanNameAware) bean).setBeanName(beanName);<br>        &#125;<br>        <span class="hljs-comment">// 如果bean实现了BeanClassLoaderAware，则强转后调用setBeanClassLoader方法注入当前的ClassLoader</span><br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware) &#123;<br>            ClassLoader bcl = getBeanClassLoader();<br>            <span class="hljs-keyword">if</span> (bcl != <span class="hljs-keyword">null</span>) &#123;<br>                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果bean实现了BeanFactoryAware，则强转后调用setBeanFactory方法注入BeanFactory</span><br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware) &#123;<br>            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不过这里面有一个问题：有关 <code>ApplicationContext</code> 部分的处理，怎么一个也没有咧？？？有关这个问题，我们马上在下面就提到了，接着往下来看。</p>
<h4 id="1-4-2-applyBeanPostProcessorsBeforeInitialization"><a href="#1-4-2-applyBeanPostProcessorsBeforeInitialization" class="headerlink" title="1.4.2 applyBeanPostProcessorsBeforeInitialization"></a>1.4.2 applyBeanPostProcessorsBeforeInitialization</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    Object result = existingBean;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        Object current = processor.postProcessBeforeInitialization(result, beanName);<br>        <span class="hljs-comment">// 此处做了一个分支控制：如果处理完的结果返回null，则认为停止BeanPostProcessor的处理，返回bean对象</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个逻辑就很简单了，它会依次执行容器中所有 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法。不过这里有一个分支控制处理：如果处理完的结果返回 null ，则不再执行后面剩余的 <code>BeanPostProcessor</code> ，直接返回上一个 <code>BeanPostProcessor</code> 处理之后的 bean 对象返回。由此我们可以在此处针对自己项目中某些特定的 bean 搞一些特殊的拦截的处理。</p>
<p>只看这个逻辑还是很简单的吧，所以我们要深入其中，看几个 <code>BeanPostProcessor</code> 的实现。</p>
<h5 id="1-4-2-1-InitDestroyAnnotationBeanPostProcessor"><a href="#1-4-2-1-InitDestroyAnnotationBeanPostProcessor" class="headerlink" title="1.4.2.1 InitDestroyAnnotationBeanPostProcessor"></a>1.4.2.1 InitDestroyAnnotationBeanPostProcessor</h5><p>又要看它了，既然它有收集 bean 的初始化和销毁信息，那这里就肯定有回调的时机咯。这个源码的写法我们在上面已经看过好几个差不多的了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());<br>    <span class="hljs-keyword">try</span> &#123;<br>        metadata.invokeInitMethods(bean, beanName);<br>    &#125;<br>    <span class="hljs-comment">// catch ......</span><br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据上面分析的内容，我们已经知道，<code>findLifecycleMetadata</code> 方法可以把标注了 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解的方法都取出来，所以这里就相当于<strong>回调 <code>@PostConstruct</code> 标注的方法</strong>了！</p>
<p>进入到 <code>metadata.invokeInitMethod</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeInitMethods</span><span class="hljs-params">(Object target, String beanName)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    Collection&lt;LifecycleElement&gt; checkedInitMethods = <span class="hljs-keyword">this</span>.checkedInitMethods;<br>    Collection&lt;LifecycleElement&gt; initMethodsToIterate =<br>            (checkedInitMethods != <span class="hljs-keyword">null</span> ? checkedInitMethods : <span class="hljs-keyword">this</span>.initMethods);<br>    <span class="hljs-keyword">if</span> (!initMethodsToIterate.isEmpty()) &#123;<br>        <span class="hljs-keyword">for</span> (LifecycleElement element : initMethodsToIterate) &#123;<br>            <span class="hljs-comment">// logger ......</span><br>            element.invoke(target);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>又是熟悉的 <code>element.invoke</code> 操作，不过这里就没那么复杂了，点进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    ReflectionUtils.makeAccessible(<span class="hljs-keyword">this</span>.method);<br>    <span class="hljs-keyword">this</span>.method.invoke(target, (Object[]) <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>嚯，直接反射调用方法啊，也是非常简单粗暴咯。</p>
<p>另外，根据这个源码中的反射细节，我们也就知道一开始学习 bean 的初始化和销毁方法标注时的规定了：对于 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 标注的方法来讲，<strong>方法的访问修饰符无所谓，但一定不能有方法参数</strong>。</p>
<h5 id="1-4-2-2-ApplicationContextAwareProcessor"><a href="#1-4-2-2-ApplicationContextAwareProcessor" class="headerlink" title="1.4.2.2 ApplicationContextAwareProcessor"></a>1.4.2.2 ApplicationContextAwareProcessor</h5><p>呦，看到类名了，是不是突然明白前面的 <code>Aware</code> 回调为什么没有 <code>ApplicationContext</code> 相关的操作了？是的，这些回调都在这个 <code>ApplicationContextAwareProcessor</code> 中实现了。由此我们可以先得出一个结论：**<code>BeanFactory</code> 的注入时机比 <code>ApplicationContext</code> 早。**</p>
<p>接下来我们看源码的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-keyword">if</span> (!(bean <span class="hljs-keyword">instanceof</span> EnvironmentAware || bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware ||<br>            bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware || bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware ||<br>            bean <span class="hljs-keyword">instanceof</span> MessageSourceAware || bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware))&#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        invokeAwareInterfaces(bean);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现，这一个 <code>ApplicationContextAwareProcessor</code> 可以支持 6 个 <code>Aware</code> 接口的回调。至于回调的实现，<code>invokeAwareInterfaces</code> 的操作跟上面 <code>invokeAwareMethods</code> 一模一样，小册就不再贴出啦，小伙伴们可以自行去看一下。</p>
<h4 id="1-4-3-invokeInitMethods-执行初始化生命周期回调"><a href="#1-4-3-invokeInitMethods-执行初始化生命周期回调" class="headerlink" title="1.4.3 invokeInitMethods - 执行初始化生命周期回调"></a>1.4.3 invokeInitMethods - 执行初始化生命周期回调</h4><p>终于到了我们可能最熟悉的部分了，这里有 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet</code> 方法回调，以及 <code>init-method</code> 的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeInitMethods</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>    <span class="hljs-keyword">boolean</span> isInitializingBean = (bean <span class="hljs-keyword">instanceof</span> InitializingBean);<br>    <span class="hljs-keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="hljs-keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="hljs-string">&quot;afterPropertiesSet&quot;</span>))) &#123;<br>        <span class="hljs-comment">// ......</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 回调InitializingBean的afterPropertiesSet方法</span><br>            ((InitializingBean) bean).afterPropertiesSet();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mbd != <span class="hljs-keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;<br>        String initMethodName = mbd.getInitMethodName();<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;<br>                !(isInitializingBean &amp;&amp; <span class="hljs-string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;<br>                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;<br>            <span class="hljs-comment">// 回调init-method方法（同样是反射调用）</span><br>            invokeCustomInitMethod(beanName, bean, mbd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这部分源码理解起来那是相当的容易了是吧！so 小册也不作过多解释咯。</p>
<h4 id="1-4-4-applyBeanPostProcessorsAfterInitialization"><a href="#1-4-4-applyBeanPostProcessorsAfterInitialization" class="headerlink" title="1.4.4 applyBeanPostProcessorsAfterInitialization"></a>1.4.4 applyBeanPostProcessorsAfterInitialization</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    Object result = existingBean;<br>    <span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;<br>        Object current = processor.postProcessAfterInitialization(result, beanName);<br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        result = current;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>处理逻辑与 <code>applyBeanPostProcessorsBeforeInitialization</code> 部分几乎一模一样，我们还是来关注几个重要的后置处理的实现。</p>
<h5 id="1-4-4-1-AbstractAutoProxyCreator"><a href="#1-4-4-1-AbstractAutoProxyCreator" class="headerlink" title="1.4.4.1 AbstractAutoProxyCreator"></a>1.4.4.1 AbstractAutoProxyCreator</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>        Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;<br>            <span class="hljs-comment">// 创建代理对象</span><br>            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这就是之前我们在学习 <code>BeanPostProcessor</code> 中一直提到的创建代理的核心处理器了，它也是 <strong>AOP</strong> 创建代理对象的核心实现。由于这个逻辑属于 AOP 的内容，咱回头放到 AOP 章节详细展开。</p>
<h5 id="1-4-4-2-ApplicationListenerDetector"><a href="#1-4-4-2-ApplicationListenerDetector" class="headerlink" title="1.4.4.2 ApplicationListenerDetector"></a>1.4.4.2 ApplicationListenerDetector</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationListener) &#123;<br>        Boolean flag = <span class="hljs-keyword">this</span>.singletonNames.get(beanName);<br>        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(flag)) &#123;<br>            <span class="hljs-keyword">this</span>.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);<br>        &#125;<br>        <span class="hljs-comment">// 异常分支处理 ......</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 <code>ApplicationListenerDetector</code> 我们在上一章的 <code>BeanPostProcessor</code> 初始化阶段还说过一次，它用来关联所有的监听器引用。同样的，监听器在创建的时候，也需要 <code>ApplicationListenerDetector</code> 把这些监听器挂进 <code>ApplicationContext</code> 中，这样这些监听器才可以被事件广播器使用。</p>
<h3 id="1-5-注册销毁时的回调"><a href="#1-5-注册销毁时的回调" class="headerlink" title="1.5 注册销毁时的回调"></a>1.5 注册销毁时的回调</h3><p>如果一个 bean 定义的 class 有实现 <code>DisposableBean</code> 接口，或者声明了 <code>@PreDestroy</code> 注解，或者声明了 <code>destroy-method</code> 方法，则会在 <code>doCreateBean</code> 方法的最后一步，注册一个销毁 bean 的回调钩子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// doCreateBean 最后 ......</span><br>    <span class="hljs-comment">// Register bean as disposable.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>    &#125;<br>    <span class="hljs-comment">// catch ......</span><br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>进入 <code>registerDisposableBeanIfNecessary</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDisposableBeanIfNecessary</span><span class="hljs-params">(String beanName, Object bean, RootBeanDefinition mbd)</span> </span>&#123;<br>    AccessControlContext acc = (System.getSecurityManager() != <span class="hljs-keyword">null</span> ? getAccessControlContext() : <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 不是原型bean，且有定义销毁类型的方法</span><br>    <span class="hljs-keyword">if</span> (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;<br>        <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>            registerDisposableBean(beanName,<br>                    <span class="hljs-keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));<br>        &#125;<br>        <span class="hljs-comment">// 处理特殊的scope ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可见，通常情况下可以记录销毁 bean 的回调钩子的原则是：<strong>单实例 bean ，并且有定义销毁类型的方法</strong>，而这些销毁类型的方法，就是刚才提到的三种类型，也是早在第 13 章我们就学过的类型。</p>
<p>对于这些定义了销毁类型的方法的 bean ，会记录到一个 <code>disposableBeans</code> 的 <code>Map</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; disposableBeans = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDisposableBean</span><span class="hljs-params">(String beanName, DisposableBean bean)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.disposableBeans) &#123;<br>        <span class="hljs-keyword">this</span>.disposableBeans.put(beanName, bean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 <code>Map</code> 在下一章的 bean 销毁部分还会提及，小伙伴们可以先留意一下。</p>
<p>到这里，<code>doCreateBean</code> 方法全部执行完毕，一个 bean 已经被成功的创建出来了。</p>
<h2 id="2-SmartInitializingSingleton"><a href="#2-SmartInitializingSingleton" class="headerlink" title="2. SmartInitializingSingleton"></a>2. SmartInitializingSingleton</h2><p>在上一章的第 2 节 <code>preInstantiateSingletons</code> 方法中，我们只做了 <code>getBean</code> 方法的全解析，当时在源码的注释中，小册在最后埋了一个伏笔：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 普通的初始化，就是getBean方法</span><br>                getBean(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化的最后阶段 ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个初始化的最后阶段，是在 SpringFramework 4.1 之后才有的，而支撑这个阶段的核心接口是 <code>SmartInitializingSingleton</code> 。</p>
<blockquote>
<p>这个接口在开发中的使用意义不是很大，小伙伴们简单了解下就可以了。</p>
</blockquote>
<h3 id="2-1-SmartInitializingSingleton的设计"><a href="#2-1-SmartInitializingSingleton的设计" class="headerlink" title="2.1 SmartInitializingSingleton的设计"></a>2.1 SmartInitializingSingleton的设计</h3><p>在 <code>SmartInitializingSingleton</code> 接口的 javadoc 中，可以找到这样的一段话：</p>
<blockquote>
<p>This callback variant is somewhat similar to org.springframework.context.event.ContextRefreshedEvent but doesn’t require an implementation of org.springframework.context.ApplicationListener, with no need to filter context references across a context hierarchy etc. It also implies a more minimal dependency on just the beans package and is being honored by standalone ListableBeanFactory implementations, not just in an org.springframework.context.ApplicationContext environment.</p>
<p>这个回调变体有点类似于 <code>ContextRefreshedEvent</code> ，但是不需要 <code>ApplicationListener</code> 的实现，不需要在整个上下文层次结构中过滤上下文引用。这也意味着更多对 bean 包的依赖性最小，并且由独立的 <code>ListableBeanFactory</code> 实现兑现，而不仅仅是在 <code>ApplicationContext</code> 环境中。</p>
</blockquote>
<p>从这段注释中，我们就可以知道，**<code>SmartInitializingSingleton</code> 的设计是为了只让 <code>BeanFactory</code> 控制的，不需要 <code>ApplicationContext</code> 也能实现的 bean 的初始化后处理**。而且从包名上也能看得出来：<code>org.springframework.beans.factory</code> ，嗯，是 <code>beans</code> 包下的，与 <code>context</code> 没关联。</p>
<blockquote>
<p>这个地方作者认为没有必要深究它的出现缘由，毕竟对于我们开发者来讲，可供切入框架中的时机越多，灵活度也就越高，重要的我们学习，不重要的我们知道一下就好了。</p>
</blockquote>
<h3 id="2-2-SmartInitializingSingleton的回调"><a href="#2-2-SmartInitializingSingleton的回调" class="headerlink" title="2.2 SmartInitializingSingleton的回调"></a>2.2 SmartInitializingSingleton的回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">            <span class="hljs-keyword">else</span> &#123;<br>                getBean(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        Object singletonInstance = getSingleton(beanName);<br>        <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;<br>            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;<br>            <span class="hljs-comment">// ......</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                smartSingleton.afterSingletonsInstantiated();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>SmartInitializingSingleton</code> 的回调时机，是所有的非延迟加载的单实例 bean 都初始化完成后，再挨个执行 <code>afterSingletonsInstantiated</code> 方法，调用的方式非常简单，逐个判断就完事了，也没什么好解释的。</p>
<h2 id="3-Lifecycle的回调"><a href="#3-Lifecycle的回调" class="headerlink" title="3. Lifecycle的回调"></a>3. Lifecycle的回调</h2><p>在 <code>ApplicationContext</code> 的 <code>refresh</code> 方法最后，初始化完成所有非延迟加载的单实例 bean 之后，会执行 <code>finishRefresh</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span><br>    <span class="hljs-comment">// 清除上下文级别的资源缓存</span><br>    clearResourceCaches();<br><br>    <span class="hljs-comment">// Initialize lifecycle processor for this context.</span><br>    <span class="hljs-comment">// 为当前ApplicationContext初始化一个生命周期处理器</span><br>    initLifecycleProcessor();<br><br>    <span class="hljs-comment">// Propagate refresh to lifecycle processor first.</span><br>    <span class="hljs-comment">// 将refresh的动作传播到生命周期处理器</span><br>    getLifecycleProcessor().onRefresh();<br><br>    <span class="hljs-comment">// Publish the final event.</span><br>    <span class="hljs-comment">// 广播事件</span><br>    publishEvent(<span class="hljs-keyword">new</span> ContextRefreshedEvent(<span class="hljs-keyword">this</span>));<br><br>    <span class="hljs-comment">// Participate in LiveBeansView MBean, if active.</span><br>    LiveBeansView.registerApplicationContext(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以发现，这里面的处理逻辑还是很有序的，首先把该读取的一些资源缓存都清除掉，然后它初始化了一个生命周期处理器，随后调用它的 <code>onRefresh</code> 方法，接下来广播 <code>ContextRefreshedEvent</code> 事件。而回调 <code>Lifecycle</code> 接口的动作，就发生在这个生命周期处理器中。</p>
<h3 id="3-1-initLifecycleProcessor"><a href="#3-1-initLifecycleProcessor" class="headerlink" title="3.1 initLifecycleProcessor"></a>3.1 initLifecycleProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLifecycleProcessor</span><span class="hljs-params">()</span> </span>&#123;<br>    ConfigurableListableBeanFactory beanFactory = getBeanFactory();<br>    <span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;<br>        <span class="hljs-keyword">this</span>.lifecycleProcessor =<br>                beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);<br>        <span class="hljs-comment">// logger ......</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        DefaultLifecycleProcessor defaultProcessor = <span class="hljs-keyword">new</span> DefaultLifecycleProcessor();<br>        defaultProcessor.setBeanFactory(beanFactory);<br>        <span class="hljs-keyword">this</span>.lifecycleProcessor = defaultProcessor;<br>        beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="hljs-keyword">this</span>.lifecycleProcessor);<br>        <span class="hljs-comment">// logger ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由此可以发现，无论 <code>BeanFactory</code> 中有没有 <code>LifecycleProcessor</code> ，它都会保证最终容器中会有，注意它的实现类是 <code>DefaultLifecycleProcessor</code> ，我们下面会进入它的内部实现。</p>
<h3 id="3-2-onRefresh"><a href="#3-2-onRefresh" class="headerlink" title="3.2 onRefresh"></a>3.2 onRefresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> </span>&#123;<br>    startBeans(<span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">this</span>.running = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>DefaultLifecycleProcessor</code> 的 <code>onRefresh</code> 方法非常简单，就是启动 bean 。继续往下进到源码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startBeans</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoStartupOnly)</span> </span>&#123;<br>    Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();<br>    Map&lt;Integer, LifecycleGroup&gt; phases = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    lifecycleBeans.forEach((beanName, bean) -&gt; &#123;<br>        <span class="hljs-comment">// 注意此处，如果autoStartupOnly为true，则不会执行</span><br>        <span class="hljs-keyword">if</span> (!autoStartupOnly || (bean <span class="hljs-keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;<br>            <span class="hljs-keyword">int</span> phase = getPhase(bean);<br>            LifecycleGroup group = phases.get(phase);<br>            <span class="hljs-keyword">if</span> (group == <span class="hljs-keyword">null</span>) &#123;<br>                group = <span class="hljs-keyword">new</span> LifecycleGroup(phase, <span class="hljs-keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);<br>                phases.put(phase, group);<br>            &#125;<br>            group.add(beanName, bean);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (!phases.isEmpty()) &#123;<br>        List&lt;Integer&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(phases.keySet());<br>        Collections.sort(keys);<br>        <span class="hljs-keyword">for</span> (Integer key : keys) &#123;<br>            <span class="hljs-comment">// 依次调用Lifecycle的start方法</span><br>            phases.get(key).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里面就是一个一个调用 <code>Lifecycle</code> 的 <code>start</code> 方法的位置了，但请小伙伴们注意一点：由于 <code>onRefresh</code> 方法中调用的 <code>startBeans(true);</code> 传入的参数是 <strong>true</strong> ，<code>lifecycleBeans.forEach</code> 部分不会执行，所以在该阶段不会回调 <code>Lifecycle</code> 的 <code>start</code> 方法！</p>
<h3 id="3-3-ApplicationContext-start"><a href="#3-3-ApplicationContext-start" class="headerlink" title="3.3 ApplicationContext#start"></a>3.3 ApplicationContext#start</h3><p>那这些 <code>Lifecycle</code> 的 <code>start</code> 方法什么时候才能被调用呢？我们回到测试代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.refresh();<br>System.out.println(<span class="hljs-string">&quot;================IOC容器刷新完毕==================&quot;</span>);<br>ctx.start();<br><br><span class="hljs-comment">// ---------AbstractApplicationContext----------</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    getLifecycleProcessor().start();<br>    publishEvent(<span class="hljs-keyword">new</span> ContextStartedEvent(<span class="hljs-keyword">this</span>));<br>&#125;<br><br><span class="hljs-comment">// ---------DefaultLifecycleProcessor-----------</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    startBeans(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">this</span>.running = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面我们主动的调用了 <code>ctx.start()</code> 方法，而 <code>ApplicationContext</code> 的 <code>start</code> 方法中调用的 <code>LifecycleProcessor</code> ，会最终调用 <code>startBeans(false);</code> ，激活 <code>Lifecycle</code> 回调的逻辑。</p>
<p>好，了解到 <code>Lifecycle</code> 真正回调的时机，下面我们还是看看 SpringFramework 是如何回调 <code>Lifecycle</code> 的。</p>
<h4 id="3-3-1-startBeans"><a href="#3-3-1-startBeans" class="headerlink" title="3.3.1 startBeans"></a>3.3.1 startBeans</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startBeans</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoStartupOnly)</span> </span>&#123;<br>    Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();<br>    Map&lt;Integer, LifecycleGroup&gt; phases = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    lifecycleBeans.forEach((beanName, bean) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (!autoStartupOnly || (bean <span class="hljs-keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;<br>            <span class="hljs-comment">// 此处的phase可类比Order</span><br>            <span class="hljs-keyword">int</span> phase = getPhase(bean);<br>            LifecycleGroup group = phases.get(phase);<br>            <span class="hljs-keyword">if</span> (group == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 不同的phase分到不同的group中</span><br>                group = <span class="hljs-keyword">new</span> LifecycleGroup(phase, <span class="hljs-keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);<br>                phases.put(phase, group);<br>            &#125;<br>            group.add(beanName, bean);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>我们把 <code>startBeans</code> 方法分为两部分来看，前半段的操作很明显是一个分组的动作。这里面的 <code>phase</code> 可以类比为 <code>Order</code> ，<code>LifecycleGroup</code> 可以简单的理解为 <code>List&lt;Lifecycle&gt;</code> 。所以这个过程很明显，就是<strong>将所有的 <code>Lifecycle</code> 按照不同的 <code>phase</code> 分组</strong>而已。</p>
<h4 id="3-3-2-start"><a href="#3-3-2-start" class="headerlink" title="3.3.2 start"></a>3.3.2 start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">if</span> (!phases.isEmpty()) &#123;<br>        List&lt;Integer&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(phases.keySet());<br>        Collections.sort(keys);<br>        <span class="hljs-keyword">for</span> (Integer key : keys) &#123;<br>            <span class="hljs-comment">// </span><br>            phases.get(key).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分组之后，它会根据不同的 <code>phase</code> 排序后依次执行，而执行的 <code>start</code> 方法看上去比较复杂，最终还是调用 <code>Lifecycle</code> 的 <code>start</code> 方法：（注意下面的源码中比较靠后的关键注释）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.members.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// logger ......</span><br>    Collections.sort(<span class="hljs-keyword">this</span>.members);<br>    <span class="hljs-keyword">for</span> (LifecycleGroupMember member : <span class="hljs-keyword">this</span>.members) &#123;<br>        doStart(<span class="hljs-keyword">this</span>.lifecycleBeans, member.name, <span class="hljs-keyword">this</span>.autoStartupOnly);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStart</span><span class="hljs-params">(Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, String beanName, <span class="hljs-keyword">boolean</span> autoStartupOnly)</span> </span>&#123;<br>    Lifecycle bean = lifecycleBeans.remove(beanName);<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span> &amp;&amp; bean != <span class="hljs-keyword">this</span>) &#123;<br>        String[] dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName);<br>        <span class="hljs-keyword">for</span> (String dependency : dependenciesForBean) &#123;<br>            doStart(lifecycleBeans, dependency, autoStartupOnly);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!bean.isRunning() &amp;&amp;<br>                (!autoStartupOnly || !(bean <span class="hljs-keyword">instanceof</span> SmartLifecycle) || ((SmartLifecycle) bean).isAutoStartup())) &#123;<br>            <span class="hljs-comment">// logger ......</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 【调用实现了Lifecycle接口的bean】</span><br>                bean.start();<br>            &#125;<br>            <span class="hljs-comment">// catch ......</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>等所有 <code>Lifecycle</code> 都执行完毕，一个 bean 的完整初始化生命周期也就结束了。</p>
<h2 id="面试如何回答bean初始化部分的生命周期"><a href="#面试如何回答bean初始化部分的生命周期" class="headerlink" title="面试如何回答bean初始化部分的生命周期"></a>面试如何回答bean初始化部分的生命周期</h2><p>以下答案<strong>仅供参考</strong>，可根据个人理解进行实际调整：</p>
<p><strong>bean 对象创建完成后，会进行属性赋值、组件依赖注入，以及初始化阶段的方法回调。在 <code>populateBean</code> 属性赋值阶段，会事先收集好 bean 中标注了依赖注入的注解（ <code>@Autowired</code> 、<code>@Value</code> 、<code>@Resource</code> 、<code>@Inject</code> ），之后会借助后置处理器，回调 <code>postProcessProperties</code> 方法实现依赖注入。</strong></p>
<p><strong>属性赋值和依赖注入之后，会回调执行 bean 的初始化方法，以及后置处理器的逻辑：首先会执行 Aware 相关的回调注入，之后执行后置处理器的前置回调，在后置处理器的前置方法中，会回调 bean 中标注了 <code>@PostConstruct</code> 注解的方法，所有的后置处理器前置回调后，会执行 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法，随后是 <code>init-method</code> 指定的方法，等这些 bean 的初始化方法都回调完毕后，最后执行后置处理器的后置回调。</strong></p>
<p><strong>全部的 bean 初始化结束后，<code>ApplicationContext</code> 的 <code>start</code> 方法触发时，会触发实现了 <code>Lifecycle</code> 接口的 bean 的 <code>start</code> 方法。</strong></p>
<p>到此为止，bean 的初始化部分就全部完成了，最后一部分我们来看看 bean 的销毁阶段会发生哪些逻辑。</p>
<h1 id="五、Bean的生命周期-Bean的销毁阶段"><a href="#五、Bean的生命周期-Bean的销毁阶段" class="headerlink" title="五、Bean的生命周期-Bean的销毁阶段"></a>五、Bean的生命周期-Bean的销毁阶段</h1><p>bean 完整生命周期原理的最后一部分，我们来研究应用停止时，bean 的销毁阶段都有哪些动作和过程。</p>
<p>本章主要会涉及到的原理部分：</p>
<ul>
<li>bean 销毁前 IOC 容器的处理</li>
<li>bean 销毁阶段的回调</li>
</ul>
<p>在测试代码中，我们有主动调用 <code>ApplicationContext</code> 的 <code>stop</code> 和 <code>close</code> 方法，这样 IOC 容器的关闭和销毁流程就会依次执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">    ctx.stop();<br>    System.out.println(<span class="hljs-string">&quot;================IOC容器停止成功==================&quot;</span>);<br>    ctx.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先来看 <code>stop</code> 的内容。</p>
<h2 id="1-ApplicationContext-stop"><a href="#1-ApplicationContext-stop" class="headerlink" title="1. ApplicationContext#stop"></a>1. ApplicationContext#stop</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    getLifecycleProcessor().stop();<br>    publishEvent(<span class="hljs-keyword">new</span> ContextStoppedEvent(<span class="hljs-keyword">this</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>呦，这个套路不正好跟上一章看到的 <code>start</code> 动作完全相反吗？这个 <code>LifecycleProcessor</code> 中的 <code>stop</code> 方法一定也是先给所有的 <code>Lifecycle</code> bean 分组，排序，依次调用 <code>stop</code> 方法。当然，我们的推测是绝对正确的，小伙伴们可以跟着源码进去看一看，小册就不贴出来了。</p>
<h2 id="2-ApplicationContext-close"><a href="#2-ApplicationContext-close" class="headerlink" title="2. ApplicationContext#close"></a>2. ApplicationContext#close</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        doClose();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.shutdownHook != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Runtime.getRuntime().removeShutdownHook(<span class="hljs-keyword">this</span>.shutdownHook);<br>            &#125;<br>            <span class="hljs-comment">// catch ......</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关闭容器的动作，仅仅只有一个 <code>doClose</code> 方法，那我们就往里进就好。不过这个 <code>doClose</code> 方法有点长，我们拆解开来讲解。</p>
<h3 id="2-1-广播事件"><a href="#2-1-广播事件" class="headerlink" title="2.1 广播事件"></a>2.1 广播事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doClose</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Check whether an actual close attempt is necessary...</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.active.get() &amp;&amp; <span class="hljs-keyword">this</span>.closed.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        <span class="hljs-comment">// logger ......</span><br>        LiveBeansView.unregisterApplicationContext(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Publish shutdown event.</span><br>            publishEvent(<span class="hljs-keyword">new</span> ContextClosedEvent(<span class="hljs-keyword">this</span>));<br>        &#125; <span class="hljs-comment">// catch ......</span><br>        <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这一段非常简单，广播 <code>ContextClosedEvent</code> 事件而已。前面在事件章节的讲解中我们也说过，SpringFramework 中一共内置了 4 个可供监听的预设事件，它们<strong>都是给开发者自己使用</strong>的，SpringFramework 内部是没有任何利用的。</p>
<h3 id="2-2-LifecycleProcessor-onClose"><a href="#2-2-LifecycleProcessor-onClose" class="headerlink" title="2.2 LifecycleProcessor#onClose"></a>2.2 LifecycleProcessor#onClose</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lifecycleProcessor != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">this</span>.lifecycleProcessor.onClose();<br>    &#125; <span class="hljs-comment">// catch ......</span><br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>等一下？这怎么又是 <code>LifecycleProcessor</code> ？该不会。。。它的 <code>onClose</code> 方法又是跟 <code>stop</code> 一样？看一眼源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span> </span>&#123;<br>    stopBeans();<br>    <span class="hljs-keyword">this</span>.running = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>wtf ？？？好吧，果然跟上面是一样一样的，那小册就不赘述啦。</p>
<h3 id="2-3-destroyBeans-销毁bean"><a href="#2-3-destroyBeans-销毁bean" class="headerlink" title="2.3 destroyBeans - 销毁bean"></a>2.3 destroyBeans - 销毁bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Destroy all cached singletons in the context&#x27;s BeanFactory.</span><br>destroyBeans();<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这一部分我们只看这一个方法，不要觉得它简单哦，它的复杂度还是挺高的，我们进入来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyBeans</span><span class="hljs-params">()</span> </span>&#123;<br>    getBeanFactory().destroySingletons();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现倒也简单，仅仅是获取到 <code>ApplicationContext</code> 内部的 <code>BeanFactory</code> ，让它去销毁所有的单实例 bean 。</p>
<h4 id="2-3-1-DefaultListableBeanFactory-destroySingletons"><a href="#2-3-1-DefaultListableBeanFactory-destroySingletons" class="headerlink" title="2.3.1 DefaultListableBeanFactory#destroySingletons"></a>2.3.1 DefaultListableBeanFactory#destroySingletons</h4><p>继续往里走，进入到 <code>DefaultListableBeanFactory</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroySingletons</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.destroySingletons();<br>    <span class="hljs-comment">// 清空单实例bean的名称</span><br>    updateManualSingletonNames(Set::clear, set -&gt; !set.isEmpty());<br>    clearByTypeCache();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">64</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">64</span>);<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearByTypeCache</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.allBeanNamesByType.clear();<br>    <span class="hljs-keyword">this</span>.singletonBeanNamesByType.clear();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码中首先会调用父类 <code>DefaultSingletonBeanRegistry</code> 的 <code>destroySingletons</code> 方法，随后会清空所有的单实例 bean 的名称，以及 “类型到 name ” 的映射。（ <code>allBeanNamesByType</code> 中保存了 bean 的类型包含的所有 bean ，如 <code>Person</code> 类型的 bean 在 IOC 容器中包含 <code>master</code> 和 <code>admin</code> ）</p>
<h4 id="2-3-2-DefaultSingletonBeanRegistry-destroySingletons"><a href="#2-3-2-DefaultSingletonBeanRegistry-destroySingletons" class="headerlink" title="2.3.2 DefaultSingletonBeanRegistry#destroySingletons"></a>2.3.2 DefaultSingletonBeanRegistry#destroySingletons</h4><p>重点还是在 <code>DefaultSingletonBeanRegistry</code> 中，进入它的 <code>destroySingletons</code> 方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroySingletons</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// logger ......</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>        <span class="hljs-keyword">this</span>.singletonsCurrentlyInDestruction = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    String[] disposableBeanNames;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.disposableBeans) &#123;<br>        <span class="hljs-comment">// set -&gt; array</span><br>        disposableBeanNames = StringUtils.toStringArray(<span class="hljs-keyword">this</span>.disposableBeans.keySet());<br>    &#125;<br>    <span class="hljs-comment">// 销毁所有单实例bean</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = disposableBeanNames.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        destroySingleton(disposableBeanNames[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 清空一切缓存</span><br>    <span class="hljs-keyword">this</span>.containedBeanMap.clear();<br>    <span class="hljs-keyword">this</span>.dependentBeanMap.clear();<br>    <span class="hljs-keyword">this</span>.dependenciesForBeanMap.clear();<br><br>    clearSingletonCache();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段源码看着挺长，核心就一句：重载的 <code>destroySingleton(beanName)</code> 。下面的好多 <code>Map</code> 的 <code>clear</code> 动作，以及 <code>clearSingletonCache</code> 方法，都是清除掉缓存而已，核心还是逐个销毁单实例 bean 。</p>
<h4 id="2-3-3-destroySingleton"><a href="#2-3-3-destroySingleton" class="headerlink" title="2.3.3 destroySingleton"></a>2.3.3 destroySingleton</h4><p>进入到单个 bean 的销毁流程，Debug 发现又回到 <code>DefaultListableBeanFactory</code> 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroySingleton</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.destroySingleton(beanName);<br>    removeManualSingletonName(beanName);<br>    clearByTypeCache();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>-.- 又来这一套是吧，合着销毁一个，跟销毁一堆的套路是一样一样的，那我们继续往里进，还是走到 <code>DefaultSingletonBeanRegistry</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroySingleton</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// Remove a registered singleton of the given name, if any.</span><br>    <span class="hljs-comment">// 此处会清理掉BeanFactory中设计的用于处理bean循环依赖的三级缓存</span><br>    <span class="hljs-comment">// 如果小伙伴对此感兴趣，可以参考boot小册第15章</span><br>    removeSingleton(beanName);<br><br>    <span class="hljs-comment">// Destroy the corresponding DisposableBean instance.</span><br>    DisposableBean disposableBean;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.disposableBeans) &#123;<br>        disposableBean = (DisposableBean) <span class="hljs-keyword">this</span>.disposableBeans.remove(beanName);<br>    &#125;<br>    destroyBean(beanName, disposableBean);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>销毁单个 bean 的动作总共就两步：<strong>清空 <code>BeanFactory</code> 中用于处理循环依赖的缓存，回调 bean 的销毁动作</strong>。重要的方法仍然在最后，我们继续往里深入：</p>
<h4 id="2-3-4-destroyBean"><a href="#2-3-4-destroyBean" class="headerlink" title="2.3.4 destroyBean"></a>2.3.4 destroyBean</h4><p>这个方法又是好长啊，我们还是拆解开来看。</p>
<h5 id="2-3-4-1-销毁依赖的bean"><a href="#2-3-4-1-销毁依赖的bean" class="headerlink" title="2.3.4.1 销毁依赖的bean"></a>2.3.4.1 销毁依赖的bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyBean</span><span class="hljs-params">(String beanName, <span class="hljs-meta">@Nullable</span> DisposableBean bean)</span> </span>&#123;<br>    Set&lt;String&gt; dependencies;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.dependentBeanMap) &#123;<br>        dependencies = <span class="hljs-keyword">this</span>.dependentBeanMap.remove(beanName);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dependencies != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// logger ......</span><br>        <span class="hljs-keyword">for</span> (String dependentBeanName : dependencies) &#123;<br>            destroySingleton(dependentBeanName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>首先，在销毁一个 bean 时，如果它有依赖其它的 bean ，则首要目标不是销毁自己，而是先销毁那些依赖的 bean ，所以这里会有递归调用上面 <code>destroySingleton</code> 方法的动作。</p>
<h5 id="2-3-4-2-自定义bean销毁方法的回调"><a href="#2-3-4-2-自定义bean销毁方法的回调" class="headerlink" title="2.3.4.2 自定义bean销毁方法的回调"></a>2.3.4.2 自定义bean销毁方法的回调</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Actually destroy the bean now...</span><br><span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        bean.destroy();<br>    &#125;<br>    <span class="hljs-comment">// catch ......</span><br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>动作很简单，一个 <code>destroy</code> 方法就完事了，点击去看一下吧：（注意看源码中的注释）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.beanPostProcessors)) &#123;<br>        <span class="hljs-comment">// 回调DestructionAwareBeanPostProcessor</span><br>        <span class="hljs-comment">// 此处会有执行@PreDestroy注解标注的销毁方法</span><br>        <span class="hljs-keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="hljs-keyword">this</span>.beanPostProcessors) &#123;<br>            processor.postProcessBeforeDestruction(<span class="hljs-keyword">this</span>.bean, <span class="hljs-keyword">this</span>.beanName);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.invokeDisposableBean) &#123;<br>        <span class="hljs-comment">// logger ......</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ......</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 回调DisposableBean接口的destroy方法</span><br>                ((DisposableBean) <span class="hljs-keyword">this</span>.bean).destroy();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// catch ......</span><br>    &#125;<br><br>    <span class="hljs-comment">// 回调自定义的destroy-method方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyMethod != <span class="hljs-keyword">null</span>) &#123;<br>        invokeCustomDestroyMethod(<span class="hljs-keyword">this</span>.destroyMethod);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyMethodName != <span class="hljs-keyword">null</span>) &#123;<br>        Method methodToInvoke = determineDestroyMethod(<span class="hljs-keyword">this</span>.destroyMethodName);<br>        <span class="hljs-keyword">if</span> (methodToInvoke != <span class="hljs-keyword">null</span>) &#123;<br>            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里我们就发现了，它会把我们常用的三种 bean 的销毁手段都依次执行一遍，同时也就解释了 bean 的销毁阶段生命周期回调的顺序：**<code>@PreDestroy</code> → <code>DisposableBean</code> → <code>destroy-method</code>** 。</p>
<h5 id="2-3-4-3-处理bean中bean"><a href="#2-3-4-3-处理bean中bean" class="headerlink" title="2.3.4.3 处理bean中bean"></a>2.3.4.3 处理bean中bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Trigger destruction of contained beans...</span><br>Set&lt;String&gt; containedBeans;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.containedBeanMap) &#123;<br>    <span class="hljs-comment">// Within full synchronization in order to guarantee a disconnected Set</span><br>    containedBeans = <span class="hljs-keyword">this</span>.containedBeanMap.remove(beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (containedBeans != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (String containedBeanName : containedBeans) &#123;<br>        destroySingleton(containedBeanName);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure>
<p>这个概念不是很好理解吧，bean 中 bean 是什么鬼？还记得第 9 章中，我们在写复杂类型注入的时候，说可以在 property 中再写 <code>&lt;bean&gt;</code> 这回事吧，不记得也没有关系，我改一下原有的测试代码，想必你一下子就能想起来了吧：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.lifecycle.e_source.bean.Cat&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mimi&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;master&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.lifecycle.e_source.bean.Person&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>哎，这种嵌套 bean ，就会记录在 <code>DefaultSingletonBeanRegistry</code> 的 <code>containedBeanMap</code> 中，既然外头的 bean 要销毁了，那里头的这些 bean 也就应该被销毁了，所以这里又是取到那些内部构造好的 bean ，依次递归调用 <code>destroySingleton</code> 方法来销毁这些 bean 。</p>
<h5 id="2-3-4-4-销毁被依赖的bean"><a href="#2-3-4-4-销毁被依赖的bean" class="headerlink" title="2.3.4.4 销毁被依赖的bean"></a>2.3.4.4 销毁被依赖的bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// Remove destroyed bean from other beans&#x27; dependencies.</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.dependentBeanMap) &#123;<br>        <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = <span class="hljs-keyword">this</span>.dependentBeanMap.entrySet().iterator(); it.hasNext();) &#123;<br>            Map.Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();<br>            Set&lt;String&gt; dependenciesToClean = entry.getValue();<br>            dependenciesToClean.remove(beanName);<br>            <span class="hljs-keyword">if</span> (dependenciesToClean.isEmpty()) &#123;<br>                it.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Remove destroyed bean&#x27;s prepared dependency information.</span><br>    <span class="hljs-keyword">this</span>.dependenciesForBeanMap.remove(beanName);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意这里的说法，这里是销毁那些<strong>被</strong>依赖的 bean ，由于一个 bean 可能被其它 bean 引用或者依赖，所以在最后一步，<strong>当自己销毁之后，那些依赖了当前 bean 的 bean 也就应该被销毁</strong>。套路都是一样的，取到那些被依赖的 bean 的名称，依次递归调用 <code>destroySingleton</code> 方法销毁。</p>
<p>到这里，<code>destroyBeans</code> 销毁单实例 bean 的逻辑就全部走完了，继续往下看 <code>doClose</code> 方法还干了什么事。</p>
<h3 id="2-4-关闭BeanFactory"><a href="#2-4-关闭BeanFactory" class="headerlink" title="2.4 关闭BeanFactory"></a>2.4 关闭BeanFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Close the state of this context itself.</span><br>closeBeanFactory();<br></code></pre></td></tr></table></figure>
<p>这个步骤，说是关闭 <code>BeanFactory</code> ，实际上更接近于 “销毁” ，因为原来的 <code>BeanFactory</code> 无论如何都无法继续用了。</p>
<p>在基于 xml 和基于注解驱动的两种 <code>ApplicationContext</code> 的实现里，它们的策略既相似又不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractRefreshableApplicationContext</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeBeanFactory</span><span class="hljs-params">()</span> </span>&#123;<br>    DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.beanFactory;<br>    <span class="hljs-keyword">if</span> (beanFactory != <span class="hljs-keyword">null</span>) &#123;<br>        beanFactory.setSerializationId(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">this</span>.beanFactory = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在基于 xml 配置文件的 <code>ApplicationContext</code> 中，它会获取到原有的 <code>BeanFactory</code> ，移除序列化 ID ，并直接丢弃原来的 <code>BeanFactory</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GenericApplicationContext</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeBeanFactory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.beanFactory.setSerializationId(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在基于注解驱动的 <code>ApplicationContext</code> 中，它只会给内部组合的 <code>BeanFactory</code> 移除序列化 ID 而已。</p>
<h4 id="2-4-1-GenericApplicationContext不允许被重复刷新的原因"><a href="#2-4-1-GenericApplicationContext不允许被重复刷新的原因" class="headerlink" title="2.4.1 GenericApplicationContext不允许被重复刷新的原因"></a>2.4.1 GenericApplicationContext不允许被重复刷新的原因</h4><p>这个时候可能会有小伙伴们产生疑惑：之前不是说 <code>GenericApplicationContext</code> 不允许重复刷新吗？既然它只是移除了一下序列化 ID ，那刷新的时候重新设置一个不就行了吗？哎，这个时候我们要了解 <code>GenericApplicationContext</code> 中的另外一个成员了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean refreshed = <span class="hljs-keyword">new</span> AtomicBoolean();<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshed.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br>            <span class="hljs-string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>看这里，如果当前 <code>GenericApplicationContext</code> 是刚创建的，那么 <code>refreshed</code> 的值一定是 false ，此时使用 CAS 设置 true 是成功的，下面的 <code>throw ex</code> 动作不会执行；而第二次再调用 <code>refresh</code> 刷新 <code>ApplicationContext</code> 时，进入到该方法时，CAS 不通过，无法刷新 <code>BeanFactory</code> ，最终抛出异常。</p>
<p>为什么 <code>AbstractRefreshableApplicationContext</code> 就没这事呢？因为 <code>AbstractRefreshableApplicationContext</code> 中本来就没这个 <code>refreshed</code> 的设计，而且人家在关闭 <code>BeanFactory</code> 的时候，直接把原来的 <code>BeanFactory</code> 扔了，不要了，那当然得支持刷新呀（不然 <code>BeanFactory</code> 都没了 <code>ApplicationContext</code> 就是一空壳）。</p>
<h3 id="2-5-剩余动作"><a href="#2-5-剩余动作" class="headerlink" title="2.5 剩余动作"></a>2.5 剩余动作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ......</span><br>    <span class="hljs-comment">// Let subclasses do some final clean-up if they wish...</span><br>    <span class="hljs-comment">// 给子类用的，然而子类没一个重写的</span><br>    onClose();<br><br>    <span class="hljs-comment">// Reset local application listeners to pre-refresh state.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyApplicationListeners != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.applicationListeners.clear();<br>        <span class="hljs-keyword">this</span>.applicationListeners.addAll(<span class="hljs-keyword">this</span>.earlyApplicationListeners);<br>    &#125;<br><br>    <span class="hljs-comment">// Switch to inactive.</span><br>    <span class="hljs-keyword">this</span>.active.set(<span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>剩余的动作就不重要了，而且也没什么实在东西，我们就不关注了。</p>
<p>至此，<code>ApplicationContext</code> 关闭，bean 的销毁动作也就全部结束了。</p>
<h2 id="面试如何回答bean销毁阶段的生命周期"><a href="#面试如何回答bean销毁阶段的生命周期" class="headerlink" title="面试如何回答bean销毁阶段的生命周期"></a>面试如何回答bean销毁阶段的生命周期</h2><p>以下答案<strong>仅供参考</strong>，可根据个人理解进行实际调整：</p>
<p><strong>bean 对象在销毁时，由 <code>ApplicationContext</code> 发起关闭动作。销毁 bean 的阶段，由 <code>BeanFactory</code> 取出所有单实例 bean ，并逐个销毁。</strong></p>
<p><strong>销毁动作会先将当前 bean 依赖的所有 bean 都销毁，随后回调自定义的 bean 的销毁方法，之后如果 bean 中有定义内部 bean 则会一并销毁，最后销毁那些依赖了当前 bean 的 bean 也一起销毁。</strong></p>
<p>【好了，bean 的完整生命周期终于都看完了，IOC 原理部分的最后一章，我们来对整个 <code>ApplicationContext</code> 的生命周期有一个大致的了解，做到能从整体把控好 <code>ApplicationContext</code> 在初始化阶段做的工作】</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                      <a class="hover-with-bg" href="/tags/IOC/">IOC</a>
                    
                      <a class="hover-with-bg" href="/tags/Bean/">Bean</a>
                    
                      <a class="hover-with-bg" href="/tags/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Bean生命周期</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/18/09-%E8%A1%A5%E5%85%85-%E6%A8%A1%E5%9D%97%E8%A3%85%E9%85%8D%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8/">
                        <span class="hidden-mobile">09-补充-模块装配和条件装配组合使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2022/04/18/21-IOC%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
