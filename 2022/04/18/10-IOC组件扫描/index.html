

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>10-IOC组件扫描 - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="10-IOC组件扫描">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-18 10:14" pubdate>
        2022年4月18日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      44
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">10-IOC组件扫描</h1>
            
            <div class="markdown-body">
              <h1 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h1><p>前面在第 7 章中，咱介绍了最基础的注解驱动 IOC ，以及组件扫描的最基本使用方式。然而，组件扫描本身可是大有文章的，深入了解组件扫描中的各个细节，对了解这部分内容很有帮助。本章咱就来学习组件扫描中的一些高级使用和底层实现原理。</p>
<h2 id="1-包扫描的路径【掌握】"><a href="#1-包扫描的路径【掌握】" class="headerlink" title="1. 包扫描的路径【掌握】"></a>1. 包扫描的路径【掌握】</h2><p>第 7 章中咱有讲过，<code>@ComponentScan</code> 注解可以指定包扫描的路径（而且还可以声明不止一个），它的写法是使用 <code>@ComponentScan</code> 的 <code>value</code> / <code>basePackages</code> 属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.example.spring.annotation.e_basepackageclass.bean&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePackageClassConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种方式是最常用的，也是最推荐使用的。除此之外，还有一种声明方式，它使用的是类的 Class 字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(ComponentScans.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ComponentScan &#123;<br>	<span class="hljs-meta">@AliasFor(&quot;basePackages&quot;)</span><br>	String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>	<span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>	String[] basePackages() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">// 注意这个</span><br>	Class&lt;?&gt;[] basePackageClasses() <span class="hljs-keyword">default</span> &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>它的这个 <code>basePackageClasses</code> 属性，可以传入一组 Class 进去，它代表的意思，是扫描<strong>传入的这些 Class 所在包及子包下的所有组件</strong>。</p>
<p>下面用一个简单的例子演示一下效果</p>
<h3 id="1-1-声明几个组件类-配置类"><a href="#1-1-声明几个组件类-配置类" class="headerlink" title="1.1 声明几个组件类+配置类"></a>1.1 声明几个组件类+配置类</h3><p>继续沿用之前注解驱动 IOC 的包吧，咱这里创建一个 <code>e_basepackageclass</code> 包，声明几个组件和配置类：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74ac99edff2a4c1c81bc781e8d5dc65d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<h3 id="1-2-标注配置类的包扫描规则"><a href="#1-2-标注配置类的包扫描规则" class="headerlink" title="1.2 标注配置类的包扫描规则"></a>1.2 标注配置类的包扫描规则</h3><p>配置类中，声明包扫描配置，咱先拿 <code>DemoService</code> 传进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackageClasses = DemoService.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePackageClassConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="1-3-测试运行"><a href="#1-3-测试运行" class="headerlink" title="1.3 测试运行"></a>1.3 测试运行</h3><p>编写启动类，驱动 IOC 容器，并打印容器中所有的 Bean 的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePackageClassApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(BasePackageClassConfiguration.class);<br>        String[] beanDefinitionNames = ctx.getBeanDefinitionNames();<br>        Stream.of(beanDefinitionNames).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 <code>main</code> 方法，发现控制台中只打印了 <code>DemoService</code> 与 <code>DemoDao</code> ：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalConfigurationAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalAutowiredAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalCommonAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerFactory<br>basePackageClassConfiguration<br>demoDao<br>demoService<br></code></pre></td></tr></table></figure>
<p>说明它确实以 <code>DemoService</code> 所在的包为基准扫描了，不过没有扫描到 <code>DemoComponent</code> 。</p>
<h3 id="1-4-加入DemoComponent"><a href="#1-4-加入DemoComponent" class="headerlink" title="1.4 加入DemoComponent"></a>1.4 加入DemoComponent</h3><p>在 <code>@ComponentScan</code> 中，再加入 <code>DemoComponent</code> 的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackageClasses = &#123;DemoService.class, DemoComponent.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePackageClassConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，控制台中多了 <code>DemoComponent</code> 与 <code>InnerComponent</code> 的打印，由此体现出 <code>basePackageClasses</code> 的作用。</p>
<h2 id="2-包扫描的过滤【掌握】"><a href="#2-包扫描的过滤【掌握】" class="headerlink" title="2. 包扫描的过滤【掌握】"></a>2. 包扫描的过滤【掌握】</h2><p>在实际开发的场景中，我们用包扫描拿到的组件不一定全部都需要，也或者只有一部分需要，这个时候就需要用到包扫描的过滤了。</p>
<blockquote>
<p>如果小伙伴之前有用 SpringWebMvc 的 xml 配置开发 Web 应用的话，应该印象蛮深刻吧！<code>spring-mvc.xml</code> 中配置只能扫描 <code>@Controller</code> 注解，<code>applicationContext.xml</code> 中又要设置不扫描 <code>@Controller</code> 注解，这就是扫描过滤的规则设置。</p>
</blockquote>
<blockquote>
<p>本小节源码位置：<code>com.example.spring.annotation.f_typefilter</code></p>
</blockquote>
<p>下面咱先来创建一些组件类。</p>
<h3 id="2-1-声明好多组件类-配置类"><a href="#2-1-声明好多组件类-配置类" class="headerlink" title="2.1 声明好多组件类 + 配置类"></a>2.1 声明好多组件类 + 配置类</h3><p>这次声明的更多了，可想而知接下来得有多少种过滤的规则哦（滑稽）</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1e87da9645449ecb66111006edf9a00~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<p>简单说一下这些组件的编写。</p>
<ul>
<li><pre><code>@Animal
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   <br><br>  是一个普通的注解，它可以标注在类上<br><br>  - `Cat` 、`Dog` 、`Pikachu` 是三个最简单的类，其中 `Cat` 和 `Dog` 上除了标注 `@Component` 注解外，还标注 `@Animal`<br><br>- color 包下的<br><br>   <br><br></code></pre></td></tr></table></figure>
Color
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   <br><br>  是一个父类<br><br>  - 下面的红黄绿三个类均标注 `@Component` ，不过只有 `Red` 和 `Yellow` 继承 `Color`<br><br>- bean 包的 `DemoService` 与 `DemoDao` 均是普通的类，且都没有标注任何注解<br><br>下面咱开始介绍过滤的几种方式。<br><br>### <span class="hljs-number">2.2</span> includeFilters 按注解筛选<br><br>在 `TypeFilterConfiguration` 中，声明 `@ComponentScan` 注解，扫描整个 `f_typefilter`包，之后在 `@ComponentScan` 注解中声明 `includeFilters` 属性，让它把含有 `@Animal` 注解的类带进来：<br><br>```java<br>@Configuration<br>@ComponentScan(basePackages = <span class="hljs-string">&quot;com.example.spring.annotation.f_typefilter&quot;</span>,<br>               includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class))<br>public class TypeFilterConfiguration &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
注意这里面的 `@Filter` 是 `@ComponentScan` 注解的内部类哦。
</code></pre>
</li>
</ul>
<p>编写启动类，驱动 IOC 容器，并打印容器中所有 Bean 的名称，发现所有标注了模式注解的类全加载进来了：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing">typeFilterConfiguration<br>cat<br>dog<br>pikachu<br><span class="hljs-built_in">green</span><br><span class="hljs-built_in">red</span><br>yellow<br></code></pre></td></tr></table></figure>
<p>这跟咱的预想似乎不是很一致：我想只让你把 <code>@Animal</code> 注解过的类带进来，你咋把这么一大堆都给我注册了呢？那是因为，<code>@ComponentScan</code> 注解中还有一个属性：<code>useDefaultFilters</code> ，它代表的是“是否启用默认的过滤规则”。咱之前也讲过了，默认规则就是扫那些以 <code>@Component</code> 注解为基准的模式注解。其实这个属性的文档注释也写的很明白了：</p>
<blockquote>
<p>Indicates whether automatic detection of classes annotated with @Component @Repository, @Service, or @Controller should be enabled.</p>
<p>指示是否应启用对以 <code>@Component</code> 、<code>@Repository</code> 、<code>@Service</code> 或 <code>@Controller</code> 注解的类的自动检测。</p>
</blockquote>
<p>合着人家默认就扫这几个注解的原因在这里啊，那我指定了我自己想过滤的规则你还不理呗？这是瞧谁不起啊？</p>
<p>莫急莫急，<strong>你声明了自己的过滤规则，不耽误人家的呀</strong>。换句话说，<strong>这些 include 的过滤规则之间互相不受影响，且不会互相排除</strong>：你包含的组件我也包含，那咱就一起加载；你不包含的我包含，那我也把它们带过来，而不是我拿过来了你又给我扔了。</p>
<p>也许这样理解起来更容易一些（有颜色的部分代表匹配规则）：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cc6502a040548d6966aa52e89d6542a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<h3 id="2-3-excludeFilters-按注解排除"><a href="#2-3-excludeFilters-按注解排除" class="headerlink" title="2.3 excludeFilters 按注解排除"></a>2.3 excludeFilters 按注解排除</h3><p>这次咱反过来，刚才不是 include 了吗？这次咱换用 <strong>exclude</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.example.spring.annotation.f_typefilter&quot;,</span><br><span class="hljs-meta">               excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class))</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeFilterConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，可以发现 <code>Cat</code> 和 <code>Dog</code> 都不见了：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">typeFilterConfiguration<br>pikachu<br><span class="hljs-built_in">green</span><br><span class="hljs-built_in">red</span><br>yellow<br></code></pre></td></tr></table></figure>
<p>由此可以得出结论：<strong>排除型过滤器会排除掉其他过滤规则已经包含进来的 Bean</strong> 。</p>
<p>跟上面对比起来，很明显这种情况下包含的组件会少一些（只要是带 <code>@Animal</code> 的都不会被匹配）：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8246722a7844fe9b10793033120120~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" srcset="/img/loading.gif" alt="img"></p>
<h3 id="2-3-按ASSIGNABLE-TYPE过滤"><a href="#2-3-按ASSIGNABLE-TYPE过滤" class="headerlink" title="2.3 按ASSIGNABLE_TYPE过滤"></a>2.3 按ASSIGNABLE_TYPE过滤</h3><p>继续在 <code>@ComponentScan</code> 注解上添加过滤规则，这次咱把所有 <code>Color</code> 类型都包含进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.example.spring.annotation.f_typefilter&quot;,</span><br><span class="hljs-meta">               includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = Color.class)&#125;,</span><br><span class="hljs-meta">               excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeFilterConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行 <code>main</code> 方法，发现这次连父类 <code>Color</code> 也给带进来了：（第 5 个）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">typeFilterConfiguration<br>pikachu<br>color<br>green<br>red<br>yellow<br></code></pre></td></tr></table></figure>
<p>如果把这个规则也挪到 <strong>exclude</strong> 中，则 color 、red 、yellow 都就没了：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">typeFilterConfiguration</span><br><span class="hljs-attribute">pikachu</span><br><span class="hljs-attribute">green</span><br></code></pre></td></tr></table></figure>
<h3 id="2-4-pattern正则表达式过滤"><a href="#2-4-pattern正则表达式过滤" class="headerlink" title="2.4 pattern正则表达式过滤"></a>2.4 pattern正则表达式过滤</h3><p>除了按注解过滤、按类型过滤，它内置的模式还有两种表达式的过滤规则，分别是 “切入点表达式过滤” 和 “正则表达式过滤” 。关于切入点表达式的概念咱放到 AOP 中再讲，这里先讲正则表达式的方式。</p>
<p>这次咱想通过正则表达式的方式，把那两个 Demo 开头的组件加载进来，正则表达式就可以这样编写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.example.spring.annotation.f_typefilter&quot;,</span><br><span class="hljs-meta">               includeFilters = &#123;</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.REGEX, pattern = &quot;com.example.spring.annotation.f_typefilter.+Demo.+&quot;)</span><br><span class="hljs-meta">               &#125;,</span><br><span class="hljs-meta">               excludeFilters = &#123;</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class),</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = Color.class)</span><br><span class="hljs-meta">               &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeFilterConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样编写好后，重新运行 <code>main</code> 方法，<code>DemoService</code> 和 <code>DemoDao</code> 就会被注册到 IOC 容器了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">typeFilterConfiguration<br>pikachu<br>demoDao<br>demoService<br>green<br></code></pre></td></tr></table></figure>
<h3 id="2-5-CUSTOM自定义过滤"><a href="#2-5-CUSTOM自定义过滤" class="headerlink" title="2.5 CUSTOM自定义过滤"></a>2.5 CUSTOM自定义过滤</h3><p>如果预设的几种模式都不能满足要求，那就需要用编程式过滤方式了，也就是自定义过滤规则。</p>
<p>先定个目标吧，这次编写自定义过滤后，咱们把 green 也过滤掉。</p>
<h4 id="2-5-1-TypeFilter接口"><a href="#2-5-1-TypeFilter接口" class="headerlink" title="2.5.1 TypeFilter接口"></a>2.5.1 TypeFilter接口</h4><p>编程式自定义过滤，需要编写过滤策略，实现 <code>TypeFilter</code> 接口。这个接口只有一个 <code>match</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TypeFilter</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 <code>match</code> 方法有两个参数，咱是一个也看不懂呀！好在文档注释中有描述，咱可以来参考一下：</p>
<ul>
<li><p>metadataReader</p>
<p>：the metadata reader for the target class</p>
<ul>
<li>通过这个 Reader ，可以读取到正在扫描的类的信息（包括类的信息、类上标注的注解等）</li>
</ul>
</li>
<li><p>metadataReaderFactory</p>
<p>：a factory for obtaining metadata readers for other classes (such as superclasses and interfaces)</p>
<ul>
<li>借助这个 Factory ，可以获取到其他类的 Reader ，进而获取到那些类的信息</li>
<li>可以这样理解：<strong>借助 ReaderFactory 可以获取到 Reader ，借助 Reader 可以获取到指定类的信息</strong></li>
</ul>
</li>
</ul>
<p>现在看不懂没关系，咱把上面的需求实现出来就好了嘛。</p>
<h4 id="2-5-2-编写自定义过滤规则"><a href="#2-5-2-编写自定义过滤规则" class="headerlink" title="2.5.2 编写自定义过滤规则"></a>2.5.2 编写自定义过滤规则</h4><p><code>MetadataReader</code> 中有一个 <code>getClassMetadata</code> 方法，可以拿到正在扫描的类的基本信息，咱可以由此取到全限定类名，进而与咱需求中的 <code>Green</code> 类做匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span><br><span class="hljs-function">         <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>    <span class="hljs-keyword">return</span> classMetadata.getClassName().equals(Green.class.getName());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回 true ，则说明已经匹配上了。</p>
<h4 id="2-5-3-添加过滤规则声明"><a href="#2-5-3-添加过滤规则声明" class="headerlink" title="2.5.3 添加过滤规则声明"></a>2.5.3 添加过滤规则声明</h4><p><code>TypeFilter</code> 写完了，不要忘记加在 <code>@ComponentScan</code> 上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.example.spring.annotation.f_typefilter&quot;,</span><br><span class="hljs-meta">               includeFilters = &#123;</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.REGEX, pattern = &quot;com.example.spring.annotation.f_typefilter.+Demo.+&quot;)</span><br><span class="hljs-meta">               &#125;,</span><br><span class="hljs-meta">               excludeFilters = &#123;</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class),</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = Color.class),</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.CUSTOM, value = GreenTypeFilter.class)</span><br><span class="hljs-meta">               &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeFilterConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新运行启动类的 <code>main</code> 方法，可以发现 <code>Green</code> 也没了，自定义 <code>TypeFilter</code> 生效。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">typeFilterConfiguration</span><br><span class="hljs-attribute">pikachu</span><br><span class="hljs-attribute">demoDao</span><br><span class="hljs-attribute">demoService</span><br></code></pre></td></tr></table></figure>
<p>更多的 <code>MetadataReader</code> 和 <code>MetadataReaderFactory</code> 的使用，小伙伴们可以自行探索，小册不过多列举。</p>
<h4 id="2-5-4-metadata的概念"><a href="#2-5-4-metadata的概念" class="headerlink" title="2.5.4 metadata的概念"></a>2.5.4 metadata的概念</h4><p>讲到这里了，咱先不着急往下走，停一停，咱讲讲 <strong>metadata</strong> 的概念。</p>
<p>回想一下 JavaSE 的反射，它是不是可以根据咱写好的类，获取到类的全限定名、属性、方法等信息呀。好，咱现在就建立起这么一个概念：咱定义的类，它叫什么名，它有哪些属性，哪些方法，这些信息，统统叫做<strong>元信息</strong>，<strong>元信息会描述它的目标的属性和特征</strong>。</p>
<p>在 SpringFramework 中，元信息大量出现在框架的底层设计中，不只是 <strong>metadata</strong> ，前面咱屡次见到的 <strong>definition</strong> ，也是元信息的体现。后面到了 IOC 高级部分，咱会整体的学习 SpringFramework 中的元信息、元定义设计，以及 <code>BeanDefinition</code> 的全解析。</p>
<h2 id="3-包扫描的其他特性【熟悉】"><a href="#3-包扫描的其他特性【熟悉】" class="headerlink" title="3. 包扫描的其他特性【熟悉】"></a>3. 包扫描的其他特性【熟悉】</h2><p>两个比较重头的特性咱说完之后，还有一些小零碎，咱也盘点盘点。</p>
<h3 id="3-1-包扫描可以组合使用"><a href="#3-1-包扫描可以组合使用" class="headerlink" title="3.1 包扫描可以组合使用"></a>3.1 包扫描可以组合使用</h3><p>小伙伴们在写 <code>@ComponentScan</code> 注解时一定有发现还有一个 <code>@ComponentScans</code> 注解吧！不过比较靠前的版本是看不到它的，它起源自 4.3 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @since 4.3</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ComponentScans &#123;<br>	ComponentScan[] value();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实它就是一次性组合了一堆 <code>@ComponentScan</code> 注解而已了，没啥好说的。</p>
<h3 id="3-2-包扫描的组件名称生成"><a href="#3-2-包扫描的组件名称生成" class="headerlink" title="3.2 包扫描的组件名称生成"></a>3.2 包扫描的组件名称生成</h3><p>咱在前面刚学习注解驱动时，就知道默认情况下生成的 bean 的名称是类名的首字母小写形式（ Person → person ），可是它为啥就有这个规则呢？这个问题，也可以从 <code>@ComponentScan</code>注解中找到。</p>
<p>在 <code>@ComponentScan</code> 注解的属性中，有一个 <code>nameGenerator</code> ，它的默认值是 <code>BeanNameGenerator</code> 。不过这个 <code>BeanNameGenerator</code> 是一个接口，从文档注释中不难找到实现类是 <code>AnnotationBeanNameGenerator</code> 。</p>
<h4 id="3-2-1-BeanNameGenerator"><a href="#3-2-1-BeanNameGenerator" class="headerlink" title="3.2.1 BeanNameGenerator"></a>3.2.1 BeanNameGenerator</h4><p>从名称上就知道它是 Bean 的名字生成器了，它只有一个 <code>generateBeanName</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanNameGenerator</span> </span>&#123;<br>	<span class="hljs-function">String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>又出现 <code>BeanDefinition</code> 和 <code>BeanDefinitionRegistry</code> 了，可见元信息、元定义在底层真的太常见了！</p>
<p>不过咱先不要把精力放在这里，实现类才是重点。</p>
<h4 id="3-2-2-AnnotationBeanNameGenerator的实现"><a href="#3-2-2-AnnotationBeanNameGenerator的实现" class="headerlink" title="3.2.2 AnnotationBeanNameGenerator的实现"></a>3.2.2 AnnotationBeanNameGenerator的实现</h4><p>找到 <code>AnnotationBeanNameGenerator</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-comment">// 组件的注册方式是注解扫描的</span><br>    <span class="hljs-keyword">if</span> (definition <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>        <span class="hljs-comment">// 尝试从注解中获取名称</span><br>        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(beanName)) &#123;<br>            <span class="hljs-comment">// Explicit bean name found.</span><br>            <span class="hljs-keyword">return</span> beanName;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Fallback: generate a unique default bean name.</span><br>    <span class="hljs-comment">// 如果没有获取到，则创建默认的名称</span><br>    <span class="hljs-keyword">return</span> buildDefaultBeanName(definition, registry);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看这段源码的实现，整体的逻辑还是非常容易理解的：</p>
<ol>
<li><p>只有注解扫描注册进来的 Bean 才会被处理（ <code>AnnotationBeanNameGenerator</code> ，看类名 ￣へ￣ ）</p>
</li>
<li><p>既然是注解扫描进来的，那我就要看看有木有在注解中声明好了</p>
<blockquote>
<p>这种声明方式就是 <code>@Component(&quot;person&quot;)</code></p>
</blockquote>
</li>
<li><p>注解中找不到名，那好吧，我给你构造一个，不过这个名是按照我默认规则来的，你就别挑挑拣拣咯</p>
</li>
</ol>
<p>上面从注解中获取的部分咱留到后面再看，这里咱只看 <code>buildDefaultBeanName</code> 的实现。</p>
<h4 id="3-2-3-buildDefaultBeanName的实现"><a href="#3-2-3-buildDefaultBeanName的实现" class="headerlink" title="3.2.3 buildDefaultBeanName的实现"></a>3.2.3 buildDefaultBeanName的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> buildDefaultBeanName(definition);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition)</span> </span>&#123;<br>    String beanClassName = definition.getBeanClassName();<br>    Assert.state(beanClassName != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;No bean class name set&quot;</span>);<br>    String shortClassName = ClassUtils.getShortName(beanClassName);<br>    <span class="hljs-keyword">return</span> Introspector.decapitalize(shortClassName);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一路走到最底下的方法中，它会根据组件类的全限定名，截取出短类名（如 <code>com.example.Person</code> → <code>Person</code> ），最后用一个叫 <code>Introspector</code> 的类，去生成 bean 的名称。那想必这个 <code>Introspector.decapitalize</code> 方法肯定就可以把类名的首字母转为小写咯，点进去发现确实如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decapitalize</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span> || name.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (name.length() &gt; <span class="hljs-number">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class="hljs-number">1</span>)) &amp;&amp;<br>        Character.isUpperCase(name.charAt(<span class="hljs-number">0</span>)))&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">char</span> chars[] = name.toCharArray();<br>    <span class="hljs-comment">// 第一个字母转小写</span><br>    chars[<span class="hljs-number">0</span>] = Character.toLowerCase(chars[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>原理实现看完了，小伙伴们肯定有一个疑惑：<code>Introspector</code> 是个什么鬼哦？？</p>
<h4 id="3-2-4-Java的内省机制【扩展】"><a href="#3-2-4-Java的内省机制【扩展】" class="headerlink" title="3.2.4 Java的内省机制【扩展】"></a>3.2.4 Java的内省机制【扩展】</h4><p>说到这个<strong>内省</strong>，或许好多小伙伴都没听说过。其实<strong>它是 JavaSE 中就有的，对 JavaBean 中属性的默认处理规则</strong>。</p>
<p>回想一下咱写的所有模型类，包括 vo 类，是不是都是写好了属性，之后借助 IDE 生成 <code>getter</code> 和 <code>setter</code> ，或者借助 <code>Lombok</code> 的注解生成 <code>getter</code> 和 <code>setter</code> ？其实这个生成规则，就是利用了 Java 的内省机制。</p>
<p><strong>Java 的内省默认规定，所有属性的获取方法以 get 开头（ boolean 类型以 is 开头），属性的设置方法以 set 开头。</strong>根据这个规则，才有的默认的 getter 和 setter 方法。</p>
<p><code>Introspector</code> 类是 Java 内省机制中最核心的类之一，它可以进行很多默认规则的处理（包括获取类属性的 get / set 方法，添加方法描述等），当然它也可以处理这种类名转 beanName 的操作。SpringFramework 深知这个设计之妙，就直接利用过来了。</p>
<p>有关更多的 Java 内省机制，小伙伴们可以搜索相关资料学习，小册不多展开讲解了（这部分适当了解即可）。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                      <a class="hover-with-bg" href="/tags/IOC/">IOC</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F/">组件扫描</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/18/11-IOC%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">11-IOC的资源管理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/18/09-IOC%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D/">
                        <span class="hidden-mobile">09-IOC的条件装配</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2022/04/18/10-IOC%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
