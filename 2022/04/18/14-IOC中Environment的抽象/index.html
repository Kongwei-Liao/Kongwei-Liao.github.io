

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kongwei_Liao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Kongwei_Liao
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-18 10:43" pubdate>
        2022年4月18日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      56
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            <div class="markdown-body">
              <h1 id="Environment抽象"><a href="#Environment抽象" class="headerlink" title="Environment抽象"></a>Environment抽象</h1><p>根据上节内容这里提出了几个问题：</p>
<ol>
<li>加载的 properties 资源配置，以及 <code>ApplicationContext</code> 内部的一些默认配置属性，都放在哪里了？</li>
<li>组件 Bean 又是怎么把配置值注入进去到对象的属性中的？</li>
</ol>
<h2 id="1-Environment概述【理解】"><a href="#1-Environment概述【理解】" class="headerlink" title="1. Environment概述【理解】"></a>1. Environment概述【理解】</h2><p><code>Environment</code> 是从 SpringFramework 3.1 开始引入的一个抽象模型。</p>
<h3 id="1-1-第一直觉"><a href="#1-1-第一直觉" class="headerlink" title="1.1 第一直觉"></a>1.1 第一直觉</h3><p>其实第一眼看到这个名词，我们就应该有一个模糊的猜想了，它应该是基于 SpringFramework 的工程的<strong>运行时环境</strong>。所以我们可以这样看待我们编写的基于 SpringFramework 的应用程序：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461c0349a0964aa8925dc92648796803~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<blockquote>
<p>这个概念的理解，在 SpringBoot 源码的小册中也有提过，当时也是画了这样一个概念图来帮助小伙伴们理解。</p>
</blockquote>
<p>这个理解是否正确呢？我们可以去官方文档加以验证。</p>
<h3 id="1-2-官方文档的描述"><a href="#1-2-官方文档的描述" class="headerlink" title="1.2 官方文档的描述"></a>1.2 官方文档的描述</h3><p>当我们去翻 SpringFramework 的官方文档时，会发现官方是这样概述 <code>Environment</code> 的：</p>
<p><a href="https://link.juejin.cn/?target=https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/core.html%23beans-environment">docs.spring.io/spring/docs…</a></p>
<blockquote>
<p>The <code>Environment</code> interface is an abstraction integrated in the container that models two key aspects of the application environment: profiles and properties. A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or with annotations. The role of the <code>Environment</code> object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default. Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc <code>Properties</code> objects, <code>Map</code> objects, and so on. The role of the <code>Environment</code> object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.</p>
<p><code>Environment</code> 接口是集成在容器中的抽象，可对应用程序环境的两个关键方面进行建模：<strong>Profile</strong> 和 <strong>properties</strong> 。</p>
<ol>
<li><p>Profiles 是仅在指定 profile 处于活动状态（ active ）时才向容器注册 <code>BeanDefinition</code> 的命名逻辑组。它可以将 Bean 分配给不同的 profile （无论是以 XML 定义还是注解配置）。</p>
</li>
<li><p>与配置文件相关的 <code>Environment</code> 作用是确定哪些配置文件当前处于活动状态，以及哪些配置文件在默认情况下应处于活动状态。 </p>
</li>
</ol>
<p>Properties 在几乎所有应用程序中都起着重要作用，并且可能源自多种来源：</p>
<ol>
<li><strong>属性文件</strong>；</li>
<li><strong>JVM 系统属性</strong>；</li>
<li><strong>系统环境变量</strong>；</li>
<li><strong>JNDI</strong>；</li>
<li><strong><code>ServletContext</code> 参数</strong>；</li>
<li><strong>临时属性对象</strong>，<code>Map</code> 对象等。</li>
</ol>
<p><code>Environment</code> 与属性相关联的作用是为用户提供方便的接口，它可以用于配置属性源，并从 <code>Environment</code> 中解析属性。</p>
</blockquote>
<p>讲道理这段话理解起来不是那么容易，不过第一句【<code>Environment</code> 是集成在容器中的抽象】，会让我们产生一种感觉：前面的理解是不是出现了一些偏差？如果按照官方文档的说法，<code>Environment</code> 与工程的结构应该是这样才对：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5166a2a211cf4cb1a36a6bb4f5232755~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>到底是不是这样呢，根据个人的理解不同，表达出来的也会不太一样。</p>
<h3 id="1-3-小册一家之言"><a href="#1-3-小册一家之言" class="headerlink" title="1.3 小册一家之言"></a>1.3 小册一家之言</h3><p>作者个人是倾向于如下的结构理解，这样解释起来会相对更合理一些：</p>
<ul>
<li>首先，<code>Environment</code> 中包含 profiles 和 properties ，这些配置信息会影响 IOC 容器中的 bean 的注册与创建；</li>
<li>其次，<code>Environment</code> 的创建是在 <code>ApplicationContext</code> 创建后才创建的（ IOC 原理部分会解释），所以 <code>Environment</code> 应该是伴随着 <code>ApplicationContext</code> 的存在而存在；</li>
<li>第三，<code>ApplicationContext</code> 中同时包含 <code>Environment</code> 和 <strong>组件 bean</strong> ，而且从 <code>BeanFactory</code> 的视角来看，<code>Environment</code> 也是一个 Bean ，只不过它的地位比较特殊。</li>
</ul>
<p>基于这三点，<code>Environment</code> 与工程的结构应该是下图这样的：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07df885666e94a248600430502779905~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>理解了两者的结构及关系，再来回头看看 <code>Environment</code> 的组成部分：<strong>profiles 和 properties</strong> ，咱之前也都了解过了，所以 <code>Environment</code> 的整体理解也就相对没有那么难了吧！</p>
<h3 id="1-4-javadoc中的描述"><a href="#1-4-javadoc中的描述" class="headerlink" title="1.4 javadoc中的描述"></a>1.4 javadoc中的描述</h3><p>上面并没有引用 <code>Environment</code> 的 javadoc 来阐述 <code>Environment</code> 的概念和定义，原因是 javadoc 并没有对 Application 和 <code>Environment</code> 之间的关系进行描述，所以小册选择在这里再贴出。</p>
<p>由于 javadoc 的篇幅太长，咱们拆解开来看。</p>
<h4 id="1-4-1-Environment包含profile于properties"><a href="#1-4-1-Environment包含profile于properties" class="headerlink" title="1.4.1 Environment包含profile于properties"></a>1.4.1 Environment包含profile于properties</h4><blockquote>
<p>Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the <code>PropertyResolver</code> superinterface.</p>
<p><code>Environment</code> 是表示当前应用程序正在其中运行的环境的接口。它为应用环境制定了两个关键的方面：<strong>profile</strong> 和 <strong>properties</strong>。</p>
<p>与属性访问有关的方法通过 <code>PropertyResolver</code> 这个父接口公开。</p>
</blockquote>
<p>这一段也是总体的概括 <code>Environment</code> 的基本设计和作用，不过它又提到了 <code>PropertyResolver</code> 这个接口，这个接口负责解析占位符（ <strong>${…}</strong> ）对应的值，作用也比较容易理解，这里就不多展开解释啦。</p>
<h4 id="1-4-2-profile用于区分不同的环境模式"><a href="#1-4-2-profile用于区分不同的环境模式" class="headerlink" title="1.4.2 profile用于区分不同的环境模式"></a>1.4.2 profile用于区分不同的环境模式</h4><blockquote>
<p>A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations; see the <code>spring-beans 3.1 schema</code> or the <code>@Profile</code> annotation for syntax details. The role of the <code>Environment</code> object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default. profile 机制保证了仅在给定 profile 处于激活状态时，才向容器注册的 <code>BeanDefinition</code> 的命名逻辑组。无论是用 XML 定义还是通过注解定义，都可以将 Bean 分配给指定的 profile。</p>
<p>有关语法的详细信息，请参见 <code>spring-beans 3.1规范文档</code> 或 <code>@Profile</code> 注解。<code>Environment</code> 的作用是决定当前哪些配置文件（如果有）处于活动状态，以及默认情况下哪些配置文件（如果有）应处于活动状态。</p>
</blockquote>
<p>通过前面 18 章条件装配的学习，这段文档注释也就不难理解了吧。<code>Environment</code> 配合 profile 可以完成<strong>指定模式的环境的组件装配</strong>，以及不同的配置属性注入。</p>
<h4 id="1-4-3-Properties-用于配置属性和注入值"><a href="#1-4-3-Properties-用于配置属性和注入值" class="headerlink" title="1.4.3 Properties 用于配置属性和注入值"></a>1.4.3 Properties 用于配置属性和注入值</h4><blockquote>
<p>Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them. </p>
<p><code>Properties</code> 在几乎所有应用程序中都起着重要作用，并且可能来源自多种途径：属性文件，JVM 系统属性，系统环境变量，JNDI，<code>ServletContext</code> 参数，临时属性对象，Map等。</p>
<p><code>Environment</code> 与 <code>Properties</code> 的关系是为用户提供方便的服务接口，以配置属性源，并从中解析属性值。</p>
</blockquote>
<p>上一章的配置元信息中我们已经知道 properties 的最大作用之一是做<strong>外部化配置</strong>，<code>Environment</code> 中存放了很多 properties ，它们的来源有很多种，而最终的作用都是<strong>提供了属性配置</strong>，或者<strong>给组件注入属性值</strong>。</p>
<h4 id="1-4-4-Environment不建议直接使用"><a href="#1-4-4-Environment不建议直接使用" class="headerlink" title="1.4.4 Environment不建议直接使用"></a>1.4.4 Environment不建议直接使用</h4><blockquote>
<p>Beans managed within an <code>ApplicationContext</code> may register to be <code>EnvironmentAware</code> or <code>@Inject</code> the Environment in order to query profile state or resolve properties directly. In most cases, however, application-level beans should not need to interact with the Environment directly but instead may have to have ${…} property values replaced by a property placeholder configurer such as <code>PropertySourcesPlaceholderConfigurer</code>, which itself is EnvironmentAware and as of Spring 3.1 is registered by default when using <code>&lt;context:property-placeholder/&gt;</code>.</p>
<p>在 <code>ApplicationContext</code> 中管理的 Bean 可以注册为 <code>EnvironmentAware</code> 或使用 <code>@Inject</code> 标注在 <code>Environment</code> 上，以便直接查询 profile 的状态或解析 <code>Properties</code>。 但是，在大多数情况下，应用程序级 Bean 不必直接与 <code>Environment</code> 交互，而是通过将 <strong>${…}</strong> 属性值替换为属性占位符配置器进行属性注入（例如 <code>PropertySourcesPlaceholderConfigurer</code>），该属性本身是 <code>EnvironmentAware</code>，当配置了 <code>&lt;context:property-placeholder/&gt;</code> 时，默认情况下会使用 Spring 3.1 的规范注册。</p>
</blockquote>
<p>这一段的描述主要讲了两件事情：</p>
<ul>
<li><code>Environment</code> 可以注入到组件中，用于获取当前环境激活的所有 profile 模式；</li>
<li>但是又不推荐开发者直接使用它，而是通过占位符注入配置属性的值。为什么会这么说呢，其实这个又要说回 <code>Environment</code> 设计的原始意图。<code>Environment</code> 的设计本身就应该是一个<strong>不被应用程序接触到的 “环境”</strong> ，我们<strong>只能从环境中获取一些它已经有的信息，但不应该获取它本身</strong>。所以，在处理 properties 的获取时，直接使用占位符就可以获取了。</li>
</ul>
<h4 id="1-4-5-ApplicationContext-获取到的是-ConfigurableEnvironment"><a href="#1-4-5-ApplicationContext-获取到的是-ConfigurableEnvironment" class="headerlink" title="1.4.5 ApplicationContext 获取到的是 ConfigurableEnvironment"></a>1.4.5 ApplicationContext 获取到的是 ConfigurableEnvironment</h4><blockquote>
<p>Configuration of the environment object must be done through the <code>ConfigurableEnvironment</code> interface, returned from all <code>AbstractApplicationContext</code> subclass <code>getEnvironment()</code> methods. See <code>ConfigurableEnvironment Javadoc</code> for usage examples demonstrating manipulation of property sources prior to application context <code>refresh()</code> .</p>
<p>必须通过从所有 <code>AbstractApplicationContext</code> 子类的 <code>getEnvironment()</code> 方法返回的 <code>ConfigurableEnvironment</code> 接口完成环境对象的配置。</p>
<p>请参阅 <code>ConfigurableEnvironment</code> 的 javadoc 以获取使用示例，这些示例演示在应用程序上下文 <code>refresh()</code> 方法被调用之前对属性源进行的操作。</p>
</blockquote>
<p>注意这里，<code>ApplicationContext</code> 的根实现类 <code>AbstractApplicationContext</code> 获取到的是 <code>ConfigurableEnvironment</code> ，它具有 <strong>“可写”</strong> 的特征，换言之我们可以修改它内部的属性值 / 数据。不过话又说回来，通常情况下我们都不会直接改它，除非要对 SpringFramework 应用的启动流程或者运行中进行一些额外的扩展或者修改。</p>
<p>到这里，整个 javadoc 也就读完了，最后总结一下吧，这部分最终还是要理解，并且最好用自己的话概括出来。</p>
<h3 id="1-5-【面试题】面试中如何概述Environment"><a href="#1-5-【面试题】面试中如何概述Environment" class="headerlink" title="1.5 【面试题】面试中如何概述Environment"></a>1.5 【面试题】面试中如何概述Environment</h3><p>以下答案仅供参考，可根据自己的理解调整回答内容：</p>
<p><code>Environment</code> 是 SpringFramework 3.1 引入的抽象的概念，它包含 profiles 和 properties 的信息，可以实现统一的配置存储和注入、配置属性的解析等。</p>
<ul>
<li>其中 profiles 实现了一种基于模式的环境配置；</li>
<li>properties 则应用于外部化配置。</li>
</ul>
<h2 id="2-Environment-的结构【了解】"><a href="#2-Environment-的结构【了解】" class="headerlink" title="2. Environment 的结构【了解】"></a>2. Environment 的结构【了解】</h2><p>了解了概念和设计的思想，下面咱来看看 <code>Environment</code> 在 SpringFramework 中设计的结构。</p>
<p>借助 IDEA ，可以看到 <code>Environment</code> 的上下级继承和派生关系：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ace9b0f0c144ca4a49e3083fbece4eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>这里面的几个重要的接口和类关注一下。</p>
<h3 id="2-1-PropertyResolver"><a href="#2-1-PropertyResolver" class="headerlink" title="2.1 PropertyResolver"></a>2.1 PropertyResolver</h3><p>这个接口，只从接口名就知道它应该是处理占位符 <strong>${}</strong> 的。观察接口的方法定义，直接实锤了它就是做配置属性值的获取和解析的：（下面是 <code>PropertyResolver</code> 的部分方法定义）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PropertyResolver</span> </span>&#123;<br><br>    <span class="hljs-comment">// 检查所有的配置属性中是否包含指定key</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsProperty</span><span class="hljs-params">(String key)</span></span>;<br><br>    <span class="hljs-comment">// 以String的形式返回指定的配置属性的值</span><br>    <span class="hljs-function">String <span class="hljs-title">getProperty</span><span class="hljs-params">(String key)</span></span>;<br><br>    <span class="hljs-comment">// 带默认值的获取</span><br>    <span class="hljs-function">String <span class="hljs-title">getProperty</span><span class="hljs-params">(String key, String defaultValue)</span></span>;<br><br>    <span class="hljs-comment">// 指定返回类型的配置属性值获取</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProperty</span><span class="hljs-params">(String key, Class&lt;T&gt; targetType)</span></span>;<br><br>    <span class="hljs-comment">// ......</span><br><br>    <span class="hljs-comment">// 解析占位符</span><br>    <span class="hljs-function">String <span class="hljs-title">resolvePlaceholders</span><span class="hljs-params">(String text)</span></span>;<br><br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以由此也就证明了：**<code>Environment</code> 可以获取配置元信息，同时也可以解析占位符的信息**。</p>
<h3 id="2-2-ConfigurableEnvironment"><a href="#2-2-ConfigurableEnvironment" class="headerlink" title="2.2 ConfigurableEnvironment"></a>2.2 ConfigurableEnvironment</h3><p>它又扩展了一些设置 Environment 的方法，可以从接口的方法定义中看到这样的方法名：<code>setActiveProfiles</code> 、<code>addActiveProfile</code> 等等。可以通过这个接口进行编程式设置 profile ！</p>
<p>除此之外，这个接口中还有一个方法比较值得注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">MutablePropertySources <span class="hljs-title">getPropertySources</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>看方法名可以知道它会返回所有的 <code>PropertySource</code> 对象，可是 <code>MutablePropertySources</code> 是个什么？查看它的源码，发现它的内部就是一个 <strong>List</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutablePropertySources</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PropertySources</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由此可以总结出一个小小的结论：<strong>以后见到 Mutable 开头的类名，通常可以认为是一个类型的 List 组合包装</strong>。</p>
<h3 id="2-3-StandardEnvironment"><a href="#2-3-StandardEnvironment" class="headerlink" title="2.3 StandardEnvironment"></a>2.3 StandardEnvironment</h3><p>它是 SpringFramework 中默认使用的标准运行时环境的抽象实现，不过它里面的方法实现的非常少，基本都是由 <code>AbstractEnvironment</code> 负责实现。在后面的原理部分，我们还会再见到它的，这里先留意一下就好。</p>
<h2 id="3-Environment-的使用"><a href="#3-Environment-的使用" class="headerlink" title="3. Environment 的使用"></a>3. Environment 的使用</h2><p>虽说 <code>Environment</code> 不建议直接在应用程序中使用，但是部分场景下还是需要直接接触它来操纵。本节小册不会直接介绍 <code>Environment</code> 的实际使用，而是先带小伙伴用最简单的方式用一用，体会一下 <code>Environment</code> 的作用即可。</p>
<h3 id="3-1-获取-Environment"><a href="#3-1-获取-Environment" class="headerlink" title="3.1 获取 Environment"></a>3.1 获取 Environment</h3><h4 id="3-1-1、依赖查找（DL）或者依赖注入"><a href="#3-1-1、依赖查找（DL）或者依赖注入" class="headerlink" title="3.1.1、依赖查找（DL）或者依赖注入"></a>3.1.1、依赖查找（DL）或者依赖注入</h4><p>既然 <code>Environment</code> 存在于 <code>ApplicationContext</code> 中，那么获取 <code>Environment</code> 的方式自然也就可以想到：<code>@Autowired</code> 就可以吧！下面咱来实际操作一下。</p>
<p>任意编写一个 Bean ，并声明注入 <code>Environment</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentHolder</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    Environment environment;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEnvironment</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(environment);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之后直接使用包扫描的方式，驱动 <code>AnnotationConfigApplicationContext</code> ，就可以取到刚写的这个 <code>EnvironmentHolder</code> 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentQuickstartApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.example.spring.environment.a_quickstart.bean&quot;</span>);<br>        EnvironmentHolder environmentHolder = ctx.getBean(EnvironmentHolder.class);<br>        environmentHolder.printEnvironment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行 <code>main</code> 方法，控制台会打印出 <code>Environment</code> 的对象信息：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix">StandardEnvironment &#123;<br><span class="hljs-attr">activeProfiles=[],</span> <br><span class="hljs-attr">defaultProfiles=[default],</span> <br><span class="hljs-attr">propertySources=[</span><br>        PropertiesPropertySource &#123;<span class="hljs-attr">name=&#x27;systemProperties&#x27;&#125;,</span> <br>        SystemEnvironmentPropertySource &#123;<span class="hljs-attr">name=&#x27;systemEnvironment&#x27;&#125;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-1-2、实现-EnvironmentAware-回调接口"><a href="#3-1-2、实现-EnvironmentAware-回调接口" class="headerlink" title="3.1.2、实现 EnvironmentAware 回调接口"></a>3.1.2、实现 EnvironmentAware 回调接口</h4><p>除此 依赖查找 和 依赖注入 之外，联想到 <code>BeanFactory</code> 、<code>ApplicationContext</code> 的注入方式还有回调注入，作为 SpringFramework 的内置 API ，估计也会有一个 <strong>Aware</strong> 回调注入的接口吧！</p>
<blockquote>
<p>使用 <code>@Autowired</code> 的方式在某些情况下会注入失败，所以对于小伙伴们而言，注入是否能成功需要亲手测试运行检验才能知道。</p>
<p>在后面的后置处理器部分，会演示一种无法使用 <code>@Autowired</code> 注入 <code>Environment</code> 的方式，小伙伴们到时候可以留意一下。</p>
</blockquote>
<h3 id="3-2-使用Environment获取配置属性的值"><a href="#3-2-使用Environment获取配置属性的值" class="headerlink" title="3.2 使用Environment获取配置属性的值"></a>3.2 使用Environment获取配置属性的值</h3><p>为了方便获取 properties 的配置信息，这里编写一个配置类，把上一章 <code>PropertySource</code> 的 <code>jdbc.properties</code> 加载进去，之后使用该配置类驱动 IOC 容器即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.example.spring.environment.b_api.bean&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;propertysource/jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentPropertyConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-1、获取profile"><a href="#3-2-1、获取profile" class="headerlink" title="3.2.1、获取profile"></a>3.2.1、获取profile</h4><h4 id="3-2-2、获取properties"><a href="#3-2-2、获取properties" class="headerlink" title="3.2.2、获取properties"></a>3.2.2、获取properties</h4><p><code>EnvironmentHolder</code> 中，这次我们取一下默认的 profiles ，以及 <code>jdbc.properties</code> 中的配置属性值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentHolder</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    Environment environment;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEnvironment</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Arrays.toString(environment.getDefaultProfiles()));<br>        System.out.println(environment.getProperty(<span class="hljs-string">&quot;jdbc.url&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重新驱动 IOC 容器，并取出 <code>EnvironmentHolder</code> 执行 <code>printEnvironment</code> 方法，控制台打印如下信息：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">[<span class="hljs-keyword">default</span>]<br>jdbc:mysql:<span class="hljs-comment">//localhost:3306/test</span><br></code></pre></td></tr></table></figure>


<h2 id="4-Environment深入探讨【原理】"><a href="#4-Environment深入探讨【原理】" class="headerlink" title="4. Environment深入探讨【原理】"></a>4. Environment深入探讨【原理】</h2><p>先注意一下上面控制台打印的默认 profiles ，发现它有一个默认值是 <strong>default</strong> ，它是从哪来的呢？我们又没声明呀！</p>
<h3 id="4-1-Environment-的默认-profiles"><a href="#4-1-Environment-的默认-profiles" class="headerlink" title="4.1 Environment 的默认 profiles"></a>4.1 Environment 的默认 profiles</h3><p>想知道 profiles 的默认配置，就要进入到 <code>Environment</code> 的抽象实现 <code>AbstractEnvironment</code> 中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] getDefaultProfiles() &#123;<br>    <span class="hljs-keyword">return</span> StringUtils.toStringArray(doGetDefaultProfiles());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里有一个很有意思的操作：<code>getDefaultProfiles</code> 调用了 <code>doGetDefaultProfiles</code> 方法，这个设计在 SpringFramework 中大量出现和使用！</p>
<h4 id="4-1-1-Spring-框架中的方法命名规范【旁知引入】"><a href="#4-1-1-Spring-框架中的方法命名规范【旁知引入】" class="headerlink" title="4.1.1 Spring 框架中的方法命名规范【旁知引入】"></a>4.1.1 Spring 框架中的方法命名规范【旁知引入】</h4><p>在 SpringFramework 的框架编码中，如果有出现一个方法是 do 开头，并且去掉 do 后能找到一个与剩余名称一样的方法，则代表如下含义：</p>
<ul>
<li>不带 do 开头的方法一般负责前置校验处理、返回结果封装，</li>
<li>带 do 开头的方法是真正执行逻辑的方法（如 <code>getBean</code> 方法的底层会调用 <code>doGetBean</code> 来真正的寻找 IOC 容器的 bean ，<code>createBean</code> 会调用 <code>doCreateBean</code> 来真正的创建一个 bean ）。</li>
</ul>
<h4 id="4-1-2-doGetDefaultProfiles的实现"><a href="#4-1-2-doGetDefaultProfiles的实现" class="headerlink" title="4.1.2 doGetDefaultProfiles的实现"></a>4.1.2 doGetDefaultProfiles的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PROFILES_PROPERTY_NAME = <span class="hljs-string">&quot;spring.profiles.default&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;String&gt; <span class="hljs-title">doGetDefaultProfiles</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.defaultProfiles) &#123;<br>        <span class="hljs-comment">// 取框架默认的profiles，并与当前的 RESERVED_DEFAULT_PROFILE_NAME = &quot;default&quot; 对比</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultProfiles.equals(getReservedDefaultProfiles())) &#123;<br>          <br>            <span class="hljs-comment">// 一致，则尝试从 Environment 中获取默认的声明 DEFAULT_PROFILES_PROPERTY_NAME = &quot;spring.profiles.default&quot; 的 profiles</span><br>            String profiles = getProperty(DEFAULT_PROFILES_PROPERTY_NAME);<br>          <br>            <span class="hljs-comment">// 如果有显式声明，则覆盖原有的默认值</span><br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(profiles)) &#123;<br>                setDefaultProfiles(StringUtils.commaDelimitedListToStringArray(<br>                        StringUtils.trimAllWhitespace(profiles)));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultProfiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看这个方法的实现，整体逻辑也不算复杂，关键是看它取框架默认的 profiles ，它其实就是取的 <code>AbstractEnvironment</code> 中内置的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESERVED_DEFAULT_PROFILE_NAME = <span class="hljs-string">&quot;default&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;String&gt; <span class="hljs-title">getReservedDefaultProfiles</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Collections.singleton(RESERVED_DEFAULT_PROFILE_NAME);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-1-3-覆盖默认的profiles方法"><a href="#4-1-3-覆盖默认的profiles方法" class="headerlink" title="4.1.3 覆盖默认的profiles方法"></a>4.1.3 覆盖默认的profiles方法</h4><p>可以通过声明 <strong><code>spring.profiles.default</code></strong> 的配置，来覆盖 SpringFramework 中原有的默认 profiles ，一个比较常用的方法是在 jvm 的启动参数上添加：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b2c5bf327624be2ac918edecfdf7f20~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>在 IDEA 的启动配置中，声明 VM options 就可以指定默认的 profiles 了。同理，指定激活的 profiles 也可以像这样指定，只不过它的参数名称为 <strong><code>spring.profiles.active</code></strong> 。</p>
<h3 id="4-2-Environment-解析-properties-的底层"><a href="#4-2-Environment-解析-properties-的底层" class="headerlink" title="4.2 Environment 解析 properties 的底层"></a>4.2 Environment 解析 properties 的底层</h3><p>前面看 <code>Environment</code> 的结构，我们已经知道 <code>Environment</code> 继承了父接口 <code>PropertyResolver</code> ，自然它拥有解析配置元信息的能力，它的底层是如何实现的呢？是 <code>Environment</code> 自己干活，还是…有其人？</p>
<h4 id="4-2-1-PropertyResolver的实现类"><a href="#4-2-1-PropertyResolver的实现类" class="headerlink" title="4.2.1 PropertyResolver的实现类"></a>4.2.1 PropertyResolver的实现类</h4><p>借助 IDE ，翻看 PropertyResolver 的子接口和实现类，发现仅仅就这么几个而已：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28a65c7615f54444ae97480dbb97300d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" alt="img"></p>
<p>自然地，我们要去找 <code>Environment</code> 的实现类，<code>StandardEnvironment</code> ，看它是如何解析配置属性值的。</p>
<h4 id="4-2-2-getProperty-的实现是委派"><a href="#4-2-2-getProperty-的实现是委派" class="headerlink" title="4.2.2 getProperty 的实现是委派"></a>4.2.2 getProperty 的实现是委派</h4><p>翻看 <code>StandardEnvironment</code> ，发现 <code>getProperty</code> 方法并没有在此实现，而是父类 <code>AbstractEnvironment</code> 中，但是实现类中发现它是直接调用了自身组合的一个 <code>ConfigurablePropertyResolver</code> 来处理（果然环境本身不适合干这个事，得让专门的组件来干）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConfigurablePropertyResolver propertyResolver =<br>        <span class="hljs-keyword">new</span> PropertySourcesPropertyResolver(<span class="hljs-keyword">this</span>.propertySources);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProperty</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertyResolver.getProperty(key);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一般的，我们称这种方式叫做 <strong>“委派”</strong> ，它与代理、装饰者不同：<strong>委派仅仅是将方法的执行转移给另一个对象，而代理可能会在此做额外的处理，装饰者也会在方法执行前后做增强</strong>。</p>
<p>继续往里看，就要进入 <code>PropertySourcesPropertyResolver</code> 的底层来研究了，再往里研究的性价比相对就不高了：这里面的解析逻辑相对复杂，但搞明白后的收益并不大，综合来看不太适合再深入研究。</p>
<p>小伙伴们只需要了解 <code>Environment</code> 的解析配置属性值的底层是交给 <code>PropertySourcesPropertyResolver</code> 来处理就好啦。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/18/15-IOC%E4%B8%ADBeanDefinition%E6%A6%82%E5%BF%B5/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">15-IOC中BeanDefinition概念</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/18/13-IOC%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%BA%90%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%85%83%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/">
                        <span class="hidden-mobile">13-IOC中配置源与配置元概念区别</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="SOHUCS" sid='http://example.com/2022/04/18/14-IOC%E4%B8%ADEnvironment%E7%9A%84%E6%8A%BD%E8%B1%A1/'></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('SOHUCS', function() {
      var appid = 'cyvjg8eoK';
      var conf = '2085177cb8fe4ee04d95c509f52d4b8b';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      } else {
        Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
          window.changyan.api.config({
            appid: appid,
            conf: conf
          })
        });
      }
    })
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
