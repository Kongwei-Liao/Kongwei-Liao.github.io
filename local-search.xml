<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>15-IOC中BeanDefinition概念</title>
    <link href="/2022/04/18/15-IOC%E4%B8%ADBeanDefinition%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/04/18/15-IOC%E4%B8%ADBeanDefinition%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Bean与BeanDefinition"><a href="#Bean与BeanDefinition" class="headerlink" title="Bean与BeanDefinition"></a>Bean与BeanDefinition</h1><p>前面，我们了解了 <code>Environment</code> 抽象，以及元信息的概念。在元信息中小册提到了那个拖了好久的概念：<code>BeanDefinition</code> ，现在终于到了要解答它的时候了！这个概念相当重要，理解 <code>BeanDefinition</code> 有助于我们更深入的进入 SpringFramework 的核心原理内部探索。</p><h2 id="1-BeanDefinition概述【熟悉】"><a href="#1-BeanDefinition概述【熟悉】" class="headerlink" title="1. BeanDefinition概述【熟悉】"></a>1. BeanDefinition概述【熟悉】</h2><p>前面我们已经知道，<code>BeanDefinition</code> 也是一种<strong>配置元信息</strong>，它描述了 <strong>Bean 的定义信息</strong>。下面咱还是通过多个途径来试着了解 <code>BeanDefinition</code> 的概念。</p><p>【以下内容可能比较啰里八嗦，想直接拿来面试的小伙伴请直接移步 1.4 节】</p><h3 id="1-1-官方文档"><a href="#1-1-官方文档" class="headerlink" title="1.1 官方文档"></a>1.1 官方文档</h3><p>官方文档对于 <code>BeanDefinition</code> 的介绍并没有使用很大的篇幅，基本也只是概述一下就完事了：</p><p><a href="https://link.juejin.cn/?target=https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/core.html%23beans-child-bean-definitions">docs.spring.io/spring/docs…</a></p><blockquote><p>A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific information, such as the initialization method, a static factory method name, and so on. A child bean definition inherits configuration data from a parent definition. The child definition can override some values or add others as needed. Using parent and child bean definitions can save a lot of typing. Effectively, this is a form of templating.</p><p>bean 的定义信息可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子 bean 定义可以从父 bean 定义继承配置数据。子 bean 的定义信息可以覆盖某些值，或者可以根据需要添加其他值。使用父 bean 和子 bean 的定义可以节省很多输入（实际上，这是一种模板的设计形式）。</p></blockquote><p>文档已经解释的比较清楚了，bean 的定义就是包含了这个 bean 应该有的所有重要信息，并且它又提到了一个概念：bean 的定义信息也是有<strong>层次性</strong>的（联想 <code>BeanFactory</code> 的层次性），bean 的定义信息可以继承自某个已经有的定义信息，并覆盖父信息的一些配置值（而且文档最后也说了这相当于模板的设计）。</p><h3 id="1-2-javadoc"><a href="#1-2-javadoc" class="headerlink" title="1.2 javadoc"></a>1.2 javadoc</h3><p>翻开 <code>BeanDefinition</code> 接口的 javadoc ，里面写的不多，不过也已经很精确的说明了 <code>BeanDefinition</code> 的基本作用：</p><blockquote><p>A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information supplied by concrete implementations. This is just a minimal interface: The main intention is to allow a BeanFactoryPostProcessor such as PropertyPlaceholderConfigurer to introspect and modify property values and other bean metadata.</p><p><code>BeanDefinition</code> 描述了一个 bean 的实例，该实例具有属性值，构造函数参数值以及具体实现所提供的更多信息。 这只是一个最小的接口，它的主要目的是允许 <code>BeanFactoryPostProcessor</code>（例如 <code>PropertyPlaceholderConfigurer</code> ）内省和修改属性值和其他 bean 的元数据。</p></blockquote><p>对比起官方文档，javadoc 额外提了编码设计中 <code>BeanDefinition</code> 的使用：<code>BeanFactoryPostProcessor</code> 可以任意修改 <code>BeanDefinition</code> 中的信息。这里面又提到了一个 <code>BeanFactoryPostProcessor</code> 的概念，不要着急不要慌张，后面我们马上就学到后置处理器的部分，自然就都学到啦 ~</p><h3 id="1-3-BeanDefinition接口的方法定义"><a href="#1-3-BeanDefinition接口的方法定义" class="headerlink" title="1.3 BeanDefinition接口的方法定义"></a>1.3 BeanDefinition接口的方法定义</h3><p>借助 IDE ，打开 <code>BeanDefinition</code> 的接口定义，从方法列表上看，<code>BeanDefinition</code> 整体包含以下几个部分：</p><ul><li>Bean 的类信息 - 全限定类名 ( beanClassName )</li><li>Bean 的属性 - 作用域 ( scope ) 、是否默认 Bean ( primary ) 、描述信息 ( description ) 等</li><li>Bean 的行为特征 - 是否延迟加载 ( lazy ) 、是否自动注入 ( autowireCandidate ) 、初始化 / 销毁方法 ( initMethod / destroyMethod ) 等</li><li>Bean 与其他 Bean 的关系 - 父 Bean 名 ( parentName ) 、依赖的 Bean ( dependsOn ) 等</li><li>Bean 的配置属性 - 构造器参数 ( constructorArgumentValues ) 、属性变量值 ( propertyValues ) 等</li></ul><p>由此可见，<code>BeanDefinition</code> 几乎把 bean 的所有信息都能收集并封装起来，可以说是很全面了。</p><h3 id="1-4-【面试题】面试中如何概述BeanDefinition"><a href="#1-4-【面试题】面试中如何概述BeanDefinition" class="headerlink" title="1.4 【面试题】面试中如何概述BeanDefinition"></a>1.4 【面试题】面试中如何概述BeanDefinition</h3><p>以下答案仅供参考，可根据自己的理解调整回答内容：</p><p><code>BeanDefinition</code> 描述了 SpringFramework 中 bean 的元信息，它包含 bean 的类信息、属性、行为、依赖关系、配置信息等。</p><p><code>BeanDefinition</code> 具有层次性，并且可以在 IOC 容器初始化阶段被 <code>BeanDefinitionRegistryPostProcessor</code> 构造和注册，被 <code>BeanFactoryPostProcessor</code> 拦截修改等。</p><blockquote><p>这里贴出的是完整的回答，由于后置处理器的部分还没有学到，小伙伴们可以暂时把最后一句话理解为 “在 IOC 容器初始化阶段被拦截处理” 即可。</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">还是老套路，如果小伙伴想先了解并快速入门 <span class="hljs-keyword">BeanDefinition </span>，可以先跳过第 <span class="hljs-number">2</span> 章，待基本会使用后再回过头来看 <span class="hljs-keyword">BeanDefinition </span>的结构。<br></code></pre></td></tr></table></figure><h2 id="2-BeanDefinition的结构【了解】"><a href="#2-BeanDefinition的结构【了解】" class="headerlink" title="2. BeanDefinition的结构【了解】"></a>2. BeanDefinition的结构【了解】</h2><p>跟上一章一样，搞明白了 <code>BeanDefinition</code> 是什么，下面咱来看看 <code>BeanDefinition</code> 在 SpringFramework 中是如何设计的：</p><p>借助 IDEA ，可以形成如下的继承关系图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e4f5db098034b6385f9645092990679~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>可以发现这里面涉及到的接口、抽象类和扩展居然如此之多，当然我们也不会全部都去探索，只挑其中重要的来看就好啦。</p><h3 id="2-1-AttributeAccessor"><a href="#2-1-AttributeAccessor" class="headerlink" title="2.1 AttributeAccessor"></a>2.1 AttributeAccessor</h3><p>看类名就知道，它是<strong>属性的访问器</strong>，那它一定具有可以访问对象属性的功能咯？文档注释写的非常简单，就一句话：</p><blockquote><p>Interface defining a generic contract for attaching and accessing metadata to/from arbitrary objects.</p><p>定义用于将元数据附加到任意对象，或从任意对象访问元数据的通用协定的接口。</p></blockquote><p>看上去，它很像是类中定义的 getter 和 setter 方法呀，不过实际上它与 getter 、setter 方法有所区别。</p><h4 id="2-1-1-回顾元信息的概念"><a href="#2-1-1-回顾元信息的概念" class="headerlink" title="2.1.1 回顾元信息的概念"></a>2.1.1 回顾元信息的概念</h4><p>元信息的部分我们有说过，一个类中有什么属性、什么方法，是封装在 <strong><code>Class</code></strong> 类对象中的，通过<strong>反射</strong>可以获取类的属性、方法定义信息。</p><p>比方说以下一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样的一个简单的类，如果用定义性质的语言描述，可以抽象成如下内容：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">className:</span> Person<br><span class="hljs-symbol">attributes:</span> [name]<br><span class="hljs-symbol">methods:</span> [getName, setName]<br></code></pre></td></tr></table></figure><h4 id="2-1-2-AttributeAccessor的设计"><a href="#2-1-2-AttributeAccessor的设计" class="headerlink" title="2.1.2 AttributeAccessor的设计"></a>2.1.2 AttributeAccessor的设计</h4><p>翻看 <code>AttributeAccessor</code> 的接口方法，会发现它不只是简单的 getter 和 setter ，它还能移除属性信息（此处的属性就是 bean 的成员属性）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeAccessor</span> </span>&#123;<br>    <span class="hljs-comment">// 设置bean中属性的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Object value)</span></span>;<br><br>    <span class="hljs-comment">// 获取bean中指定属性的值</span><br>    <span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">// 移除bean中的属性</span><br>    <span class="hljs-function">Object <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">// 判断bean中是否存在指定的属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttribute</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">// 获取bean的所有属性</span><br>    String[] attributeNames();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>看这个设计，有木有联想到 <code>Map</code> 呢？（都有 <code>get</code> <code>set</code> <code>remove</code> <code>contains</code> <code>getAll</code> 之类的操作）</p></blockquote><p>由此，我们就可以总结出第一个 <code>BeanDefinition</code> 的特征：**<code>BeanDefinition</code> 继承了 <code>AttributeAccessor</code> 接口，具有配置 bean 属性的功能。**（注意此处的措辞，配置 bean 就包含了访问、修改、移除在内的操作）</p><h3 id="2-2-BeanMetadataElement"><a href="#2-2-BeanMetadataElement" class="headerlink" title="2.2 BeanMetadataElement"></a>2.2 BeanMetadataElement</h3><p>看到 <strong>metadata</strong> ，是不是立马就回想起元信息的概念了？其实这个类名已经把它的功能都告诉我们了：它<strong>存放了 bean 的元信息</strong>。这个接口只有一个方法，是获取 bean 的资源来源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanMetadataElement</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">getSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>资源来源，说白了，就是 bean 的文件 / url 路径。咱们前面写的所有示例，都是在本地磁盘上的 .class 文件加载进来的，所以对应的也就应该是 <code>FileSystemResource</code> （回想前面 20 章资源管理的 3.2 节），这个过会咱们到演示部分看一下就知道了。</p><h3 id="2-3-AbstractBeanDefinition"><a href="#2-3-AbstractBeanDefinition" class="headerlink" title="2.3 AbstractBeanDefinition"></a>2.3 AbstractBeanDefinition</h3><p>到了 <code>BeanDefinition</code> 的第一个实现类了，作为 <code>BeanDefinition</code> 的抽象实现，它里面已经定义好了一些属性和功能（大部分都有了），大体包含以下内容：（只挑选部分重要属性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// bean的全限定类名</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Object beanClass;<br><br><span class="hljs-comment">// 默认的作用域为单实例</span><br><span class="hljs-keyword">private</span> String scope = SCOPE_DEFAULT;<br><br><span class="hljs-comment">// 默认bean都不是抽象的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> abstractFlag = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 是否延迟初始化</span><br><span class="hljs-keyword">private</span> Boolean lazyInit;<br><br><span class="hljs-comment">// 自动注入模式(默认不自动注入)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> autowireMode = AUTOWIRE_NO;<br><br><span class="hljs-comment">// 是否参与IOC容器的自动注入(设置为false则它不会注入到其他bean，但其他bean可以注入到它本身)</span><br><span class="hljs-comment">// 可以这样理解：设置为false后，你们不要来找我，但我可以去找你们</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> autowireCandidate = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-comment">// 同类型的首选bean</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> primary = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// bean的构造器参数和参数值列表</span><br><span class="hljs-keyword">private</span> ConstructorArgumentValues constructorArgumentValues;<br><br><span class="hljs-comment">// bean的属性和属性值集合</span><br><span class="hljs-keyword">private</span> MutablePropertyValues propertyValues;<br><br><span class="hljs-comment">// bean的初始化方法</span><br><span class="hljs-keyword">private</span> String initMethodName;<br><br><span class="hljs-comment">// bean的销毁方法</span><br><span class="hljs-keyword">private</span> String destroyMethodName;<br><br><span class="hljs-comment">// bean的资源来源</span><br><span class="hljs-keyword">private</span> Resource resource;<br></code></pre></td></tr></table></figure><p>可以发现，基本上前面提到的，这里都有了！那它干嘛还要抽象出来呢？看看文档注释怎么说：</p><blockquote><p>Base class for concrete, full-fledged BeanDefinition classes, factoring out common properties of GenericBeanDefinition, RootBeanDefinition, and ChildBeanDefinition. The autowire constants match the ones defined in the AutowireCapableBeanFactory interface.</p><p>它是 <code>BeanDefinition</code> 接口的抽象实现类，其中排除了 <code>GenericBeanDefinition</code> ，<code>RootBeanDefinition</code> 和 <code>ChildBeanDefinition</code> 的常用属性。 自动装配常量与 <code>AutowireCapableBeanFactory</code> 接口中定义的常量匹配。</p></blockquote><p>哦，看样子它还不是最全的咯？针对不同的 <code>BeanDefinition</code> 落地实现，还有一些特殊的属性咯，所以还是需要抽象出一个父类才行哈。</p><p>在继续往下走之前，这里有必要插入一点东西，就是这个 <code>autowireMode</code> 属性，我们之前在 bean 的依赖注入中没有讲到，这里补充一下。</p><h4 id="2-3-1-补充-自动注入模式"><a href="#2-3-1-补充-自动注入模式" class="headerlink" title="2.3.1 补充 : 自动注入模式"></a>2.3.1 补充 : 自动注入模式</h4><p>其实这个自动注入模式，在前面就已经有提过一嘴了（ <code>default-autowire</code> ），不过它的作用小册没有提及，这里咱讲解一下。</p><p>正常来讲，bean 中的组件依赖注入，是需要在 xml 配置文件，或者在属性 / 构造器 / setter 方法上标注注入的注解（ <code>@Autowired</code> / <code>@Resource</code> / <code>@Inject</code> 的。不过，SpringFramework 为我们提供了另外一种方式，<strong>如果组件中的类型 / 属性名与需要注入的 bean 的类型 / name 完全一致，可以不标注依赖注入的注解，也能实现依赖注入</strong>。</p><p>一般情况下，自动注入只会在 xml 配置文件中出现，注解配置中 <code>@Bean</code> 注解的 <code>autowire</code> 属性在 SpringFramework 5.1 之后被标记为已过时，替代方案是使用 <code>@Autowired</code> 等注解。</p><p>使用方式很简单，譬如前面的依赖注入章节中，<code>basic_di/inject-set.xml</code> 配置文件里面，cat 注入的 <code>Person</code> 完全可以不写，只需要在 <code>&lt;bean&gt;</code> 标签上声明自动注入模式为按名称注入即可，运行效果是完全一样的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_di.a_quickstart_set.bean.Cat&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test-cat&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;property name=&quot;master&quot; ref=&quot;person&quot;/&gt; 可以不写 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>自动注入的模式有 5 种选择：</p><ol><li><code>AUTOWIRE_NO</code>（不自动注入）、</li><li><code>AUTOWIRE_BY_NAME</code>（根据 bean 的名称注入）、</li><li><code>AUTOWIRE_BY_TYPE</code>（根据 bean 的类型注入）、</li><li><code>AUTOWIRE_CONSTRUCTOR</code>（根据 bean 的构造器注入）、</li><li><code>AUTOWIRE_AUTODETECT</code>（借助内省决定如何注入，3.0 即弃用）。</li></ol><p><strong>默认是不开启的</strong>（所以才需要我们开发者对需要注入的属性标注注解，或者在 xml 配置文件中配置），不过讲道理这个配置真的很少用，我们知道一下就可以了。</p><hr><h3 id="2-4-GenericBeanDefinition"><a href="#2-4-GenericBeanDefinition" class="headerlink" title="2.4 GenericBeanDefinition"></a>2.4 GenericBeanDefinition</h3><p>又看到 <code>Generic</code> 了，它代表着通用、一般的，所以这种 <code>BeanDefinition</code> 也具有一般性。<code>GenericBeanDefinition</code> 的源码实现非常简单，仅仅是比 <code>AbstractBeanDefinition</code> 多了一个 <code>parentName</code> 属性而已。</p><p>由这个设计，可以得出以下几个结论：</p><ul><li><code>AbstractBeanDefinition</code> 已经完全可以构成 <code>BeanDefinition</code> 的实现了</li><li><code>GenericBeanDefinition</code> 就是 <code>AbstractBeanDefinition</code> 的非抽象扩展而已</li><li><code>GenericBeanDefinition</code> 具有层次性（可从父 <code>BeanDefinition</code> 处继承一些属性信息）</li></ul><p>不过，相比较下面的而言，它的层次性体现的不是那么强烈，下面的这两种 <code>BeanDefinition</code> 就有非常强的层次性关系了。</p><h3 id="2-5-RootBeanDefinition-与-ChildBeanDefinition"><a href="#2-5-RootBeanDefinition-与-ChildBeanDefinition" class="headerlink" title="2.5 RootBeanDefinition 与 ChildBeanDefinition"></a>2.5 RootBeanDefinition 与 ChildBeanDefinition</h3><p><strong>root</strong> 和 <strong>child</strong> ，很明显这是父子关系的意思了呀。对于 <code>ChildBeanDefinition</code> ，它的设计实现与 <code>GenericBeanDefinition</code> 如出一辙，都是集成一个 <code>parentName</code> 来作为父 <code>BeanDefinition</code> 的 “指向引用” 。不过有一点要注意， <code>ChildBeanDefinition</code> 没有默认的无参构造器，必须要传入 <code>parentName</code> 才可以，但 <code>GenericBeanDefinition</code> 则有两种不同的构造器。</p><p><code>RootBeanDefinition</code> 有着 “根” 的概念在里面，它只能作为单体独立的 <code>BeanDefinition</code> ，或者父 <code>BeanDefinition</code> 出现（不能继承其他 <code>BeanDefinition</code> ）。它里面的设计也复杂得多，从源码的篇幅上就能看得出来（接近 500 行，而 <code>GenericBeanDefinition</code> 只有 100 行多一点）。不过这里我们不去挨个属性研究它的作用，只了解重要的组成部分就好啦。</p><p>下面是 <code>RootBeanDefinition</code> 的一些重要的成员属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BeanDefinition的引用持有，存放了Bean的别名</span><br><span class="hljs-keyword">private</span> BeanDefinitionHolder decoratedDefinition;<br><br><span class="hljs-comment">// Bean上面的注解信息</span><br><span class="hljs-keyword">private</span> AnnotatedElement qualifiedElement;<br><br><span class="hljs-comment">// Bean中的泛型</span><br><span class="hljs-keyword">volatile</span> ResolvableType targetType;<br><br><span class="hljs-comment">// BeanDefinition对应的真实的Bean</span><br><span class="hljs-keyword">volatile</span> Class&lt;?&gt; resolvedTargetType;<br><br><span class="hljs-comment">// 是否是FactoryBean</span><br><span class="hljs-keyword">volatile</span> Boolean isFactoryBean;<br><span class="hljs-comment">// 工厂Bean方法返回的类型</span><br><span class="hljs-keyword">volatile</span> ResolvableType factoryMethodReturnType;<br><span class="hljs-comment">// 工厂Bean对应的方法引用</span><br><span class="hljs-keyword">volatile</span> Method factoryMethodToIntrospect;<br></code></pre></td></tr></table></figure><p>可以发现，<code>RootBeanDefinition</code> 在 <code>AbstractBeanDefinition</code> 的基础上，又扩展了这么些 Bean 的信息：</p><ul><li>Bean 的 id 和别名</li><li>Bean 的注解信息</li><li>Bean 的工厂相关信息（是否为工厂 Bean 、工厂类、工厂方法等）</li></ul><p>而且这里面直接把一些反射相关的元素都包含进来了，可见 <code>BeanDefinition</code> 在底层可是要在反射上 “大动干戈”了。</p><h3 id="2-6-AnnotatedBeanDefinition"><a href="#2-6-AnnotatedBeanDefinition" class="headerlink" title="2.6 AnnotatedBeanDefinition"></a>2.6 AnnotatedBeanDefinition</h3><p>最后，提一下这个家伙。它并不是 <code>BeanDefinition</code> 的实现类，而是一个子接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnnotatedBeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanDefinition</span> </span>&#123;<br>    <br><span class="hljs-function">AnnotationMetadata <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-function">MethodMetadata <span class="hljs-title">getFactoryMethodMetadata</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由这个接口定义的方法，大概就可以猜测到，它可以把 Bean 上的注解信息提供出来。借助 IDEA ，发现它的子类里，有一个 <code>AnnotatedGenericBeanDefinition</code> ，还有一个 <code>ScannedGenericBeanDefinition</code> ，它们都是基于注解驱动下的 Bean 的注册，封装的 <code>BeanDefinition</code> 。现在我们没有必要对这些 <code>BeanDefinition</code> 深入研究，到后面 IOC 原理中，遇到咱们会解释的。</p><h2 id="3-体会BeanDefinition【熟悉】"><a href="#3-体会BeanDefinition【熟悉】" class="headerlink" title="3. 体会BeanDefinition【熟悉】"></a>3. 体会BeanDefinition【熟悉】</h2><p>下面使用一些简单的 Demo ，帮助小伙伴们体会 <code>BeanDefinition</code> 中的设计，以及封装的内容。本章只会了解 <code>BeanDefinition</code> 的设计部分，至于如何利用它们，咱们统一放到下一章讲解。</p><blockquote><p>本章源码均在 <code>com.example.spring.definition.a_quickstart</code></p></blockquote><h3 id="3-1-基于xml的BeanDefinition"><a href="#3-1-基于xml的BeanDefinition" class="headerlink" title="3.1 基于xml的BeanDefinition"></a>3.1 基于xml的BeanDefinition</h3><p>使用 xml 配置文件的方式，每定义一个 <code>&lt;bean&gt;</code> 标签，就相当于构建了一个 <code>BeanDefinition</code> ，下面咱来演示基于 xml 的 <code>BeanDefinition</code> 。</p><h4 id="3-1-1-编写Bean与xml"><a href="#3-1-1-编写Bean与xml" class="headerlink" title="3.1.1 编写Bean与xml"></a>3.1.1 编写Bean与xml</h4><p>还是拿最最简单的 <code>Person</code> 举例吧，按照依赖注入的最简单示例编写 <code>Person</code> 与 xml 配置文件就好：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span><br><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;<br><br>    &lt;bean id=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.example.spring.definition.a_quickstart.bean.Person&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;zhangsan&quot;</span>/&gt;<br>    &lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-测试获取BeanDefinition"><a href="#3-1-2-测试获取BeanDefinition" class="headerlink" title="3.1.2 测试获取BeanDefinition"></a>3.1.2 测试获取BeanDefinition</h4><p>使用 xml 驱动 IOC 容器，并尝试获取 <code>BeanDefinition</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinitionQuickstartXmlApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;definition/definition-beans.xml&quot;</span>);<br>        <span class="hljs-comment">// ？？？</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到了这里，要写下一步的代码，发现 <code>ClassPathXmlApplicationContext</code> 里没有 <code>getBeanDefinition</code> 方法：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9f51b142352461e9c8c17b6244e163c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>woc ？这可咋整？难不成我还要取出所有的 <code>BeanDefinition</code> ，再筛选出 person 吗？这显然不合理吧！既然能获取多个，那就肯定能获取一个！那这里到底是出了什么问题呢？</p><p>别慌，回想前面学习的知识，<code>ApplicationContext</code> 中最终是组合了一个 <code>BeanFactory</code> 来存放 Bean 的，那 <code>ApplicationContext</code> 没有，<code>BeanFactory</code> 里有没有呢？</p><p>打开 <code>DefaultListableBeanFactory</code> ，搜索 <code>getBeanDefintion</code> ，发现真的能找到了：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51bb08cccdc4c62a13f3081ccc9ca5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>往上看这个方法的定义，发现它定义在 <code>ConfigurableListableBeanFactory</code> 中。虽说前面 14 章中没有介绍过 <code>ConfigurableListableBeanFactory</code> ，但它的特性应该也能猜得到吧：同时具备 <strong>“可配置”</strong> 和 <strong>“可列举”</strong> 的特性（当然人家也在此基础上又扩充了其他方法），更多的方法定义和用法，小伙伴们可以自行查看源码，小册不在此展开。</p><p>回到正题，既然 <code>ClassPathXmlApplicationContext</code> 没有这个方法，那就由它获取到 <code>BeanFactory</code> 再调用吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinitionQuickstartXmlApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;definition/definition-beans.xml&quot;</span>);<br>        BeanDefinition personBeanDefinition = ctx.getBeanFactory().getBeanDefinition(<span class="hljs-string">&quot;person&quot;</span>);<br>        System.out.println(personBeanDefinition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台可以打印出 person 的 <code>BeanDefinition</code> 信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Generic bean: <br>    class [com.example.spring.definition.a_quickstart.bean.Person]; <br>    <span class="hljs-attribute">scope</span>=; <br>    <span class="hljs-attribute">abstract</span>=<span class="hljs-literal">false</span>; <br>    <span class="hljs-attribute">lazyInit</span>=<span class="hljs-literal">false</span>; <br>    <span class="hljs-attribute">autowireMode</span>=0; <br>    <span class="hljs-attribute">dependencyCheck</span>=0; <br>    <span class="hljs-attribute">autowireCandidate</span>=<span class="hljs-literal">true</span>; <br>    <span class="hljs-attribute">primary</span>=<span class="hljs-literal">false</span>; <br>    <span class="hljs-attribute">factoryBeanName</span>=<span class="hljs-literal">null</span>; <br>    <span class="hljs-attribute">factoryMethodName</span>=<span class="hljs-literal">null</span>; <br>    <span class="hljs-attribute">initMethodName</span>=<span class="hljs-literal">null</span>; <br>    <span class="hljs-attribute">destroyMethodName</span>=<span class="hljs-literal">null</span>; <br>defined <span class="hljs-keyword">in</span> class path<span class="hljs-built_in"> resource </span>[definition/definition-beans.xml]<br></code></pre></td></tr></table></figure><p>由这个打印信息，可以获取到一个 bean 的所有基本信息了。值得注意的是，它是一个 <strong>Generic bean</strong> （打印 <code>personBeanDefinition</code> 的类型可得 <code>org.springframework.beans.factory.support.GenericBeanDefinition</code> ），这个信息比较重要哦。</p><h3 id="3-2-基于-Component的BeanDefinition"><a href="#3-2-基于-Component的BeanDefinition" class="headerlink" title="3.2 基于@Component的BeanDefinition"></a>3.2 基于@Component的BeanDefinition</h3><p>给 <code>Person</code> 上打一个 <code>@Component</code> 注解，然后使用 <code>AnnotationConfigApplicationContext</code> 来驱动扫描 <code>Person</code> 类，其余的代码不变：</p><p>（注意 <code>AnnotationConfigApplicationContext</code> 可以直接调用 <code>getBeanDefinition</code> 方法哦）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinitionQuickstartComponentApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.example.spring.definition.a_quickstart.bean&quot;</span>);<br>        BeanDefinition personBeanDefinition = ctx.getBeanDefinition(<span class="hljs-string">&quot;person&quot;</span>);<br>        System.out.println(personBeanDefinition);<br>        System.out.println(personBeanDefinition.getClass().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台打印出来的依然是一个 <strong>Generic bean</strong> ，但类型与上面的 xml <code>BeanDefinition</code> 不太一致：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Generic bean: class [com.example.spring.definition.a_quickstart.bean.Person]; <br>    <span class="hljs-attribute">scope</span>=singleton; <br>    <span class="hljs-attribute">abstract</span>=<span class="hljs-literal">false</span>; <br>    <span class="hljs-attribute">lazyInit</span>=<span class="hljs-literal">null</span>; <br>    <span class="hljs-attribute">autowireMode</span>=0; <br>    <span class="hljs-attribute">dependencyCheck</span>=0; <br>    <span class="hljs-attribute">autowireCandidate</span>=<span class="hljs-literal">true</span>; <br>    <span class="hljs-attribute">primary</span>=<span class="hljs-literal">false</span>; <br>    <span class="hljs-attribute">factoryBeanName</span>=<span class="hljs-literal">null</span>; <br>    <span class="hljs-attribute">factoryMethodName</span>=<span class="hljs-literal">null</span>; <br>    <span class="hljs-attribute">initMethodName</span>=<span class="hljs-literal">null</span>; <br>    <span class="hljs-attribute">destroyMethodName</span>=<span class="hljs-literal">null</span>; <br>defined <span class="hljs-keyword">in</span> file [E:\IDEA\spring-framework-projects\spring-01-ioc\target\classes\com\example\spring\definition\a_quickstart\bean\Person.class]<br>org.springframework.context.annotation.ScannedGenericBeanDefinition<br></code></pre></td></tr></table></figure><p>可以发现，<code>BeanDefinition</code> 的打印信息里，最大的不同是<strong>加载来源</strong>：</p><ul><li>基于 xml 解析出来的 bean ，定义来源是 xml 配置文件；</li><li>基于 <code>@Component</code> 注解解析出来的 bean ，定义来源是类的 .class 文件中。</li></ul><h3 id="3-3-基于-Bean的BeanDefinition"><a href="#3-3-基于-Bean的BeanDefinition" class="headerlink" title="3.3 基于@Bean的BeanDefinition"></a>3.3 基于@Bean的BeanDefinition</h3><p>编写一个配置类 <code>BeanDefinitionQuickstartConfiguration</code> ，使用 <code>@Bean</code> 注册一个 Person ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinitionQuickstartConfiguration</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，使用这个配置类驱动 IOC 容器，并直接获取 <code>BeanDefinition</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinitionQuickstartBeanApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                BeanDefinitionQuickstartConfiguration.class);<br>        BeanDefinition personBeanDefinition = ctx.getBeanDefinition(<span class="hljs-string">&quot;person&quot;</span>);<br>        System.out.println(personBeanDefinition);<br>        System.out.println(personBeanDefinition.getClass().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，发现控制台打印的内容与前面相比有很大的区别：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Root bean: class [<span class="hljs-literal">null</span>]; <br>    <span class="hljs-attribute">scope</span>=; <br>    <span class="hljs-attribute">abstract</span>=<span class="hljs-literal">false</span>; <br>    <span class="hljs-attribute">lazyInit</span>=<span class="hljs-literal">null</span>; <br>    <span class="hljs-attribute">autowireMode</span>=3; <br>    <span class="hljs-attribute">dependencyCheck</span>=0; <br>    <span class="hljs-attribute">autowireCandidate</span>=<span class="hljs-literal">true</span>; <br>    <span class="hljs-attribute">primary</span>=<span class="hljs-literal">false</span>; <br>    <span class="hljs-attribute">factoryBeanName</span>=beanDefinitionQuickstartConfiguration; <br>    <span class="hljs-attribute">factoryMethodName</span>=person; <br>    <span class="hljs-attribute">initMethodName</span>=<span class="hljs-literal">null</span>; <br>    destroyMethodName=(inferred); <br>defined <span class="hljs-keyword">in</span> com.example.spring.definition.a_quickstart.config.BeanDefinitionQuickstartConfiguration<br>org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader<span class="hljs-variable">$ConfigurationClassBeanDefinition</span><br></code></pre></td></tr></table></figure><p>具体区别可以发现有这么几个：</p><ul><li>Bean 的类型是 Root bean （ <code>ConfigurationClassBeanDefinition</code> 继承自 <code>RootBeanDefinition</code> ）</li><li>Bean 的 className 不见了</li><li>自动注入模式为 <code>AUTOWIRE_CONSTRUCTOR</code> （构造器自动注入）</li><li>有 factoryBean 了：person 由 <code>beanDefinitionQuickstartConfiguration</code> 的 <code>person</code> 方法创建</li></ul><p>这一切的一切都是怎么搞得呢？下面咱解释这种现象与设计。</p><h3 id="3-4-【原理】BeanDefinition是如何生成的（简易理解）"><a href="#3-4-【原理】BeanDefinition是如何生成的（简易理解）" class="headerlink" title="3.4 【原理】BeanDefinition是如何生成的（简易理解）"></a>3.4 【原理】BeanDefinition是如何生成的（简易理解）</h3><p>这个问题说实话如果想完全彻底的解释清楚，有点费劲，我们放到后面的 IOC 原理篇，<code>BeanDefinition</code> 的解析阶段解释，这里只是让小伙伴们有一个认识和印象即可。</p><ol><li>通过 xml 加载的 <code>BeanDefinition</code> ，它的读取工具是 <code>XmlBeanDefinitionReader</code> ，它会解析 xml 配置文件，最终来到 <code>DefaultBeanDefinitionDocumentReader</code> 的 <code>doRegisterBeanDefinitions</code> 方法，根据 xml 配置文件中的 bean 定义构造 <code>BeanDefinition</code> ，最底层创建 <code>BeanDefinition</code> 的位置在 <code>org.springframework.beans.factory.support.BeanDefinitionReaderUtils#createBeanDefinition</code> 。</li><li>通过<strong>模式注解</strong> + <strong>组件扫描</strong>的方式构造的 <code>BeanDefinition</code> ，它的扫描工具是 <code>ClassPathBeanDefinitionScanner</code> ，它会扫描指定包路径下包含特定模式注解的类，核心工作方法是 <code>doScan</code> 方法，它会调用到父类 <code>ClassPathScanningCandidateComponentProvider</code> 的 <code>findCandidateComponents</code> 方法，创建 <code>ScannedGenericBeanDefinition</code> 并返回。</li><li>通过<strong>配置类</strong> + <code>@Bean</code> 注解的方式构造的 <code>BeanDefinition</code> 最复杂，它涉及到配置类的解析。配置类的解析要追踪到 <code>ConfigurationClassPostProcessor</code> 的 <code>processConfigBeanDefinitions</code> 方法，它会处理配置类，并交给 <code>ConfigurationClassParser</code> 来解析配置类，取出所有标注了 <code>@Bean</code> 的方法。随后，这些方法又被 <code>ConfigurationClassBeanDefinitionReader</code> 解析，最终在底层创建 <code>ConfigurationClassBeanDefinition</code> 并返回。</li></ol><p>再啰嗦一边哈，小伙伴只需要对这些内容有一个最简单的了解就好了，至于里面的原理是什么样子，我们现在不要关心！不要关心！不要关心！</p><p>好了，先对 <code>BeanDefinition</code> 了解这么多就好，主要是对 <code>BeanDefinition</code> 有一个总体的认识，能认识到这里面的设计，就已经 OK 了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>BeanDefinition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/18/14-IOC%E4%B8%ADEnvironment%E7%9A%84%E6%8A%BD%E8%B1%A1/"/>
    <url>/2022/04/18/14-IOC%E4%B8%ADEnvironment%E7%9A%84%E6%8A%BD%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Environment抽象"><a href="#Environment抽象" class="headerlink" title="Environment抽象"></a>Environment抽象</h1><p>根据上节内容这里提出了几个问题：</p><ol><li>加载的 properties 资源配置，以及 <code>ApplicationContext</code> 内部的一些默认配置属性，都放在哪里了？</li><li>组件 Bean 又是怎么把配置值注入进去到对象的属性中的？</li></ol><h2 id="1-Environment概述【理解】"><a href="#1-Environment概述【理解】" class="headerlink" title="1. Environment概述【理解】"></a>1. Environment概述【理解】</h2><p><code>Environment</code> 是从 SpringFramework 3.1 开始引入的一个抽象模型。</p><h3 id="1-1-第一直觉"><a href="#1-1-第一直觉" class="headerlink" title="1.1 第一直觉"></a>1.1 第一直觉</h3><p>其实第一眼看到这个名词，我们就应该有一个模糊的猜想了，它应该是基于 SpringFramework 的工程的<strong>运行时环境</strong>。所以我们可以这样看待我们编写的基于 SpringFramework 的应用程序：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461c0349a0964aa8925dc92648796803~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><blockquote><p>这个概念的理解，在 SpringBoot 源码的小册中也有提过，当时也是画了这样一个概念图来帮助小伙伴们理解。</p></blockquote><p>这个理解是否正确呢？我们可以去官方文档加以验证。</p><h3 id="1-2-官方文档的描述"><a href="#1-2-官方文档的描述" class="headerlink" title="1.2 官方文档的描述"></a>1.2 官方文档的描述</h3><p>当我们去翻 SpringFramework 的官方文档时，会发现官方是这样概述 <code>Environment</code> 的：</p><p><a href="https://link.juejin.cn/?target=https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/core.html%23beans-environment">docs.spring.io/spring/docs…</a></p><blockquote><p>The <code>Environment</code> interface is an abstraction integrated in the container that models two key aspects of the application environment: profiles and properties. A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or with annotations. The role of the <code>Environment</code> object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default. Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc <code>Properties</code> objects, <code>Map</code> objects, and so on. The role of the <code>Environment</code> object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.</p><p><code>Environment</code> 接口是集成在容器中的抽象，可对应用程序环境的两个关键方面进行建模：<strong>Profile</strong> 和 <strong>properties</strong> 。</p><ol><li><p>Profiles 是仅在指定 profile 处于活动状态（ active ）时才向容器注册 <code>BeanDefinition</code> 的命名逻辑组。它可以将 Bean 分配给不同的 profile （无论是以 XML 定义还是注解配置）。</p></li><li><p>与配置文件相关的 <code>Environment</code> 作用是确定哪些配置文件当前处于活动状态，以及哪些配置文件在默认情况下应处于活动状态。 </p></li></ol><p>Properties 在几乎所有应用程序中都起着重要作用，并且可能源自多种来源：</p><ol><li><strong>属性文件</strong>；</li><li><strong>JVM 系统属性</strong>；</li><li><strong>系统环境变量</strong>；</li><li><strong>JNDI</strong>；</li><li><strong><code>ServletContext</code> 参数</strong>；</li><li><strong>临时属性对象</strong>，<code>Map</code> 对象等。</li></ol><p><code>Environment</code> 与属性相关联的作用是为用户提供方便的接口，它可以用于配置属性源，并从 <code>Environment</code> 中解析属性。</p></blockquote><p>讲道理这段话理解起来不是那么容易，不过第一句【<code>Environment</code> 是集成在容器中的抽象】，会让我们产生一种感觉：前面的理解是不是出现了一些偏差？如果按照官方文档的说法，<code>Environment</code> 与工程的结构应该是这样才对：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5166a2a211cf4cb1a36a6bb4f5232755~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>到底是不是这样呢，根据个人的理解不同，表达出来的也会不太一样。</p><h3 id="1-3-小册一家之言"><a href="#1-3-小册一家之言" class="headerlink" title="1.3 小册一家之言"></a>1.3 小册一家之言</h3><p>作者个人是倾向于如下的结构理解，这样解释起来会相对更合理一些：</p><ul><li>首先，<code>Environment</code> 中包含 profiles 和 properties ，这些配置信息会影响 IOC 容器中的 bean 的注册与创建；</li><li>其次，<code>Environment</code> 的创建是在 <code>ApplicationContext</code> 创建后才创建的（ IOC 原理部分会解释），所以 <code>Environment</code> 应该是伴随着 <code>ApplicationContext</code> 的存在而存在；</li><li>第三，<code>ApplicationContext</code> 中同时包含 <code>Environment</code> 和 <strong>组件 bean</strong> ，而且从 <code>BeanFactory</code> 的视角来看，<code>Environment</code> 也是一个 Bean ，只不过它的地位比较特殊。</li></ul><p>基于这三点，<code>Environment</code> 与工程的结构应该是下图这样的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07df885666e94a248600430502779905~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>理解了两者的结构及关系，再来回头看看 <code>Environment</code> 的组成部分：<strong>profiles 和 properties</strong> ，咱之前也都了解过了，所以 <code>Environment</code> 的整体理解也就相对没有那么难了吧！</p><h3 id="1-4-javadoc中的描述"><a href="#1-4-javadoc中的描述" class="headerlink" title="1.4 javadoc中的描述"></a>1.4 javadoc中的描述</h3><p>上面并没有引用 <code>Environment</code> 的 javadoc 来阐述 <code>Environment</code> 的概念和定义，原因是 javadoc 并没有对 Application 和 <code>Environment</code> 之间的关系进行描述，所以小册选择在这里再贴出。</p><p>由于 javadoc 的篇幅太长，咱们拆解开来看。</p><h4 id="1-4-1-Environment包含profile于properties"><a href="#1-4-1-Environment包含profile于properties" class="headerlink" title="1.4.1 Environment包含profile于properties"></a>1.4.1 Environment包含profile于properties</h4><blockquote><p>Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the <code>PropertyResolver</code> superinterface.</p><p><code>Environment</code> 是表示当前应用程序正在其中运行的环境的接口。它为应用环境制定了两个关键的方面：<strong>profile</strong> 和 <strong>properties</strong>。</p><p>与属性访问有关的方法通过 <code>PropertyResolver</code> 这个父接口公开。</p></blockquote><p>这一段也是总体的概括 <code>Environment</code> 的基本设计和作用，不过它又提到了 <code>PropertyResolver</code> 这个接口，这个接口负责解析占位符（ <strong>${…}</strong> ）对应的值，作用也比较容易理解，这里就不多展开解释啦。</p><h4 id="1-4-2-profile用于区分不同的环境模式"><a href="#1-4-2-profile用于区分不同的环境模式" class="headerlink" title="1.4.2 profile用于区分不同的环境模式"></a>1.4.2 profile用于区分不同的环境模式</h4><blockquote><p>A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations; see the <code>spring-beans 3.1 schema</code> or the <code>@Profile</code> annotation for syntax details. The role of the <code>Environment</code> object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default. profile 机制保证了仅在给定 profile 处于激活状态时，才向容器注册的 <code>BeanDefinition</code> 的命名逻辑组。无论是用 XML 定义还是通过注解定义，都可以将 Bean 分配给指定的 profile。</p><p>有关语法的详细信息，请参见 <code>spring-beans 3.1规范文档</code> 或 <code>@Profile</code> 注解。<code>Environment</code> 的作用是决定当前哪些配置文件（如果有）处于活动状态，以及默认情况下哪些配置文件（如果有）应处于活动状态。</p></blockquote><p>通过前面 18 章条件装配的学习，这段文档注释也就不难理解了吧。<code>Environment</code> 配合 profile 可以完成<strong>指定模式的环境的组件装配</strong>，以及不同的配置属性注入。</p><h4 id="1-4-3-Properties-用于配置属性和注入值"><a href="#1-4-3-Properties-用于配置属性和注入值" class="headerlink" title="1.4.3 Properties 用于配置属性和注入值"></a>1.4.3 Properties 用于配置属性和注入值</h4><blockquote><p>Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them. </p><p><code>Properties</code> 在几乎所有应用程序中都起着重要作用，并且可能来源自多种途径：属性文件，JVM 系统属性，系统环境变量，JNDI，<code>ServletContext</code> 参数，临时属性对象，Map等。</p><p><code>Environment</code> 与 <code>Properties</code> 的关系是为用户提供方便的服务接口，以配置属性源，并从中解析属性值。</p></blockquote><p>上一章的配置元信息中我们已经知道 properties 的最大作用之一是做<strong>外部化配置</strong>，<code>Environment</code> 中存放了很多 properties ，它们的来源有很多种，而最终的作用都是<strong>提供了属性配置</strong>，或者<strong>给组件注入属性值</strong>。</p><h4 id="1-4-4-Environment不建议直接使用"><a href="#1-4-4-Environment不建议直接使用" class="headerlink" title="1.4.4 Environment不建议直接使用"></a>1.4.4 Environment不建议直接使用</h4><blockquote><p>Beans managed within an <code>ApplicationContext</code> may register to be <code>EnvironmentAware</code> or <code>@Inject</code> the Environment in order to query profile state or resolve properties directly. In most cases, however, application-level beans should not need to interact with the Environment directly but instead may have to have ${…} property values replaced by a property placeholder configurer such as <code>PropertySourcesPlaceholderConfigurer</code>, which itself is EnvironmentAware and as of Spring 3.1 is registered by default when using <code>&lt;context:property-placeholder/&gt;</code>.</p><p>在 <code>ApplicationContext</code> 中管理的 Bean 可以注册为 <code>EnvironmentAware</code> 或使用 <code>@Inject</code> 标注在 <code>Environment</code> 上，以便直接查询 profile 的状态或解析 <code>Properties</code>。 但是，在大多数情况下，应用程序级 Bean 不必直接与 <code>Environment</code> 交互，而是通过将 <strong>${…}</strong> 属性值替换为属性占位符配置器进行属性注入（例如 <code>PropertySourcesPlaceholderConfigurer</code>），该属性本身是 <code>EnvironmentAware</code>，当配置了 <code>&lt;context:property-placeholder/&gt;</code> 时，默认情况下会使用 Spring 3.1 的规范注册。</p></blockquote><p>这一段的描述主要讲了两件事情：</p><ul><li><code>Environment</code> 可以注入到组件中，用于获取当前环境激活的所有 profile 模式；</li><li>但是又不推荐开发者直接使用它，而是通过占位符注入配置属性的值。为什么会这么说呢，其实这个又要说回 <code>Environment</code> 设计的原始意图。<code>Environment</code> 的设计本身就应该是一个<strong>不被应用程序接触到的 “环境”</strong> ，我们<strong>只能从环境中获取一些它已经有的信息，但不应该获取它本身</strong>。所以，在处理 properties 的获取时，直接使用占位符就可以获取了。</li></ul><h4 id="1-4-5-ApplicationContext-获取到的是-ConfigurableEnvironment"><a href="#1-4-5-ApplicationContext-获取到的是-ConfigurableEnvironment" class="headerlink" title="1.4.5 ApplicationContext 获取到的是 ConfigurableEnvironment"></a>1.4.5 ApplicationContext 获取到的是 ConfigurableEnvironment</h4><blockquote><p>Configuration of the environment object must be done through the <code>ConfigurableEnvironment</code> interface, returned from all <code>AbstractApplicationContext</code> subclass <code>getEnvironment()</code> methods. See <code>ConfigurableEnvironment Javadoc</code> for usage examples demonstrating manipulation of property sources prior to application context <code>refresh()</code> .</p><p>必须通过从所有 <code>AbstractApplicationContext</code> 子类的 <code>getEnvironment()</code> 方法返回的 <code>ConfigurableEnvironment</code> 接口完成环境对象的配置。</p><p>请参阅 <code>ConfigurableEnvironment</code> 的 javadoc 以获取使用示例，这些示例演示在应用程序上下文 <code>refresh()</code> 方法被调用之前对属性源进行的操作。</p></blockquote><p>注意这里，<code>ApplicationContext</code> 的根实现类 <code>AbstractApplicationContext</code> 获取到的是 <code>ConfigurableEnvironment</code> ，它具有 <strong>“可写”</strong> 的特征，换言之我们可以修改它内部的属性值 / 数据。不过话又说回来，通常情况下我们都不会直接改它，除非要对 SpringFramework 应用的启动流程或者运行中进行一些额外的扩展或者修改。</p><p>到这里，整个 javadoc 也就读完了，最后总结一下吧，这部分最终还是要理解，并且最好用自己的话概括出来。</p><h3 id="1-5-【面试题】面试中如何概述Environment"><a href="#1-5-【面试题】面试中如何概述Environment" class="headerlink" title="1.5 【面试题】面试中如何概述Environment"></a>1.5 【面试题】面试中如何概述Environment</h3><p>以下答案仅供参考，可根据自己的理解调整回答内容：</p><p><code>Environment</code> 是 SpringFramework 3.1 引入的抽象的概念，它包含 profiles 和 properties 的信息，可以实现统一的配置存储和注入、配置属性的解析等。</p><ul><li>其中 profiles 实现了一种基于模式的环境配置；</li><li>properties 则应用于外部化配置。</li></ul><h2 id="2-Environment-的结构【了解】"><a href="#2-Environment-的结构【了解】" class="headerlink" title="2. Environment 的结构【了解】"></a>2. Environment 的结构【了解】</h2><p>了解了概念和设计的思想，下面咱来看看 <code>Environment</code> 在 SpringFramework 中设计的结构。</p><p>借助 IDEA ，可以看到 <code>Environment</code> 的上下级继承和派生关系：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ace9b0f0c144ca4a49e3083fbece4eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>这里面的几个重要的接口和类关注一下。</p><h3 id="2-1-PropertyResolver"><a href="#2-1-PropertyResolver" class="headerlink" title="2.1 PropertyResolver"></a>2.1 PropertyResolver</h3><p>这个接口，只从接口名就知道它应该是处理占位符 <strong>${}</strong> 的。观察接口的方法定义，直接实锤了它就是做配置属性值的获取和解析的：（下面是 <code>PropertyResolver</code> 的部分方法定义）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PropertyResolver</span> </span>&#123;<br><br>    <span class="hljs-comment">// 检查所有的配置属性中是否包含指定key</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsProperty</span><span class="hljs-params">(String key)</span></span>;<br><br>    <span class="hljs-comment">// 以String的形式返回指定的配置属性的值</span><br>    <span class="hljs-function">String <span class="hljs-title">getProperty</span><span class="hljs-params">(String key)</span></span>;<br><br>    <span class="hljs-comment">// 带默认值的获取</span><br>    <span class="hljs-function">String <span class="hljs-title">getProperty</span><span class="hljs-params">(String key, String defaultValue)</span></span>;<br><br>    <span class="hljs-comment">// 指定返回类型的配置属性值获取</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProperty</span><span class="hljs-params">(String key, Class&lt;T&gt; targetType)</span></span>;<br><br>    <span class="hljs-comment">// ......</span><br><br>    <span class="hljs-comment">// 解析占位符</span><br>    <span class="hljs-function">String <span class="hljs-title">resolvePlaceholders</span><span class="hljs-params">(String text)</span></span>;<br><br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以由此也就证明了：**<code>Environment</code> 可以获取配置元信息，同时也可以解析占位符的信息**。</p><h3 id="2-2-ConfigurableEnvironment"><a href="#2-2-ConfigurableEnvironment" class="headerlink" title="2.2 ConfigurableEnvironment"></a>2.2 ConfigurableEnvironment</h3><p>它又扩展了一些设置 Environment 的方法，可以从接口的方法定义中看到这样的方法名：<code>setActiveProfiles</code> 、<code>addActiveProfile</code> 等等。可以通过这个接口进行编程式设置 profile ！</p><p>除此之外，这个接口中还有一个方法比较值得注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">MutablePropertySources <span class="hljs-title">getPropertySources</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>看方法名可以知道它会返回所有的 <code>PropertySource</code> 对象，可是 <code>MutablePropertySources</code> 是个什么？查看它的源码，发现它的内部就是一个 <strong>List</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutablePropertySources</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PropertySources</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可以总结出一个小小的结论：<strong>以后见到 Mutable 开头的类名，通常可以认为是一个类型的 List 组合包装</strong>。</p><h3 id="2-3-StandardEnvironment"><a href="#2-3-StandardEnvironment" class="headerlink" title="2.3 StandardEnvironment"></a>2.3 StandardEnvironment</h3><p>它是 SpringFramework 中默认使用的标准运行时环境的抽象实现，不过它里面的方法实现的非常少，基本都是由 <code>AbstractEnvironment</code> 负责实现。在后面的原理部分，我们还会再见到它的，这里先留意一下就好。</p><h2 id="3-Environment-的使用"><a href="#3-Environment-的使用" class="headerlink" title="3. Environment 的使用"></a>3. Environment 的使用</h2><p>虽说 <code>Environment</code> 不建议直接在应用程序中使用，但是部分场景下还是需要直接接触它来操纵。本节小册不会直接介绍 <code>Environment</code> 的实际使用，而是先带小伙伴用最简单的方式用一用，体会一下 <code>Environment</code> 的作用即可。</p><h3 id="3-1-获取-Environment"><a href="#3-1-获取-Environment" class="headerlink" title="3.1 获取 Environment"></a>3.1 获取 Environment</h3><h4 id="3-1-1、依赖查找（DL）或者依赖注入"><a href="#3-1-1、依赖查找（DL）或者依赖注入" class="headerlink" title="3.1.1、依赖查找（DL）或者依赖注入"></a>3.1.1、依赖查找（DL）或者依赖注入</h4><p>既然 <code>Environment</code> 存在于 <code>ApplicationContext</code> 中，那么获取 <code>Environment</code> 的方式自然也就可以想到：<code>@Autowired</code> 就可以吧！下面咱来实际操作一下。</p><p>任意编写一个 Bean ，并声明注入 <code>Environment</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentHolder</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    Environment environment;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEnvironment</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(environment);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后直接使用包扫描的方式，驱动 <code>AnnotationConfigApplicationContext</code> ，就可以取到刚写的这个 <code>EnvironmentHolder</code> 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentQuickstartApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.example.spring.environment.a_quickstart.bean&quot;</span>);<br>        EnvironmentHolder environmentHolder = ctx.getBean(EnvironmentHolder.class);<br>        environmentHolder.printEnvironment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台会打印出 <code>Environment</code> 的对象信息：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix">StandardEnvironment &#123;<br><span class="hljs-attr">activeProfiles=[],</span> <br><span class="hljs-attr">defaultProfiles=[default],</span> <br><span class="hljs-attr">propertySources=[</span><br>        PropertiesPropertySource &#123;<span class="hljs-attr">name=&#x27;systemProperties&#x27;&#125;,</span> <br>        SystemEnvironmentPropertySource &#123;<span class="hljs-attr">name=&#x27;systemEnvironment&#x27;&#125;</span><br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2、实现-EnvironmentAware-回调接口"><a href="#3-1-2、实现-EnvironmentAware-回调接口" class="headerlink" title="3.1.2、实现 EnvironmentAware 回调接口"></a>3.1.2、实现 EnvironmentAware 回调接口</h4><p>除此 依赖查找 和 依赖注入 之外，联想到 <code>BeanFactory</code> 、<code>ApplicationContext</code> 的注入方式还有回调注入，作为 SpringFramework 的内置 API ，估计也会有一个 <strong>Aware</strong> 回调注入的接口吧！</p><blockquote><p>使用 <code>@Autowired</code> 的方式在某些情况下会注入失败，所以对于小伙伴们而言，注入是否能成功需要亲手测试运行检验才能知道。</p><p>在后面的后置处理器部分，会演示一种无法使用 <code>@Autowired</code> 注入 <code>Environment</code> 的方式，小伙伴们到时候可以留意一下。</p></blockquote><h3 id="3-2-使用Environment获取配置属性的值"><a href="#3-2-使用Environment获取配置属性的值" class="headerlink" title="3.2 使用Environment获取配置属性的值"></a>3.2 使用Environment获取配置属性的值</h3><p>为了方便获取 properties 的配置信息，这里编写一个配置类，把上一章 <code>PropertySource</code> 的 <code>jdbc.properties</code> 加载进去，之后使用该配置类驱动 IOC 容器即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.example.spring.environment.b_api.bean&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;propertysource/jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentPropertyConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-1、获取profile"><a href="#3-2-1、获取profile" class="headerlink" title="3.2.1、获取profile"></a>3.2.1、获取profile</h4><h4 id="3-2-2、获取properties"><a href="#3-2-2、获取properties" class="headerlink" title="3.2.2、获取properties"></a>3.2.2、获取properties</h4><p><code>EnvironmentHolder</code> 中，这次我们取一下默认的 profiles ，以及 <code>jdbc.properties</code> 中的配置属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentHolder</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    Environment environment;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEnvironment</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Arrays.toString(environment.getDefaultProfiles()));<br>        System.out.println(environment.getProperty(<span class="hljs-string">&quot;jdbc.url&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新驱动 IOC 容器，并取出 <code>EnvironmentHolder</code> 执行 <code>printEnvironment</code> 方法，控制台打印如下信息：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">[<span class="hljs-keyword">default</span>]<br>jdbc:mysql:<span class="hljs-comment">//localhost:3306/test</span><br></code></pre></td></tr></table></figure><h2 id="4-Environment深入探讨【原理】"><a href="#4-Environment深入探讨【原理】" class="headerlink" title="4. Environment深入探讨【原理】"></a>4. Environment深入探讨【原理】</h2><p>先注意一下上面控制台打印的默认 profiles ，发现它有一个默认值是 <strong>default</strong> ，它是从哪来的呢？我们又没声明呀！</p><h3 id="4-1-Environment-的默认-profiles"><a href="#4-1-Environment-的默认-profiles" class="headerlink" title="4.1 Environment 的默认 profiles"></a>4.1 Environment 的默认 profiles</h3><p>想知道 profiles 的默认配置，就要进入到 <code>Environment</code> 的抽象实现 <code>AbstractEnvironment</code> 中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] getDefaultProfiles() &#123;<br>    <span class="hljs-keyword">return</span> StringUtils.toStringArray(doGetDefaultProfiles());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个很有意思的操作：<code>getDefaultProfiles</code> 调用了 <code>doGetDefaultProfiles</code> 方法，这个设计在 SpringFramework 中大量出现和使用！</p><h4 id="4-1-1-Spring-框架中的方法命名规范【旁知引入】"><a href="#4-1-1-Spring-框架中的方法命名规范【旁知引入】" class="headerlink" title="4.1.1 Spring 框架中的方法命名规范【旁知引入】"></a>4.1.1 Spring 框架中的方法命名规范【旁知引入】</h4><p>在 SpringFramework 的框架编码中，如果有出现一个方法是 do 开头，并且去掉 do 后能找到一个与剩余名称一样的方法，则代表如下含义：</p><ul><li>不带 do 开头的方法一般负责前置校验处理、返回结果封装，</li><li>带 do 开头的方法是真正执行逻辑的方法（如 <code>getBean</code> 方法的底层会调用 <code>doGetBean</code> 来真正的寻找 IOC 容器的 bean ，<code>createBean</code> 会调用 <code>doCreateBean</code> 来真正的创建一个 bean ）。</li></ul><h4 id="4-1-2-doGetDefaultProfiles的实现"><a href="#4-1-2-doGetDefaultProfiles的实现" class="headerlink" title="4.1.2 doGetDefaultProfiles的实现"></a>4.1.2 doGetDefaultProfiles的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PROFILES_PROPERTY_NAME = <span class="hljs-string">&quot;spring.profiles.default&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;String&gt; <span class="hljs-title">doGetDefaultProfiles</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.defaultProfiles) &#123;<br>        <span class="hljs-comment">// 取框架默认的profiles，并与当前的 RESERVED_DEFAULT_PROFILE_NAME = &quot;default&quot; 对比</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultProfiles.equals(getReservedDefaultProfiles())) &#123;<br>          <br>            <span class="hljs-comment">// 一致，则尝试从 Environment 中获取默认的声明 DEFAULT_PROFILES_PROPERTY_NAME = &quot;spring.profiles.default&quot; 的 profiles</span><br>            String profiles = getProperty(DEFAULT_PROFILES_PROPERTY_NAME);<br>          <br>            <span class="hljs-comment">// 如果有显式声明，则覆盖原有的默认值</span><br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(profiles)) &#123;<br>                setDefaultProfiles(StringUtils.commaDelimitedListToStringArray(<br>                        StringUtils.trimAllWhitespace(profiles)));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultProfiles;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看这个方法的实现，整体逻辑也不算复杂，关键是看它取框架默认的 profiles ，它其实就是取的 <code>AbstractEnvironment</code> 中内置的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESERVED_DEFAULT_PROFILE_NAME = <span class="hljs-string">&quot;default&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;String&gt; <span class="hljs-title">getReservedDefaultProfiles</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Collections.singleton(RESERVED_DEFAULT_PROFILE_NAME);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-覆盖默认的profiles方法"><a href="#4-1-3-覆盖默认的profiles方法" class="headerlink" title="4.1.3 覆盖默认的profiles方法"></a>4.1.3 覆盖默认的profiles方法</h4><p>可以通过声明 <strong><code>spring.profiles.default</code></strong> 的配置，来覆盖 SpringFramework 中原有的默认 profiles ，一个比较常用的方法是在 jvm 的启动参数上添加：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b2c5bf327624be2ac918edecfdf7f20~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>在 IDEA 的启动配置中，声明 VM options 就可以指定默认的 profiles 了。同理，指定激活的 profiles 也可以像这样指定，只不过它的参数名称为 <strong><code>spring.profiles.active</code></strong> 。</p><h3 id="4-2-Environment-解析-properties-的底层"><a href="#4-2-Environment-解析-properties-的底层" class="headerlink" title="4.2 Environment 解析 properties 的底层"></a>4.2 Environment 解析 properties 的底层</h3><p>前面看 <code>Environment</code> 的结构，我们已经知道 <code>Environment</code> 继承了父接口 <code>PropertyResolver</code> ，自然它拥有解析配置元信息的能力，它的底层是如何实现的呢？是 <code>Environment</code> 自己干活，还是…有其人？</p><h4 id="4-2-1-PropertyResolver的实现类"><a href="#4-2-1-PropertyResolver的实现类" class="headerlink" title="4.2.1 PropertyResolver的实现类"></a>4.2.1 PropertyResolver的实现类</h4><p>借助 IDE ，翻看 PropertyResolver 的子接口和实现类，发现仅仅就这么几个而已：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28a65c7615f54444ae97480dbb97300d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>自然地，我们要去找 <code>Environment</code> 的实现类，<code>StandardEnvironment</code> ，看它是如何解析配置属性值的。</p><h4 id="4-2-2-getProperty-的实现是委派"><a href="#4-2-2-getProperty-的实现是委派" class="headerlink" title="4.2.2 getProperty 的实现是委派"></a>4.2.2 getProperty 的实现是委派</h4><p>翻看 <code>StandardEnvironment</code> ，发现 <code>getProperty</code> 方法并没有在此实现，而是父类 <code>AbstractEnvironment</code> 中，但是实现类中发现它是直接调用了自身组合的一个 <code>ConfigurablePropertyResolver</code> 来处理（果然环境本身不适合干这个事，得让专门的组件来干）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConfigurablePropertyResolver propertyResolver =<br>        <span class="hljs-keyword">new</span> PropertySourcesPropertyResolver(<span class="hljs-keyword">this</span>.propertySources);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProperty</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertyResolver.getProperty(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>一般的，我们称这种方式叫做 <strong>“委派”</strong> ，它与代理、装饰者不同：<strong>委派仅仅是将方法的执行转移给另一个对象，而代理可能会在此做额外的处理，装饰者也会在方法执行前后做增强</strong>。</p><p>继续往里看，就要进入 <code>PropertySourcesPropertyResolver</code> 的底层来研究了，再往里研究的性价比相对就不高了：这里面的解析逻辑相对复杂，但搞明白后的收益并不大，综合来看不太适合再深入研究。</p><p>小伙伴们只需要了解 <code>Environment</code> 的解析配置属性值的底层是交给 <code>PropertySourcesPropertyResolver</code> 来处理就好啦。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>13-IOC中配置源与配置元概念区别</title>
    <link href="/2022/04/18/13-IOC%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%BA%90%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%85%83%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/18/13-IOC%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%BA%90%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%85%83%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="配置源-amp-配置元信息"><a href="#配置源-amp-配置元信息" class="headerlink" title="配置源&amp;配置元信息"></a>配置源&amp;配置元信息</h1><p>从这一章开始，咱开始进入到难度更高的 IOC 高级部分了。对于要深入学习 SpringFramework 中 IOC 的高级特性或者深入原理部分的小伙伴们来讲，这部分真的很重要呀，一定要好好学习哦。</p><p>本章介绍 SpringFramework 中的配置源和配置元信息。说到配置源，可能有部分小伙伴的第一反应是：数据源？不是还没到 jdbc 吗？那当然没到啦，配置源是针对 SpringFramework 的，不是对数据库的，这个概念，以及元信息的概念可能理解起来会比较困难，本章会尽可能的用比较容易理解的例子来解释清楚。</p><p>配置源指的是配置的来源有xml和配置类，配置元是描述配置源的信息。</p><h2 id="1-配置源【理解】"><a href="#1-配置源【理解】" class="headerlink" title="1. 配置源【理解】"></a>1. 配置源【理解】</h2><h3 id="1-1-如何理解配置源"><a href="#1-1-如何理解配置源" class="headerlink" title="1.1 如何理解配置源"></a>1.1 如何理解配置源</h3><p><strong>配置源</strong>，简单理解，就是<strong>配置的来源</strong>。在前面的超多例子中，都是使用 xml 配置文件或者注解配置类来驱动 IOC 容器，那么对于 IOC 容器而言，<strong>xml 配置文件</strong>或者<strong>注解配置类</strong>就可以称之为配置源。</p><p>解释这个概念倒是不难，不过我想请小伙伴们思考一个问题：我们自己写好的配置源给了 Spring 之后，Spring 是如何驱动起整个应用上下文的呢？</p><p>这个问题倒是不难回答，Spring 拿到配置源后肯定是<strong>先加载</strong>，<strong>再解析</strong>，<strong>最后注册</strong>那些定义好的 <strong>bean 到 IOC 容器</strong>，这个过程基本也就算结束了。下面咱来简单捋一捋这个过程中配置源的<strong>解析</strong>部分。</p><h3 id="1-2-配置源的解析思路"><a href="#1-2-配置源的解析思路" class="headerlink" title="1.2 配置源的解析思路"></a>1.2 配置源的解析思路</h3><p>咱现在已经学过的配置源就是：</p><ul><li> xml 配置文件，</li><li> 以及注解配置类两种，</li></ul><p>分别来看</p><h4 id="1-2-1-xml配置文件"><a href="#1-2-1-xml配置文件" class="headerlink" title="1.2.1 xml配置文件"></a>1.2.1 xml配置文件</h4><p>仔细端倪一会之前写过的 xml 配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example.spring.basic_di.c_value_spel.bean&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:basic_di/value/red.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_di.a_quickstart_set.bean.Person&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test-person-byset&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个 xml 中包含几个部分：</p><ul><li>xml 头信息</li><li><code>component-scan</code> 声明包扫描</li><li><code>property-placeholder</code> 引入外部 properties 文件</li><li><code>&lt;bean&gt;</code> 注册 bean 并属性赋值</li></ul><p>再思考一个问题：为什么在 xml 中能写这些标签呢？很简单，xml 头上的那些约束声明的可以写呗。</p><p>那 xml 头上的约束又是从哪来的呢？当然是 SpringFramework 中的 jar 包自带的呗。</p><blockquote><p>那 jar 包是哪里来。。。【给劳资停下！tm说什么狗话呢？】皮一下很开心 ~ ~ ~</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/013c67e797f74e4b8452b23c2ca46980~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p></blockquote><p>思考到这里就可以了，要是真的问 jar 包是哪里来的，可能不出 10 个问题，我们就要开始思考人生了。。。</p><p>回到正题上，xml 中定义的这些信息，如果给这些信息一个定义，那它们就可以这样解释：</p><ul><li>xml 中包含 1 条组件扫描的声明</li><li>包含一条 properties 资源文件引入的声明</li><li>包含一个 bean 的注册</li></ul><p>于是这个 xml 可以用如下的一种抽象语言描述：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">beans.<span class="hljs-keyword">xml</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">    context</span>: [component-scan, <span class="hljs-keyword">property</span><span class="hljs-title"></span>-placeholder]<br>    beans: [person]<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面不会描述具体的组件扫描路径等等，只会<strong>记录这个 xml 中声明了哪些标签</strong>。</p><h4 id="1-2-2-注解配置类"><a href="#1-2-2-注解配置类" class="headerlink" title="1.2.2 注解配置类"></a>1.2.2 注解配置类</h4><p>跟上面一样，咱先找一个之前写过的注解配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.example.spring.bean.b_scope.bean&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanScopeConfiguration</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Child <span class="hljs-title">child1</span><span class="hljs-params">(Toy toy)</span> </span>&#123;<br>        Child child = <span class="hljs-keyword">new</span> Child();<br>        child.setToy(toy);<br>        <span class="hljs-keyword">return</span> child;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Child <span class="hljs-title">child2</span><span class="hljs-params">(Toy toy)</span> </span>&#123;<br>        Child child = <span class="hljs-keyword">new</span> Child();<br>        child.setToy(toy);<br>        <span class="hljs-keyword">return</span> child;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的抽象思维，这个注解配置类也可以进行如下转换：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">BeanScopeConfiguration<span class="hljs-selector-class">.java</span>: &#123;<br>    annotations: <span class="hljs-selector-attr">[ComponentScan]</span><br>    beans: <span class="hljs-selector-attr">[child1, child2]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与上面一样，只会记录配置类中的<strong>配置结构</strong>而已，任何配置信息都不会体现在这里面。</p><blockquote><p>注意，这个解析思路仅仅是我们自己分析的，与 SpringFramework 没有关系。</p></blockquote><h2 id="2-元信息【理解】"><a href="#2-元信息【理解】" class="headerlink" title="2. 元信息【理解】"></a>2. 元信息【理解】</h2><p>突然跳到元信息的章节了，是不是有点猝不及防？先缓缓神，想想上面为什么会叨叨这个解析思路呢？</p><p>也或者，可能会有一些小伙伴产生一种感觉：这种解析思路像是把<strong>整个文件中配置的所有定义都抽取出来</strong>了，形成了一个类似于<strong>配置定义信息</strong>的东西。</p><p>好，如果真的有这个感觉，请一直保持住；如果没有感觉到，那也没有关系，咱来解释一下这里头的重要概念：<strong>元信息</strong>。</p><h3 id="2-1-如何理解元信息"><a href="#2-1-如何理解元信息" class="headerlink" title="2.1 如何理解元信息"></a>2.1 如何理解元信息</h3><blockquote><p>我们不讲究那些通用的概念哈，仅仅是针对 SpringFramework 而言，所以不会涉及到像数据分析与数据挖掘这样的概念进来。</p></blockquote><p><strong>元信息</strong>，又可以理解为<strong>元定义</strong>，简单的说，它就是<strong>定义的定义</strong>。</p><p>干说太抽象，直接上例子吧，方便理解：</p><ul><li>张三，男，18岁<ul><li>它的元信息就是它的属性们：<code>Person &#123;name, age, sex&#125;</code></li></ul></li><li>咪咪，美国短毛，黑白毛，主人是张三<ul><li>它的元信息可以抽取为：<code>Cat &#123;name, type, color, master&#125;</code></li></ul></li></ul><p>写到这里是不是突然产生一种感觉：这不就是<strong>对象和类</strong>吗？？？是的，所以我们可以这样说：<strong>类中包含对象的元信息</strong>。</p><p>想一个小问题，类有元信息吗？当然有，**<code>Class</code>** 这个类里面就包含一个类的所有定义（属性、方法、继承实现、注解等），所以我们可以说：**<code>Class</code> 中包含类的元信息**。</p><p>再举一个小伙伴们都比较熟悉的吧：数据库表与表结构信息，这也是非常典型的<strong>信息与元信息</strong>：数据库表结构描述了数据库表的整体表属性，以及表字段的属性。</p><h3 id="2-2-SpringFramework中的配置元信息"><a href="#2-2-SpringFramework中的配置元信息" class="headerlink" title="2.2 SpringFramework中的配置元信息"></a>2.2 SpringFramework中的配置元信息</h3><p>理解了元信息的概念，接下来就可以来看 SpringFramework 中的元信息了。不过在 SpringFramework 中涉及到的元信息更多，咱先从最熟悉的开始看。</p><h4 id="2-2-1-Bean-的定义元信息【重点】"><a href="#2-2-1-Bean-的定义元信息【重点】" class="headerlink" title="2.2.1 Bean 的定义元信息【重点】"></a>2.2.1 Bean 的定义元信息【重点】</h4><p>跟上面的 Class 描述类相似，SpringFramework 中定义的 Bean 也会封装为一个个的 Bean 的元信息，也就是 <strong><code>BeanDefinition</code></strong> 。它包含了一个 Bean 所需要的几乎所有维度的定义：</p><ul><li>Bean 的全限定名 className</li><li>Bean 的作用域 scope</li><li>Bean 是否延迟加载 lazy</li><li>Bean 的工厂 Bean 名称 factoryBean</li><li>Bean 的构造方法参数列表 constructorArgumentValues</li><li>Bean 的属性值 propertyValues</li><li>……</li></ul><p>可以发现，通过这些定义，基本上一个 Bean 的所有特征、属性就全部都描述出来了。</p><p>有关 <code>BeanDefinition</code> 的内容，咱们放到后面专门开 2 章来讲解，这里先一带而过了。</p><h4 id="2-2-2-IOC容器的配置元信息【了解】"><a href="#2-2-2-IOC容器的配置元信息【了解】" class="headerlink" title="2.2.2 IOC容器的配置元信息【了解】"></a>2.2.2 IOC容器的配置元信息【了解】</h4><p>IOC 容器的配置元信息分为 <strong>beans</strong> 和 <strong>context</strong> 两部分，分别展开来看。</p><h5 id="2-2-2-1-beans的配置元信息"><a href="#2-2-2-1-beans的配置元信息" class="headerlink" title="2.2.2.1 beans的配置元信息"></a>2.2.2.1 beans的配置元信息</h5><p>IOC 容器本身也是有元信息的，只不过这些元信息咱基本没怎么接触。以 xml 配置文件为例，如果你仔细注意一下整个配置文件的最顶层标签，会发现 <code>&lt;beans&gt;</code> 其实是有属性的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bd653d381db4bc0a9483ae256fb3df0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>只不过这些属性我们几乎不怎么用，都是用它默认的值了。</p><p>这个时候可能会有小伙伴一脸楞逼了，我去这都哪来的，我咋不知道呢，还有默认值呢？好吧没有关系，咱下面列出来这些属性的含义和默认值。</p><table><thead><tr><th>配置元信息</th><th>含义 / 作用</th><th>默认值</th></tr></thead><tbody><tr><td>profile</td><td>基于环境的配置</td><td>“”</td></tr><tr><td>default-autowire</td><td>默认的自动注入模式（不需要声明 <code>@Autowired</code> 等注解即可注入组件）</td><td>default（no）</td></tr><tr><td>default-autowire-candidates</td><td>满足指定属性名规则的属性才会被自动注入</td><td>“”</td></tr><tr><td>default-init-method</td><td>全局 bean 的初始化方法</td><td>“”</td></tr><tr><td>default-destroy-method</td><td>全局 bean 的销毁方法</td><td>“”</td></tr><tr><td>default-lazy-init</td><td>全局 bean 是否延迟加载</td><td>default（false）</td></tr><tr><td>default-merge</td><td>继承父 bean 时直接合并父 bean 的属性值</td><td>default（false）</td></tr></tbody></table><blockquote><p>注：默认值中提到的 default 是在没有声明时继承父配置的默认值（ <code>&lt;beans&gt;</code> 标签是可以嵌套使用的），如果都没有声明，则配置的默认值是括号内的值。</p></blockquote><h5 id="2-2-2-2-context的配置元信息"><a href="#2-2-2-2-context的配置元信息" class="headerlink" title="2.2.2.2 context的配置元信息"></a>2.2.2.2 context的配置元信息</h5><p>除此之外，还有一部分 IOC 容器的配置源信息来自于 <code>spring-context</code> 包的 context 前缀标签中（如之前写过的 <code>&lt;component-scan /&gt;</code> 标签）。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c4a59d8759a4ceebf0f8c7920da304f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>同样的，咱也把这些配置元信息都列出来，小伙伴们对里面几个相对常见的配置有一个了解即可。</p><table><thead><tr><th>配置元信息</th><th>含义 / 作用</th></tr></thead><tbody><tr><td><code>&lt;context:annotation-config/&gt;</code></td><td>开启注解驱动</td></tr><tr><td><code>&lt;context:component-scan/&gt;</code></td><td>开启组件扫描</td></tr><tr><td><code>&lt;context:property-placeholder/&gt;</code></td><td>引入外部的资源文件（ properties xml yml 等）</td></tr><tr><td><code>&lt;context:property-override/&gt;</code></td><td>指定配置源会覆盖全局配置（可用于配置覆盖）</td></tr><tr><td><code>&lt;context:spring-configured/&gt;</code></td><td>可以对没有注册到 IOC 容器的 bean 实现依赖注入</td></tr><tr><td><code>&lt;context:load-time-weaver/&gt;</code></td><td>与 AOP 相关（放到 AOP 章节介绍）</td></tr><tr><td><code>&lt;context:mbean-server/&gt;</code></td><td>暴露应用运行状态监控（与 JMX 管理监控有关）</td></tr><tr><td><code>&lt;context:mbean-export/&gt;</code></td><td>注册 MBean 到 JMX 实现运行状态监控（与 JMX 管理监控有关）</td></tr></tbody></table><p>相对比较常用的标签是前三个，小伙伴们只需要对前三个比较了解即可。</p><p>到这里，针对 IOC 容器的基本配置也就都列举完毕了，需要了解的不多，而且大多都接触过了，小伙伴们注意巩固前面的知识点即可。</p><h3 id="2-3-beans的其他配置元信息"><a href="#2-3-beans的其他配置元信息" class="headerlink" title="2.3 beans的其他配置元信息"></a>2.3 beans的其他配置元信息</h3><p>前面介绍 <code>&lt;beans&gt;</code> 的配置元信息中，只是介绍了 <code>&lt;beans&gt;</code> 标签的属性，在 beans 的命名空间里还有两个常用的标签，而且也都比较简单：</p><table><thead><tr><th>配置元信息</th><th>含义 / 作用</th><th>使用方式举例</th></tr></thead><tbody><tr><td><code>&lt;alias /&gt;</code></td><td>给指定的 bean 指定别名</td><td><code>&lt;alias name=&quot;person&quot; alias=&quot;zhangsan&quot;/&gt;</code></td></tr><tr><td><code>&lt;import /&gt;</code></td><td>导入外部现有的 xml 配置文件</td><td><code>&lt;import resource=&quot;classpath:basic_dl/quickstart-byname.xml&quot;/&gt;</code></td></tr></tbody></table><p>使用方式也比较简单，小伙伴们可以自行试探着借助 IDEA 写一写。</p><h3 id="2-4-properties等配置元信息"><a href="#2-4-properties等配置元信息" class="headerlink" title="2.4 properties等配置元信息"></a>2.4 properties等配置元信息</h3><p>上一章我们反复研究的 properties 、xml 、yml 文件，它们的作用都是为了将具体的配置抽取为一个可任意修改的配置文件，防止在程序代码中出现硬编码配置，导致修改配置还需要重新编译的麻烦。这种<strong>将配置内容抽取为配置文件</strong>的动作，我们称之为 <strong>“配置外部化”</strong>，抽取出来的配置文件又被成为 <strong>“外部化配置文件”</strong> （其实这个概念在第 3 章 4.2 节就提过了）。</p><p>而加载这些外部化配置文件的方式，要么通过上面的 <code>&lt;context:property-placeholder/&gt;</code> ，要么通过 <code>@PropertySource</code> 注解，它们最终都会被封装为一个一个的 <code>PropertySource</code> 对象（ properties 文件被封装为 <code>PropertiesPropertySource</code> ）了，而这个 <code>PropertySource</code> 对象内部就持有了这些外部化配置文件的所有内容。</p><p>到这里，差不多 SpringFramework 中的配置源和配置元信息就介绍的差不多了，不过还没有完全介绍完，后面还会有一部分是 Java 编程式驱动 IOC ，届时也会有一部分元信息的提及。</p><p>多啰嗦一句，这个<strong>元信息</strong>的概念会贯穿整个 IOC 高级和后面的原理部分，非常重要，小伙伴一定要建立起这个概念来呀。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12-IOC的资源加载</title>
    <link href="/2022/04/18/12-IOC%E7%9A%84%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/04/18/12-IOC%E7%9A%84%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="PropertySource的使用"><a href="#PropertySource的使用" class="headerlink" title="@PropertySource的使用"></a>@PropertySource的使用</h1><p>承接上一章的内容，本章介绍一个重要的资源加载注解：<code>@PropertySource</code> 。</p><h2 id="1-PropertySource引入properties文件"><a href="#1-PropertySource引入properties文件" class="headerlink" title="1. @PropertySource引入properties文件"></a>1. @PropertySource引入properties文件</h2><h3 id="1-1-声明properties文件"><a href="#1-1-声明properties文件" class="headerlink" title="1.1 声明properties文件"></a>1.1 声明properties文件</h3><p>在 <code>resources</code> 目录下新建一个 <code>propertysource</code> 文件夹，此处存放本章声明的所有资源文件。</p><p>新建一个 <code>jdbc.properties</code> 文件，用来代表声明一个 jdbc 的连接属性（这种写法在后续的 jdbc 整合时非常常见，不过咱还没有学到跟 jdbc 打交道，所以此处只是单纯的声明下而已）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br><span class="hljs-meta">jdbc.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><h3 id="1-2-编写配置模型类"><a href="#1-2-编写配置模型类" class="headerlink" title="1.2 编写配置模型类"></a>1.2 编写配置模型类</h3><p>为了方便观察资源文件是否注入到了 IOC 容器，咱写一个模型类来接收这些配置项，就叫 <code>JdbcProperties</code> 吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcProperties</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver-class-name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driverClassName;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br>    <br>    <span class="hljs-comment">// 省略getter setter toString</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-编写配置类"><a href="#1-3-编写配置类" class="headerlink" title="1.3 编写配置类"></a>1.3 编写配置类</h3><p>新建一个 <code>JdbcPropertiesConfiguration</code> ，扫描配置模型类所在的包，并声明导入上面的 <code>jdbc.properties</code> 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.annotation.g_propertysource.bean&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:propertysource/jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcPropertiesConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-测试运行"><a href="#1-4-测试运行" class="headerlink" title="1.4 测试运行"></a>1.4 测试运行</h3><p>编写启动类，驱动 <code>JdbcPropertiesConfiguration</code> 配置类，并尝试打印容器中的配置模型类的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertySourcePropertiesApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                JdbcPropertiesConfiguration.class);<br>        System.out.println(ctx.getBean(JdbcProperties.class).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台打印了 <code>jdbc.properties</code> 中的属性，证明 properties 文件导入成功。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">JdbcProperties&#123;<br>    <span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;jdbc:mysql://localhost:3306/test&#x27;</span>, <br>    <span class="hljs-attribute">driverClassName</span>=<span class="hljs-string">&#x27;com.mysql.jdbc.Driver&#x27;</span>, <br>    <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;root&#x27;</span>, <br>    <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;123456&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-PropertySource引入xml文件"><a href="#2-PropertySource引入xml文件" class="headerlink" title="2. @PropertySource引入xml文件"></a>2. @PropertySource引入xml文件</h2><p>意料之外吧，<code>@PropertySource</code> 还可以引入 xml 文件，其实在它的注解属性上已经有标注了：</p><blockquote><p>Indicate the resource location(s) of the properties file to be loaded. Both traditional and XML-based properties file formats are supported.</p><p>指示要加载的属性文件的资源位置。 支持原生 properties 和基于 XML 的属性文件格式。</p></blockquote><h3 id="2-1-声明xml文件"><a href="#2-1-声明xml文件" class="headerlink" title="2.1 声明xml文件"></a>2.1 声明xml文件</h3><p>新建一个 <code>jdbc.xml</code> 文件，但是这里面的写法可是有严格的格式要求的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">properties</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xml.jdbc.url&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xml.jdbc.driver-class-name&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xml.jdbc.username&quot;</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;xml.jdbc.password&quot;</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>看得出写xml文件还是比较费劲的？但是没办法，这是 sun 当时给出的 Properties 格式的 xml 标准规范写法，必须按照这个格式来，才能够将xml文件解析为 <code>Properties</code> ，稍后会解释这样写的原因。</p><h3 id="2-2-编写配置模型类"><a href="#2-2-编写配置模型类" class="headerlink" title="2.2 编写配置模型类"></a>2.2 编写配置模型类</h3><p>仿造上面的配置模型类，搞一个基本一样的出来：（注意这里的 <code>@Value</code> 取值加了 xml 前缀）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcXmlProperty</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;xml.jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;xml.jdbc.driver-class-name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driverClassName;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;xml.jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;xml.jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br>    <br>    <span class="hljs-comment">// 省略getter setter toString</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-编写配置类"><a href="#2-3-编写配置类" class="headerlink" title="2.3 编写配置类"></a>2.3 编写配置类</h3><p>仿造上面的配置类写法，造一个基本一样的配置类，注意扫描包的位置不要写错了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.annotation.h_propertyxml.bean&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:propertysource/jdbc.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcXmlConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-测试运行"><a href="#2-4-测试运行" class="headerlink" title="2.4 测试运行"></a>2.4 测试运行</h3><p>编写启动类，驱动 <code>JdbcXmlConfiguration</code> ，并打印 IOC 容器中的 <code>JdbcXmlProperty</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertySourceXmlApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JdbcXmlConfiguration.class);<br>        System.out.println(ctx.getBean(JdbcXmlProperty.class).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台也可以打印出各项属性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">JdbcXmlProperty&#123;<br>    <span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;jdbc:mysql://localhost:3306/test&#x27;</span>, <br>    <span class="hljs-attribute">driverClassName</span>=<span class="hljs-string">&#x27;com.mysql.jdbc.Driver&#x27;</span>, <br>    <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;root&#x27;</span>, <br>    <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;123456&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-xml格式被限制的原因"><a href="#2-5-xml格式被限制的原因" class="headerlink" title="2.5 xml格式被限制的原因"></a>2.5 xml格式被限制的原因</h3><p>好了，来解答上面那个问题：为了完成跟 <code>.properties</code> 文件一样的写法，反而在 xml 中要写这么一大堆乱七八糟的格式，这都哪来的？？？</p><p>别着急，在这个问题之前，先请小伙伴思考另一个问题：SpringFramework 是怎么加载那些 <code>.properties</code> 文件的呢？答案很简单，走的 jdk 原生的 <code>Properties</code> 类。</p><p>下面咱来解答这个问题。</p><h4 id="2-5-1-解析Properties的入口"><a href="#2-5-1-解析Properties的入口" class="headerlink" title="2.5.1 解析Properties的入口"></a>2.5.1 解析Properties的入口</h4><p>答案的追踪可以从 <code>@PropertySource</code> 注解的一个属性入手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> PropertySource &#123;<br>    <span class="hljs-comment">// ......</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Specify a custom &#123;<span class="hljs-doctag">@link</span> PropertySourceFactory&#125;, if any.</span><br><span class="hljs-comment"> * &lt;p&gt;By default, a default factory for standard resource files will be used.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 4.3</span><br><span class="hljs-comment"> */</span><br>Class&lt;? extends PropertySourceFactory&gt; factory() <span class="hljs-keyword">default</span> PropertySourceFactory.class;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个 <code>factory</code> 的属性，它自 SpringFramework 4.3 开始出现，它代表的是：</p><p><strong>使用什么类型的解析器解析当前导入的资源文件</strong>，说的简单点，它想表达的是，用 <code>@PropertySource</code> 注解引入的资源文件需要<strong>用什么策略来解析</strong>它。</p><p>默认情况下它只放了一个 <code>PropertySourceFactory</code> 在这里，看一眼 <code>factory</code> 属性的泛型也能大概猜得出来，<code>PropertySourceFactory</code> 应该是一个接口 / 抽象类，它肯定有默认实现的子类。借助 IDEA 咱很容易就能找到它在 SpringFramework 中默认的唯一实现：<code>DefaultPropertySourceFactory</code> 。</p><h4 id="2-5-2-默认的Properties解析工厂"><a href="#2-5-2-默认的Properties解析工厂" class="headerlink" title="2.5.2 默认的Properties解析工厂"></a>2.5.2 默认的Properties解析工厂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultPropertySourceFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PropertySourceFactory</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PropertySource&lt;?&gt; createPropertySource(<span class="hljs-meta">@Nullable</span> String name, EncodedResource resource) <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-keyword">return</span> (name != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> ResourcePropertySource(name, resource) : <span class="hljs-keyword">new</span> ResourcePropertySource(resource));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认实现中，它只是 new 了一个 <code>ResourcePropertySource</code> 而已，而这个构造方法中有一句让我们很敏感的方法调用：<code>PropertiesLoaderUtils.loadProperties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ResourcePropertySource</span><span class="hljs-params">(String name, EncodedResource resource)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">super</span>(name, PropertiesLoaderUtils.loadProperties(resource));<br>    <span class="hljs-keyword">this</span>.resourceName = getNameForResource(resource.getResource());<br>&#125;<br></code></pre></td></tr></table></figure><p>进入这个 <code>loadProperties</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Properties <span class="hljs-title">loadProperties</span><span class="hljs-params">(EncodedResource resource)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Properties props = <span class="hljs-keyword">new</span> Properties();<br>    fillProperties(props, resource);<br>    <span class="hljs-keyword">return</span> props;<br>&#125;<br></code></pre></td></tr></table></figure><p>得了，它的底层果然是这么用的，那问题自然也就解开了。<code>@PropertySource</code> 解析 xml 也是用 <code>Properties</code> 这个类解析的。可是我们在之前的 JavaSE 中可能没学过 <code>Properties</code> 解析 xml 啊，这还第一次听说咧。</p><h4 id="2-5-3-【扩展】jdk原生Properties解析xml"><a href="#2-5-3-【扩展】jdk原生Properties解析xml" class="headerlink" title="2.5.3 【扩展】jdk原生Properties解析xml"></a>2.5.3 【扩展】jdk原生Properties解析xml</h4><p>其实在 jdk 内置的 <code>Properties</code> 类中有这么一个方法可以解析 xml 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadFromXML</span><span class="hljs-params">(InputStream in)</span> <span class="hljs-keyword">throws</span> IOException, InvalidPropertiesFormatException </span>&#123;<br>    XmlSupport.load(<span class="hljs-keyword">this</span>, Objects.requireNonNull(in));<br>    in.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>只是这个 xml 的要求，属实有点高，它是 sun 公司在很早之前就制定的一个 xml 表达 properties 的标准：（以下是 dtd 约束文件内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--<br>   Copyright <span class="hljs-number">2006</span> Sun Microsystems, Inc.  All rights reserved.<br>  --&gt;<br><br>&lt;!-- DTD <span class="hljs-keyword">for</span> properties --&gt;<br><br>&lt;!<span class="hljs-function">ELEMENT <span class="hljs-title">properties</span> <span class="hljs-params">( comment?, entry* )</span> &gt;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&lt;!ATTLIST properties version CDATA #FIXED &quot;1.0&quot;&gt;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&lt;!ELEMENT <span class="hljs-title">comment</span> <span class="hljs-params">(#PCDATA)</span> &gt;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&lt;!ELEMENT <span class="hljs-title">entry</span> <span class="hljs-params">(#PCDATA)</span> &gt;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&lt;!ATTLIST entry key CDATA #REQUIRED&gt;</span><br></code></pre></td></tr></table></figure><p>可以发现确实是有固定格式的，必须按照这个约束来编写 xml 文件。这个东西知道就好了，估计你以后也用不到 ~ ~ ~</p><h4 id="2-5-4-properties与xml的对比"><a href="#2-5-4-properties与xml的对比" class="headerlink" title="2.5.4 properties与xml的对比"></a>2.5.4 properties与xml的对比</h4><p>对比一下 properties 与 xml 的编写风格：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br><span class="hljs-meta">jdbc.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">123456</span><br><br><br><span class="hljs-meta">&lt;?xml</span> <span class="hljs-string">version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE</span> <span class="hljs-string">properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span><br><span class="hljs-attr">&lt;properties&gt;</span><br>    <span class="hljs-meta">&lt;entry</span> <span class="hljs-string">key=&quot;xml.jdbc.url&quot;&gt;jdbc:mysql://localhost:3306/test&lt;/entry&gt;</span><br>    <span class="hljs-meta">&lt;entry</span> <span class="hljs-string">key=&quot;xml.jdbc.driver-class-name&quot;&gt;com.mysql.jdbc.Driver&lt;/entry&gt;</span><br>    <span class="hljs-meta">&lt;entry</span> <span class="hljs-string">key=&quot;xml.jdbc.username&quot;&gt;root&lt;/entry&gt;</span><br>    <span class="hljs-meta">&lt;entry</span> <span class="hljs-string">key=&quot;xml.jdbc.password&quot;&gt;123456&lt;/entry&gt;</span><br><span class="hljs-attr">&lt;/properties&gt;</span><br></code></pre></td></tr></table></figure><p>难易程度高下立判，properties 完胜，所以对于这种配置型的资源文件，通常都是使用 properties 来编写。</p><p>当然，properties 也不是完全 OK ，由于它的特征是 key-value 的形式，整个文件排下来是没有任何层次性可言的（换句话说，每个配置项之间的地位都是平等的）。</p><p>这个时候 xml 的优势就体现出来了，它可以非常容易的体现出层次性，不过咱不能因为这一个点就觉得 xml 还可以，因为有一个更适合解决这个问题的配置格式：<strong>yml</strong> 。</p><h2 id="3-PropertySource引入yml文件【了解】"><a href="#3-PropertySource引入yml文件【了解】" class="headerlink" title="3. @PropertySource引入yml文件【了解】"></a>3. @PropertySource引入yml文件【了解】</h2><p>接触过 SpringBoot 的小伙伴对 yml 肯定很熟悉了，当然也不乏有一些新学习的小伙伴，所以咱还是在这里简单介绍下 yml 。</p><h3 id="3-1-yml的语法格式"><a href="#3-1-yml的语法格式" class="headerlink" title="3.1 yml的语法格式"></a>3.1 yml的语法格式</h3><p><strong>yml</strong> 又称 <strong>yaml</strong> ，它是可以代替 properties 同时又可以表达层级关系的标记语言，它的基本格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span> <br>  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">cat:</span> <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mimi</span><br>    <span class="hljs-attr">color:</span> <span class="hljs-string">white</span><br><span class="hljs-attr">dog:</span> <br>  <span class="hljs-attr">name:</span> <span class="hljs-string">wangwang</span><br></code></pre></td></tr></table></figure><p>可以发现这种写法既可以表达出 properties 的 key-value 形式，同时可以非常清晰的看到层级之间的关系（ cat 在 person 中，person 与 dog 在一个层级）。</p><p>这种写法同等于下面的 properties ：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">person.name</span>=<span class="hljs-string">zhangsan</span><br><span class="hljs-meta">person.age</span>=<span class="hljs-string">18</span><br><span class="hljs-meta">person.cat.name</span>=<span class="hljs-string">mimi</span><br><span class="hljs-meta">person.cat.color</span>=<span class="hljs-string">white</span><br><span class="hljs-meta">dog.name</span>=<span class="hljs-string">wangwang</span><br></code></pre></td></tr></table></figure><p>两种写法各有优劣，在 SpringBoot 中这两种写法都予以支持。不过这不是咱本章讨论的重点了，下面咱介绍如何把 yml 引入到 IOC 容器中。</p><h3 id="3-2-声明yml文件"><a href="#3-2-声明yml文件" class="headerlink" title="3.2 声明yml文件"></a>3.2 声明yml文件</h3><p>根据上面的 yaml 格式，可以编写出如下 yml 的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">yml:</span> <br>  <span class="hljs-attr">jdbc:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><h3 id="3-3-编写配置模型类"><a href="#3-3-编写配置模型类" class="headerlink" title="3.3 编写配置模型类"></a>3.3 编写配置模型类</h3><p>写法与上面的一模一样，不过 <code>@Value</code> 中的 key 前缀改为了 yml ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcYmlProperty</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;yml.jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;yml.jdbc.driver-class-name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driverClassName;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;yml.jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;yml.jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br>    <br>    <span class="hljs-comment">// 省略getter setter toString</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-编写配置类"><a href="#3-4-编写配置类" class="headerlink" title="3.4 编写配置类"></a>3.4 编写配置类</h3><p>继续仿照上面的写法，把配置类也造出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.annotation.i_propertyyml.bean&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:propertysource/jdbc.yml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcYmlConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-测试运行"><a href="#3-5-测试运行" class="headerlink" title="3.5 测试运行"></a>3.5 测试运行</h3><p>直接编写启动类，驱动 <code>JdbcYmlConfiguration</code> ，取出 <code>JdbcYmlProperty</code> 并打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertySourceYmlApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JdbcYmlConfiguration.class);<br>        System.out.println(ctx.getBean(JdbcYmlProperty.class).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，发现属性是一个也没有注入呀：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">JdbcYmlProperty&#123;<br>    <span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;$&#123;yml.jdbc.url&#125;&#x27;</span>, <br>    <span class="hljs-attribute">driverClassName</span>=<span class="hljs-string">&#x27;$&#123;yml.jdbc.driver-class-name&#125;&#x27;</span>, <br>    <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;$&#123;yml.jdbc.username&#125;&#x27;</span>, <br>    <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;$&#123;yml.jdbc.password&#125;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>小伙伴们是不是又开始 “地铁老人看手机” 了？如果你真的在 “地铁老人看手机” ，那你可得往回翻一翻了哦，上面咱看到解析资源文件的默认实现策略是 <code>DefaultPropertySourceFactory</code> ，它是解析 properties 和标准 xml 文件的，要是能把 yml 文件也解析出来，那才奇了怪呢！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;? extends PropertySourceFactory&gt; factory() <span class="hljs-keyword">default</span> PropertySourceFactory.class;<br></code></pre></td></tr></table></figure><p>那这个时候小伙伴们又有话说了：咋地搁这玩我呐，正经方法不教，净搁这乱跳 ~ ~ ~ 好吧，不闹了，下面介绍如何把 yml 文件也解析出来，并且加载进 IOC 容器。</p><h3 id="3-6-自定义PropertySourceFactory解析yml"><a href="#3-6-自定义PropertySourceFactory解析yml" class="headerlink" title="3.6 自定义PropertySourceFactory解析yml"></a>3.6 自定义PropertySourceFactory解析yml</h3><p>解析 yml 文件，讲道理咱能搞，但是太费劲了，而且现有的开源技术中已经有很成熟的组件能解决 yml 文件的解析，所以咱就来引入一个目前来讲非常成熟，且一直被 SpringBoot 使用的 yml 解析器：snake-yaml 。</p><h4 id="3-6-1-导入snake-yaml的maven坐标"><a href="#3-6-1-导入snake-yaml的maven坐标" class="headerlink" title="3.6.1 导入snake-yaml的maven坐标"></a>3.6.1 导入snake-yaml的maven坐标</h4><p>在 2020 年 2 月，snake-yaml 升级了 1.26 版本，自此之后很长一段时间没有再升级过，且观察最近几个版本的更新速度也非常慢，基本可以断定它的近几个版本都是很稳定的，于是咱就选择这个 1.26 版本作为 yml 文件的解析底层。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>snakeyaml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-6-2-自定义PropertySourceFactory"><a href="#3-6-2-自定义PropertySourceFactory" class="headerlink" title="3.6.2 自定义PropertySourceFactory"></a>3.6.2 自定义PropertySourceFactory</h4><p>为了代替原有的 <code>DefaultPropertySourceFactory</code> ，就需要咱来自定义一个 <code>PropertySourceFactory</code> 的实现了，那就造一个吧，名就叫 <code>YmlPropertySourceFactory</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YmlPropertySourceFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PropertySourceFactory</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，把这个 <code>YmlPropertySourceFactory</code> 设置到 <code>@PropertySource</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(value = &quot;classpath:propertysource/jdbc.yml&quot;, factory = YmlPropertySourceFactory.class)</span><br></code></pre></td></tr></table></figure><p>注意看这个接口的方法，它要返回一个 <code>PropertySource&lt;?&gt;</code> ，借助 IDEA 观察它的继承关系，可以发现它里头有一个实现类叫 <code>PropertiesPropertySource</code> ：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a17375783cc4a42989f9aeff408281b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>那估计咱用这个返回就可以吧！点开它，发现它只有一个公开的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropertiesPropertySource</span><span class="hljs-params">(String name, Properties source)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(name, (Map) source);<br>&#125;<br></code></pre></td></tr></table></figure><p>果然，它只需要传 name 和 <code>Properties</code> 对象就可以了。</p><p>于是，现在的目标就变成了：如何把 yml 资源文件的对象，转换为 <code>Properties</code> 的对象。</p><h4 id="3-6-3-资源文件转换为Properties对象"><a href="#3-6-3-资源文件转换为Properties对象" class="headerlink" title="3.6.3 资源文件转换为Properties对象"></a>3.6.3 资源文件转换为Properties对象</h4><p>在 snake-yaml 中有一个能快速解析 yml 文件的类，叫 <code>YamlPropertiesFactoryBean</code> ，它可以快速加载 <code>Resource</code> 并转为 <code>Properties</code> ，具体写法可参加下面的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) <span class="hljs-keyword">throws</span> IOException &#123;<br>    YamlPropertiesFactoryBean yamlPropertiesFactoryBean = <span class="hljs-keyword">new</span> YamlPropertiesFactoryBean();<br>    <span class="hljs-comment">// 传入resource资源文件</span><br>    yamlPropertiesFactoryBean.setResources(resource.getResource());<br>    <span class="hljs-comment">// 直接解析获得Properties对象</span><br>    Properties properties = yamlPropertiesFactoryBean.getObject();<br>    <span class="hljs-comment">// 如果@PropertySource没有指定name，则使用资源文件的文件名</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PropertiesPropertySource((name != <span class="hljs-keyword">null</span> ? name : resource.getResource().getFilename()), properties);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意这个 <code>EncodedResource</code> ，它就是上一章 2.3 节中提到的封装式资源哦。</p></blockquote><h3 id="3-7-重新测试"><a href="#3-7-重新测试" class="headerlink" title="3.7 重新测试"></a>3.7 重新测试</h3><p>重新运行 <code>main</code> 方法，控制台打印出配置文件的内容，证明 yml 文件解析成功。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">JdbcYmlProperty&#123;<br>    <span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;jdbc:mysql://localhost:3306/test&#x27;</span>, <br>    <span class="hljs-attribute">driverClassName</span>=<span class="hljs-string">&#x27;com.mysql.jdbc.Driver&#x27;</span>, <br>    <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;root&#x27;</span>, <br>    <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;123456&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>资源加载</tag>
      
      <tag>PropertySource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11-IOC的资源管理</title>
    <link href="/2022/04/18/11-IOC%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <url>/2022/04/18/11-IOC%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p> <code>ApplicationContext</code> 中，有看到 <code>ClassPathXmlApplicationContext</code>的直接父类 <code>AbstractXmlApplicationContext</code> 中组合了一个 <code>XmlBeanDefinitionReader</code>组件来解析 xml 配置文件。</p><p>其中，<code>XmlBeanDefinitionReader</code> 接收的 xml 配置文件是一组 <strong><code>Resource</code></strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;<br>    Resource[] configResources = getConfigResources();<br>    <span class="hljs-keyword">if</span> (configResources != <span class="hljs-keyword">null</span>) &#123;<br>        reader.loadBeanDefinitions(configResources);<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <strong><code>Resource</code></strong> 就是 SpringFramework 中定义的资源模型。</p><h2 id="1-Spring框架为什么要自己设计资源模型"><a href="#1-Spring框架为什么要自己设计资源模型" class="headerlink" title="1. Spring框架为什么要自己设计资源模型"></a>1. Spring框架为什么要自己设计资源模型</h2><p>一看到资源管理，或许会有小伙伴立马想到 <code>ClassLoader</code> 的 <code>getResource</code> 和 <code>getResourceAsStream</code> 方法，它们本身就是 jdk 内置的加载资源文件的方式。</p><p>然而 SpringFramework 中并没有直接拿它的这一套，而是自己重新造了一套比原生 JDK 更强大的资源管理。既然是造了，那就肯定有原因（人家的挺好你为啥不用呢，肯定是你觉得它不好），而这个原因，咱们可以翻看 SpringFramework 的官方文档：</p><p><a href="https://link.juejin.cn/?target=https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/core.html%23resources-introduction">docs.spring.io/spring/docs…</a></p><p>概述一下就是说，JDK 原生的 URL 那一套资源加载方式，对于加载 classpath 或者 <code>ServletContext</code> 中的资源来说<u>没有标准的处理手段</u>，而且即便是实现起来也很麻烦，倒不如我自己写一套。（大佬就是强啊）</p><p>如果对比原生 JDK 和 SpringFramework 中的资源管理，可能 SpringFramework 的资源管理真的要更强大吧（问题时这里没有具体说强在哪里？待理解补充），下面咱来了解下 SpringFramework 中定义的资源模型都有什么结构，分别负责哪些功能。</p><h2 id="2-Spring框架中的资源模型【了解】"><a href="#2-Spring框架中的资源模型【了解】" class="headerlink" title="2. Spring框架中的资源模型【了解】"></a>2. Spring框架中的资源模型【了解】</h2><p>先来一张图概览一下吧：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcf8b03d274f4de1a52bbc2c02706277~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>可以发现，SpringFramework 中资源模型最顶级的其实不是 <code>Resource</code> ，而是一个叫 <code>InputStreamSource</code> 的接口：</p><h4 id="2-1-InputStreamSource"><a href="#2-1-InputStreamSource" class="headerlink" title="2.1 InputStreamSource"></a>2.1 InputStreamSource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;<br><span class="hljs-function">InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口只有一个 <code>getInputStream</code> 方法，很明显它表达了一件事情：实现了 <code>InputStreamSource</code> 接口的实现类，都可以从中取到资源的输入流。</p><h4 id="2-2-Resource"><a href="#2-2-Resource" class="headerlink" title="2.2 Resource"></a>2.2 Resource</h4><p>然后就是 <code>InputStreamSource</code> 的子接口 <code>Resource</code> 了，它的文档注释中有写到这么一句话：</p><blockquote><p>Interface for a resource descriptor that abstracts from the actual type of underlying resource, such as a file or class path resource.  它是资源描述符的接口，它可以从基础资源的实际类型中抽象出来，例如文件或类路径资源。</p></blockquote><p>这个翻译看起来很生硬，不过咱只需要关注到一个点：<strong>文件 或 类路径的资源</strong>，仅凭这一个点，Resource 确实更适合 SpringFramework 做资源加载（配置文件通常都放到类路径下）。</p><h4 id="2-3-EncodedResource"><a href="#2-3-EncodedResource" class="headerlink" title="2.3 EncodedResource"></a>2.3 EncodedResource</h4><p>在 <code>Resource</code> 的旁边，有一个 <code>EncodedResource</code> 直接实现了 <code>InputStreamSource</code> 接口，从类名上也能看得出来<u>它抽象的是<strong>编码后</strong>的资源</u>。通过源码，发现它内部组合了一个 <code>Resource</code> ，说明它本身并不是直接加载资源的，资源还是由 Resource 来加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncodedResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Resource resource;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><h4 id="2-4-WritableResource"><a href="#2-4-WritableResource" class="headerlink" title="2.4 WritableResource"></a>2.4 WritableResource</h4><p>自 SpringFramework 3.1 之后，<code>Resource</code> 新的子接口：<code>WritableResource</code> ，它代表着“可写的资源”，那 <code>Resource</code> 就可以理解为“可读的资源”；</p><p>Spring中有很多类似的命名，比如 <code>BeanFactory</code> 与 <code>ConfigurableBeanFactory</code> 前者就是可读的容器，后者是可以配置的容器。</p><h4 id="2-5-ContextResource"><a href="#2-5-ContextResource" class="headerlink" title="2.5 ContextResource"></a>2.5 ContextResource</h4><p>跟 <code>WritableResource</code> 并列的还有一个 <code>ContextResource</code> ，看到类名是不是突然一阵狂喜？它肯定是跟 <code>ApplicationContext</code> 有关系吧！打开源码，看一眼文档注释：</p><blockquote><p>Extended interface for a resource that is loaded from an enclosing ‘context’, e.g. from a javax.servlet.ServletContext but also from plain classpath paths or relative file system paths (specified without an explicit prefix, hence applying relative to the local ResourceLoader’s context).</p></blockquote><p>Emmm？它是跟 <code>ServletContext</code> 有关的？那跟 <code>ApplicationContext</code> 没关系咯。。。是的，它强调的是从一个<strong>封闭的 “上下文” 中加载</strong>，这其实就是说像 <code>ServletContext</code> 这种域（当然文档也说了只是举个例子）。（没有理解，先搁置后面补充）</p><p>以上就是 SpringFramework 中设计的资源模型，不过平时咱用的只有 <code>Resource</code> 接口而已。</p><h2 id="3-Spring-框架中的资源模型实现"><a href="#3-Spring-框架中的资源模型实现" class="headerlink" title="3. Spring 框架中的资源模型实现"></a>3. Spring 框架中的资源模型实现</h2><p>说完了接口，下面说说实现类。不过在说实现类之前，咱先说另外一件事，就是 Java 原生的资源加载方式。</p><h3 id="3-1-Java原生资源加载方式"><a href="#3-1-Java原生资源加载方式" class="headerlink" title="3.1 Java原生资源加载方式"></a>3.1 Java原生资源加载方式</h3><p>Java 原生能加载到哪些地方的资源？大致上分 3 种：</p><ul><li>借助 ClassLoader 加载类路径下的资源</li><li>借助 File 加载文件系统中的资源</li><li>借助 URL 和不同的协议加载本地 / 网络上的资源</li></ul><p>这里为什么要提它呢？那是因为，SpringFramework 中的资源模型实现，就是这三种的体现。</p><h3 id="3-2-Spring框架的实现"><a href="#3-2-Spring框架的实现" class="headerlink" title="3.2 Spring框架的实现"></a>3.2 Spring框架的实现</h3><p>SpringFramework 分别对上面提到的这三种情况提供了三种不同的<strong>（Resource的）实现</strong>：</p><ul><li>ClassLoader → <code>ClassPathResource</code> [ classpath:/ ]</li><li>File → <code>FileSystemResource</code> [ file:/ ]</li><li>URL → <code>UrlResource</code> [ xxx:/ ]</li></ul><p>注意每一行最后的方括号，它代表的是资源路径的前缀：</p><ul><li>如果是 <strong>classpath</strong> 开头的资源路径，SpringFramework 解析到后会自动去类路径下找；</li><li>如果是 <strong>file</strong> 开头的资源路径，则会去文件系统中找；</li><li>如果是 <strong>URL</strong> 支持的协议开头，则底层会使用对应的协议，去尝试获取相应的资源文件。</li></ul><p>除了这三种实现，还有对应于 <code>ContextResource</code> 的实现：<code>ServletContextResource</code> ，它意味着资源是去 <code>ServletContext</code> 域中寻找。</p><h2 id="4-Spring-框架加载资源的方式"><a href="#4-Spring-框架加载资源的方式" class="headerlink" title="4. Spring 框架加载资源的方式"></a>4. Spring 框架加载资源的方式</h2><p>关于 SpringFramework 的资源加载，此前提到过一个 <code>ResourcePatternResolver</code> ，它的父接口 <code>ResourceLoader</code> 才是那个真正负责加载资源的角色。另外也提过在 <code>AbstractApplicationContext</code> 中，通过类继承关系可以得知它继承了 <code>DefaultResourceLoader</code> ，也就是说，<code>ApplicationContext</code> 也通过继承获得了加载资源的能力。</p><p>下面咱简单了解一下 <code>DefaultResourceLoader</code> 是如何根据一个路径，加载到相应的资源的。这段源码的篇幅稍微有点长，咱分开几个部分来看：</p><h3 id="4-1-DefaultResourceLoader"><a href="#4-1-DefaultResourceLoader" class="headerlink" title="4.1 DefaultResourceLoader"></a>4.1 DefaultResourceLoader</h3><p>DefaultResourceLoader 中组合了一堆 ProtocolResolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;ProtocolResolver&gt; protocolResolvers = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">4</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String location)</span> </span>&#123;<br>    Assert.notNull(location, <span class="hljs-string">&quot;Location must not be null&quot;</span>);<br><br>  <span class="hljs-comment">// 类似策略模式（多个协议解析器，找到能够解析 location 的解析器并解析加载资源）</span><br>    <span class="hljs-keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;<br>        Resource resource = protocolResolver.resolve(location, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> resource;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这一段，它会先取它内部组合的几个 <code>ProtocolResolver</code> 来尝试着加载资源，而这个 <code>ProtocolResolver</code> 的设计也是跟 <code>ResourceLoader</code> 有关。</p><h4 id="4-1-1-ProtocolResolver介绍"><a href="#4-1-1-ProtocolResolver介绍" class="headerlink" title="4.1.1 ProtocolResolver介绍"></a>4.1.1 ProtocolResolver介绍</h4><p>它的设计倒是蛮简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @since 4.3</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProtocolResolver</span> </span>&#123;<br><span class="hljs-function">Resource <span class="hljs-title">resolve</span><span class="hljs-params">(String location, ResourceLoader resourceLoader)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它只有一个接口，而且是在 SpringFramework 4.3 版本才出现的：</p><ol><li>它本身可以搭配 <code>ResourceLoader</code> ，在 <code>ApplicationContext</code> 中实现自定义协议的资源加载；</li><li>还可以脱离 <code>ApplicationContext</code> ，直接跟 <code>ResourceLoader</code> 搭配即可。</li></ol><p>这个特性蛮有趣的，咱可以稍微写点代码演示一下效果。</p><h4 id="4-1-2-实现-ProtocolResolver-进行自定义协议资源加载"><a href="#4-1-2-实现-ProtocolResolver-进行自定义协议资源加载" class="headerlink" title="4.1.2 实现 ProtocolResolver 进行自定义协议资源加载"></a>4.1.2 实现 ProtocolResolver 进行自定义协议资源加载</h4><p>在工程的 <code>resources</code> 目录下新建一个 <code>Dog.txt</code> 文件（随便放哪儿都行，只要能找得到），然后写一个 <code>DogProtocolResolver</code> ，实现 <code>ProtocolResolver</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogProtocolResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProtocolResolver</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DOG_PATH_PREFIX = <span class="hljs-string">&quot;dog:&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">resolve</span><span class="hljs-params">(String location, ResourceLoader resourceLoader)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!location.startsWith(DOG_PATH_PREFIX)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 把自定义前缀去掉</span><br>        String realpath = location.substring(DOG_PATH_PREFIX.length());<br>        String classpathLocation = <span class="hljs-string">&quot;classpath:resource/&quot;</span> + realpath;<br>        <span class="hljs-keyword">return</span> resourceLoader.getResource(classpathLocation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，编写启动类，分别实例化 <code>DefaultResourceLoader</code> 与 <code>DogProtocolResolver</code> ，并将 <code>DogProtocolResolver</code> 加入到 <code>ResourceLoader</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtocolResolverApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        DefaultResourceLoader resourceLoader = <span class="hljs-keyword">new</span> DefaultResourceLoader();<br>        DogProtocolResolver dogProtocolResolver = <span class="hljs-keyword">new</span> DogProtocolResolver();<br>        resourceLoader.addProtocolResolver(dogProtocolResolver);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，用 <code>ResourceLoader</code> 获取刚编写好的 <code>Dog.txt</code> ，并用缓冲流读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    DefaultResourceLoader resourceLoader = <span class="hljs-keyword">new</span> DefaultResourceLoader();<br>    DogProtocolResolver dogProtocolResolver = <span class="hljs-keyword">new</span> DogProtocolResolver();<br>    resourceLoader.addProtocolResolver(dogProtocolResolver);<br><br>    Resource resource = resourceLoader.getResource(<span class="hljs-string">&quot;dog:Dog.txt&quot;</span>);<br>    InputStream inputStream = resource.getInputStream();<br>    InputStreamReader reader = <span class="hljs-keyword">new</span> InputStreamReader(inputStream, StandardCharsets.UTF_8);<br>    BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(reader);<br>    String readLine;<br>    <span class="hljs-keyword">while</span> ((readLine = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>        System.out.println(readLine);<br>    &#125;<br>    br.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台打印出 <code>Dog.txt</code> 的内容，证明 <code>DogProtocolResolver</code> 已经起到了作用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">wangwangwang</span><br></code></pre></td></tr></table></figure><h3 id="4-2-DRL-可自行加载类路径下的资源"><a href="#4-2-DRL-可自行加载类路径下的资源" class="headerlink" title="4.2 DRL 可自行加载类路径下的资源"></a>4.2 DRL 可自行加载类路径下的资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String location)</span> </span>&#123;<br>  <br>  <span class="hljs-comment">//Assert.notNull(location, &quot;Location must not be null&quot;);</span><br><br>  <span class="hljs-comment">// 类似策略模式（多个协议解析器，找到能够解析 location 的解析器并解析加载资源）</span><br>    <span class="hljs-comment">//for (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br>    <span class="hljs-comment">//    Resource resource = protocolResolver.resolve(location, this);</span><br>    <span class="hljs-comment">//    if (resource != null) &#123;</span><br>    <span class="hljs-comment">//        return resource;</span><br>    <span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-comment">//&#125;</span><br>  <br>  <br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">if</span> (location.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> getResourceByPath(location);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这部分，且不看上面的 <code>startsWith</code> ，只看中间的 else if 部分返回的类型，就知道它能解析类路径下的资源了，而上面的 <code>getResourceByPath</code> 方法，点进去发现默认还是加载类路径下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Resource <span class="hljs-title">getResourceByPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassPathContextResource(path, getClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure><p>不过这个不是绝对的，如果小伙伴现在手头的工程还有引入 <code>spring-web</code> 模块的 pom 依赖，会发现 <code>DefaultResourceLoader</code> 的几个 Web 级子类中有重写这个方法，以 <code>GenericWebApplicationContext</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Resource <span class="hljs-title">getResourceByPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br>    Assert.state(<span class="hljs-keyword">this</span>.servletContext != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;No ServletContext available&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletContextResource(<span class="hljs-keyword">this</span>.servletContext, path);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现这里创建的不再是类路径下了，Web 环境下 SpringFramework 更倾向于从 <code>ServletContext</code> 中加载。</p><h3 id="4-3-DRL-可支持特定协议"><a href="#4-3-DRL-可支持特定协议" class="headerlink" title="4.3 DRL 可支持特定协议"></a>4.3 DRL 可支持特定协议</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String location)</span> </span>&#123;<br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Try to parse the location as a URL...</span><br>            URL url = <span class="hljs-keyword">new</span> URL(location);<br>          <span class="hljs-comment">// 对应 File 和 URL 这两种</span><br>            <span class="hljs-keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="hljs-keyword">new</span> FileUrlResource(url) : <span class="hljs-keyword">new</span> UrlResource(url));<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (MalformedURLException ex) &#123;<br>            <span class="hljs-comment">// No URL -&gt; resolve as resource path.</span><br>            <span class="hljs-keyword">return</span> getResourceByPath(location);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上面它不能处理类路径的文件，就会尝试通过 URL 的方式加载，这里面包含文件系统的资源，和特殊协议的资源。</p><p>这里面就不进一步深入了，小伙伴们了解 <code>DefaultResourceLoader</code> 能加载的资源类型和大体的流程即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>资源管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-IOC组件扫描</title>
    <link href="/2022/04/18/10-IOC%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F/"/>
    <url>/2022/04/18/10-IOC%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h1><p>前面在第 7 章中，咱介绍了最基础的注解驱动 IOC ，以及组件扫描的最基本使用方式。然而，组件扫描本身可是大有文章的，深入了解组件扫描中的各个细节，对了解这部分内容很有帮助。本章咱就来学习组件扫描中的一些高级使用和底层实现原理。</p><h2 id="1-包扫描的路径【掌握】"><a href="#1-包扫描的路径【掌握】" class="headerlink" title="1. 包扫描的路径【掌握】"></a>1. 包扫描的路径【掌握】</h2><p>第 7 章中咱有讲过，<code>@ComponentScan</code> 注解可以指定包扫描的路径（而且还可以声明不止一个），它的写法是使用 <code>@ComponentScan</code> 的 <code>value</code> / <code>basePackages</code> 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.example.spring.annotation.e_basepackageclass.bean&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePackageClassConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式是最常用的，也是最推荐使用的。除此之外，还有一种声明方式，它使用的是类的 Class 字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repeatable(ComponentScans.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ComponentScan &#123;<br><span class="hljs-meta">@AliasFor(&quot;basePackages&quot;)</span><br>String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br><span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>String[] basePackages() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">// 注意这个</span><br>Class&lt;?&gt;[] basePackageClasses() <span class="hljs-keyword">default</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><p>它的这个 <code>basePackageClasses</code> 属性，可以传入一组 Class 进去，它代表的意思，是扫描<strong>传入的这些 Class 所在包及子包下的所有组件</strong>。</p><p>下面用一个简单的例子演示一下效果</p><h3 id="1-1-声明几个组件类-配置类"><a href="#1-1-声明几个组件类-配置类" class="headerlink" title="1.1 声明几个组件类+配置类"></a>1.1 声明几个组件类+配置类</h3><p>继续沿用之前注解驱动 IOC 的包吧，咱这里创建一个 <code>e_basepackageclass</code> 包，声明几个组件和配置类：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74ac99edff2a4c1c81bc781e8d5dc65d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h3 id="1-2-标注配置类的包扫描规则"><a href="#1-2-标注配置类的包扫描规则" class="headerlink" title="1.2 标注配置类的包扫描规则"></a>1.2 标注配置类的包扫描规则</h3><p>配置类中，声明包扫描配置，咱先拿 <code>DemoService</code> 传进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackageClasses = DemoService.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePackageClassConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-测试运行"><a href="#1-3-测试运行" class="headerlink" title="1.3 测试运行"></a>1.3 测试运行</h3><p>编写启动类，驱动 IOC 容器，并打印容器中所有的 Bean 的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePackageClassApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(BasePackageClassConfiguration.class);<br>        String[] beanDefinitionNames = ctx.getBeanDefinitionNames();<br>        Stream.of(beanDefinitionNames).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，发现控制台中只打印了 <code>DemoService</code> 与 <code>DemoDao</code> ：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalConfigurationAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalAutowiredAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalCommonAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerFactory<br>basePackageClassConfiguration<br>demoDao<br>demoService<br></code></pre></td></tr></table></figure><p>说明它确实以 <code>DemoService</code> 所在的包为基准扫描了，不过没有扫描到 <code>DemoComponent</code> 。</p><h3 id="1-4-加入DemoComponent"><a href="#1-4-加入DemoComponent" class="headerlink" title="1.4 加入DemoComponent"></a>1.4 加入DemoComponent</h3><p>在 <code>@ComponentScan</code> 中，再加入 <code>DemoComponent</code> 的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackageClasses = &#123;DemoService.class, DemoComponent.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePackageClassConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，控制台中多了 <code>DemoComponent</code> 与 <code>InnerComponent</code> 的打印，由此体现出 <code>basePackageClasses</code> 的作用。</p><h2 id="2-包扫描的过滤【掌握】"><a href="#2-包扫描的过滤【掌握】" class="headerlink" title="2. 包扫描的过滤【掌握】"></a>2. 包扫描的过滤【掌握】</h2><p>在实际开发的场景中，我们用包扫描拿到的组件不一定全部都需要，也或者只有一部分需要，这个时候就需要用到包扫描的过滤了。</p><blockquote><p>如果小伙伴之前有用 SpringWebMvc 的 xml 配置开发 Web 应用的话，应该印象蛮深刻吧！<code>spring-mvc.xml</code> 中配置只能扫描 <code>@Controller</code> 注解，<code>applicationContext.xml</code> 中又要设置不扫描 <code>@Controller</code> 注解，这就是扫描过滤的规则设置。</p></blockquote><blockquote><p>本小节源码位置：<code>com.example.spring.annotation.f_typefilter</code></p></blockquote><p>下面咱先来创建一些组件类。</p><h3 id="2-1-声明好多组件类-配置类"><a href="#2-1-声明好多组件类-配置类" class="headerlink" title="2.1 声明好多组件类 + 配置类"></a>2.1 声明好多组件类 + 配置类</h3><p>这次声明的更多了，可想而知接下来得有多少种过滤的规则哦（滑稽）</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1e87da9645449ecb66111006edf9a00~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>简单说一下这些组件的编写。</p><ul><li><pre><code>@Animal<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   <br><br>  是一个普通的注解，它可以标注在类上<br><br>  - `Cat` 、`Dog` 、`Pikachu` 是三个最简单的类，其中 `Cat` 和 `Dog` 上除了标注 `@Component` 注解外，还标注 `@Animal`<br><br>- color 包下的<br><br>   <br><br></code></pre></td></tr></table></figure>Color<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   <br><br>  是一个父类<br><br>  - 下面的红黄绿三个类均标注 `@Component` ，不过只有 `Red` 和 `Yellow` 继承 `Color`<br><br>- bean 包的 `DemoService` 与 `DemoDao` 均是普通的类，且都没有标注任何注解<br><br>下面咱开始介绍过滤的几种方式。<br><br>### <span class="hljs-number">2.2</span> includeFilters 按注解筛选<br><br>在 `TypeFilterConfiguration` 中，声明 `@ComponentScan` 注解，扫描整个 `f_typefilter`包，之后在 `@ComponentScan` 注解中声明 `includeFilters` 属性，让它把含有 `@Animal` 注解的类带进来：<br><br>```java<br>@Configuration<br>@ComponentScan(basePackages = <span class="hljs-string">&quot;com.example.spring.annotation.f_typefilter&quot;</span>,<br>               includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class))<br>public class TypeFilterConfiguration &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>注意这里面的 `@Filter` 是 `@ComponentScan` 注解的内部类哦。</code></pre></li></ul><p>编写启动类，驱动 IOC 容器，并打印容器中所有 Bean 的名称，发现所有标注了模式注解的类全加载进来了：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing">typeFilterConfiguration<br>cat<br>dog<br>pikachu<br><span class="hljs-built_in">green</span><br><span class="hljs-built_in">red</span><br>yellow<br></code></pre></td></tr></table></figure><p>这跟咱的预想似乎不是很一致：我想只让你把 <code>@Animal</code> 注解过的类带进来，你咋把这么一大堆都给我注册了呢？那是因为，<code>@ComponentScan</code> 注解中还有一个属性：<code>useDefaultFilters</code> ，它代表的是“是否启用默认的过滤规则”。咱之前也讲过了，默认规则就是扫那些以 <code>@Component</code> 注解为基准的模式注解。其实这个属性的文档注释也写的很明白了：</p><blockquote><p>Indicates whether automatic detection of classes annotated with @Component @Repository, @Service, or @Controller should be enabled.</p><p>指示是否应启用对以 <code>@Component</code> 、<code>@Repository</code> 、<code>@Service</code> 或 <code>@Controller</code> 注解的类的自动检测。</p></blockquote><p>合着人家默认就扫这几个注解的原因在这里啊，那我指定了我自己想过滤的规则你还不理呗？这是瞧谁不起啊？</p><p>莫急莫急，<strong>你声明了自己的过滤规则，不耽误人家的呀</strong>。换句话说，<strong>这些 include 的过滤规则之间互相不受影响，且不会互相排除</strong>：你包含的组件我也包含，那咱就一起加载；你不包含的我包含，那我也把它们带过来，而不是我拿过来了你又给我扔了。</p><p>也许这样理解起来更容易一些（有颜色的部分代表匹配规则）：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cc6502a040548d6966aa52e89d6542a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h3 id="2-3-excludeFilters-按注解排除"><a href="#2-3-excludeFilters-按注解排除" class="headerlink" title="2.3 excludeFilters 按注解排除"></a>2.3 excludeFilters 按注解排除</h3><p>这次咱反过来，刚才不是 include 了吗？这次咱换用 <strong>exclude</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.example.spring.annotation.f_typefilter&quot;,</span><br><span class="hljs-meta">               excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class))</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeFilterConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，可以发现 <code>Cat</code> 和 <code>Dog</code> 都不见了：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">typeFilterConfiguration<br>pikachu<br><span class="hljs-built_in">green</span><br><span class="hljs-built_in">red</span><br>yellow<br></code></pre></td></tr></table></figure><p>由此可以得出结论：<strong>排除型过滤器会排除掉其他过滤规则已经包含进来的 Bean</strong> 。</p><p>跟上面对比起来，很明显这种情况下包含的组件会少一些（只要是带 <code>@Animal</code> 的都不会被匹配）：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8246722a7844fe9b10793033120120~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h3 id="2-3-按ASSIGNABLE-TYPE过滤"><a href="#2-3-按ASSIGNABLE-TYPE过滤" class="headerlink" title="2.3 按ASSIGNABLE_TYPE过滤"></a>2.3 按ASSIGNABLE_TYPE过滤</h3><p>继续在 <code>@ComponentScan</code> 注解上添加过滤规则，这次咱把所有 <code>Color</code> 类型都包含进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.example.spring.annotation.f_typefilter&quot;,</span><br><span class="hljs-meta">               includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = Color.class)&#125;,</span><br><span class="hljs-meta">               excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeFilterConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，发现这次连父类 <code>Color</code> 也给带进来了：（第 5 个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">typeFilterConfiguration<br>pikachu<br>color<br>green<br>red<br>yellow<br></code></pre></td></tr></table></figure><p>如果把这个规则也挪到 <strong>exclude</strong> 中，则 color 、red 、yellow 都就没了：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">typeFilterConfiguration</span><br><span class="hljs-attribute">pikachu</span><br><span class="hljs-attribute">green</span><br></code></pre></td></tr></table></figure><h3 id="2-4-pattern正则表达式过滤"><a href="#2-4-pattern正则表达式过滤" class="headerlink" title="2.4 pattern正则表达式过滤"></a>2.4 pattern正则表达式过滤</h3><p>除了按注解过滤、按类型过滤，它内置的模式还有两种表达式的过滤规则，分别是 “切入点表达式过滤” 和 “正则表达式过滤” 。关于切入点表达式的概念咱放到 AOP 中再讲，这里先讲正则表达式的方式。</p><p>这次咱想通过正则表达式的方式，把那两个 Demo 开头的组件加载进来，正则表达式就可以这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.example.spring.annotation.f_typefilter&quot;,</span><br><span class="hljs-meta">               includeFilters = &#123;</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.REGEX, pattern = &quot;com.example.spring.annotation.f_typefilter.+Demo.+&quot;)</span><br><span class="hljs-meta">               &#125;,</span><br><span class="hljs-meta">               excludeFilters = &#123;</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class),</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = Color.class)</span><br><span class="hljs-meta">               &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeFilterConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这样编写好后，重新运行 <code>main</code> 方法，<code>DemoService</code> 和 <code>DemoDao</code> 就会被注册到 IOC 容器了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">typeFilterConfiguration<br>pikachu<br>demoDao<br>demoService<br>green<br></code></pre></td></tr></table></figure><h3 id="2-5-CUSTOM自定义过滤"><a href="#2-5-CUSTOM自定义过滤" class="headerlink" title="2.5 CUSTOM自定义过滤"></a>2.5 CUSTOM自定义过滤</h3><p>如果预设的几种模式都不能满足要求，那就需要用编程式过滤方式了，也就是自定义过滤规则。</p><p>先定个目标吧，这次编写自定义过滤后，咱们把 green 也过滤掉。</p><h4 id="2-5-1-TypeFilter接口"><a href="#2-5-1-TypeFilter接口" class="headerlink" title="2.5.1 TypeFilter接口"></a>2.5.1 TypeFilter接口</h4><p>编程式自定义过滤，需要编写过滤策略，实现 <code>TypeFilter</code> 接口。这个接口只有一个 <code>match</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TypeFilter</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>match</code> 方法有两个参数，咱是一个也看不懂呀！好在文档注释中有描述，咱可以来参考一下：</p><ul><li><p>metadataReader</p><p>：the metadata reader for the target class</p><ul><li>通过这个 Reader ，可以读取到正在扫描的类的信息（包括类的信息、类上标注的注解等）</li></ul></li><li><p>metadataReaderFactory</p><p>：a factory for obtaining metadata readers for other classes (such as superclasses and interfaces)</p><ul><li>借助这个 Factory ，可以获取到其他类的 Reader ，进而获取到那些类的信息</li><li>可以这样理解：<strong>借助 ReaderFactory 可以获取到 Reader ，借助 Reader 可以获取到指定类的信息</strong></li></ul></li></ul><p>现在看不懂没关系，咱把上面的需求实现出来就好了嘛。</p><h4 id="2-5-2-编写自定义过滤规则"><a href="#2-5-2-编写自定义过滤规则" class="headerlink" title="2.5.2 编写自定义过滤规则"></a>2.5.2 编写自定义过滤规则</h4><p><code>MetadataReader</code> 中有一个 <code>getClassMetadata</code> 方法，可以拿到正在扫描的类的基本信息，咱可以由此取到全限定类名，进而与咱需求中的 <code>Green</code> 类做匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span><br><span class="hljs-function">         <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>    <span class="hljs-keyword">return</span> classMetadata.getClassName().equals(Green.class.getName());<br>&#125;<br></code></pre></td></tr></table></figure><p>返回 true ，则说明已经匹配上了。</p><h4 id="2-5-3-添加过滤规则声明"><a href="#2-5-3-添加过滤规则声明" class="headerlink" title="2.5.3 添加过滤规则声明"></a>2.5.3 添加过滤规则声明</h4><p><code>TypeFilter</code> 写完了，不要忘记加在 <code>@ComponentScan</code> 上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.example.spring.annotation.f_typefilter&quot;,</span><br><span class="hljs-meta">               includeFilters = &#123;</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.REGEX, pattern = &quot;com.example.spring.annotation.f_typefilter.+Demo.+&quot;)</span><br><span class="hljs-meta">               &#125;,</span><br><span class="hljs-meta">               excludeFilters = &#123;</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.ANNOTATION, value = Animal.class),</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = Color.class),</span><br><span class="hljs-meta">                       @ComponentScan.Filter(type = FilterType.CUSTOM, value = GreenTypeFilter.class)</span><br><span class="hljs-meta">               &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeFilterConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行启动类的 <code>main</code> 方法，可以发现 <code>Green</code> 也没了，自定义 <code>TypeFilter</code> 生效。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">typeFilterConfiguration</span><br><span class="hljs-attribute">pikachu</span><br><span class="hljs-attribute">demoDao</span><br><span class="hljs-attribute">demoService</span><br></code></pre></td></tr></table></figure><p>更多的 <code>MetadataReader</code> 和 <code>MetadataReaderFactory</code> 的使用，小伙伴们可以自行探索，小册不过多列举。</p><h4 id="2-5-4-metadata的概念"><a href="#2-5-4-metadata的概念" class="headerlink" title="2.5.4 metadata的概念"></a>2.5.4 metadata的概念</h4><p>讲到这里了，咱先不着急往下走，停一停，咱讲讲 <strong>metadata</strong> 的概念。</p><p>回想一下 JavaSE 的反射，它是不是可以根据咱写好的类，获取到类的全限定名、属性、方法等信息呀。好，咱现在就建立起这么一个概念：咱定义的类，它叫什么名，它有哪些属性，哪些方法，这些信息，统统叫做<strong>元信息</strong>，<strong>元信息会描述它的目标的属性和特征</strong>。</p><p>在 SpringFramework 中，元信息大量出现在框架的底层设计中，不只是 <strong>metadata</strong> ，前面咱屡次见到的 <strong>definition</strong> ，也是元信息的体现。后面到了 IOC 高级部分，咱会整体的学习 SpringFramework 中的元信息、元定义设计，以及 <code>BeanDefinition</code> 的全解析。</p><h2 id="3-包扫描的其他特性【熟悉】"><a href="#3-包扫描的其他特性【熟悉】" class="headerlink" title="3. 包扫描的其他特性【熟悉】"></a>3. 包扫描的其他特性【熟悉】</h2><p>两个比较重头的特性咱说完之后，还有一些小零碎，咱也盘点盘点。</p><h3 id="3-1-包扫描可以组合使用"><a href="#3-1-包扫描可以组合使用" class="headerlink" title="3.1 包扫描可以组合使用"></a>3.1 包扫描可以组合使用</h3><p>小伙伴们在写 <code>@ComponentScan</code> 注解时一定有发现还有一个 <code>@ComponentScans</code> 注解吧！不过比较靠前的版本是看不到它的，它起源自 4.3 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @since 4.3</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ComponentScans &#123;<br>ComponentScan[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实它就是一次性组合了一堆 <code>@ComponentScan</code> 注解而已了，没啥好说的。</p><h3 id="3-2-包扫描的组件名称生成"><a href="#3-2-包扫描的组件名称生成" class="headerlink" title="3.2 包扫描的组件名称生成"></a>3.2 包扫描的组件名称生成</h3><p>咱在前面刚学习注解驱动时，就知道默认情况下生成的 bean 的名称是类名的首字母小写形式（ Person → person ），可是它为啥就有这个规则呢？这个问题，也可以从 <code>@ComponentScan</code>注解中找到。</p><p>在 <code>@ComponentScan</code> 注解的属性中，有一个 <code>nameGenerator</code> ，它的默认值是 <code>BeanNameGenerator</code> 。不过这个 <code>BeanNameGenerator</code> 是一个接口，从文档注释中不难找到实现类是 <code>AnnotationBeanNameGenerator</code> 。</p><h4 id="3-2-1-BeanNameGenerator"><a href="#3-2-1-BeanNameGenerator" class="headerlink" title="3.2.1 BeanNameGenerator"></a>3.2.1 BeanNameGenerator</h4><p>从名称上就知道它是 Bean 的名字生成器了，它只有一个 <code>generateBeanName</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanNameGenerator</span> </span>&#123;<br><span class="hljs-function">String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>又出现 <code>BeanDefinition</code> 和 <code>BeanDefinitionRegistry</code> 了，可见元信息、元定义在底层真的太常见了！</p><p>不过咱先不要把精力放在这里，实现类才是重点。</p><h4 id="3-2-2-AnnotationBeanNameGenerator的实现"><a href="#3-2-2-AnnotationBeanNameGenerator的实现" class="headerlink" title="3.2.2 AnnotationBeanNameGenerator的实现"></a>3.2.2 AnnotationBeanNameGenerator的实现</h4><p>找到 <code>AnnotationBeanNameGenerator</code> 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-comment">// 组件的注册方式是注解扫描的</span><br>    <span class="hljs-keyword">if</span> (definition <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>        <span class="hljs-comment">// 尝试从注解中获取名称</span><br>        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(beanName)) &#123;<br>            <span class="hljs-comment">// Explicit bean name found.</span><br>            <span class="hljs-keyword">return</span> beanName;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Fallback: generate a unique default bean name.</span><br>    <span class="hljs-comment">// 如果没有获取到，则创建默认的名称</span><br>    <span class="hljs-keyword">return</span> buildDefaultBeanName(definition, registry);<br>&#125;<br></code></pre></td></tr></table></figure><p>看这段源码的实现，整体的逻辑还是非常容易理解的：</p><ol><li><p>只有注解扫描注册进来的 Bean 才会被处理（ <code>AnnotationBeanNameGenerator</code> ，看类名 ￣へ￣ ）</p></li><li><p>既然是注解扫描进来的，那我就要看看有木有在注解中声明好了</p><blockquote><p>这种声明方式就是 <code>@Component(&quot;person&quot;)</code></p></blockquote></li><li><p>注解中找不到名，那好吧，我给你构造一个，不过这个名是按照我默认规则来的，你就别挑挑拣拣咯</p></li></ol><p>上面从注解中获取的部分咱留到后面再看，这里咱只看 <code>buildDefaultBeanName</code> 的实现。</p><h4 id="3-2-3-buildDefaultBeanName的实现"><a href="#3-2-3-buildDefaultBeanName的实现" class="headerlink" title="3.2.3 buildDefaultBeanName的实现"></a>3.2.3 buildDefaultBeanName的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> buildDefaultBeanName(definition);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition)</span> </span>&#123;<br>    String beanClassName = definition.getBeanClassName();<br>    Assert.state(beanClassName != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;No bean class name set&quot;</span>);<br>    String shortClassName = ClassUtils.getShortName(beanClassName);<br>    <span class="hljs-keyword">return</span> Introspector.decapitalize(shortClassName);<br>&#125;<br></code></pre></td></tr></table></figure><p>一路走到最底下的方法中，它会根据组件类的全限定名，截取出短类名（如 <code>com.example.Person</code> → <code>Person</code> ），最后用一个叫 <code>Introspector</code> 的类，去生成 bean 的名称。那想必这个 <code>Introspector.decapitalize</code> 方法肯定就可以把类名的首字母转为小写咯，点进去发现确实如此：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decapitalize</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span> || name.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (name.length() &gt; <span class="hljs-number">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class="hljs-number">1</span>)) &amp;&amp;<br>        Character.isUpperCase(name.charAt(<span class="hljs-number">0</span>)))&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">char</span> chars[] = name.toCharArray();<br>    <span class="hljs-comment">// 第一个字母转小写</span><br>    chars[<span class="hljs-number">0</span>] = Character.toLowerCase(chars[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);<br>&#125;<br></code></pre></td></tr></table></figure><p>原理实现看完了，小伙伴们肯定有一个疑惑：<code>Introspector</code> 是个什么鬼哦？？</p><h4 id="3-2-4-Java的内省机制【扩展】"><a href="#3-2-4-Java的内省机制【扩展】" class="headerlink" title="3.2.4 Java的内省机制【扩展】"></a>3.2.4 Java的内省机制【扩展】</h4><p>说到这个<strong>内省</strong>，或许好多小伙伴都没听说过。其实<strong>它是 JavaSE 中就有的，对 JavaBean 中属性的默认处理规则</strong>。</p><p>回想一下咱写的所有模型类，包括 vo 类，是不是都是写好了属性，之后借助 IDE 生成 <code>getter</code> 和 <code>setter</code> ，或者借助 <code>Lombok</code> 的注解生成 <code>getter</code> 和 <code>setter</code> ？其实这个生成规则，就是利用了 Java 的内省机制。</p><p><strong>Java 的内省默认规定，所有属性的获取方法以 get 开头（ boolean 类型以 is 开头），属性的设置方法以 set 开头。</strong>根据这个规则，才有的默认的 getter 和 setter 方法。</p><p><code>Introspector</code> 类是 Java 内省机制中最核心的类之一，它可以进行很多默认规则的处理（包括获取类属性的 get / set 方法，添加方法描述等），当然它也可以处理这种类名转 beanName 的操作。SpringFramework 深知这个设计之妙，就直接利用过来了。</p><p>有关更多的 Java 内省机制，小伙伴们可以搜索相关资料学习，小册不多展开讲解了（这部分适当了解即可）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>组件扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09-IOC的条件装配</title>
    <link href="/2022/04/18/09-IOC%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D/"/>
    <url>/2022/04/18/09-IOC%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h1><p>上一章咱完整的学习了模块装配的核心使用方法，通过模块装配，咱可以通过一个注解，一次性导入指定场景中需要的组件和配置。那么只靠模块装配的内容，就可以把这些装配都考虑到位吗？</p><h2 id="1-模块装配考虑不到的地方"><a href="#1-模块装配考虑不到的地方" class="headerlink" title="1. 模块装配考虑不到的地方"></a>1. 模块装配考虑不到的地方</h2><p>还是拿上一章的酒馆为例。如果这套代码模拟的环境放到<strong>一片荒野</strong>，那这个时候可能吧台还在，老板还在，但是<strong>调酒师</strong>肯定就<strong>不干活了</strong>（荒郊野外哪来那些闲情雅致的人去喝酒呢），所以这个时候调酒师就不应该注册到 IOC 容器了。这种情况下，如果只是模块装配，那就没办法搞定了：只要配置类中声明了 <code>@Bean</code> 注解的方法，那这个方法的返回值就一定会被注册到 IOC 容器成为一个 Bean 。</p><p>所以，有没有办法解决这个问题呢？当然是有（不然咱这一章讲个啥呢），先来学习第一种方式：<strong>Profile</strong> 。</p><h2 id="2-Profile【掌握】"><a href="#2-Profile【掌握】" class="headerlink" title="2. Profile【掌握】"></a>2. Profile【掌握】</h2><p>SpringFramework 3.1 中就已经引入 Profile 的概念了，可它是什么意思呢？咱先了解一下。</p><h3 id="2-1-什么是Profile【理解】"><a href="#2-1-什么是Profile【理解】" class="headerlink" title="2.1 什么是Profile【理解】"></a>2.1 什么是Profile【理解】</h3><p>从字面上理解，并不能 get 到它真正的含义（外形？简介？概述？），实际上如果小伙伴借助词典查看网络翻译，profile 有“配置文件”的意思，倒不是说一个 profile 是一个配置文件，它更像是一个标识。最具权威的描述，自然还是去找官方文档和 javadoc 吧。</p><p>SpringFramework 的官方文档中并没有对 Profile 进行过多的描述，而是借助了一篇官网的博客来详细介绍 Profile 的使用：<a href="https://link.juejin.cn/?target=https://spring.io/blog/2011/02/14/spring-3-1-m1-introducing-profile/">spring.io/blog/2011/0…</a> ，咱这里的讲解也会参考这篇博客的内容。另外的，javadoc 中有对 <code>@Profile</code> 注解的介绍，这个介绍可以说是把 Profile 的设计思想介绍的很到位了：</p><blockquote><p>Indicates that a component is eligible for registration when one or more specified profiles are active. A profile is a named logical grouping that may be activated programmatically via ConfigurableEnvironment.setActiveProfiles or declaratively by setting the spring.profiles.active property as a JVM system property, as an environment variable, or as a Servlet context parameter in web.xml for web applications. Profiles may also be activated declaratively in integration tests via the @ActiveProfiles annotation.</p><p><code>@Profile</code> 注解可以标注一些组件，当应用上下文的一个或多个指定配置文件处于活动状态时，这些组件允许被注册。</p><p>配置文件是一个命名的逻辑组，可以通过 <code>ConfigurableEnvironment.setActiveProfiles</code> 以编程方式激活，也可以通过将 <code>spring.profiles.active</code> 属性设置为 JVM 系统属性，环境变量或 <code>web.xml</code> 中用于 Web 应用的 <code>ServletContext</code> 参数来声明性地激活，还可以通过 <code>@ActiveProfiles</code>注解在集成测试中声明性地激活配置文件。</p></blockquote><p>简单理解下这段文档注释的意思：<code>@Profile</code> 注解可以标注在组件上，当一个配置属性（并不是文件）激活时，它才会起作用，而激活这个属性的方式有很多种（启动参数、环境变量、<code>web.xml</code> 配置等）。</p><p>如果小伙伴看完这段话开始有点感觉了，那说明你可能已经知道它的作用了。说白了，profile 提供了一种可以理解成“<strong>基于环境的配置</strong>”：<strong>根据当前项目的运行时环境不同，可以动态的注册当前运行环境匹配的组件</strong>。</p><p>下面咱就上一章的场景，为酒馆添加外置的环境因素。</p><h3 id="2-2-Profile的使用【掌握】"><a href="#2-2-Profile的使用【掌握】" class="headerlink" title="2.2 @Profile的使用【掌握】"></a>2.2 @Profile的使用【掌握】</h3><blockquote><p>本小节源码位置：<code>com.example.spring.configuration.b_profile</code></p></blockquote><p>咱把上一章的代码原样复制一份，粘贴到上面所述的包中：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c6a1f3fb0594205829b7b4b9efeaaea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>下面咱开始改造。</p><h4 id="2-2-1-Bartender添加-Profile"><a href="#2-2-1-Bartender添加-Profile" class="headerlink" title="2.2.1 Bartender添加@Profile"></a>2.2.1 Bartender添加@Profile</h4><p>刚在上面说了，荒郊野外下，调酒师率先不干了，跑路了，此时调酒师就不会在荒郊野外的环境下存在，只会在城市存在。用代码来表达，就是在注册调酒师的配置类上标注 <code>@Profile</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Profile(&quot;city&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BartenderConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bartender <span class="hljs-title">zhangxiaosan</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bartender(<span class="hljs-string">&quot;张小三&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bartender <span class="hljs-title">zhangdasan</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bartender(<span class="hljs-string">&quot;张大三&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-编程式设置运行时环境"><a href="#2-2-2-编程式设置运行时环境" class="headerlink" title="2.2.2 编程式设置运行时环境"></a>2.2.2 编程式设置运行时环境</h4><p>如果现在直接运行 <code>TavernProfileApplication</code> 的 <code>main</code> 方法，控制台中不会打印 <code>zhangxiaosan</code> 和 <code>zhangdasan</code> ：（已省略一些内部的组件打印）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tavernConfiguration<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.b_profile</span><span class="hljs-selector-class">.component</span>.Boss<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.b_profile</span><span class="hljs-selector-class">.component</span>.Bar<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.b_profile</span><span class="hljs-selector-class">.config</span>.BarConfiguration<br>bbbar<br>waiter<br></code></pre></td></tr></table></figure><p>默认情况下，<code>ApplicationContext</code> 中的 profile 为 <strong>“default”</strong>，那上面 <code>@Profile(&quot;city&quot;)</code>不匹配，<code>BartenderConfiguration</code> 不会生效，那这两个调酒师也不会被注册到 IOC 容器中。要想让调酒师注册进 IOC 容器，就需要给 <code>ApplicationContext</code> 中设置一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(TavernConfiguration.class);<br>    <span class="hljs-comment">// 给ApplicationContext的环境设置正在激活的profile</span><br>    ctx.getEnvironment().setActiveProfiles(<span class="hljs-string">&quot;city&quot;</span>);<br>    Stream.of(ctx.getBeanDefinitionNames()).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，发现控制台还是只打印上面那些，两个调酒师还是没有被注册到 IOC 容器中。</p><p>这个时候可能有小伙伴要一脸问号了：我去你这不是逗我玩吗？你告诉我用 <code>setActiveProfiles</code> 激活，我好不容易写上，结果不好使？？？你在骗我吗？</p><p>不要着急嘛，这都是节目效果而已（狗头保命）。在生气之余，我希望小伙伴们能停下来思考一下：既然这样写不好使，但我又告诉你这么写，那是不是哪里出了问题呢？</p><p>结合前面对 <code>ApplicationContext</code> 的认识，是不是突然意识到了点什么？如果你还记得有个 <strong><code>refresh</code></strong> 方法的话，那这个地方就可以大胆猜测了：<strong>是不是在 <code>new AnnotationConfigApplicationContext</code> 的时候，如果传入了配置类，它内部就自动初始化完成了，那些 Bean 也就都创建好了？</strong></p><p>如果小伙伴能意识到这一点，说明对前面 <code>ApplicationContext</code> 的学习足够的认真了！（不记得的小伙伴可以回头看 15 章的 2.2.3 章节）</p><p>那应该怎么写才行呢？既然在构造方法中传入配置类就自动初始化完成了，那我不传呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br></code></pre></td></tr></table></figure><p>诶？这也不报错啊！那我先这样 new 一个空的呗？然后再设置 profile 是不是就好使了呢？赶紧来试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>    ctx.getEnvironment().setActiveProfiles(<span class="hljs-string">&quot;city&quot;</span>);<br>    ctx.register(TavernConfiguration.class);<br>    ctx.refresh();<br>    Stream.of(ctx.getBeanDefinitionNames()).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子一写，再重新运行 <code>main</code> 方法，果然控制台就打印 zhangxiaosan 和 zhangdasan 了！</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tavernConfiguration<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.b_profile</span><span class="hljs-selector-class">.component</span>.Boss<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.b_profile</span><span class="hljs-selector-class">.config</span>.BartenderConfiguration<br>zhangxiaosan<br>zhangdasan<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.b_profile</span><span class="hljs-selector-class">.component</span>.Bar<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.b_profile</span><span class="hljs-selector-class">.config</span>.BarConfiguration<br>bbbar<br>waiter<br></code></pre></td></tr></table></figure><blockquote><p>通过这个小小的曲折，作者在这里想表达的是，小伙伴在跟小册学习时最好跟着作者的思路来，这样小伙伴在学习时学到的可能就不仅仅是这个技术怎么用，而是带入自己的思考进去，能有更多的收获。(≖ᴗ≖)✧</p></blockquote><h4 id="2-2-3-声明式设置运行时环境"><a href="#2-2-3-声明式设置运行时环境" class="headerlink" title="2.2.3 声明式设置运行时环境"></a>2.2.3 声明式设置运行时环境</h4><p>上面编程式配置虽然可以用了，但仔细思考一下，这种方式似乎不实用吧！我都把 profile 硬编码在 .java 里了，那要是切换环境，我还得重新编译来，那图个啥呢？所以肯定还有更好的办法。上面的文档注释中也说了，它可以使用的方法很多，下面咱来演示最容易演示的一种：命令行参数配置。</p><p>测试命令行参数的环境变量，需要在 IDEA 中配置启动选项：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f672ef3d2526466fa74cb94d4cc682d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>这样配置好之后，在 <code>main</code> 方法中改回原来的构造方法传入配置类的形式，运行，控制台仍然会打印 zhangxiaosan 和 zhangdasan 。</p><p>修改传入的 jvm 参数，将 city 改成 <strong>wilderness</strong> ，重新运行 <code>main</code> 方法，发现控制台不再打印 zhangxiaosan 和 zhangdasan ，说明使用 jvm 命令行参数也可以控制 profile 。</p><p>除了 jvm 命令行参数，通过 web.xml 的方式也可以设置，不过咱还没有学习到集成 web 开发环境，所以这部分先放一放，后续讲 SpringWebMvc 时会提到它的。</p><h3 id="2-3-Profile在实际开发的用途【熟悉】"><a href="#2-3-Profile在实际开发的用途【熟悉】" class="headerlink" title="2.3 @Profile在实际开发的用途【熟悉】"></a>2.3 @Profile在实际开发的用途【熟悉】</h3><p>以数据源为例，在开发环境、测试环境、生产环境中，项目连接的数据库都是不一样的。如果每切换一个环境都要重新改一遍配置文件，那真的是太麻烦了，所以咱就可以采用 @Profile 的方式来解决。下面咱来模拟演示这种配置。</p><p>声明一个 <code>DataSourceConfiguration</code> 类，并一次性声明 3 个 <code>DataSource</code> ：（实际创建数据源的部分咱就不写了，还没学到 jdbc 部分不好剧透）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Profile(&quot;dev&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">devDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Profile(&quot;test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">testDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Profile(&quot;prod&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">prodDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写完之后，通过 <code>@PropertySource</code> 注解 + 外部配置文件，就可以做到<strong>只切换 profile 即可切换不同的数据源</strong>。</p><h3 id="2-4-profile控制不到的地方"><a href="#2-4-profile控制不到的地方" class="headerlink" title="2.4 profile控制不到的地方"></a>2.4 profile控制不到的地方</h3><p>profile 强大吗？当然很强大，但它还有一些无法控制的地方。下面咱把场景进一步复杂化：</p><p><strong>吧台应该是由老板安置好的，如果酒馆中连老板都没有，那吧台也不应该存在。</strong></p><p>这种情况下，用 profile 就不好使了：因为 <strong>profile 控制的是</strong>整个项目的运行<strong>环境</strong>，无法根据单个 Bean 的因素决定是否装配。也是因为这个问题，出现了第二种条件装配的方式：**<code>@Conditional</code> 注解**。</p><h2 id="3-Conditional【掌握】"><a href="#3-Conditional【掌握】" class="headerlink" title="3. Conditional【掌握】"></a>3. Conditional【掌握】</h2><p>看这个注解的名，condition ，很明显就是条件的意思啊，这也太直白明了了。按照惯例，咱先对 Conditional 有个清楚的认识。</p><h3 id="3-1-什么是Conditional【理解】"><a href="#3-1-什么是Conditional【理解】" class="headerlink" title="3.1 什么是Conditional【理解】"></a>3.1 什么是Conditional【理解】</h3><p><code>@Conditional</code> 是在 SpringFramework 4.0 版本正式推出的，它可以让 Bean 的装载基于一些指定的条件，换句话说，被标注 <code>@Conditional</code> 注解的 Bean 要注册到 IOC 容器时，必须全部满足 <code>@Conditional</code> 上指定的所有条件才可以。</p><p>在 SpringFramework 的官方文档中，并没有花什么篇幅介绍 <code>@Conditional</code> ，而是让咱们直接去看 javadoc ，不过有一说一，javadoc 里基本上把 <code>@Conditional</code> 的作用都描述明白了：</p><blockquote><p>Indicates that a component is only eligible for registration when all specified conditions match.</p><p>A condition is any state that can be determined programmatically before the bean definition is due to be registered (see Condition for details).</p><p>The @Conditional annotation may be used in any of the following ways:</p><ul><li>as a type-level annotation on any class directly or indirectly annotated with @Component, including @Configuration classes</li><li>as a meta-annotation, for the purpose of composing custom stereotype annotations</li><li>as a method-level annotation on any @Bean method</li></ul><p>If a @Configuration class is marked with @Conditional, all of the @Bean methods, @Import annotations, and @ComponentScan annotations associated with that class will be subject to the conditions.</p><p>被 <code>@Conditional</code> 注解标注的组件，只有所有指定条件都匹配时，才有资格注册。条件是可以在要注册 <code>BeanDefinition</code> 之前以编程式确定的任何状态。</p><p><code>@Conditional</code> 注解可以通过以下任何一种方式使用：</p><ul><li>作为任何直接或间接用 <code>@Component</code> 注解的类的类型级别注解，包括 <code>@Configuration</code> 类</li><li>作为元注解，目的是组成自定义注解</li><li>作为任何 <code>@Bean</code> 方法上的方法级注解</li></ul><p>如果 <code>@Configuration</code> 配置类被 <code>@Conditional</code> 标记，则与该类关联的所有 <code>@Bean</code>的工厂方法，<code>@Import</code> 注解和 <code>@ComponentScan</code> 注解也将受条件限制。</p></blockquote><p>简单理解下这段文档注释：<code>@Conditional</code> 注解可以指定匹配条件，而被 <code>@Conditional</code> 注解标注的 组件类 / 配置类 / 组件工厂方法 必须满足 <code>@Conditional</code> 中指定的所有条件，才会被创建 / 解析。</p><p>下面咱改造上面提到的场景，来体会 <code>@Conditional</code> 条件装配的实际使用。</p><h3 id="3-2-Conditional的使用【掌握】"><a href="#3-2-Conditional的使用【掌握】" class="headerlink" title="3.2 @Conditional的使用【掌握】"></a>3.2 @Conditional的使用【掌握】</h3><blockquote><p>本小节源码位置：<code>com.example.spring.configuration.c_conditional</code></p></blockquote><p>继续复制上面 <code>b_profile</code> 包下的所有代码，粘贴到上面所述的包中：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46ddda8da0274259a2ab6c52e3a12375~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>下面开始改造。</p><h4 id="3-2-1-Bar的创建要基于Boss"><a href="#3-2-1-Bar的创建要基于Boss" class="headerlink" title="3.2.1 Bar的创建要基于Boss"></a>3.2.1 Bar的创建要基于Boss</h4><p>在 <code>BarConfiguration</code> 的 Bar 注册中，要指定 Bar 的创建需要 Boss 的存在，反映到代码上就是在 bbbar 方法上标注 <code>@Conditional</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Conditional(???)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Bar <span class="hljs-title">bbbar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bar();<br>&#125;<br></code></pre></td></tr></table></figure><p>发现 <code>@Conditional</code> 注解中需要传入一个 <code>Condition</code> 接口的实现类数组，说明咱还需要编写条件匹配类做匹配依据。那咱就先写一个匹配条件：</p><h4 id="3-2-2-条件匹配规则类的编写"><a href="#3-2-2-条件匹配规则类的编写" class="headerlink" title="3.2.2 条件匹配规则类的编写"></a>3.2.2 条件匹配规则类的编写</h4><p>声明一个 <code>ExistBossCondition</code> 类，表示它用来判断 IOC 容器中是否存在 <code>Boss</code> 的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExistBossCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> context.getBeanFactory().containsBeanDefinition(Boss.class.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个地方用 <strong><code>BeanDefinition</code></strong> 做判断而不是 <strong>Bean</strong> ，考虑的是当条件匹配时，可能 <code>Boss</code> 还没被创建，导致条件匹配出现偏差。</p><p>然后，把这个 <code>ExistBossCondition</code> 规则类放入 <code>@Conditional</code> 注解中。</p><h4 id="3-2-3-测试运行"><a href="#3-2-3-测试运行" class="headerlink" title="3.2.3 测试运行"></a>3.2.3 测试运行</h4><p>运行启动类的 <code>main</code> 方法，发现吧台被成功创建：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tavernConfiguration<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.c_conditional</span><span class="hljs-selector-class">.component</span>.Boss<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.c_conditional</span><span class="hljs-selector-class">.component</span>.Bar<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.c_conditional</span><span class="hljs-selector-class">.config</span>.BarConfiguration<br>bbbar<br>waiter<br></code></pre></td></tr></table></figure><p>所以上面的 <code>@Conditional</code> 到底真的起作用了吗？咱把 <code>@EnableTavern</code> 中导入的 <code>Boss</code> 类去掉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;BartenderConfiguration.class, BarImportSelector.class, WaiterRegistrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTavern &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，发现 <code>Boss</code> 和 <code>bbbar</code> 都没了，说明 <code>@Conditional</code> 真的起作用了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tavernConfiguration<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.c_conditional</span><span class="hljs-selector-class">.component</span>.Bar<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.c_conditional</span><span class="hljs-selector-class">.config</span>.BarConfiguration<br>waiter<br></code></pre></td></tr></table></figure><h3 id="3-3-通用抽取【熟悉】"><a href="#3-3-通用抽取【熟悉】" class="headerlink" title="3.3 通用抽取【熟悉】"></a>3.3 通用抽取【熟悉】</h3><p>思考一个问题：如果一个项目中，有比较多的组件需要依赖另一些不同的组件，如果每个组件都写一个 <code>Condition</code> 条件，那工程量真的太大了。这个时候咱就要想想了：如果能把这个匹配的规则抽取为通用的方式，那岂不是让条件装配变得容易得多？抱着这个想法，咱来试着修改一下现有的代码。</p><h4 id="3-3-1-抽取传入的beanName"><a href="#3-3-1-抽取传入的beanName" class="headerlink" title="3.3.1 抽取传入的beanName"></a>3.3.1 抽取传入的beanName</h4><p>由于上面咱在文档注释中看到了 <code>@Conditional</code> 可以派生，那就来写一个新的注解吧：<code>@ConditionalOnBean</code> ，意为<strong>“存在指定的 Bean 时匹配”</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Conditional(OnBeanCondition.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ConditionalOnBean &#123;<br><br>    String[] beanNames() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>传入的 <code>Condition</code> 类型为自己声明的 <code>OnBeanCondition</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnBeanCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>        <span class="hljs-comment">// 先获取目标自定义注解ConditionalOnBean上的beanNames属性</span><br>        String[] beanNames = (String[]) metadata.getAnnotationAttributes(ConditionalOnBean.class.getName()).get(<span class="hljs-string">&quot;beanNames&quot;</span>);<br>        <span class="hljs-comment">// 逐个校验IOC容器中是否包含传入的bean名称</span><br>        <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>            <span class="hljs-keyword">if</span> (!context.getBeanFactory().containsBeanDefinition(beanName)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-替换上面的原生-Conditional注解"><a href="#3-3-2-替换上面的原生-Conditional注解" class="headerlink" title="3.3.2 替换上面的原生@Conditional注解"></a>3.3.2 替换上面的原生@Conditional注解</h4><p>在 <code>BarConfiguration</code> 中，将 <code>bbbar</code> 方法上的 <code>@Conditional(ExistBossCondition.class)</code> 去掉，换用 <code>@ConditionalOnBean</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(beanNames = &quot;com.example.spring.configuration.c_conditional.component.Boss&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Bar <span class="hljs-title">bbbar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bar();<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，发现 <code>bbbar</code> 依然没有创建（此时 <code>@EnableTavern</code> 中已经没有导入 Boss 类了），证明自定义注解已经生效。</p><h4 id="3-3-3-加入类型匹配"><a href="#3-3-3-加入类型匹配" class="headerlink" title="3.3.3 加入类型匹配"></a>3.3.3 加入类型匹配</h4><p>上面只能是抽取 <code>beanName</code> ，传整个类的全限定名真的很费劲。如果当前类路径下本来就有这个类，那直接写进去就好呀。我们希望代码最终改造成这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(Boss.class)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Bar <span class="hljs-title">bbbar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bar();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子多简洁啊，因为我已经有 <code>Boss</code> 类了，所以直接写进去就好嘛。那下面咱来改造这个效果。</p><p>给 <code>@ConditionalOnBean</code> 注解上添加默认的 <code>value</code> 属性，类型为 <code>Class[]</code> ，这样就可以传入类型了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Conditional(OnBeanCondition.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ConditionalOnBean &#123;<br>    <br>    Class&lt;?&gt;[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] beanNames() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，在 <code>OnBeanCondition</code> 中添加 <code>value</code> 的属性解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnBeanCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>        Map&lt;String, Object&gt; attributes = metadata.getAnnotationAttributes(ConditionalOnBean.class.getName());<br>        <span class="hljs-comment">// 匹配类型</span><br>        Class&lt;?&gt;[] classes = (Class&lt;?&gt;[]) attributes.get(<span class="hljs-string">&quot;value&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;<br>            <span class="hljs-keyword">if</span> (!context.getBeanFactory().containsBeanDefinition(clazz.getName())) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 匹配beanName</span><br>        String[] beanNames = (String[]) attributes.get(<span class="hljs-string">&quot;beanNames&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>            <span class="hljs-keyword">if</span> (!context.getBeanFactory().containsBeanDefinition(beanName)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就可以匹配 bean 的名称为默认的全限定名的情况了。</p><blockquote><p>最后多说一句，小伙伴们在自己动手练习这部分内容时不要过于纠结这里面的内容，其实咱写的这个 <code>@ConditionalOnBean</code> 是参考 SpringBoot 中的 <code>@ConditionalOnBean</code>注解，人家 SpringBoot 官方实现的功能更严密完善，后续你在项目中用到了 SpringBoot ，那这些 <code>@Conditional</code> 派生的注解尽情用就好。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>条件装配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08-IOC的模块装配</title>
    <link href="/2022/04/18/08-IOC%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A3%85%E9%85%8D/"/>
    <url>/2022/04/18/08-IOC%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A3%85%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="模块装配-EnableXxx"><a href="#模块装配-EnableXxx" class="headerlink" title="模块装配-EnableXxx"></a>模块装配-EnableXxx</h1><p>模块装配与条件装配的使用，这一部分相当重要，对于以后学习 SpringBoot 的核心<strong>自动装配</strong>有巨大的帮助（ <strong>SpringBoot 的自动装配，基础就是模块装配 + 条件装配</strong>），小伙伴们一定要好好学习这两章呀。</p><blockquote><p>如果小伙伴之前有学习或接触过 SSH 或者 SSM 的框架整合，应该还记得那些配置文件有多烦吧，又多又不好记真的很让人头大。在处理配置文件的同时，小伙伴是否有想过：如果能有一种方式，可以使用很少的配置，甚至不配置就可以完成一个功能的装载，那岂不是省了很多事？这个疑问在 SpringBoot 中得以解决，而这个解决的核心技术就是模块装配 + 条件装配。</p></blockquote><p>注：本章所有代码均使用<strong>注解驱动开发</strong>。</p><h2 id="1-原生手动装配【回顾】"><a href="#1-原生手动装配【回顾】" class="headerlink" title="1. 原生手动装配【回顾】"></a>1. 原生手动装配【回顾】</h2><p>在最原始的 SpringFramework 中，是不支持注解驱动开发的（当时最低支持版本是 1.3 、1.4 ），直到 SpringFramework 2.0 版本，才初步出现了模式注解（ <code>@Repository</code> ），到了 SpringFramework 2.5 出现了 <code>@Component</code> 和它的几个派生注解，到了 SpringFramework 3.0 才完全的支持注解驱动开发（当时最低支持版本已经升级到 1.5）。</p><p>使用 <code>@Configuration</code> + <code>@Bean</code> 注解组合，或者 <code>@Component</code> + <code>@ComponentScan</code> 注解组合，可以实现编程式 / 声明式的手动装配。这两种方式咱前面已经写过很多了，不再赘述。</p><p>不过，咱思考一个问题：如果使用这两种方式，如果要注册的 Bean 很多，要么一个一个的 <code>@Bean</code> 编程式写，要么就得选好包进行组件扫描，而且这种情况还得每个类都标注好 <code>@Component</code> 或者它的衍生注解才行。面对数量很多的 Bean ，这种装配方式很明显会比较麻烦，需要有一个新的解决方案。</p><h2 id="2-模块装配【掌握】"><a href="#2-模块装配【掌握】" class="headerlink" title="2. 模块装配【掌握】"></a>2. 模块装配【掌握】</h2><p>SpringFramework 3.0 的发布，全面支持了注解驱动开发，随之而来的就是快速方便的模块装配。在正式了解模块装配之前，咱先思考一个问题。</p><h3 id="2-1-什么是模块【理解】"><a href="#2-1-什么是模块【理解】" class="headerlink" title="2.1 什么是模块【理解】"></a>2.1 什么是模块【理解】</h3><p>通常理解下，模块可以理解成一个一个的可以<strong>分解</strong>、<strong>组合</strong>、<strong>更换</strong>的<strong>独立的单元</strong>，模块与模块之间可能存在一定的依赖，模块的内部通常是高内聚的，一个模块通常都是解决一个独立的问题（如引入事务模块是为了解决数据库操作的最终一致性）。其实按照这个理解来看，我们平时写的一个一个的功能，也可以看成一个个的模块；封装的一个个组件，可以看做是模块。</p><p>简单总结下，模块通常具有以下几个特征：</p><ul><li>独立的</li><li>功能高内聚</li><li>可相互依赖</li><li>目标明确</li></ul><h3 id="2-2-什么是模块装配【掌握】"><a href="#2-2-什么是模块装配【掌握】" class="headerlink" title="2.2 什么是模块装配【掌握】"></a>2.2 什么是模块装配【掌握】</h3><p>明确了模块的定义，下面就可以思考下一个问题了：什么是模块装配？</p><p>既然模块是功能单元，那模块装配，就可以理解为<strong>把一个模块需要的核心功能组件都装配好</strong>，当然如果能有尽可能简便的方式那最好。</p><h3 id="2-3-SpringFramework中的模块装配【了解】"><a href="#2-3-SpringFramework中的模块装配【了解】" class="headerlink" title="2.3 SpringFramework中的模块装配【了解】"></a>2.3 SpringFramework中的模块装配【了解】</h3><p>SpringFramework 中的模块装配，是在 <strong>3.1</strong> 之后引入大量 <strong><code>@EnableXXX</code></strong> 注解，来快速整合激活相对应的模块。</p><p>从现在 5.x 的官方文档中已经很难找到 <code>@EnableXXX</code> 的介绍了，小伙伴们可以回溯到 SpringFramework 3.1.0 的官方文档：</p><p><a href="https://link.juejin.cn/?target=https://docs.spring.io/spring/docs/3.1.0.RELEASE/reference/htmlsingle/">docs.spring.io/spring/docs…</a></p><p>在 3.1.5 节中，它有介绍 <code>@EnableXXX</code> 注解的使用，并且它还举了不少例子，这里面不乏有咱可能熟悉的：</p><ul><li><code>EnableTransactionManagement </code>：开启注解事务驱动</li><li><code>EnableWebMvc</code> ：激活 SpringWebMvc</li><li><code>EnableAspectJAutoProxy</code> ：开启注解 AOP 编程</li><li><code>EnableScheduling</code> ：开启调度功能（定时任务）</li></ul><p>这些内容，咱在后面的学习中都会慢慢遇到的，小伙伴们没有必要现在就搞明白这些注解都是干嘛用的，一步一个脚印学习就好。</p><p>下面，咱先来体会一下最简单的模块装配。</p><h3 id="2-4-快速体会模块装配【掌握】"><a href="#2-4-快速体会模块装配【掌握】" class="headerlink" title="2.4 快速体会模块装配【掌握】"></a>2.4 快速体会模块装配【掌握】</h3><p>先记住使用模块装配的核心原则：<strong>自定义注解 + <code>@Import</code> 导入组件。</strong></p><h4 id="2-4-1-模块装配场景概述"><a href="#2-4-1-模块装配场景概述" class="headerlink" title="2.4.1 模块装配场景概述"></a>2.4.1 模块装配场景概述</h4><p>下面咱构建一个场景：使用代码模拟构建出一个<strong>酒馆</strong>，酒馆里得有<strong>吧台</strong>，得有<strong>调酒师</strong>，得有<strong>服务员</strong>，还得有<strong>老板</strong>。这里面具体的设计咱不过多深入，小伙伴自己练习时可以自由发挥。</p><p>在这个场景中，<code>ApplicationContext</code> 看作一个酒馆，酒馆里的吧台、调酒师、服务员、老板，这些元素统统看作一个一个的<strong>组件</strong>。咱用代码模拟实现的最终目的，是可以<strong>通过一个注解，同时把这些元素都填充到酒馆中</strong>。</p><p>目的明确了，下面就开始动手吧。一开始咱先实现最简单的装配方式。</p><h4 id="2-4-2-声明自定义注解"><a href="#2-4-2-声明自定义注解" class="headerlink" title="2.4.2 声明自定义注解"></a>2.4.2 声明自定义注解</h4><p>既然是酒馆，那咱仿照着 SpringFramework 的写法，咱就来一个 <strong><code>@EnableTavern</code></strong> 吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTavern &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意注解上面要标注三个元注解，代表它在运行时起效，并且只能标注在类上。</p><p>还没完事，模块装配需要一个最核心的注解是 <strong><code>@Import</code></strong> ，它要标注在 <code>@EnableTavern</code> 上。不过这个 <code>@Import</code> 中需要传入 <code>value</code> 值，点开看一眼它的源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Import &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Configuration <span class="hljs-doctag">@Configuration</span>&#125;, &#123;<span class="hljs-doctag">@link</span> ImportSelector&#125;,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span><br><span class="hljs-comment"> */</span><br>Class&lt;?&gt;[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>看，文档注释已经写得非常明白了：它可以导入</p><ol><li><strong>配置类</strong>；</li><li><strong><code>ImportSelector</code> 的实现类</strong>；</li><li><strong><code>ImportBeanDefinitionRegistrar</code> 的实现类</strong>；</li><li>或者<strong>普通类</strong>。</li></ol><p>咱这里先来快速上手，所以咱先选择使用<strong>普通类</strong>导入。</p><h4 id="2-4-3-声明老板类"><a href="#2-4-3-声明老板类" class="headerlink" title="2.4.3 声明老板类"></a>2.4.3 声明老板类</h4><p>既然先导入普通类，那咱就来整一个老板的类吧，毕竟酒馆必须有老板经营才是呀！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boss</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>没了，这点代码就够了，连 <code>@Component</code> 注解都不用标注。</p><p>然后！咱在上面 <code>@EnableTavern</code> 的 <code>@Import</code> 注解中，填入 Boss 的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Import(Boss.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTavern &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这样就代表，如果<strong>标注了 <code>@EnableTavern</code> 注解，就会触发 <code>@Import</code> 的效果，向容器中导入一个 <code>Boss</code> 类型的 Bean</strong> 。</p><h4 id="2-4-4-创建配置类"><a href="#2-4-4-创建配置类" class="headerlink" title="2.4.4 创建配置类"></a>2.4.4 创建配置类</h4><p>注解驱动，自然少不了配置类。咱声明一个 <code>TavernConfiguration</code> 的配置类，并在类上标注 <code>@Configuration</code> 和 <code>@EnableTavern</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableTavern</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TavernConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>配置类中什么都不用写，只要标注好注解即可。</p><h4 id="2-4-5-编写启动类测试"><a href="#2-4-5-编写启动类测试" class="headerlink" title="2.4.5 编写启动类测试"></a>2.4.5 编写启动类测试</h4><p>下面就可以编写启动类测试装配的效果了，咱新建一个 <code>TavernApplication</code> ，并用刚写的 <code>TavernConfiguration</code> 驱动初始化 IOC 容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TavernApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(TavernConfiguration.class);<br>        Boss boss = ctx.getBean(Boss.class);<br>        System.out.println(boss);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，可以发现使用 <code>getBean</code> 能够正常取到 <code>Boss</code> 的对象，说明 <code>Boss</code> 类已经被注册到 IOC 容器生成了一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">com.example.spring.configuration.a_module.component.Boss<span class="hljs-meta">@b9afc07</span><br></code></pre></td></tr></table></figure><p>这样我们就完成了最简单的模块装配。</p><p>这个时候可能有小伙伴开始不耐烦了：我去原本我可以用 <code>@Configuration</code> + <code>@Bean</code> 就能完事的，你非得给我整这么一堆，这不是<strong>徒增功耗</strong>吗？别着急，往上翻一翻 <code>@Import</code> 可以传入的东西，是不是发现普通类是最简单的呀？下面咱就来学习剩下几种更复杂的方式。</p><h3 id="2-5-模块装配的四种方式【掌握】"><a href="#2-5-模块装配的四种方式【掌握】" class="headerlink" title="2.5 模块装配的四种方式【掌握】"></a>2.5 模块装配的四种方式【掌握】</h3><h4 id="2-5-1-导入普通类"><a href="#2-5-1-导入普通类" class="headerlink" title="2.5.1 导入普通类"></a>2.5.1 导入普通类</h4><p>上面的方式就是导入普通类。</p><h4 id="2-5-2-导入配置类"><a href="#2-5-2-导入配置类" class="headerlink" title="2.5.2 导入配置类"></a>2.5.2 导入配置类</h4><p>如果需要直接导入一些现有的配置类，使用 <code>@Import</code> 也可以直接加载进来。下面咱来把调酒师搞定。</p><h5 id="2-5-2-1-声明调酒师类"><a href="#2-5-2-1-声明调酒师类" class="headerlink" title="2.5.2.1 声明调酒师类"></a>2.5.2.1 声明调酒师类</h5><p>调酒师的模型，咱加一个 <strong><code>name</code></strong> 的属性吧，暗示着咱要搞不止一个调酒师咯：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bartender</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bartender</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-2-2-注册调酒师的对象"><a href="#2-5-2-2-注册调酒师的对象" class="headerlink" title="2.5.2.2 注册调酒师的对象"></a>2.5.2.2 注册调酒师的对象</h5><p>如果要注册多个相同类型的 Bean ，现在咱能想到的办法就是通过配置类了。下面咱编写一个 <code>BartenderConfiguration</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BartenderConfiguration</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bartender <span class="hljs-title">zhangxiaosan</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bartender(<span class="hljs-string">&quot;张小三&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bartender <span class="hljs-title">zhangdasan</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bartender(<span class="hljs-string">&quot;张大三&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意哦，如果小伙伴用 <strong>IDEA</strong> 开发的话，此时这个类会报黄，提示这个配置类还没有被用到过，事实上也确实是这样，咱在驱动 IOC 容器初始化时，用的是只传入一个配置类的方式，所以它肯定不会用到。那想让它起作用，只需要在 <code>@EnableTavern</code> 的 <code>@Import</code> 中把这个配置类加上即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Boss.class, BartenderConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTavern &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意这里有一个小细节，有小伙伴在学习的时候，启动类里或者配置类上用了<strong>包扫描</strong>，恰好把这个类扫描到了，导致即使没有 <code>@Import</code> 这个 <code>BartenderConfiguration</code>，<code>Bartender</code> 调酒师也被注册进 IOC 容器了。</p><p>这里一定要细心哈，包扫描本身就会扫描配置类，并且让其生效的。如果既想用包扫描，又不想扫到这个类，很简单，把这些配置类拿到别的包里，让包扫描找不到它就好啦。</p></blockquote><h5 id="2-5-2-3-测试运行"><a href="#2-5-2-3-测试运行" class="headerlink" title="2.5.2.3 测试运行"></a>2.5.2.3 测试运行</h5><p>修改启动类，使用 <code>ApplicationContext</code> 的 <code>getBeansOfType</code> 方法可以一次性取出 IOC 容器指定类型的所有 Bean ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(TavernConfiguration.class);<br>    Stream.of(ctx.getBeanDefinitionNames()).forEach(System.out::println);<br>    System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);<br>    Map&lt;String, Bartender&gt; bartenders = ctx.getBeansOfType(Bartender.class);<br>    bartenders.forEach((name, bartender) -&gt; System.out.println(bartender));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，可以发现控制台有打印出两个调酒师：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalConfigurationAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalAutowiredAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalCommonAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerFactory<br>tavernConfiguration<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.component</span>.Boss<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.config</span>.BartenderConfiguration<br>zhangxiaosan<br>zhangdasan<br>--------------------------<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.component</span>.Bartender@<span class="hljs-number">23</span>bb8443<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.component</span>.Bartender@<span class="hljs-number">1176</span>dcec<br></code></pre></td></tr></table></figure><p>注意里面一个小细节，<code>BartenderConfiguration</code> 配置类也被注册到 IOC 容器成为一个 Bean 了。</p><h4 id="2-5-3-导入ImportSelector"><a href="#2-5-3-导入ImportSelector" class="headerlink" title="2.5.3 导入ImportSelector"></a>2.5.3 导入ImportSelector</h4><p>借助 IDE 打开 <code>ImportSelector</code> ，会发现它是一个<strong>接口</strong>，它的功能可以从文档注释中读到一些信息：</p><blockquote><p>Interface to be implemented by types that determine which @Configuration class(es) should be imported based on a given selection criteria, usually one or more annotation attributes.</p><p>它是一个接口，它的实现类可以根据指定的筛选标准（通常是一个或者多个注解）来决定导入哪些配置类。</p></blockquote><p>文档注释中想表达的是可以导入配置类，但其实 <code>ImportSelector</code> 也可以导入普通类。下面咱先演示如何使用。</p><h5 id="2-5-3-1-声明吧台类"><a href="#2-5-3-1-声明吧台类" class="headerlink" title="2.5.3.1 声明吧台类"></a>2.5.3.1 声明吧台类</h5><p>吧台的模型类咱就不搞花里胡哨了，最简单的类模型即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-3-2-声明注册吧台的配置类"><a href="#2-5-3-2-声明注册吧台的配置类" class="headerlink" title="2.5.3.2 声明注册吧台的配置类"></a>2.5.3.2 声明注册吧台的配置类</h5><p>咱为了说明 <code>ImportSelector</code> 不止可以导入配置类，也可以导入普通类，所以这里咱也造一个配置类，来演示两种类型皆可的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BarConfiguration</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bar <span class="hljs-title">bbbar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bar();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-3-3-编写ImportSelector的实现类"><a href="#2-5-3-3-编写ImportSelector的实现类" class="headerlink" title="2.5.3.3 编写ImportSelector的实现类"></a>2.5.3.3 编写ImportSelector的实现类</h5><p>咱编写一个 <code>BarImportSelector</code> ，来实现 <code>ImportSelector</code> 接口，实现 <code>selectImports</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BarImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，<code>selectImports</code> 方法的返回值是一个 String 类型的数组，它这样设计的目的是什么呢？咱来看看 selectImports 方法的文档注释：</p><blockquote><p>Select and return the names of which class(es) should be imported based on the AnnotationMetadata of the importing @Configuration class.</p><p>根据导入的 <code>@Configuration</code> 类的 <code>AnnotationMetadata</code> 选择并返回要导入的类的类名。</p></blockquote><p>哦，合着它要的是一组类名呀，自然肯定是<strong>全限定类名</strong>咯（没有全限定类名没办法定位具体的类）。那既然这样，咱就在这里面把上面的 <code>Bar</code> 和 <code>BarConfiguration</code> 的类名写进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[] &#123;Bar.class.getName(), BarConfiguration.class.getName()&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，把 <code>@EnableTavern</code> 的 <code>@Import</code> 中把这个 <code>BarImportSelector</code> 导入进去即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Boss.class, BartenderConfiguration.class, BarImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTavern &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-3-4-测试运行"><a href="#2-5-3-4-测试运行" class="headerlink" title="2.5.3.4 测试运行"></a>2.5.3.4 测试运行</h5><p>修改启动类的 <code>main</code> 方法，这次只打印 IOC 容器中所有 bean 的 name 吧（主要是 bean 真的越来越多了）。运行 <code>main</code> 方法，控制台会打印出两个 <code>Bar</code> （倒数第 1 行和第 3 行），说明 <code>ImportSelector</code> 可以导入普通类和配置类：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalConfigurationAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalAutowiredAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalCommonAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerFactory<br>tavernConfiguration<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.component</span>.Boss<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.config</span>.BartenderConfiguration<br>zhangxiaosan<br>zhangdasan<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.component</span>.Bar<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.config</span>.BarConfiguration<br>bbbar<br></code></pre></td></tr></table></figure><p>另外注意一点，<code>BarImportSelector</code> 本身没有注册到 IOC 容器哦。</p><h4 id="2-5-4-导入ImportBeanDefinitionRegistrar"><a href="#2-5-4-导入ImportBeanDefinitionRegistrar" class="headerlink" title="2.5.4 导入ImportBeanDefinitionRegistrar"></a>2.5.4 导入ImportBeanDefinitionRegistrar</h4><p>如果说 <code>ImportSelector</code> 更像声明式导入的话，那 <code>ImportBeanDefinitionRegistrar</code> 就可以解释为编程式向 IOC 容器中导入 Bean 。不过由于它导入的实际是 <code>BeanDefinition</code> （ Bean 的定义信息），这部分咱还没有接触到，就先不展开大篇幅解释了（如果要解释，那可真的是大篇幅的）。咱先对 <code>ImportBeanDefinitionRegistrar</code> 有一个快速的使用入门即可，后面在讲到 IOC 高级和原理部分，会回过头来详细解析 <code>ImportBeanDefinitionRegistrar</code>的使用和原理。</p><h5 id="2-5-4-1-声明服务员类"><a href="#2-5-4-1-声明服务员类" class="headerlink" title="2.5.4.1 声明服务员类"></a>2.5.4.1 声明服务员类</h5><p>离最后的酒馆只剩服务员了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waiter</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里就先不把服务员的模型类搞得很复杂了，咱的目的是学会模块装配，而不是搞 <code>BeanDefinition</code> 的复杂操作。</p></blockquote><h5 id="2-5-4-2-编写ImportBeanDefinitionRegistrar的实现类"><a href="#2-5-4-2-编写ImportBeanDefinitionRegistrar的实现类" class="headerlink" title="2.5.4.2 编写ImportBeanDefinitionRegistrar的实现类"></a>2.5.4.2 编写ImportBeanDefinitionRegistrar的实现类</h5><p>咱编写一个 <code>WaiterRegistrar</code> ，实现 <code>ImportBeanDefinitionRegistrar</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaiterRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;waiter&quot;</span>, <span class="hljs-keyword">new</span> RootBeanDefinition(Waiter.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的写法小伙伴们先不要过度纠结，跟着写就完事了。简单解释下，这个 <code>registerBeanDefinition</code> 方法传入的两个参数，第一个参数是 Bean 的名称（id），第二个参数中传入的 <code>RootBeanDefinition</code> 要指定 Bean 的字节码（ <strong><code>.class</code></strong> ）。</p><p>最后，把 <code>WaiterRegistrar</code> 标注在 <code>@EnableTavern</code> 的 <code>@Import</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Boss.class, BartenderConfiguration.class, BarImportSelector.class, WaiterRegistrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTavern &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-4-3-测试运行"><a href="#2-5-4-3-测试运行" class="headerlink" title="2.5.4.3 测试运行"></a>2.5.4.3 测试运行</h5><p>直接重新运行 <code>main</code> 方法，控制台可以打印出服务员（最后一行）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalConfigurationAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalAutowiredAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.annotation</span>.internalCommonAnnotationProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerProcessor<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span>.internalEventListenerFactory<br>tavernConfiguration<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.component</span>.Boss<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.config</span>.BartenderConfiguration<br>zhangxiaosan<br>zhangdasan<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.component</span>.Bar<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.configuration</span><span class="hljs-selector-class">.a_module</span><span class="hljs-selector-class">.config</span>.BarConfiguration<br>bbbar<br>waiter<br></code></pre></td></tr></table></figure><p>注意这里 <code>WaiterRegistrar</code> 也没有注册到 IOC 容器中。</p><p>到这里，<code>@Import</code> 的四种导入的方式也就全部过了一遍，<strong>模块装配</strong>说白了<strong>就是这四种方式的综合使用</strong>。</p><blockquote><p>学完这几种方式后，可能小伙伴对模块装配的概念和重要性不是很能感知到，没有关系，后面咱学到 AOP 、事务等章节时，会以这些模块的激活，了解一下模块装配在 SpringFramework 内部的体现。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>模块装配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07-IOC的事件监听机制</title>
    <link href="/2022/04/18/07-IOC%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/04/18/07-IOC%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件机制-amp-监听器"><a href="#事件机制-amp-监听器" class="headerlink" title="事件机制&amp;监听器"></a>事件机制&amp;监听器</h1><p>事件和监听器，最先想到的估计就是观察者模式了吧。下面咱先快速回顾一下观察者模式。</p><h2 id="1-观察者模式【回顾】"><a href="#1-观察者模式【回顾】" class="headerlink" title="1. 观察者模式【回顾】"></a>1. 观察者模式【回顾】</h2><p><strong>观察者模式</strong>，也被称为<strong>发布订阅模式</strong>，也有的人叫它“监听器模式”，它是 GoF23 设计模式中行为型模式的其中之一。</p><p>观察者模式关注的点是某一个对象被修改 / 做出某些反应 / 发布一个信息等，会自动通知依赖它的对象（订阅者）。</p><p>观察者模式的三大核心是：<strong>观察者、被观察主题、订阅者</strong>。观察者（ Observer ）需要绑定要通知的订阅者（ Subscriber ），并且要观察指定的主题（ Subject ）。</p><h2 id="2-SpringFramework中设计的观察者模式【掌握】"><a href="#2-SpringFramework中设计的观察者模式【掌握】" class="headerlink" title="2. SpringFramework中设计的观察者模式【掌握】"></a>2. SpringFramework中设计的观察者模式【掌握】</h2><p>SpringFramework 中，体现观察者模式的特性就是事件驱动和监听器。</p><ul><li><strong>监听器</strong>充当<strong>订阅者</strong>，监听特定的事件；</li><li><strong>事件源</strong>充当<strong>被观察的主题</strong>，用来发布事件；</li><li><strong>IOC 容器</strong>本身也是事件广播器，可以理解成<strong>观察者</strong>。</li></ul><p>不过我个人比较喜欢把 SpringFramework 的事件驱动核心概念划分为 4 个：<strong>事件源、事件、广播器、监听器</strong>。</p><ul><li><strong>事件源：发布事件的对象</strong></li><li><strong>事件：事件源发布的信息 / 作出的动作</strong></li><li>广播器：事件真正广播给监听器的对象【即<code>ApplicationContext</code>】<ul><li><code>ApplicationContext</code> 接口有实现 <code>ApplicationEventPublisher</code> 接口，具备<strong>事件广播器的发布事件的能力</strong></li><li><code>ApplicationEventMulticaster</code> 组合了所有的监听器，具备<strong>事件广播器的广播事件的能力</strong></li></ul></li><li><strong>监听器：监听事件的对象</strong></li></ul><p>也许这样理解起来会更容易一些：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2d55f5256e448248c39e00482fa4396~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h2 id="3-快速体会事件与监听器【掌握】"><a href="#3-快速体会事件与监听器【掌握】" class="headerlink" title="3. 快速体会事件与监听器【掌握】"></a>3. 快速体会事件与监听器【掌握】</h2><p>下面咱先通过一个最简单的实例来体会 SpringFramework 中监听器的使用。</p><h3 id="3-1-编写监听器"><a href="#3-1-编写监听器" class="headerlink" title="3.1 编写监听器"></a>3.1 编写监听器</h3><p>SpringFramework 中内置的监听器接口是 <code>ApplicationListener</code> ，它还带了一个泛型，代表要监听的具体事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">EventListener</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(E event)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要自定义监听器，只需要实现这个 <code>ApplicationListener</code> 接口即可。</p><p>为快速体会事件和监听器的功能，下面咱先介绍两个事件：<code>ContextRefreshedEvent</code> 和 <code>ContextClosedEvent</code> ，它们分别代表<strong>容器刷新完毕</strong>和<strong>即将关闭</strong>。</p><p>下面咱编写一个监听器，来监听 <code>ContextRefreshedEvent</code> 事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextRefreshedApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ContextRefreshedEvent</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ContextRefreshedApplicationListener监听到ContextRefreshedEvent事件！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记得用 <code>@Component</code> 注解标注监听器哦，一会要进行包扫描的。监听器必须要注册到 SpringFramework 的 IOC 容器才可以生效。</p><h3 id="3-2-编写启动类"><a href="#3-2-编写启动类" class="headerlink" title="3.2 编写启动类"></a>3.2 编写启动类</h3><p>写好监听器，就可以编写启动类，驱动 IOC 容器来测试效果了。这个时候可能有小伙伴有点懵：我去，我思想工作还没建设好呢，这就完事了？然而真的就是这么回事，下面代码一写你就恍然大悟了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickstartListenerApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;准备初始化IOC容器。。。&quot;</span>);<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.example.spring.event.a_quickstart&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;IOC容器初始化完成。。。&quot;</span>);<br>        ctx.close();<br>        System.out.println(<span class="hljs-string">&quot;IOC容器关闭。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>哈哈，不会真的有小伙伴忘了 <code>AnnotationConfigApplicationContext</code> 可以直接传包扫描路径吧，不会吧不会吧！（狗头保命）</p><p>运行 <code>main</code> 方法，控制台会根据流程依次打印如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">准备初始化IOC容器。。。<br>ContextRefreshedApplicationListener监听到ContextRefreshedEvent事件！<br>IOC容器初始化完成。。。<br>IOC容器关闭。。。<br></code></pre></td></tr></table></figure><h3 id="3-3-注解式监听器"><a href="#3-3-注解式监听器" class="headerlink" title="3.3 注解式监听器"></a>3.3 注解式监听器</h3><p>除了实现 <code>ApplicationListener</code> 接口之外，还可以使用注解的形式注册监听器。</p><p>使用注解式监听器，组件不再需要实现任何接口，而是直接在需要作出事件反应的方法上标注 <code>@EventListener</code> 注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextClosedApplicationListener</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onContextClosedEvent</span><span class="hljs-params">(ContextClosedEvent event)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ContextClosedApplicationListener监听到ContextClosedEvent事件！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>QuickstartListenerApplication</code> 的 <code>main</code> 方法，控制台可以打印出 <code>ContextClosedApplicationListener</code> 监听事件的反应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">准备初始化IOC容器。。。<br>ContextRefreshedApplicationListener监听到ContextRefreshedEvent事件！<br>IOC容器初始化完成。。。<br>ContextClosedApplicationListener监听到ContextClosedEvent事件！<br>IOC容器关闭。。。<br></code></pre></td></tr></table></figure><p>由这两种监听器的 Demo ，可以得出几个结论：</p><ul><li><code>ApplicationListener</code> 会在容器初始化阶段就准备好，在容器销毁时一起销毁；</li><li><code>ApplicationListener</code> 也是 IOC 容器中的普通 Bean ；</li><li>IOC 容器中有内置的一些事件供我们监听。</li></ul><h2 id="4-SpringFramework中的内置事件【熟悉】"><a href="#4-SpringFramework中的内置事件【熟悉】" class="headerlink" title="4. SpringFramework中的内置事件【熟悉】"></a>4. SpringFramework中的内置事件【熟悉】</h2><p>在 SpringFramework 中，已经有事件的默认抽象，以及 4 个默认的内置事件了，下面咱了解一下它们。</p><h3 id="4-1-ApplicationEvent"><a href="#4-1-ApplicationEvent" class="headerlink" title="4.1 ApplicationEvent"></a>4.1 ApplicationEvent</h3><p>很明显，它是事件模型的抽象，它是一个抽象类，里面也没有定义什么东西，只有事件发生时的时间戳。值得关注的是，它是继承自 jdk 原生的观察者模式的事件模型，并且把它声明为抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventObject</span></span><br></code></pre></td></tr></table></figure><p>关于这个设计，它的文档注释就已经说明了：</p><blockquote><p>Class to be extended by all application events. Abstract as it doesn’t make sense for generic events to be published directly.</p><p>由所有应用程序事件扩展的类。它被设计为抽象的，因为<strong>直接发布一般事件没有意义</strong>。</p></blockquote><p>如果说只是有这么一个派生，那看上去没什么太大的意义，所以 SpringFramework 中又给这个 ApplicationEvent 进行了一次扩展。</p><h3 id="4-2-ApplicationContextEvent"><a href="#4-2-ApplicationContextEvent" class="headerlink" title="4.2 ApplicationContextEvent"></a>4.2 ApplicationContextEvent</h3><p>先看一眼源码，从这里面或许就能意识到什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span>&#123;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApplicationContextEvent</span><span class="hljs-params">(ApplicationContext source)</span> </span>&#123;<br><span class="hljs-keyword">super</span>(source);<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ApplicationContext <span class="hljs-title">getApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> (ApplicationContext) getSource();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它在构造时，会把 IOC 容器一起传进去，这意味着事件发生时，可以<strong>通过监听器直接取到 <code>ApplicationContext</code> 而不需要做额外的操作</strong>，这才是 SpringFramework 中事件模型扩展最值得的地方。下面列举的几个内置的事件，都是基于这个 <code>ApplicationContextEvent</code> 扩展的。</p><h3 id="4-3-ContextRefreshedEvent-amp-ContextClosedEvent"><a href="#4-3-ContextRefreshedEvent-amp-ContextClosedEvent" class="headerlink" title="4.3 ContextRefreshedEvent &amp; ContextClosedEvent"></a>4.3 ContextRefreshedEvent &amp; ContextClosedEvent</h3><p>这两个是一对，分别对应着 <strong>IOC 容器刷新完毕但尚未启动</strong>，以及 <strong>IOC 容器已经关闭但尚未销毁所有 Bean</strong> 。这个时机可能记起来有点小困难，小伙伴们可以不用记很多，只通过字面意思能知道就 OK ，至于这些事件触发的真正时机，在我的 SpringBoot 源码小册第 16 章中有提到，感兴趣的小伙伴可以去看一看。在后面的 IOC 原理篇中，这部分也会略有涉及。</p><h3 id="4-4-ContextStartedEvent-amp-ContextStoppedEvent"><a href="#4-4-ContextStartedEvent-amp-ContextStoppedEvent" class="headerlink" title="4.4 ContextStartedEvent &amp; ContextStoppedEvent"></a>4.4 ContextStartedEvent &amp; ContextStoppedEvent</h3><p><code>ContextRefreshedEvent</code> 事件的触发是所有<strong>单实例 Bean 刚创建完成后</strong>，就发布的事件，此时那些实现了 <code>Lifecycle</code> 接口的 Bean 还没有被回调 <code>start</code> 方法。</p><p>当这些 <code>start</code> 方法被调用后，<code>ContextStartedEvent</code> 才会被触发。同样的，<code>ContextStoppedEvent</code> 事件也是在 <code>ContextClosedEvent</code> 触发之后才会触发，此时单实例 Bean 还没有被销毁，要先把它们都停掉才可以释放资源，销毁 Bean 。</p><h2 id="5-自定义事件开发【熟悉】"><a href="#5-自定义事件开发【熟悉】" class="headerlink" title="5. 自定义事件开发【熟悉】"></a>5. 自定义事件开发【熟悉】</h2><p>上面咱了解了 SpringFramework 中内置的事件，如果我们想自己在合适的时机发布一些事件，让指定的监听器来以此作出反应，执行特定的逻辑，那就需要自定义事件了。下面咱模拟一个场景，来体会自定义事件的开发过程。</p><p>本节可能会使人产生不适感，请做好心理准备再继续往下阅读 <strong>-.-</strong></p><h3 id="5-1-场景概述"><a href="#5-1-场景概述" class="headerlink" title="5.1 场景概述"></a>5.1 场景概述</h3><p>论坛应用，当新用户注册成功后，会同时发送短信、邮件、站内信，通知用户注册成功，并且发放积分。</p><p>在这个场景中，用户注册成功后，广播一个“用户注册成功”的事件，将用户信息带入事件广播出去，发送短信、邮件、站内信的监听器监听到注册成功的事件后，会分别执行不同形式的通知动作。</p><h3 id="5-2-自定义用户注册成功事件"><a href="#5-2-自定义用户注册成功事件" class="headerlink" title="5.2 自定义用户注册成功事件"></a>5.2 自定义用户注册成功事件</h3><p>SpringFramework 中的自定义事件的方式就是通过继承 <code>ApplicationEvent</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注册成功的事件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterSuccessEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RegisterSuccessEvent</span><span class="hljs-params">(Object source)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-编写监听器"><a href="#5-3-编写监听器" class="headerlink" title="5.3 编写监听器"></a>5.3 编写监听器</h3><p>使用上述的两种方式，分别编写发送短信、发送邮件，和发送站内信的监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsSenderListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">RegisterSuccessEvent</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(RegisterSuccessEvent event)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;监听到用户注册成功，发送短信。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailSenderListener</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRegisterSuccess</span><span class="hljs-params">(RegisterSuccessEvent event)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;监听到用户注册成功！发送邮件中。。。&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSenderListener</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRegisterSuccess</span><span class="hljs-params">(RegisterSuccessEvent event)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;监听到用户注册成功，发送站内信。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-编写注册逻辑业务层"><a href="#5-4-编写注册逻辑业务层" class="headerlink" title="5.4 编写注册逻辑业务层"></a>5.4 编写注册逻辑业务层</h3><p>只有事件和监听器还不够，还需要有一个事件源来持有事件发布器，在应用上下文中发布事件。</p><p>Service 层中，需要注入 <code>ApplicationEventPublisher</code> 来发布事件，此处选择使用回调注入的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationEventPublisherAware</span> </span>&#123;<br>    <br>    ApplicationEventPublisher publisher;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-comment">// 用户注册的动作。。。</span><br>        System.out.println(username + <span class="hljs-string">&quot;注册成功。。。&quot;</span>);<br>        <span class="hljs-comment">// 发布事件</span><br>        publisher.publishEvent(<span class="hljs-keyword">new</span> RegisterSuccessEvent(username));<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher publisher)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.publisher = publisher;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-编写测试启动类"><a href="#5-5-编写测试启动类" class="headerlink" title="5.5 编写测试启动类"></a>5.5 编写测试启动类</h3><p>测试代码都准备好了，下面咱就来写一把启动类，模拟一次用户注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterEventApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                <span class="hljs-string">&quot;com.example.spring.event.b_registerevent&quot;</span>);<br>        RegisterService registerService = ctx.getBean(RegisterService.class);<br>        registerService.register(<span class="hljs-string">&quot;张大三&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台打印出注册动作，以及监听器的触发反应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">张大三注册成功。。。<br>监听到用户注册成功，发送邮件中。。。<br>监听到用户注册成功，发送站内信。。。<br>监听到用户注册成功，发送短信。。。<br></code></pre></td></tr></table></figure><p>由此又得出来另外一个结论：<strong>注解式监听器的触发时机比接口式监听器早</strong>。</p><h3 id="5-6-调整监听器的触发顺序"><a href="#5-6-调整监听器的触发顺序" class="headerlink" title="5.6 调整监听器的触发顺序"></a>5.6 调整监听器的触发顺序</h3><p>如果业务需要调整，需要先发送站内信，后发送邮件，这个时候就需要配合另外一个注解了：**<code>@Order</code>** 。标注上这个注解后，默认的排序值为 <strong><code>Integer.MAX_VALUE</code></strong> ，代表<strong>最靠后</strong>。</p><p>按照这个规则，那咱在 <code>MessageSenderListener</code> 的 <code>onRegisterSuccess</code> 方法上标注 <code>@Order(0)</code> ，重新运行启动类的 <code>main</code> 方法，观察控制台的打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">张大三注册成功。。。<br>监听到用户注册成功，发送站内信。。。<br>监听到用户注册成功，发送邮件中。。。<br>监听到用户注册成功，发送短信。。。<br></code></pre></td></tr></table></figure><p>需求得以解决。不过这个时候我们再思考一个问题：如果不标注 <code>@Order</code> 注解，默认的顺序是多少呢？</p><p>尝试着把刚才的 <code>@Order</code> 注解中，<code>value</code> 改为 <code>Integer.MAX_VALUE - 1</code> ，重新运行，发现运行结果还是像上面那样打印，证明<strong>默认的排序值是 <code>Integer.MAX_VALUE</code></strong> 。</p><h3 id="5-7-理性看待自定义事件"><a href="#5-7-理性看待自定义事件" class="headerlink" title="5.7 理性看待自定义事件"></a>5.7 理性看待自定义事件</h3><p>到这里，估计部分小伙伴快看不下去了，这有点多此一举呀！</p><p>我完全可以用一个监听器搞三个方法一块写就完了呀！甚至，完全可以把发送信息、邮件的动作，整合在注册的逻辑中。那这自定义事件到底有什么刚需吗？</p><p>讲道理，<strong>真的非常少</strong>。很多场景下，使用自定义事件可以处理的逻辑，完全可以通过一些其它的方案来替代，这样真的会显得自定义事件很鸡肋。</p><p>所以，一定要理性看待自定义事件的使用，千万不要一学到点东西，就疯狂输出哦 (￣▽￣)／。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>Event</tag>
      
      <tag>EventListener</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06-IOC的ApplicationContext</title>
    <link href="/2022/04/18/06-IOC%E7%9A%84ApplicationContext/"/>
    <url>/2022/04/18/06-IOC%E7%9A%84ApplicationContext/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC进阶-IOC容器的详细对比-ApplicationContext"><a href="#IOC进阶-IOC容器的详细对比-ApplicationContext" class="headerlink" title="IOC进阶-IOC容器的详细对比-ApplicationContext"></a>IOC进阶-IOC容器的详细对比-ApplicationContext</h1><p>推荐使用 <code>ApplicationContext</code> 而不是 <code>BeanFactory</code> ，因为 <code>ApplicationContext</code>相比较 <code>BeanFactory</code> 扩展的实在是太多了：</p><table><thead><tr><th>Feature</th><th><code>BeanFactory</code></th><th><code>ApplicationContext</code></th></tr></thead><tbody><tr><td>Bean instantiation/wiring —— Bean的实例化和属性注入</td><td>Yes</td><td>Yes</td></tr><tr><td>Integrated lifecycle management —— <strong>生命周期管理</strong></td><td>No</td><td>Yes</td></tr><tr><td>Automatic <code>BeanPostProcessor</code> registration —— <strong>Bean后置处理器的支持</strong></td><td>No</td><td>Yes</td></tr><tr><td>Automatic <code>BeanFactoryPostProcessor</code> registration —— <strong>BeanFactory后置处理器的支持</strong></td><td>No</td><td>Yes</td></tr><tr><td>Convenient <code>MessageSource</code> access (for internalization) —— <strong>消息转换服务（国际化）</strong></td><td>No</td><td>Yes</td></tr><tr><td>Built-in <code>ApplicationEvent</code> publication mechanism —— <strong>事件发布机制（事件驱动）</strong></td><td>No</td><td>Yes</td></tr></tbody></table><p>那既然是这样，咱就一定要更深入的了解 <code>ApplicationContext</code> 才是。</p><h2 id="1-ApplicationContext和它的上下辈们"><a href="#1-ApplicationContext和它的上下辈们" class="headerlink" title="1. ApplicationContext和它的上下辈们"></a>1. ApplicationContext和它的上下辈们</h2><p>还是跟上一章一样，咱先把关系图摆出来看看：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b31a2ee5069f4234abd048c893126ed0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>可以发现 <code>ApplicationContext</code> 不仅继承了 <code>BeanFactory</code> 的两个扩展接口，还继承了其它几个接口，咱都一并来讲解。</p><h3 id="1-1-ApplicationContext【掌握】"><a href="#1-1-ApplicationContext【掌握】" class="headerlink" title="1.1 ApplicationContext【掌握】"></a>1.1 ApplicationContext【掌握】</h3><p>这是主角之一，但它的文档注释却不是很长，咱一起来读一下。</p><h4 id="1-1-1-ApplicationContext是最核心接口"><a href="#1-1-1-ApplicationContext是最核心接口" class="headerlink" title="1.1.1 ApplicationContext是最核心接口"></a>1.1.1 ApplicationContext是最核心接口</h4><blockquote><p>Central interface to provide configuration for an application. This is read-only while the application is running, but may be reloaded if the implementation supports this.</p><p>它是为应用程序提供配置的中央接口。在应用程序运行时，它是只读的，但是如果受支持的话，它可以重新加载。</p></blockquote><p>很言简意赅，<code>ApplicationContext</code> 就是中央接口，它就是 SpringFramework 的最最核心。</p><p>另外它多提了一个概念：<strong>重新加载</strong>，这个概念很关键，咱会在后面介绍 <code>ApplicationContext</code> 的抽象实现中着重介绍它。</p><h4 id="1-1-2-ApplicationContext组合多个功能接口"><a href="#1-1-2-ApplicationContext组合多个功能接口" class="headerlink" title="1.1.2 ApplicationContext组合多个功能接口"></a>1.1.2 ApplicationContext组合多个功能接口</h4><blockquote><p>An ApplicationContext provides:</p><ul><li>Bean factory methods for accessing application components. Inherited from ListableBeanFactory.</li><li>The ability to load file resources in a generic fashion. Inherited from the ResourceLoader interface.</li><li>The ability to publish events to registered listeners. Inherited from the ApplicationEventPublisher interface.</li><li>The ability to resolve messages, supporting internationalization. Inherited from the MessageSource interface.</li><li>Inheritance from a parent context. Definitions in a descendant context will always take priority. This means, for example, that a single parent context can be used by an entire web application, while each servlet has its own child context that is independent of that of any other servlet.</li></ul><p><code>ApplicationContext</code> 提供：</p><ul><li>用于访问应用程序组件的 Bean 工厂方法。继承自 <code>ListableBeanFactory</code> 。</li><li>以通用方式加载文件资源的能力。继承自 <code>ResourceLoader</code> 接口。</li><li>能够将事件发布给注册的监听器。继承自 <code>ApplicationEventPublisher</code> 接口。</li><li>解析消息的能力，支持国际化。继承自 <code>MessageSource</code> 接口。</li><li>从父上下文继承。在子容器中的定义将始终优先。例如，这意味着整个 Web 应用程序都可以使用单个父上下文，而每个 servlet 都有其自己的子上下文，该子上下文独立于任何其他 servlet 的子上下文。</li></ul></blockquote><p>这一段它列出了 <code>ApplicationContext</code> 的核心功能，注意这里面与上面表里面列举的内容有所不同，这里主要介绍的是功能和来源的接口。</p><p>这里面有一点需要注意，<code>ApplicationContext</code> 也是支持层级结构的，但这里它的描述是<strong>父子上下文</strong>，这个概念要区分理解。<strong>上下文中包含容器，但又不仅仅是容器。容器只负责管理 Bean ，但上下文中还包括动态增强、资源加载、事件监听机制等多方面扩展功能。</strong></p><h4 id="1-1-3-ApplicationContext负责部分回调注入"><a href="#1-1-3-ApplicationContext负责部分回调注入" class="headerlink" title="1.1.3 ApplicationContext负责部分回调注入"></a>1.1.3 ApplicationContext负责部分回调注入</h4><blockquote><p>In addition to standard BeanFactory lifecycle capabilities, ApplicationContext implementations detect and invoke ApplicationContextAware beans as well as ResourceLoaderAware , ApplicationEventPublisherAware and MessageSourceAware beans.</p><p>除了标准的 <code>BeanFactory</code> 生命周期功能外，<code>ApplicationContext</code> 实现还检测并调用 <code>ApplicationContextAware</code> bean 以及 <code>ResourceLoaderAware</code> bean， <code>ApplicationEventPublisherAware</code> 和 <code>MessageSourceAware</code> bean。</p></blockquote><p>看到这个，可能小伙伴们会有些惊讶，这里面有些 Aware 接口没见过啊，它们也能注入吗？先别着急，往上看看 <code>ApplicationContext</code> 继承的接口们：</p><ul><li><code>ResourceLoader</code> → <code>ResourceLoaderAware</code></li><li><code>ApplicationEventPublisher</code> → <code>ApplicationEventPublisherAware</code></li><li><code>MessageSource</code> → <code>MessageSourceAware</code></li></ul><p>是不是突然明白了什么？这些 Aware 注入的最终结果还是 <strong><code>ApplicationContext</code></strong> 本身啊！</p><h3 id="1-2-ConfigurableApplicationContext【掌握】"><a href="#1-2-ConfigurableApplicationContext【掌握】" class="headerlink" title="1.2 ConfigurableApplicationContext【掌握】"></a>1.2 ConfigurableApplicationContext【掌握】</h3><p>与上一章的 <code>ConfigurableBeanFactory</code> 类似，它也给 <code>ApplicationContext</code> 提供了 <strong>“可写”</strong>的功能，实现了该接口的实现类可以被客户端代码修改内部的某些配置。下面还是看看文档注释的描述：</p><h4 id="1-2-1-ConfigurableApplicationContext提供了可配置的可能"><a href="#1-2-1-ConfigurableApplicationContext提供了可配置的可能" class="headerlink" title="1.2.1 ConfigurableApplicationContext提供了可配置的可能"></a>1.2.1 ConfigurableApplicationContext提供了可配置的可能</h4><blockquote><p>SPI interface to be implemented by most if not all application contexts. Provides facilities to configure an application context in addition to the application context client methods in the ApplicationContext interface.</p><p>它是一个支持 SPI 的接口，它会被大多数（如果不是全部）应用程序上下文的落地实现。除了 <code>ApplicationContext</code> 接口中的应用程序上下文客户端方法外，还提供了用于配置应用程序上下文的功能。</p></blockquote><p>这里又提到 SPI 了，咱回头讲到模块装配时再解释这个概念。后面它又提了，<code>ConfigurableApplicationContext</code> 给 <code>ApplicationContext</code> 添加了用于配置的功能，这个说法可以从接口方法中得以体现。<code>ConfigurableApplicationContext</code> 中扩展了 <code>setParent</code> 、<code>setEnvironment</code> 、<code>addBeanFactoryPostProcessor</code>、<code>addApplicationListener</code> 等方法，都是可以改变 <code>ApplicationContext</code> 本身的方法。</p><h4 id="1-2-2-ConfigurableApplicationContext只希望被调用启动和关闭"><a href="#1-2-2-ConfigurableApplicationContext只希望被调用启动和关闭" class="headerlink" title="1.2.2 ConfigurableApplicationContext只希望被调用启动和关闭"></a>1.2.2 ConfigurableApplicationContext只希望被调用启动和关闭</h4><blockquote><p>Configuration and lifecycle methods are encapsulated here to avoid making them obvious to ApplicationContext client code. The present methods should only be used by startup and shutdown code.</p><p>配置和与生命周期相关的方法都封装在这里，以避免暴露给 <code>ApplicationContext</code> 的调用者。本接口的方法仅应由启动和关闭代码使用。</p></blockquote><p>由这段话也能明白，<code>ConfigurableApplicationContext</code> 本身扩展了一些方法，但是它一般情况下不希望让咱开发者调用，而是只调用启动（refresh）和关闭（close）方法。注意这个一般情况是在程序运行期间的业务代码中，但如果是为了定制化 <code>ApplicationContext</code> 或者对其进行扩展，<code>ConfigurableApplicationContext</code> 的扩展则会成为切入的主目标。</p><p>好了，对于 <code>ApplicationContext</code> 的子接口就这一个，但它还实现了几个其他的接口，咱也一起来看看。</p><h3 id="1-3-EnvironmentCapable【熟悉】"><a href="#1-3-EnvironmentCapable【熟悉】" class="headerlink" title="1.3 EnvironmentCapable【熟悉】"></a>1.3 EnvironmentCapable【熟悉】</h3><p><strong>capable</strong> 本意为“有能力的”，在这里解释为 <strong>“携带/组合”</strong> 更为合适。</p><p><strong>在 SpringFramework 中，以 Capable 结尾的接口，通常意味着可以通过这个接口的某个特定的方法（通常是 <code>getXXX()</code> ）拿到特定的组件。</strong></p><p>按照这个概念说法，这个 <code>EnvironmentCapable</code> 接口中就应该通过一个 <code>getEnvironment()</code>方法拿到 <strong><code>Environment</code></strong> ，事实上也确实如此：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EnvironmentCapable</span> </span>&#123;<br><span class="hljs-function">Environment <span class="hljs-title">getEnvironment</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面咱还是看看官方是如何解释这个接口的。</p><h4 id="1-3-1-ApplicationContext都具有EnvironmentCapable的功能"><a href="#1-3-1-ApplicationContext都具有EnvironmentCapable的功能" class="headerlink" title="1.3.1 ApplicationContext都具有EnvironmentCapable的功能"></a>1.3.1 ApplicationContext都具有EnvironmentCapable的功能</h4><blockquote><p>Interface indicating a component that contains and exposes an Environment reference.</p><p>All Spring application contexts are EnvironmentCapable, and the interface is used primarily for performing instanceof checks in framework methods that accept BeanFactory instances that may or may not actually be ApplicationContext instances in order to interact with the environment if indeed it is available.</p><p>它是具有获取并公开 <code>Environment</code> 引用的接口。</p><p>所有 Spring 的 <code>ApplicationContext</code> 都具有 <code>EnvironmentCapable</code> 功能，并且该接口主要用于在接受 <code>BeanFactory</code> 实例的框架方法中执行 <strong>instanceof</strong> 检查，以便可以与环境进行交互（如果实际上是 <code>ApplicationContext</code> 实例）。</p></blockquote><p>从这部分可以知道，<code>ApplicationContext</code> 都实现了这个 <code>EnvironmentCapable</code> 接口，也就代表着所有的 <code>ApplicationContext</code> 的实现类都可以取到 <code>Environment</code> 抽象。至于 <code>Environment</code> 是什么，咱后面 IOC 高级部分会解释，这里简单解释一下。</p><p><code>Environment</code> 是 SpringFramework 中抽象出来的类似于<strong>运行环境</strong>的<strong>独立抽象</strong>，它内部存放着应用程序运行的一些配置。</p><p>现阶段小伙伴可以这么理解：基于 SpringFramework 的工程，在运行时包含两部分：<strong>应用程序本身、应用程序的运行时环境</strong>。</p><h4 id="1-3-2-ConfigurableApplicationContext可以获取ConfigurableEnvironment"><a href="#1-3-2-ConfigurableApplicationContext可以获取ConfigurableEnvironment" class="headerlink" title="1.3.2 ConfigurableApplicationContext可以获取ConfigurableEnvironment"></a>1.3.2 ConfigurableApplicationContext可以获取ConfigurableEnvironment</h4><blockquote><p>As mentioned, ApplicationContext extends EnvironmentCapable, and thus exposes a getEnvironment() method; however, ConfigurableApplicationContext redefines getEnvironment() and narrows the signature to return a ConfigurableEnvironment. The effect is that an Environment object is ‘read-only’ until it is being accessed from a ConfigurableApplicationContext, at which point it too may be configured.</p><p>如上面所述，<code>ApplicationContext</code> 扩展了 <code>EnvironmentCapable</code> ，因此公开了 <code>getEnvironment()</code> 方法；但是，<code>ConfigurableApplicationContext</code> 重新定义了 <code>getEnvironment()</code> 并缩小了签名范围，以返回 <code>ConfigurableEnvironment</code> 。结果是环境对象是 “只读的” ，直到从 <code>ConfigurableApplicationContext</code> 访问它为止，此时也可以对其进行配置。</p></blockquote><p>这里又看到 <strong>Configurable</strong> 的概念了，对于<strong>可配置的</strong> <code>ApplicationContext</code> ，就可以获取到<strong>可配置的</strong> <code>Environment</code> 抽象，这个也不难理解吧。</p><h3 id="1-4-MessageSource【熟悉】"><a href="#1-4-MessageSource【熟悉】" class="headerlink" title="1.4 MessageSource【熟悉】"></a>1.4 MessageSource【熟悉】</h3><p>上面咱也看到了，它是支持国际化的组件。关于国际化的内容，小册计划放到 SpringWebMvc 部分来一起讲解，这里先简单了解下即可。</p><p><strong>国际化，是针对不同地区、不同国家的访问，可以提供对应的符合用户阅读习惯（语言）的页面和数据。</strong>对于不同地区、使用不同语言的用户，需要分别提供对应语言环境的表述。</p><p>对于国际化的概念，目前先了解即可。下面看看 SpringFramework 中是如何设计国际化的：</p><blockquote><p>Strategy interface for resolving messages, with support for the parameterization and internationalization of such messages. Spring provides two out-of-the-box implementations for production:</p><ul><li>org.springframework.context.support.ResourceBundleMessageSource: built on top of the standard java.util.ResourceBundle, sharing its limitations.</li><li>org.springframework.context.support.ReloadableResourceBundleMessageSource: highly configurable, in particular with respect to reloading message definitions.</li></ul><p>用于解析消息的策略接口，并支持消息的参数化和国际化。SpringFramework 为生产提供了两种现有的实现：</p><ul><li><code>ResourceBundleMessageSource</code>：建立在标准 <code>java.util.ResourceBundle</code> 之上，共享其局限性。</li><li><code>ReloadableResourceBundleMessageSource</code>：高度可配置，尤其是在重新加载消息定义方面。</li></ul></blockquote><p>这里它又提到了关于 Java 原生的国际化，咱都放一放，现阶段只知道 SpringFramework 支持国际化就 OK 。</p><h3 id="1-5-ApplicationEventPublisher【熟悉】"><a href="#1-5-ApplicationEventPublisher【熟悉】" class="headerlink" title="1.5 ApplicationEventPublisher【熟悉】"></a>1.5 ApplicationEventPublisher【熟悉】</h3><p>类名可以理解为，它是<strong>事件的发布器</strong>。SpringFramework 内部支持很强大的事件监听机制，而 ApplicationContext 作为容器的最顶级，自然也要实现观察者模式中<strong>广播器</strong>的角色。文档注释中对于它的描述也是异常的简单：</p><blockquote><p>Interface that encapsulates event publication functionality. Serves as a super-interface for ApplicationContext.</p><p>封装事件发布功能的接口，它作为 <code>ApplicationContext</code> 的父接口。</p></blockquote><p>所以它就是一个很简单的事件发布/广播器而已，后续在 IOC 进阶部分学习事件驱动机制时会讲解它。</p><h3 id="1-6-ResourcePatternResolver【熟悉】"><a href="#1-6-ResourcePatternResolver【熟悉】" class="headerlink" title="1.6 ResourcePatternResolver【熟悉】"></a>1.6 ResourcePatternResolver【熟悉】</h3><p>这个接口可能是这几个扩展里最复杂的一个，从类名理解可以解释为“<strong>资源模式解析器</strong>”，实际上它是<strong>根据特定的路径去解析资源文件</strong>的。从下面的文档注释中，咱就可以深刻的体会 <code>ResourcePatternResolver</code> 的作用和扩展。</p><h4 id="1-6-1-ResourcePatternResolver是ResourceLoader的扩展"><a href="#1-6-1-ResourcePatternResolver是ResourceLoader的扩展" class="headerlink" title="1.6.1 ResourcePatternResolver是ResourceLoader的扩展"></a>1.6.1 ResourcePatternResolver是ResourceLoader的扩展</h4><blockquote><p>Strategy interface for resolving a location pattern (for example, an Ant-style path pattern) into Resource objects. This is an extension to the ResourceLoader interface. A passed-in ResourceLoader (for example, an org.springframework.context.ApplicationContext passed in via org.springframework.context.ResourceLoaderAware when running in a context) can be checked whether it implements this extended interface too.</p><p>它是一个策略接口，用于将位置模式（例如，Ant 样式的路径模式）解析为 <code>Resource</code>对象。 这是 <code>ResourceLoader</code> 接口的扩展。可以检查传入的 <code>ResourceLoader</code>（例如，在上下文中运行时通过 <code>ResourceLoaderAware</code> 传入的 <code>ApplicationContext</code> ）是否也实现了此扩展接口。</p></blockquote><p>可以发现，它本身还是 <code>ResourceLoader</code> 的扩展，<code>ResourceLoader</code> 实现最基本的解析，<code>ResourcePatternResolver</code> 可以支持 <strong>Ant</strong> 形式的带星号 ( * ) 的路径解析（ Ant 形式会在下面看到）。</p><h4 id="1-6-2-ResourcePatternResolver的实现方式有多种"><a href="#1-6-2-ResourcePatternResolver的实现方式有多种" class="headerlink" title="1.6.2 ResourcePatternResolver的实现方式有多种"></a>1.6.2 ResourcePatternResolver的实现方式有多种</h4><blockquote><p>PathMatchingResourcePatternResolver is a standalone implementation that is usable outside an ApplicationContext, also used by ResourceArrayPropertyEditor for populating Resource array bean properties.</p><p><code>PathMatchingResourcePatternResolver</code> 是一个独立的实现，可在 <code>ApplicationContext</code> 外部使用，<code>ResourceArrayPropertyEditor</code> 使用它来填充 <code>Resource</code> 数组中 Bean 属性。</p></blockquote><p>这一段列出了一种 <code>ResourcePatternResolver</code> 的独立实现：<strong>基于路径匹配的解析器</strong>，这种扩展实现的特点是会<strong>根据特殊的路径来返回多个匹配到的资源文件</strong>。</p><h4 id="1-6-3-ResourcePatternResolver支持的Ant路径模式匹配"><a href="#1-6-3-ResourcePatternResolver支持的Ant路径模式匹配" class="headerlink" title="1.6.3 ResourcePatternResolver支持的Ant路径模式匹配"></a>1.6.3 ResourcePatternResolver支持的Ant路径模式匹配</h4><blockquote><p>Can be used with any sort of location pattern (e.g. “/WEB-INF/*-context.xml”): Input patterns have to match the strategy implementation. This interface just specifies the conversion method rather than a specific pattern format.</p><p>可以与任何类型的位置模式一起使用（例如 <code>&quot;/WEB-INF/*-context.xml&quot;</code> ）：输入模式必须与策略实现相匹配。该接口仅指定转换方法，而不是特定的模式格式。</p></blockquote><p>根据前面的文档注释也知道，它支持的是 Ant 风格的匹配模式，这种模式可以有如下写法：</p><ul><li><code>/WEB-INF/*.xml</code> ：匹配 <code>/WEB-INF</code> 目录下的任意 xml 文件</li><li><code>/WEB-INF/**/beans-*.xml</code> ：匹配 <code>/WEB-INF</code> 下面任意层级目录的 <code>beans-</code> 开头的 xml 文件</li><li><code>/**/*.xml</code> ：匹配任意 xml 文件</li></ul><p>可以发现这种写法还是蛮灵活的，小伙伴们可以从网上搜索学习更多关于 Ant 风格的写法，不过常用的写法大概就上面几种，掌握写法即可。</p><h4 id="1-6-4-ResourcePatternResolver可以匹配类路径下的文件"><a href="#1-6-4-ResourcePatternResolver可以匹配类路径下的文件" class="headerlink" title="1.6.4 ResourcePatternResolver可以匹配类路径下的文件"></a>1.6.4 ResourcePatternResolver可以匹配类路径下的文件</h4><blockquote><p>This interface also suggests a new resource prefix “classpath*:” for all matching resources from the class path. Note that the resource location is expected to be a path without placeholders in this case (e.g. “/beans.xml”); JAR files or classes directories can contain multiple files of the same name.</p><p>此接口还为类路径中的所有匹配资源建议一个新的资源前缀 <code>&quot;classpath*: &quot;</code>。请注意，在这种情况下，资源位置应该是没有占位符的路径（例如 <code>&quot;/beans.xml&quot;</code> ）； jar 文件或类目录可以包含多个相同名称的文件。</p></blockquote><p>文档注释中又提到了 <code>ResourcePatternResolver</code> 还可以匹配类路径下的资源文件，方式是在资源路径中加一个 <code>classpath*:</code> 的前缀。由此咱也可以知道，<code>ResourcePatternResolver</code>不仅可以匹配 Web 工程中 webapps 的文件，也可以匹配 classpath 下的文件了。</p><hr><p>到这里，关于 <code>ApplicationContext</code> 相关的接口咱就大概都了解了，下面是 <code>ApplicationContext</code> 的实现类们，这里面涉及的内容可能比较难记，小伙伴根据我标注的实现类的重要程度来理解和记录即可。</p><h2 id="2-ApplicationContext的实现类们"><a href="#2-ApplicationContext的实现类们" class="headerlink" title="2. ApplicationContext的实现类们"></a>2. ApplicationContext的实现类们</h2><p>同样的，借助 IDEA 整理出一张继承关系图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/001fe910c0344849aebe654534b49cca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>这里面涉及到的实现类咱一个一个列出来看。</p><h3 id="2-1-AbstractApplicationContext【掌握-】"><a href="#2-1-AbstractApplicationContext【掌握-】" class="headerlink" title="2.1 AbstractApplicationContext【掌握*】"></a>2.1 AbstractApplicationContext【掌握*】</h3><p>这个类是 <code>ApplicationContext</code> <strong>最最最最核心的实现类，没有之一</strong>。<code>AbstractApplicationContext</code> 中定义和实现了<strong>绝大部分应用上下文的特性和功能</strong>，一定要给它<strong>最大的重视</strong>。</p><h4 id="2-1-1-AbstractApplicationContext只构建功能抽象"><a href="#2-1-1-AbstractApplicationContext只构建功能抽象" class="headerlink" title="2.1.1 AbstractApplicationContext只构建功能抽象"></a>2.1.1 AbstractApplicationContext只构建功能抽象</h4><blockquote><p>Abstract implementation of the ApplicationContext interface. Doesn’t mandate the type of storage used for configuration; simply implements common context functionality. Uses the Template Method design pattern, requiring concrete subclasses to implement abstract methods.</p><p><code>ApplicationContext</code> 接口的抽象实现。不强制用于配置的存储类型；简单地实现通用上下文功能。使用模板方法模式，需要具体的子类来实现抽象方法。</p></blockquote><p>一开始人家就解释了，<code>AbstractApplicationContext</code> 的抽象实现主要是规范功能（借助模板方法），实际的动作它不管，让子类自行去实现。</p><h4 id="2-1-2-AbstractApplicationContext可以处理特殊类型的Bean"><a href="#2-1-2-AbstractApplicationContext可以处理特殊类型的Bean" class="headerlink" title="2.1.2 AbstractApplicationContext可以处理特殊类型的Bean"></a>2.1.2 AbstractApplicationContext可以处理特殊类型的Bean</h4><blockquote><p>In contrast to a plain BeanFactory, an ApplicationContext is supposed to detect special beans defined in its internal bean factory: Therefore, this class automatically registers BeanFactoryPostProcessors, BeanPostProcessors, and ApplicationListeners which are defined as beans in the context.</p><p>与普通的 <code>BeanFactory</code> 相比，<code>ApplicationContext</code> 应该能够检测在其内部 Bean 工厂中定义的特殊 bean ：因此，此类自动注册在上下文中定义为 bean 的 <code>BeanFactoryPostProcessors</code> ，<code>BeanPostProcessors</code> 和 <code>ApplicationListeners</code>。</p></blockquote><p>咱在第 6 章就知道，<code>ApplicationContext</code> 比 <code>BeanFactory</code> 强大的地方是支持更多的机制，这里面就包括了<strong>后置处理器、监听器</strong>等，而这些器，说白了也都是<strong>一个一个的 Bean</strong>，<code>BeanFactory</code> 不会把它们区别对待，但是 <code>ApplicationContext</code> 就可以区分出来，并且赋予他们发挥特殊能力的机会。</p><h4 id="2-1-3-AbstractApplicationContext可以转换为多种类型"><a href="#2-1-3-AbstractApplicationContext可以转换为多种类型" class="headerlink" title="2.1.3 AbstractApplicationContext可以转换为多种类型"></a>2.1.3 AbstractApplicationContext可以转换为多种类型</h4><blockquote><p>A MessageSource may also be supplied as a bean in the context, with the name “messageSource”; otherwise, message resolution is delegated to the parent context. Furthermore, a multicaster for application events can be supplied as an “applicationEventMulticaster” bean of type ApplicationEventMulticaster in the context; otherwise, a default multicaster of type SimpleApplicationEventMulticaster will be used.</p><p>一个 <code>MessageSource</code> 也可以在上下文中作为一个普通的 bean 提供，名称为 <code>&quot;messageSource&quot;</code> 。否则，将消息解析委托给父上下文。此外，可以在上下文中将用于应用程序事件的广播器作为类型为 <code>ApplicationEventMulticaster</code> 的 <code>&quot;applicationEventMulticaster&quot;</code> bean 提供。否则，将使用类型为 <code>SimpleApplicationEventMulticaster</code> 的默认事件广播器。</p></blockquote><p>咱上面看到了，<code>ApplicationContext</code> 实现了国际化的接口 <code>MessageSource</code> 、事件广播器的接口 <code>ApplicationEventMulticaster</code> ，那作为容器，它也会<strong>把自己看成一个 Bean</strong> ，以支持不同类型的组件注入需要。</p><h4 id="2-1-4-AbstractApplicationContext提供默认的加载资源文件策略"><a href="#2-1-4-AbstractApplicationContext提供默认的加载资源文件策略" class="headerlink" title="2.1.4 AbstractApplicationContext提供默认的加载资源文件策略"></a>2.1.4 AbstractApplicationContext提供默认的加载资源文件策略</h4><blockquote><p>Implements resource loading by extending DefaultResourceLoader. Consequently treats non-URL resource paths as class path resources (supporting full class path resource names that include the package path, e.g. “mypackage/myresource.dat”), unless the getResourceByPath method is overridden in a subclass.</p><p>通过扩展 <code>DefaultResourceLoader</code> 实现资源加载。因此，除非在子类中覆盖了 <code>getResourceByPath()</code> 方法，否则将非 URL 资源路径视为类路径资源（支持包含包路径的完整类路径资源名称，例如 <code>&quot;mypackage/myresource.dat&quot;</code> ）。</p></blockquote><p>默认情况下，<code>AbstractApplicationContext</code> 加载资源文件的策略是直接继承了 <code>DefaultResourceLoader</code> 的策略，从类路径下加载；但在 Web 项目中，可能策略就不一样了，它可以从 <code>ServletContext</code> 中加载（扩展的子类 <code>ServletContextResourceLoader</code>等）。</p><p>看完了文档，小册在这个章节中多提一句：<code>AbstractApplicationContext</code> 中定义了一个特别特别重要的方法，它是控制 <code>ApplicationContext</code> 生命周期的核心方法：**<code>refresh</code>** 。下面是基本的方法定义，小伙伴们先对此有个印象即可，不需要深入进去看源码。对于源码的执行，小伙伴可以学完这些基础之后，参考《SpringBoot 源码解读与原理分析》的 11-15 章，学习 <code>refresh</code> 方法的核心执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-comment">// Prepare this context for refreshing.</span><br>        <span class="hljs-comment">// 1. 初始化前的预处理</span><br>        prepareRefresh();<br><br>        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>        <span class="hljs-comment">// 2. 获取BeanFactory，加载所有xml配置文件中bean的定义信息（未实例化）</span><br>        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>        <span class="hljs-comment">// 3. BeanFactory的预处理配置</span><br>        prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>            <span class="hljs-comment">// 4. 准备BeanFactory完成后进行的后置处理</span><br>            postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>            <span class="hljs-comment">// 5. 执行BeanFactory创建后的后置处理器</span><br>            invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>            <span class="hljs-comment">// 6. 注册Bean的后置处理器</span><br>            registerBeanPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// Initialize message source for this context.</span><br>            <span class="hljs-comment">// 7. 初始化MessageSource</span><br>            initMessageSource();<br><br>            <span class="hljs-comment">// Initialize event multicaster for this context.</span><br>            <span class="hljs-comment">// 8. 初始化事件派发器</span><br>            initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>            <span class="hljs-comment">// 9. 子类的多态onRefresh</span><br>            onRefresh();<br><br>            <span class="hljs-comment">// Check for listener beans and register them.</span><br>            <span class="hljs-comment">// 10. 注册监听器</span><br>            registerListeners();<br>          <br>            <span class="hljs-comment">//到此为止，BeanFactory已创建完成</span><br><br>            <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>            <span class="hljs-comment">// 11. 初始化所有剩下的单例Bean</span><br>            finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// Last step: publish corresponding event.</span><br>            <span class="hljs-comment">// 12. 完成容器的创建工作</span><br>            finishRefresh();<br>        &#125; <span class="hljs-comment">// catch ......</span><br><br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br>            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>            <span class="hljs-comment">// 13. 清除缓存</span><br>            resetCommonCaches();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有个印象即可哈，不要深入进去，不然出不来了就没法继续往下愉快的学习了~~~</p><h3 id="2-2-GenericApplicationContext【熟悉】"><a href="#2-2-GenericApplicationContext【熟悉】" class="headerlink" title="2.2 GenericApplicationContext【熟悉】"></a>2.2 GenericApplicationContext【熟悉】</h3><p>咱先从注解驱动的 IOC 容器看起，<code>GenericApplicationContext</code> 已经是一个普通的类（非抽象类）了，它里面已经具备了 <code>ApplicationContext</code> 基本的所有能力了。咱来看看官方怎么描述它的。</p><h4 id="2-2-1-GenericApplicationContext组合了BeanFactory"><a href="#2-2-1-GenericApplicationContext组合了BeanFactory" class="headerlink" title="2.2.1 GenericApplicationContext组合了BeanFactory"></a>2.2.1 GenericApplicationContext组合了BeanFactory</h4><blockquote><p>Generic ApplicationContext implementation that holds a single internal DefaultListableBeanFactory instance and does not assume a specific bean definition format. Implements the BeanDefinitionRegistry interface in order to allow for applying any bean definition readers to it.</p><p>通用 <code>ApplicationContext</code> 的实现，该实现拥有一个内部 <code>DefaultListableBeanFactory</code> 实例，并且不采用特定的 bean 定义格式。另外它实现 <code>BeanDefinitionRegistry</code> 接口，以便允许将任何 bean 定义读取器应用于该容器中。</p></blockquote><p>注意划重点：*<em><code>GenericApplicationContext</code> 中组合了一个 <code>DefaultListableBeanFactory</code>！！！*</em>由此可以得到一个非常非常重要的信息：**<code>ApplicationContext</code> 并不是继承了 <code>BeanFactory</code> 的容器，而是组合了 <code>BeanFactory</code> ！**</p><p>然后后面它说了它还实现了 <code>BeanDefinitionRegistry</code> 接口，上一章咱简单说了它是 “Bean 定义的注册器”，它与 Bean 的定义信息有关，咱往后放一放。</p><h4 id="2-2-2-GenericApplicationContext借助BeanDefinitionRegistry处理特殊Bean"><a href="#2-2-2-GenericApplicationContext借助BeanDefinitionRegistry处理特殊Bean" class="headerlink" title="2.2.2 GenericApplicationContext借助BeanDefinitionRegistry处理特殊Bean"></a>2.2.2 GenericApplicationContext借助BeanDefinitionRegistry处理特殊Bean</h4><blockquote><p>Typical usage is to register a variety of bean definitions via the BeanDefinitionRegistry interface and then call refresh() to initialize those beans with application context semantics (handling org.springframework.context.ApplicationContextAware, auto-detecting BeanFactoryPostProcessors, etc).</p><p>典型的用法是通过 <code>BeanDefinitionRegistry</code> 接口注册各种 Bean 的定义，然后调用 <code>refresh()</code> 以使用应用程序上下文语义来初始化这些 Bean（处理 <code>ApplicationContextAware</code> ，自动检测 <code>BeanFactoryPostProcessors</code> 等）。</p></blockquote><p>这里又看到了 <strong><code>BeanDefinitionRegistry</code></strong> 了，上一章咱也提了一嘴它叫 <strong>Bean 定义的注册器</strong>，<code>GenericApplicationContext</code> 实现了它，可以自定义注册一些 Bean 。然而在 <code>GenericApplicationContext</code> 中，它实现的定义注册方法 <code>registerBeanDefinition</code> ，在底层还是调用的 <code>DefaultListableBeanFactory</code> 执行 <code>registerBeanDefinition</code> 方法，说明它也没有对此做什么扩展。</p><h4 id="2-2-3-GenericApplicationContext只能刷新一次"><a href="#2-2-3-GenericApplicationContext只能刷新一次" class="headerlink" title="2.2.3 GenericApplicationContext只能刷新一次"></a>2.2.3 GenericApplicationContext只能刷新一次</h4><blockquote><p>In contrast to other ApplicationContext implementations that create a new internal BeanFactory instance for each refresh, the internal BeanFactory of this context is available right from the start, to be able to register bean definitions on it. refresh() may only be called once.</p><p>与为每次刷新创建一个新的内部 <code>BeanFactory</code> 实例的其他 <code>ApplicationContext</code> 实现相反，此上下文的内部 <code>BeanFactory</code> 从一开始就可用，以便能够在其上注册 Bean 定义。 <code>refresh()</code> 只能被调用一次。</p></blockquote><p>这句话不是很好理解，小册换一种说法尝试着解释一下：由于 <code>GenericApplicationContext</code>中组合了一个 <code>DefaultListableBeanFactory</code> ，而这个 <code>BeanFactory</code> 是在 <code>GenericApplicationContext</code> 的<strong>构造方法中就已经初始化好</strong>了，那么初始化好的 <code>BeanFactory</code> 就<strong>不允许在运行期间被重复刷新了</strong>。下面是源码中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 内置的beanFactory在GenericApplicationContext创建时就已经初始化好了</span><br>    <span class="hljs-keyword">this</span>.beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshed.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        <span class="hljs-comment">// 利用CAS，保证只能设置一次true，如果出现第二次，就抛出重复刷新异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br>                <span class="hljs-string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.beanFactory.setSerializationId(getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>可如果是这样的话，它的文档注释为什么不直接说就可以呢，还非得加一句“与…相反”，那是因为有另外一类 <code>ApplicationContext</code> 它的设计不是这样的，咱下面会讲到，它就是 <code>AbstractRefreshableApplicationContext</code> 。</p><h4 id="2-2-4-GenericApplicationContext的替代方案是用xml"><a href="#2-2-4-GenericApplicationContext的替代方案是用xml" class="headerlink" title="2.2.4 GenericApplicationContext的替代方案是用xml"></a>2.2.4 GenericApplicationContext的替代方案是用xml</h4><blockquote><p>For the typical case of XML bean definitions, simply use ClassPathXmlApplicationContext or FileSystemXmlApplicationContext, which are easier to set up - but less flexible, since you can just use standard resource locations for XML bean definitions, rather than mixing arbitrary bean definition formats. The equivalent in a web environment is org.springframework.web.context.support.XmlWebApplicationContext.</p><p>对于 XML Bean 定义的典型情况，只需使用 <code>ClassPathXmlApplicationContext</code> 或 <code>FileSystemXmlApplicationContext</code> ，因为它们更易于设置（但灵活性较差，因为只能将从标准的资源配置文件中读取 XML Bean 定义，而不能混合使用任意 Bean 定义的格式）。在 Web 环境中，替代方案是 <code>XmlWebApplicationContext</code> 。</p></blockquote><p>这段注释它提到了 xml 的配置，咱之前也讲过，<strong>注解驱动的 IOC 容器可以导入 xml 配置文件</strong>，不过如果大多数都是 xml 配置的话，官方建议还是直接用 <code>ClassPathXmlApplicationContext</code> 或者 <code>FileSystemXmlApplicationContext</code> 就好。对比起灵活度来讲，咱也能清晰地认识到：注解驱动的方式在开发时很灵活，但如果需要修改配置时，可能需要重新编译配置类；xml 驱动的方式在修改配置时直接修改即可，不需要做任何额外的操作，但能配置的内容实在是有些有限。所以这也建议咱开发者在实际开发中，要权衡对比着使用。</p><h4 id="2-2-5-GenericApplicationContext不支持特殊Bean定义的可刷新读取"><a href="#2-2-5-GenericApplicationContext不支持特殊Bean定义的可刷新读取" class="headerlink" title="2.2.5 GenericApplicationContext不支持特殊Bean定义的可刷新读取"></a>2.2.5 GenericApplicationContext不支持特殊Bean定义的可刷新读取</h4><blockquote><p>For custom application context implementations that are supposed to read special bean definition formats in a refreshable manner, consider deriving from the AbstractRefreshableApplicationContext base class.</p><p>对于应该以可刷新方式读取特殊bean定义格式的自定义应用程序上下文实现，请考虑从 <code>AbstractRefreshableApplicationContext</code> 基类派生。</p></blockquote><p>这个概念似乎很难理解，咱大可不必在意啦，它是解释怎么扩展自定义 <code>ApplicationContext</code> 实现的，咱目前也搞不了这些复杂的东西 ~ ~ ~</p><p>不过注意一点，它提到小册在上面刚刚提到的扩展实现 <code>AbstractRefreshableApplicationContext</code> 了，可见它的确很重要了，咱下面就来看它。</p><h3 id="2-3-AbstractRefreshableApplicationContext【熟悉】"><a href="#2-3-AbstractRefreshableApplicationContext【熟悉】" class="headerlink" title="2.3 AbstractRefreshableApplicationContext【熟悉】"></a>2.3 AbstractRefreshableApplicationContext【熟悉】</h3><p>类名直译为 “可刷新的 ApplicationContext ”，它跟上面 <code>GenericApplicationContext</code> 的最大区别之一就是它<strong>可以被重复刷新</strong>，那它里面的设计肯定也会不一样咯，咱赶紧来看一看吧！</p><h4 id="2-3-1-AbstractRefreshableApplicationContext支持多次刷新"><a href="#2-3-1-AbstractRefreshableApplicationContext支持多次刷新" class="headerlink" title="2.3.1 AbstractRefreshableApplicationContext支持多次刷新"></a>2.3.1 AbstractRefreshableApplicationContext支持多次刷新</h4><blockquote><p>Base class for ApplicationContext implementations which are supposed to support multiple calls to refresh(), creating a new internal bean factory instance every time. Typically (but not necessarily), such a context will be driven by a set of config locations to load bean definitions from.</p><p>它是 <code>ApplicationContext</code> 接口实现的抽象父类，应该支持多次调用 <code>refresh()</code> 方法，每次都创建一个新的内部 <code>BeanFactory</code> 实例。通常（但不是必须）这样的上下文将由一组配置文件驱动，以从中加载 bean 的定义信息。</p></blockquote><p>注释中明确说明了：每次都<strong>会创建一个新的内部的 <code>BeanFactory</code> 实例</strong>（也就是 <code>DefaultListableBeanFactory</code> ），而整个 <code>ApplicationContext</code> 的初始化中不创建。通过源码来看，它的内部也是<strong>组合 <code>DefaultListableBeanFactory</code></strong> ，但构造方法中什么也没有干：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractRefreshableApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractApplicationContext</span> </span>&#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> DefaultListableBeanFactory beanFactory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractRefreshableApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br></code></pre></td></tr></table></figure><p>那它是怎么创建 <code>BeanFactory</code> 的呢？借助 IDEA 观察方法列表，其中就有一个方法叫 <code>creatBeanFactory</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> DefaultListableBeanFactory <span class="hljs-title">createBeanFactory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());<br>&#125;<br></code></pre></td></tr></table></figure><p>很简单明了吧，小册就不多解释了。至于什么时候这个方法被触发了，咱放到后面 IOC 原理阶段再讲解。</p><h4 id="2-3-2-AbstractRefreshableApplicationContext刷新的核心是加载Bean定义信息"><a href="#2-3-2-AbstractRefreshableApplicationContext刷新的核心是加载Bean定义信息" class="headerlink" title="2.3.2 AbstractRefreshableApplicationContext刷新的核心是加载Bean定义信息"></a>2.3.2 AbstractRefreshableApplicationContext刷新的核心是加载Bean定义信息</h4><blockquote><p>The only method to be implemented by subclasses is loadBeanDefinitions, which gets invoked on each refresh. A concrete implementation is supposed to load bean definitions into the given DefaultListableBeanFactory, typically delegating to one or more specific bean definition readers. Note that there is a similar base class for WebApplicationContexts.</p><p>子类唯一需要实现的方法是 <code>loadBeanDefinitions</code> ，它在每次刷新时都会被调用。一个具体的实现应该将 bean 的定义信息加载到给定的 <code>DefaultListableBeanFactory</code>中，通常委托给一个或多个特定的 bean 定义读取器。 注意，<code>WebApplicationContexts</code> 有一个类似的父类。</p></blockquote><p>这段话告诉我们，既然是可刷新的 <code>ApplicationContext</code> ，那它里面存放的 <strong>Bean 定义信息应该是可以被覆盖加载的</strong>。由于 <code>AbstractApplicationContext</code> 就已经实现了 <code>ConfigurableApplicationContext</code> 接口，容器本身可以重复刷新，那么每次刷新时就应该重新加载 Bean 的定义信息，以及初始化 Bean 实例。</p><p>另外它还说，在 Web 环境下也有一个类似的父类，猜都能猜到肯定是名字里多了个 Web ：<code>AbstractRefreshableWebApplicationContext</code> ，它的特征与 <code>AbstractRefreshableApplicationContext</code> 基本一致，不重复解释。</p><h4 id="2-3-3-AbstractRefreshableWebApplicationContext额外扩展了Web环境的功能"><a href="#2-3-3-AbstractRefreshableWebApplicationContext额外扩展了Web环境的功能" class="headerlink" title="2.3.3 AbstractRefreshableWebApplicationContext额外扩展了Web环境的功能"></a>2.3.3 AbstractRefreshableWebApplicationContext额外扩展了Web环境的功能</h4><blockquote><p>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext provides the same subclassing strategy, but additionally pre-implements all context functionality for web environments. There is also a pre-defined way to receive config locations for a web context.</p><p><code>AbstractRefreshableWebApplicationContext</code> 提供了相同的子类化策略，但是还预先实现了 Web 环境的所有上下文功能。还有一种预定义的方式来接收 Web 上下文的配置位置。</p></blockquote><p>与普通的 <code>ApplicationContext</code> 相比，<code>WebApplicationContext</code> 额外扩展的是与 Servlet 相关的部分（ request 、<code>ServletContext</code>等），<code>AbstractRefreshableWebApplicationContext</code> 内部就组合了一个 <code>ServletContext</code>，并且支持给 Bean 注入 <code>ServletContext</code> 、<code>ServletConfig</code> 等 Servlet 中的组件。</p><h4 id="2-3-4-几个重要的最终实现类"><a href="#2-3-4-几个重要的最终实现类" class="headerlink" title="2.3.4 几个重要的最终实现类"></a>2.3.4 几个重要的最终实现类</h4><blockquote><p>Concrete standalone subclasses of this base class, reading in a specific bean definition format, are ClassPathXmlApplicationContext and FileSystemXmlApplicationContext, which both derive from the common AbstractXmlApplicationContext base class; org.springframework.context.annotation.AnnotationConfigApplicationContext supports @Configuration-annotated classes as a source of bean definitions.</p><p>以特定的 bean 定义格式读取的该父类的具体独立子类是 <code>ClassPathXmlApplicationContext</code> 和 <code>FileSystemXmlApplicationContext</code> ，它们均从 <code>AbstractXmlApplicationContext</code> 基类扩展。 <code>AnnotationConfigApplicationContext</code> 支持 <code>@Configuration</code> 注解的类作为 <code>BeanDefinition</code> 的源。</p></blockquote><p>最后一段它提了几个内置的最终实现类，分别是基于 xml 配置的 <code>ClassPathXmlApplicationContext</code> 和 <code>FileSystemXmlApplicationContext</code> ，以及基于注解启动的 <code>AnnotationConfigApplicationContext</code> 。这些咱已经有了解了，下面也会展开来讲。</p><h3 id="2-4-AbstractRefreshableConfigApplicationContext【了解】"><a href="#2-4-AbstractRefreshableConfigApplicationContext【了解】" class="headerlink" title="2.4 AbstractRefreshableConfigApplicationContext【了解】"></a>2.4 AbstractRefreshableConfigApplicationContext【了解】</h3><p>与上面的 <code>AbstractRefreshableApplicationContext</code> 相比较，只是多了一个 <strong>Config</strong> ，说明它有<strong>扩展跟配置相关的特性</strong>。翻看方法列表，可以看到有它自己定义的 <code>getConfigLocations</code> 方法，意为“<strong>获取配置源路径</strong>”，由此也就证明它确实有配置的意思了。</p><p>它的文档注释就一段话，解释的内容恰好就是上面刚刚说的：</p><blockquote><p>AbstractRefreshableApplicationContext subclass that adds common handling of specified config locations. Serves as base class for XML-based application context implementations such as ClassPathXmlApplicationContext and FileSystemXmlApplicationContext, as well as org.springframework.web.context.support.XmlWebApplicationContext.</p><p><code>AbstractRefreshableApplicationContext</code> 的子类，用于添加对指定配置位置的通用处理。作为基于 XML 的 <code>ApplicationContext</code> 实现（例如<code>ClassPathXmlApplicationContext</code> 、 <code>FileSystemXmlApplicationContext</code> 以及 <code>XmlWebApplicationContext</code> ）的父类。</p></blockquote><p>通篇就抽出来一句话：用于添加对指定配置位置的通用处理。由于它是基于 xml 配置的 <code>ApplicationContext</code> 的父类，所以肯定需要传入配置源路径，那这个配置的动作就封装在这个 <code>AbstractRefreshableConfigApplicationContext</code> 中了。</p><h3 id="2-5-AbstractXmlApplicationContext【掌握】"><a href="#2-5-AbstractXmlApplicationContext【掌握】" class="headerlink" title="2.5 AbstractXmlApplicationContext【掌握】"></a>2.5 AbstractXmlApplicationContext【掌握】</h3><p>到这里，xml 终于浮出水面了，它就是最终 <code>ClassPathXmlApplicationContext</code> 和 <code>FileSystemXmlApplicationContext</code> 的直接父类了。</p><p>跟前面一样，先看一眼文档注释，这段注释也不算很长：</p><h4 id="2-5-1-AbstractXmlApplicationContext已具备基本全部功能"><a href="#2-5-1-AbstractXmlApplicationContext已具备基本全部功能" class="headerlink" title="2.5.1 AbstractXmlApplicationContext已具备基本全部功能"></a>2.5.1 AbstractXmlApplicationContext已具备基本全部功能</h4><blockquote><p>Convenient base class for ApplicationContext implementations, drawing configuration from XML documents containing bean definitions understood by an XmlBeanDefinitionReader. Subclasses just have to implement the getConfigResources and/or the getConfigLocations method. Furthermore, they might override the getResourceByPath hook to interpret relative paths in an environment-specific fashion, and/or getResourcePatternResolver for extended pattern resolution.</p><p>方便的 <code>ApplicationContext</code> 父类，从包含 <code>XmlBeanDefinitionReader</code> 解析的 <code>BeanDefinition</code> 的 XML 文档中提取配置。</p><p>子类只需要实现 <code>getConfigResources</code> 和/或 <code>getConfigLocations</code> 方法。此外，它们可能会覆盖 <code>getResourceByPath</code> 的钩子回调，以特定于环境的方式解析相对路径，和/或 <code>getResourcePatternResolver</code> 来扩展模式解析。</p></blockquote><p>看上去有点难懂，小册大概解释一下意思哈。</p><p>由于 <code>AbstractXmlApplicationContext</code> 已经接近于最终的 xml 驱动 IOC 容器的实现了，所以它应该有基本上所有的功能。又根据子类的两种不同的配置文件加载方式，说明<strong>加载配置文件的策略是不一样的</strong>，所以文档注释中有说子类只需要实现 <code>getConfigLocations</code> 这样的方法就好。</p><p>对于 <code>AbstractXmlApplicationContext</code> ，还有一个非常关键的部分需要咱知道，那就是加载到配置文件后如何处理。</p><h4 id="2-5-2-AbstractXmlApplicationContext中有loadBeanDefinitions的实现"><a href="#2-5-2-AbstractXmlApplicationContext中有loadBeanDefinitions的实现" class="headerlink" title="2.5.2 AbstractXmlApplicationContext中有loadBeanDefinitions的实现"></a>2.5.2 AbstractXmlApplicationContext中有loadBeanDefinitions的实现</h4><p>定位到源码中，可以在 <code>AbstractXmlApplicationContext</code> 中找到 <code>loadBeanDefinitions</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;<br>    <span class="hljs-comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br>    <span class="hljs-comment">// 借助XmlBeanDefinitionReader解析xml配置文件</span><br>    XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);<br><br>    <span class="hljs-comment">// Configure the bean definition reader with this context&#x27;s</span><br>    <span class="hljs-comment">// resource loading environment.</span><br>    beanDefinitionReader.setEnvironment(<span class="hljs-keyword">this</span>.getEnvironment());<br>    beanDefinitionReader.setResourceLoader(<span class="hljs-keyword">this</span>);<br>    beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> ResourceEntityResolver(<span class="hljs-keyword">this</span>));<br><br>    <span class="hljs-comment">// Allow a subclass to provide custom initialization of the reader,</span><br>    <span class="hljs-comment">// then proceed with actually loading the bean definitions.</span><br>    <span class="hljs-comment">// 初始化BeanDefinitionReader，后加载BeanDefinition</span><br>    initBeanDefinitionReader(beanDefinitionReader);<br>    loadBeanDefinitions(beanDefinitionReader);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它解析 xml 配置文件不是自己干活，是<strong>组合了一个 <code>XmlBeanDefinitionReader</code></strong> ，让它去解析。而实际解析配置文件的动作，就很好理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException </span>&#123;<br>    Resource[] configResources = getConfigResources();<br>    <span class="hljs-keyword">if</span> (configResources != <span class="hljs-keyword">null</span>) &#123;<br>        reader.loadBeanDefinitions(configResources);<br>    &#125;<br>    String[] configLocations = getConfigLocations();<br>    <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-keyword">null</span>) &#123;<br>        reader.loadBeanDefinitions(configLocations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到就是调用上面文档注释中提到的 <code>getConfigResources</code> 和 <code>getConfigLocations</code> 方法，取到配置文件的路径 / 资源类，交给 <code>BeanDefinitionReader</code> 解析。</p><h3 id="2-6-ClassPathXmlApplicationContext【掌握】"><a href="#2-6-ClassPathXmlApplicationContext【掌握】" class="headerlink" title="2.6 ClassPathXmlApplicationContext【掌握】"></a>2.6 ClassPathXmlApplicationContext【掌握】</h3><p>终于到了一个咱非常熟悉的 <code>ApplicationContext</code> 了，咱已经很清楚它是从 classpath 下加载 xml 配置文件的 <code>ApplicationContext</code> 了，不过文档注释中也描述了一些内容和建议，咱还是要看一看的。</p><h4 id="2-6-1-ClassPathXmlApplicationContext是一个最终落地实现"><a href="#2-6-1-ClassPathXmlApplicationContext是一个最终落地实现" class="headerlink" title="2.6.1 ClassPathXmlApplicationContext是一个最终落地实现"></a>2.6.1 ClassPathXmlApplicationContext是一个最终落地实现</h4><blockquote><p>Standalone XML application context, taking the context definition files from the class path, interpreting plain paths as class path resource names that include the package path (e.g. “mypackage/myresource.txt”). Useful for test harnesses as well as for application contexts embedded within JARs.</p><p>独立的基于 XML 的 <code>ApplicationContext</code> ，它从 classpath 中获取配置文件，将纯路径解释为包含包路径的 classpath 资源名称（例如 <code>mypackage / myresource.txt</code>）。对于测试工具以及 jar 包中嵌入的 <code>ApplicationContext</code> 很有用。</p></blockquote><p>这段话写的很明白，它支持的配置文件加载位置都是 classpath 下取，这种方式的一个好处是：如果工程中依赖了一些其他的 jar 包，而工程启动时需要同时传入这些 jar 包中的配置文件，那 <code>ClassPathXmlApplicationContext</code> 就可以加载它们。</p><h4 id="2-6-2-ClassPathXmlApplicationContext使用Ant模式声明配置文件路径"><a href="#2-6-2-ClassPathXmlApplicationContext使用Ant模式声明配置文件路径" class="headerlink" title="2.6.2 ClassPathXmlApplicationContext使用Ant模式声明配置文件路径"></a>2.6.2 ClassPathXmlApplicationContext使用Ant模式声明配置文件路径</h4><blockquote><p>The config location defaults can be overridden via getConfigLocations, Config locations can either denote concrete files like “/myfiles/context.xml” or Ant-style patterns like “/myfiles/*-context.xml” (see the org.springframework.util.AntPathMatcher javadoc for pattern details).</p><p>可以通过 <code>getConfigLocations</code> 方法覆盖配置文件位置的默认值，配置位置可以表示具体的文件，例如 <code>/myfiles/context.xml</code> ，也可以表示Ant样式的模式，例如 <code>/myfiles/*-context.xml</code>（请参见 <code>AntPathMatcher</code> 的 javadoc 以获取模式详细信息）。</p></blockquote><p>上面 <code>AbstractXmlApplicationContext</code> 中就说了，可以重写 <code>getConfigLocations</code> 方法来调整配置文件的默认读取位置，它这里又重复了一遍。除此之外它还提到了，加载配置文件的方式可以<strong>使用 Ant 模式匹配</strong>（比较经典的写法当属 web.xml 中声明的 <code>application-*.xml</code>）。</p><h4 id="2-6-3-ClassPathXmlApplicationContext解析的配置文件有先后之分"><a href="#2-6-3-ClassPathXmlApplicationContext解析的配置文件有先后之分" class="headerlink" title="2.6.3 ClassPathXmlApplicationContext解析的配置文件有先后之分"></a>2.6.3 ClassPathXmlApplicationContext解析的配置文件有先后之分</h4><blockquote><p>Note: In case of multiple config locations, later bean definitions will override ones defined in earlier loaded files. This can be leveraged to deliberately override certain bean definitions via an extra XML file.</p><p>注意：如果有多个配置位置，则较新的 <code>BeanDefinition</code> 会覆盖较早加载的文件中的 <code>BeanDefinition</code> ，可以利用它来通过一个额外的 XML 文件有意覆盖某些 <code>BeanDefinition</code> 。</p></blockquote><p>这一点是配合第一点的多配置文件读取来的。通常情况下，如果在一个 jar 包的 xml 配置文件中声明了一个 Bean ，并且又在工程的 resources 目录下又声明了同样的 Bean ，则 jar 包中声明的 Bean 会被覆盖，这也就是配置文件加载优先级的设定。</p><h4 id="2-6-4-ApplicationContext可组合灵活使用"><a href="#2-6-4-ApplicationContext可组合灵活使用" class="headerlink" title="2.6.4 ApplicationContext可组合灵活使用"></a>2.6.4 ApplicationContext可组合灵活使用</h4><blockquote><p>This is a simple, one-stop shop convenience ApplicationContext. Consider using the GenericApplicationContext class in combination with an org.springframework.beans.factory.xml.XmlBeanDefinitionReader for more flexible context setup.</p><p>这是一个简单的一站式便利 <code>ApplicationContext</code> 。可以考虑将 <code>GenericApplicationContext</code> 类与 <code>XmlBeanDefinitionReader</code> 结合使用，以实现更灵活的上下文配置。</p></blockquote><p>最后文档中并没有非常强调 <code>ClassPathXmlApplicationContext</code> 的作用，而是提了另外一个建议：由于 <code>ClassPathXmlApplicationContext</code> 继承了 <code>AbstractXmlApplicationContext</code>，而 <code>AbstractXmlApplicationContext</code> 实际上是内部组合了一个 <code>XmlBeanDefinitionReader</code> ，所以就可以有一种组合的使用方式：利用 <code>GenericApplicationContext</code> 或者子类 <code>AnnotationConfigApplicationContext</code> ，配合 <code>XmlBeanDefinitionReader</code> ，就可以做到注解驱动和 xml 通吃了。</p><h3 id="2-7-AnnotationConfigApplicationContext【掌握】"><a href="#2-7-AnnotationConfigApplicationContext【掌握】" class="headerlink" title="2.7 AnnotationConfigApplicationContext【掌握】"></a>2.7 AnnotationConfigApplicationContext【掌握】</h3><p>最后一个，咱介绍一个也用过很多次的了，就是注解驱动的 IOC 容器。它本身继承了 <code>GenericApplicationContext</code> ，那自然它也只能刷新一次。同样是最终的落地实现，它自然也应该跟 <code>ClassPathXmlApplicationContext</code> 类似的有一些特征，下面咱来看看。</p><h4 id="2-7-1-AnnotationConfigApplicationContext是一个最终落地实现"><a href="#2-7-1-AnnotationConfigApplicationContext是一个最终落地实现" class="headerlink" title="2.7.1 AnnotationConfigApplicationContext是一个最终落地实现"></a>2.7.1 AnnotationConfigApplicationContext是一个最终落地实现</h4><blockquote><p>Standalone application context, accepting component classes as input — in particular @Configuration-annotated classes, but also plain @Component types and JSR-330 compliant classes using javax.inject annotations.</p><p>独立的注解驱动的 <code>ApplicationContext</code> ，接受组件类作为输入，特别是使用 <code>@Configuration</code> 注解的类，还可以使用普通的 <code>@Component</code> 类型和符合 JSR-330 规范（使用 <code>javax.inject</code> 包的注解）的类。</p></blockquote><p>注解驱动，除了 <code>@Component</code> 及其衍生出来的几个注解，更重要的是 <code>@Configuration</code> 注解，一个被 <code>@Configuration</code> 标注的类相当于一个 xml 文件。至于下面还提到的关于 JSR-330 的东西，它没有类似于 <code>@Component</code> 的东西（它只是定义了依赖注入的标准，与组件注册无关），它只是说如果一个组件 Bean 里面有 JSR-330 的注解，那它能给解析而已。</p><h4 id="2-7-2-AnnotationConfigApplicationContext解析的配置类也有先后之分"><a href="#2-7-2-AnnotationConfigApplicationContext解析的配置类也有先后之分" class="headerlink" title="2.7.2 AnnotationConfigApplicationContext解析的配置类也有先后之分"></a>2.7.2 AnnotationConfigApplicationContext解析的配置类也有先后之分</h4><blockquote><p>Allows for registering classes one by one using register(Class…) as well as for classpath scanning using scan(String…). In case of multiple @Configuration classes, @Bean methods defined in later classes will override those defined in earlier classes. This can be leveraged to deliberately override certain bean definitions via an extra @Configuration class.</p><p>允许使用 <code>register(Class ...)</code> 一对一注册类，以及使用 <code>scan(String ...)</code> 进行类路径的包扫描。 如果有多个 <code>@Configuration</code> 类，则在以后的类中定义的 <code>@Bean</code>方法将覆盖在先前的类中定义的方法。这可以通过一个额外的 <code>@Configuration</code> 类来故意覆盖某些 <code>BeanDefinition</code> 。</p></blockquote><p>这个操作就跟上面 <code>ClassPathXmlApplicationContext</code> 如出一辙了，它也有配置覆盖的概念。除此之外，它上面还说了初始化的两种方式：要么注册配置类，要么直接进行包扫描。由于注解驱动开发中可能没有一个主配置类，都是一上来就一堆 <code>@Component</code> ，这个时候完全可以直接声明根扫描包，进行组件扫描。</p><p>有关 <code>FileSystemXmlApplicationContext</code> ，以及 Web 环境下扩展的 <code>ApplicationContext</code>，本章不作更多的解析，小伙伴们可以举一反三，根据现有已经了解的知识，对比学习其它的一些 IOC 容器的实现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>05-IOC的BeanFactory</title>
    <link href="/2022/04/17/05-IOC%E7%9A%84BeanFactory/"/>
    <url>/2022/04/17/05-IOC%E7%9A%84BeanFactory/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC容器的详细对比-BeanFactory"><a href="#IOC容器的详细对比-BeanFactory" class="headerlink" title="IOC容器的详细对比-BeanFactory"></a>IOC容器的详细对比-BeanFactory</h1><p>进入 SpringFramework 更深层次的部分，来更透彻的了解 SpringFramework ，从而更好地驾驭它。</p><p>SpringFramework 中的容器最核心的是 <code>BeanFactory</code> 与 <code>ApplicationContext</code> ，但它们还有好多的子接口、抽象类和具体实现类，接下来的两章咱就把这些重要的子接口、实现类都研究个明明白白。</p><h2 id="1-BeanFactory-接口及子接口"><a href="#1-BeanFactory-接口及子接口" class="headerlink" title="1. BeanFactory 接口及子接口"></a>1. BeanFactory 接口及子接口</h2><p>借助 IDEA ，可以将 <code>BeanFactory</code> 接口的所有子接口都取出来，形成一张图：</p><p><img src="/2022/04/17/05-IOC%E7%9A%84BeanFactory/c3fb460e3a9343d5b47a101d9bc5a9df~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image.png" alt="img"></p><p>可以发现，这里面除了一些 <code>BeanFactory</code> 接口的扩展，还有是 <code>ApplicationContext</code> 。</p><p>关于 <code>ApplicationContext</code> 的部分咱放到下一章，这部分只解释 <code>BeanFactory</code> 相关的重要接口。</p><h3 id="1-1-BeanFactory"><a href="#1-1-BeanFactory" class="headerlink" title="1.1 BeanFactory"></a>1.1 BeanFactory</h3><p><code>BeanFactory</code> 作为 SpringFramework 中最顶级的容器接口，它的作用一定是最简单、最核心的。下面咱先来看一看文档注释 ( javadoc ) 中的描述。</p><p>文档注释的内容很多，咱拆分成几个部分来看，并详细解析。</p><h4 id="1-1-1-BeanFactory是根容器"><a href="#1-1-1-BeanFactory是根容器" class="headerlink" title="1.1.1 BeanFactory是根容器"></a>1.1.1 BeanFactory是根容器</h4><blockquote><p>The root interface for accessing a Spring bean container. This is the basic client view of a bean container; further interfaces such as <code>ListableBeanFactory</code> and <code>org.springframework.beans.factory.config.ConfigurableBeanFactory</code> are available for specific purposes.</p><p>用于访问 SpringFramework bean 容器的根接口。这是 bean 容器的基本客户端视图。诸如 <code>ListableBeanFactory</code> 和 <code>org.springframework.beans.factory.config.ConfigurableBeanFactory</code> 之类的扩展接口可用于特定的用途。</p></blockquote><p>这一段的解释是最开始，解释 <code>BeanFactory</code> 是 SpringFramework 中管理 Bean 的容器，它是最最基本的根接口，它下面的扩展接口都是为了实现某些额外的特性（层次性、可搜索性、可配置性等）。</p><h4 id="1-1-2-BeanFactory定义了作用域的概念"><a href="#1-1-2-BeanFactory定义了作用域的概念" class="headerlink" title="1.1.2 BeanFactory定义了作用域的概念"></a>1.1.2 BeanFactory定义了作用域的概念</h4><blockquote><p>This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. “request” and “session” scopes in a web environment).</p><p><code>BeanFactory</code> 接口由包含多个 bean 定义的对象实现，每个 bean 的定义信息均由 “name” 进行唯一标识。</p><p>根据 bean 的定义，SpringFramework 中的工厂会返回所包含对象的独立实例 ( prototype ，原型模式 ) ，或者返回单个共享实例 ( singleton ，单例模式的替代方案，其中实例是工厂作用域中的单例 ) 。</p><p>返回 bean 的实例类型取决于 bean 工厂的配置：API是相同的。从 SpringFramework 2.0 开始，根据具体的应用程序上下文 ( 例如 Web 环境中的 request 和 session 作用域 ) ，可以使用更多作用域。</p></blockquote><p>解释了 <code>BeanFactory</code> 中设计了作用域概念，默认情况下，<code>BeanFactory</code> 中的 Bean 只有<strong>单实例 Bean（<code>singleton</code>）</strong> 和<strong>原型 Bean（<code>prototype</code>）</strong> 。</p><p>自打 SpringFramework2.0 开始，出现了 Web 系列的作用域 <code>“request”</code> 和 <code>“session”</code> ，后续的又出现了 <code>“global session”</code> 和 <code>“websocket”</code> 作用域。</p><p>这里面有一句话不是很好理解：</p><blockquote><p>Which type of instance will be returned depends on the bean factory configuration: the API is the same.</p><p>返回 bean 的实例类型<strong>取决于 bean 工厂的配置</strong>：API都是相同的。</p></blockquote><p>前面的部分还可以，咱知道 Bean 的作用域类型取决于定义的 scope ，但后面的 <code>the API is the same.</code> 是什么鬼呢？回想一下配置 Bean 的作用域是怎么来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>无论是声明单实例 Bean ，还是原型 Bean ，都是用 <code>@Scope</code> 注解标注；在配置类中用 <code>@Bean</code> 注册组件，如果要显式声明作用域，也是用 <code>@Scope</code> 注解。</p><p>由此就可以解释这句话了：产生单实例 Bean 和原型 Bean 所用的 API 是相同的，都是用 <code>@Scope</code> 注解来声明，然后由 <code>BeanFactory</code> 来创建。</p><h4 id="1-1-3-BeanFactory-集成了环境配置"><a href="#1-1-3-BeanFactory-集成了环境配置" class="headerlink" title="1.1.3 BeanFactory 集成了环境配置"></a>1.1.3 BeanFactory 集成了环境配置</h4><blockquote><p>The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of “Expert One-on-One J2EE Design and Development” for a discussion of the benefits of this approach.</p><p>这种方法的重点是 <code>BeanFactory</code> 是应用程序组件的注册中心，并且它集成了应用程序组件的配置（例如不再需要单个对象读取属性文件）。有关此方法的好处的讨论，请参见《Expert One-on-One J2EE Design and Development》的第4章和第11章。</p></blockquote><p>这部分解释了 <code>BeanFactory</code> 它本身是所有 Bean 的注册中心，所有的 Bean 最终都在 <code>BeanFactory</code> 中创建和保存。</p><p>另外 <code>BeanFactory</code> 中还集成了配置信息，通过加载外部的 properties 文件，借助 SpringFramework 的方式将配置文件的属性值设置到 Bean 对象中。</p><p>不过，这里面有关集成配置的概念，其实说的有点老了，自 SpringFramework 3.1 之后出现了一个新的概念叫 <strong><code>Environment</code></strong> ，到后面咱会展开讲解，它才是真正做环境和配置的保存地。</p><h4 id="1-1-4-BeanFactory-推荐使用DI而不是DL"><a href="#1-1-4-BeanFactory-推荐使用DI而不是DL" class="headerlink" title="1.1.4 BeanFactory 推荐使用DI而不是DL"></a>1.1.4 BeanFactory 推荐使用DI而不是DL</h4><blockquote><p>Note that it is generally better to rely on Dependency Injection (“push” configuration) to configure application objects through setters or constructors, rather than use any form of “pull” configuration like a BeanFactory lookup. Spring’s Dependency Injection functionality is implemented using this BeanFactory interface and its subinterfaces.</p><p>请注意，通常最好使用依赖注入（“推”的配置），通过setter方法或构造器注入的方式，配置应用程序对象，而不是使用任何形式的“拉”的配置（例如借助 <code>BeanFactory</code>进行依赖查找）。 </p><p>SpringFramework 的 Dependency Injection 功能是使用 <code>BeanFactory</code> 接口及其子接口实现的。</p></blockquote><p>这部分的内容其实跟 <code>BeanFactory</code> 的关系不是特别大，它阐述的是 SpringFramework 官方在 IOC 的两种实现上的权衡：<strong>推荐使用 DI ，尽可能不要使用 DL</strong> 。</p><p>另外它这里面的一个概念特别好：<strong>DI 的思想是“推”</strong>，它主张把组件需要的依赖“推”到组件的成员上；<strong>DL 的思想是”拉“</strong>，组件需要哪些依赖需要组件自己去 IOC 容器中“拉取”。</p><h4 id="1-1-5-BeanFactory支持多种类型的配置源"><a href="#1-1-5-BeanFactory支持多种类型的配置源" class="headerlink" title="1.1.5 BeanFactory支持多种类型的配置源"></a>1.1.5 BeanFactory支持多种类型的配置源</h4><blockquote><p>Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection).</p><p>通常情况下，<code>BeanFactory</code> 会加载存储在配置源（例如 XML 文档）中 bean 的定义，并使用 <code>org.springframework.beans</code> 包中的 API 来配置 bean 。</p><p>然而，<code>BeanFactory</code> 的实现可以根据需要，直接在 Java 代码中返回它创建的 Java 对象。bean 定义的存储方式没有任何限制，它可以是 LDAP （轻型文件目录访问协议），RDBMS（关系型数据库系统），XML，properties 文件等。</p><p>鼓励实现以支持 Bean 之间的引用（依赖注入）。</p></blockquote><p>这一段告诉我们，SpringFramework 可以支持的配置源类型有很多种，当然咱最常用的还是 <strong>xml</strong> 和<strong>注解驱动</strong>啦 ~  这些配置源中存储的信息是一些 Bean 的定义，这个概念很复杂，咱放到后面的 <code>BeanDefinition</code> 中介绍。</p><h4 id="1-1-6-BeanFactory-实现了容器父子层次关系"><a href="#1-1-6-BeanFactory-实现了容器父子层次关系" class="headerlink" title="1.1.6 BeanFactory 实现了容器父子层次关系"></a>1.1.6 BeanFactory 实现了容器父子层次关系</h4><blockquote><p>In contrast to the methods in ListableBeanFactory, all of the operations in this interface will also check parent factories if this is a HierarchicalBeanFactory. If a bean is not found in this factory instance, the immediate parent factory will be asked. Beans in this factory instance are supposed to override beans of the same name in any parent factory.</p><p>与 <code>ListableBeanFactory</code> 中的方法相比，<code>BeanFactory</code> 中的所有操作还将检查父工厂（如果这是 <code>HierarchicalBeanFactory</code> ）。</p><p>如果在 <code>BeanFactory</code> 实例中没有找到指定的 bean ，则会向父工厂中搜索查找。<code>BeanFactory</code> 实例中的 Bean 会覆盖任何父工厂中的同名 Bean 。</p></blockquote><p>这部分想告诉我们的是，<code>BeanFactory</code> 本身可以支持父子结构，这个父子结构的概念和实现由 <code>HierarchicalBeanFactory</code> 实现，在 <code>BeanFactory</code> 中它也只是提了一下。</p><p>这部分咱放到下面的 <code>HierarchicalBeanFactory</code> 中解释。</p><h4 id="1-1-7-BeanFactory-有-Bean-的完整的生命周期控制"><a href="#1-1-7-BeanFactory-有-Bean-的完整的生命周期控制" class="headerlink" title="1.1.7 BeanFactory 有 Bean 的完整的生命周期控制"></a>1.1.7 BeanFactory 有 Bean 的完整的生命周期控制</h4><blockquote><p>Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:</p><ol><li>BeanNameAware’s <code>setBeanName</code></li><li>BeanClassLoaderAware’s <code>setBeanClassLoader</code></li><li>……</li></ol><p>On shutdown of a bean factory, the following lifecycle methods apply: ……</p><p><code>BeanFactory</code> 接口实现了尽可能支持标准 Bean 的生命周期接口。全套初始化方法及其标准顺序为：……</p><p>在关闭 <code>BeanFactory</code> 时，以下生命周期方法适用：……</p></blockquote><p>由这一段咱能很清楚的了解到，Bean 的生命周期是在 <code>BeanFactory</code> 中就有设计的，而且官方文档也提供了全套的 init 和 destory 流程，这个咱在这里不展开，后面会有专门介绍完整的 Bean 的生命周期的章节来讲解此部分内容（讲真想完整理解好也挺难的，先做好心理预备）。</p><h3 id="1-2-HierarchicalBeanFactory"><a href="#1-2-HierarchicalBeanFactory" class="headerlink" title="1.2 HierarchicalBeanFactory"></a>1.2 HierarchicalBeanFactory</h3><p>从类名上能很容易的理解，它是体现了层次性的 <code>BeanFactory</code> 。有了这个特性，<code>BeanFactory</code> 就有了父子层次结构。</p><blockquote><p>Sub-interface implemented by bean factories that can be part of a hierarchy.</p><p>The corresponding setParentBeanFactory method for bean factories that allow setting the parent in a configurable fashion can be found in the ConfigurableBeanFactory interface.</p><p>由 <code>BeanFactory</code> 实现的子接口，它可以理解为是层次结构的一部分。</p><p>可以在 <code>ConfigurableBeanFactory</code> 接口中找到用于 <code>BeanFactory</code> 的相应 <code>setParentBeanFactory</code> 方法，该方法允许以可配置的方式设置父容器。</p></blockquote><p>对应的接口方法定义中，就有这么一个方法：**<code>getParentBeanFactory()</code>** ，它就可以获取到父 <code>BeanFactory</code> 对象；</p><p>接口中还有一个方法是 <code>containsLocalBean(String name)</code> ，它是检查当前本地的容器中是否有指定名称的 Bean ，而不会往上找父 <code>BeanFactory</code> 。</p><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">getBean` 方法会从当前 `BeanFactory` 开始查找是否存在指定的 Bean ，如果当前找不到就依次向上找父 `BeanFactory` ，直到找到为止返回，或者都找不到最终抛出 `NoSuchBeanDefinitionException。<br><br>注意这里的说法：如果当前找不到就往上找，那如果找到了就不往上找了。<br></code></pre></td></tr></table></figure><p>思考一个问题：如果当前 <code>BeanFactory</code> 中存在有一个 Bean 了，父 <code>BeanFactory</code> 中可能有相同的这个 Bean 吗？</p></blockquote><ul><li>答案是肯定的，因为即便存在父子关系，但他们本质上是不同的容器，所以有可能找到多个相同的 Bean。</li><li>换句话说，<code>@Scope</code> 中声明的 Singleton 只是在一个容器中是单实例的，但有了层次性结构后，对于整体的多个容器来看，就不是单实例的了。</li></ul><p>至于怎么设置父 <code>BeanFactory</code> ，文档注释中也说了，要用 <code>ConfigurableBeanFactory</code> 的 <code>setParentBeanFactory</code> 方法，那至于 <code>ConfigurableBeanFactory</code> 是什么东西，咱下面自然会解释。</p><h3 id="1-3-ListableBeanFactory"><a href="#1-3-ListableBeanFactory" class="headerlink" title="1.3 ListableBeanFactory"></a>1.3 ListableBeanFactory</h3><p>类名理解为<strong>“可列举”</strong>的 <code>BeanFactory</code> ，它的文档也把这个特性解释的很清楚，咱一段一段来读。</p><h4 id="1-3-1-可列举容器中的所有Bean实例"><a href="#1-3-1-可列举容器中的所有Bean实例" class="headerlink" title="1.3.1 可列举容器中的所有Bean实例"></a>1.3.1 可列举容器中的所有Bean实例</h4><blockquote><p>Extension of the BeanFactory interface to be implemented by bean factories that can enumerate all their bean instances, rather than attempting bean lookup by name one by one as requested by clients. BeanFactory implementations that preload all their bean definitions (such as XML-based factories) may implement this interface.</p><p>它是 <code>BeanFactory</code> 接口的扩展实现，它可以列举出所有 bean 实例，而不是按客户端调用的要求，按照名称一一进行 bean 的依赖查找。</p><p>具有 “预加载其所有 bean 定义信息” 的 <code>BeanFactory</code> 实现（例如基于XML的 <code>BeanFactory</code> ）可以实现此接口。</p></blockquote><p>这段话比较好理解了，它的扩展功能是能让咱在拿到 <code>BeanFactory</code> 时可以直接把容器中的所有 Bean 都拿出来，也就相当于提供了针对容器中的Bean可迭代的特性，而不是挨个的拿Bean的名字去GET。</p><p>后面提到了一个概念，叫 “预加载所有 bean 的定义信息” ，这个也是涉及到 <code>BeanDefinition</code> 的东西了，后面到 <code>BeanDefinition </code>时再详细介绍。</p><h4 id="1-3-2-仅列举在当前层次容器中的Bean实例"><a href="#1-3-2-仅列举在当前层次容器中的Bean实例" class="headerlink" title="1.3.2 仅列举在当前层次容器中的Bean实例"></a>1.3.2 仅列举在当前层次容器中的Bean实例</h4><blockquote><p>If this is a HierarchicalBeanFactory, the return values will not take any BeanFactory hierarchy into account, but will relate only to the beans defined in the current factory. Use the BeanFactoryUtils helper class to consider beans in ancestor factories too.</p><p>如果当前 <code>BeanFactory</code> 同时也是 <code>HierarchicalBeanFactory</code> ，则返回值会忽略 <code>BeanFactory</code> 的层次结构，仅仅与当前 <code>BeanFactory</code> 中定义的 bean 有关。</p><p>除此之外，也可以使用 <code>BeanFactoryUtils</code> 来考虑父 <code>BeanFactory</code> 中的 bean 实例。</p></blockquote><p>通过这部分可以了解到另外一个特性：</p><ul><li><code>ListableBeanFactory</code> 只会列举当前容器的 Bean 实例，因为咱上面也看了，<code>BeanFactory</code> 可以具有层次性，那这样再列举所有 Bean 的时候，就需要斟酌到底是获取包括父容器在内的所有 Bean ，还是只获取当前容器中的 Bean ，SpringFramework 在斟酌之后选择了只获取当前容器中的 Bean 实例；</li><li>而如果真的想获取所有 Bean ，可以借助 <code>BeanFactoryUtils</code> 工具类来实现（工具类中有不少以 <code>&quot;IncludingAncestors&quot;</code> 结尾的方法，代表可以一起取父容器）。</li></ul><h4 id="1-3-3-是有选择性的列举"><a href="#1-3-3-是有选择性的列举" class="headerlink" title="1.3.3 是有选择性的列举"></a>1.3.3 是有选择性的列举</h4><blockquote><p>The methods in this interface will just respect bean definitions of this factory. They will ignore any singleton beans that have been registered by other means like org.springframework.beans.factory.config.ConfigurableBeanFactory’s registerSingleton method, with the exception of getBeanNamesForType and getBeansOfType which will check such manually registered singletons too. Of course, BeanFactory’s getBean does allow transparent access to such special beans as well. However, in typical scenarios, all beans will be defined by external bean definitions anyway, so most applications don’t need to worry about this differentiation.</p><p><code>ListableBeanFactory</code> 中的方法将仅遵循当前工厂的 bean 定义，它们将<strong>忽略通过其他方式</strong>，例如 <code>ConfigurableBeanFactory</code> 的 <code>registerSingleton</code> 方法注册的任何单实例 bean。</p><p> <code>getBeanNamesForType</code> 和 <code>getBeansOfType</code> 除外，它们也会检查这种手动注册的单实例 Bean 。</p><p>当然，<code>BeanFactory</code> 的 <code>getBean</code> 确实也允许透明访问此类特殊 bean 。在一般情况下，无论如何所有的 bean 都来自由外部的 bean 定义信息，因此大多数应用程序不必担心这种区别。</p></blockquote><p>这一段注释的意思似乎有点让人摸不着头脑：</p><p>作为一个“可迭代”的 <code>BeanFactory</code> ，按理来讲应该最起码得把当前容器中的所有 Bean 都列出来，结果你又告诉我有些 Bean 会被忽略掉不给列出，到底想怎样嘛！</p><p>ヽ(`Д´)ﾉ 别着急，下面会给出解释的，不过在解释之前，咱先演示一下这段注释的代码体现。</p><p>创建两个最最简单的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure><p>之后编写 xml 配置文件，只注册 Cat 进去：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.container.a_beanfactory.bean.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>选用 <code>BeanFactory</code> 的最终实现来构造 IOC 容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListableBeanFactoryApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathResource resource = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;container/listable-container.xml&quot;</span>);<br>        DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<br>        XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);<br>        beanDefinitionReader.loadBeanDefinitions(resource);<br>        <span class="hljs-comment">// 直接打印容器中的所有Bean</span><br>        System.out.println(<span class="hljs-string">&quot;加载xml文件后容器中的Bean：&quot;</span>);<br>        Stream.of(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这种方式，也可以加载 xml 配置文件，完成 IOC 容器的构建，此时直接打印 IOC 容器中的 Bean ，发现确实只有一个 cat ：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">加载xml文件后容器中的Bean：<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.container</span><span class="hljs-selector-class">.a_beanfactory</span><span class="hljs-selector-class">.bean</span>.Cat#<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>通过 registerSingleton 方法注册，虽然现在看来这个操作小伙伴还不熟悉，但是没关系先跟着敲，了解一下还有这种操作就 OK ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListableBeanFactoryApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathResource resource = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;container/listable-container.xml&quot;</span>);<br>        DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<br>        XmlBeanDefinitionReader beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);<br>        beanDefinitionReader.loadBeanDefinitions(resource);<br>        <span class="hljs-comment">// 直接打印容器中的所有Bean</span><br>        System.out.println(<span class="hljs-string">&quot;加载xml文件后容器中的Bean：&quot;</span>);<br>        Stream.of(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);<br>        System.out.println();<br>        <br>        <span class="hljs-comment">// 手动注册一个单实例 Bean</span><br>        beanFactory.registerSingleton(<span class="hljs-string">&quot;doggg&quot;</span>, <span class="hljs-keyword">new</span> Dog());<br>        <span class="hljs-comment">// 再打印容器中的所有 Bean</span><br>        System.out.println(<span class="hljs-string">&quot;手动注册单实例Bean后容器中的所有Bean：&quot;</span>);<br>        Stream.of(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次运行 <code>main</code> 方法，可以发现控制台还是只打印了一个 cat ：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">加载xml文件后容器中的Bean：<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.container</span><span class="hljs-selector-class">.a_beanfactory</span><span class="hljs-selector-class">.bean</span>.Cat#<span class="hljs-number">0</span><br><br>手动注册单实例Bean后容器中的所有Bean：<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.container</span><span class="hljs-selector-class">.a_beanfactory</span><span class="hljs-selector-class">.bean</span>.Cat#<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>是不是突然一脸楞逼，也或者突然明白上面文档注释中说的那句话了？</p><p><code>ListableBeanFactory</code> 在获取容器内所有 Bean 时真的不会把这些手动注册的拿出来，也就是文档注释中说的 <strong>“忽略通过其他方式”</strong> ！可是容器里真的有 <code>Dog</code> 了吗？</p><p>在上面的启动类 <code>main</code> 方法最后再追加这么几行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;容器中真的有注册Dog：&quot;</span> + beanFactory.getBean(<span class="hljs-string">&quot;doggg&quot;</span>));<br><span class="hljs-comment">// 通过getBeanNamesOfType查找Dog</span><br>System.out.println(<span class="hljs-string">&quot;容器中的所有Dog：&quot;</span> + Arrays.toString(beanFactory.getBeanNamesForType(Dog.class)));<br></code></pre></td></tr></table></figure><p>重新运行，控制台打印了 <code>Dog</code> 的地址和名称：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">容器中真的有注册Dog：com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.container</span><span class="hljs-selector-class">.a_beanfactory</span><span class="hljs-selector-class">.bean</span>.Dog@<span class="hljs-number">50</span>cbc42f<br>容器中的所有Dog：<span class="hljs-selector-attr">[doggg]</span><br></code></pre></td></tr></table></figure><p>说明文档注释中说的 <code>getBeanNamesOfType</code> 和 <code>getBeansOfType</code> 两个方法是例外的，它们可以取到手动注册的 Bean 。</p><p>现象看到了，可它为什么要这么设计呢？这里只是先简单提一下，后面在讲解 <code>BeanDefinition</code> 章节部分时会回来填这个坑的。</p><p>借助 IDEA ，查看 <code>ConfigurableBeanFactory</code> 的 <code>registerSingleton</code> 方法调用，可以发现在一个叫 <code>AbstractApplicationContext</code> 的 <code>prepareBeanFactory</code> 方法中有一些使用：（源码节选）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Register default environment beans.</span><br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;<br>  beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;<br>  beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;<br>  beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现它在这里直接注册了几个关于环境信息的组件，而这些组件都是属于 SpringFramework 内部使用的，这样做的目的是 SpringFramework 不希望咱开发者直接操控他们，于是就使用了这种方式来隐藏它们。</p><blockquote><p>这个设计如果不是很好理解的话，我举另外一个例子：在 Windows 系统中，系统不希望咱用户去随意改动系统内部使用的一些文件，会在文件资源管理器中设置一个选项：<strong>隐藏受保护的操作系统文件</strong>（在控制面板 → 文件资源管理器选项中）。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3a847772a8048098e49275da443c76b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>默认情况下这个选项是勾选的（意思就是这些文件我都藏起来了，我自己管理就行，不用你操心），当然你可以取消勾选它，这样文件资源管理器中也能显示那些操作系统的文件，但你要是真的动了它们，指不定你的机器就出什么问题了。</p></blockquote><p>这里我不理解的一点是 SpringFramework 不希望咱开发者直接操控这种，但是我们就操纵不了吗？这里的实现好像是绕过 BeanDefinition 的注册，直接向容器中放入 Bean 实例。</p><h4 id="1-3-4-LBF大部分方法都不适合频繁调用"><a href="#1-3-4-LBF大部分方法都不适合频繁调用" class="headerlink" title="1.3.4 LBF大部分方法都不适合频繁调用"></a>1.3.4 LBF大部分方法都不适合频繁调用</h4><blockquote><p>NOTE: With the exception of getBeanDefinitionCount and containsBeanDefinition, the methods in this interface are not designed for frequent invocation. Implementations may be slow.</p><p>注意：除了 <code>getBeanDefinitionCount</code> 和 <code>containsBeanDefinition</code> 之外，此接口中的方法不适用于频繁调用，方法的实现可能执行速度会很慢。</p></blockquote><h3 id="1-4-AutowireCapableBeanFactory"><a href="#1-4-AutowireCapableBeanFactory" class="headerlink" title="1.4 AutowireCapableBeanFactory"></a>1.4 AutowireCapableBeanFactory</h3><p>类名中有一个熟悉的概念：自动注入，它的意思就应该是：支持自动注入的 <code>BeanFactory</code> 。那是不是就意味着，这个扩展的 <code>BeanFactory</code> 就可以支持 DI 了呢？</p><h4 id="1-4-1-ACBF-可以支持外部-Bean-的自动装配"><a href="#1-4-1-ACBF-可以支持外部-Bean-的自动装配" class="headerlink" title="1.4.1 ACBF 可以支持外部 Bean 的自动装配"></a>1.4.1 ACBF 可以支持外部 Bean 的自动装配</h4><blockquote><p>Extension of the BeanFactory interface to be implemented by bean factories that are capable of autowiring, provided that they want to expose this functionality for existing bean instances.</p><p>它是 <code>BeanFactory</code> 接口的扩展实现，它可以实现自动装配，前提是开发者希望为现有的 bean 实例公开此功能。</p></blockquote><p>意思是：AutowireCapableBeanFactory 本身可以支持自动装配，而且还可以为现有的一些 Bean 也能支持自动装配。</p><p>而这个 “现有” 的概念，实际上指的是那些不被 SpringFramework 管理的 Bean ，下面两段话就有解释：</p><h4 id="1-4-2-ACBF-用于框架集成"><a href="#1-4-2-ACBF-用于框架集成" class="headerlink" title="1.4.2 ACBF 用于框架集成"></a>1.4.2 ACBF 用于框架集成</h4><blockquote><p>This subinterface of BeanFactory is not meant to be used in normal application code: stick to BeanFactory or ListableBeanFactory for typical use cases.</p><p>Integration code for other frameworks can leverage this interface to wire and populate existing bean instances that Spring does not control the lifecycle of. This is particularly useful for WebWork Actions and Tapestry Page objects, for example.</p><p><code>AutowireCapableBeanFactory</code> 这个子接口不能在常规的应用程序代码中使用：一般情况下，请坚持使用 <code>BeanFactory</code> 或 <code>ListableBeanFactory</code> 。 其他框架的集成代码可以利用此接口来连接和注入 SpringFramework 无法控制其生命周期的现有 bean 实例。例如，这对于 WebWork 操作和 Tapestry 页面对象特别有用。</p></blockquote><p>这两段话想表达的意思，主要是说这个 <code>AutowireCapableBeanFactory</code> 一般不要让咱自己用，而是在与其他框架进行集成时才使用。</p><p>注意这里面它的描述：利用此接口来连接和注入 SpringFramework 无法控制其生命周期的现有 bean 实例，这其实已经把它的作用完整的描述出来了：</p><blockquote><p>你要是真想用它，那也是在跟其它框架集成时，比如其它框架的一些 Bean 实例无法让 SpringFramework 控制，但又需要注入一些由 SpringFramework 管理的对象，那就可以用它了。</p></blockquote><p>下面介绍一个，这个思路有什么使用场景：</p><blockquote><p>你自己编写了一个 Servlet ，这个 Servlet 并不在容器的管理范围 ，但是这个 Servlet 里面需要引入 IOC 容器中的一个存在的 Service ，应该如何处理呢？</p><p>根据 IOC 的思路，很明显还是两种思路：</p><ul><li>DL ：由 Servlet 自己取到 IOC 容器，并直接从 IOC 容器中获取到对应的 Service 并保存至成员属性中</li><li>DI ：给需要注入的 Service 上标注 <code>@Autowired</code> 等自动注入的注解，并且让 IOC 容器识别这个 Servlet ，完成自动注入</li></ul><p>对于 DL 的实现，SpringFramework 有一种机制可以让 Servlet 取到 IOC 容器；而 DI 的实现，就需要这个 <code>AutowireCapableBeanFactory</code> 帮忙注入了。至于这部分怎么搞，咱放到后面介绍 Web 部分时再讲解。</p></blockquote><h4 id="1-4-3-ACBF-不由-ApplicationContext-实现但可从中获取"><a href="#1-4-3-ACBF-不由-ApplicationContext-实现但可从中获取" class="headerlink" title="1.4.3 ACBF 不由 ApplicationContext 实现但可从中获取"></a>1.4.3 ACBF 不由 ApplicationContext 实现但可从中获取</h4><p>Note that this interface is not implemented by ApplicationContext facades, as it is hardly ever used by application code. That said, it is available from an application context too, accessible through ApplicationContext’s getAutowireCapableBeanFactory() method.</p><p>该接口没有在 <code>ApplicationContext</code> 中实现，因为应用程序代码几乎从未使用过此接口。</p><p>也就是说，这个扩展你们一般用不到，但它确实在我们需要的时候从应用程序上下文中获得，通过 <code>ApplicationContext</code> 的 <code>getAutowireCapableBeanFactory()</code> 方法进行访问。</p><h4 id="1-4-4-ACBF-可以借助-BeanFactoryAware-回调注入"><a href="#1-4-4-ACBF-可以借助-BeanFactoryAware-回调注入" class="headerlink" title="1.4.4 ACBF 可以借助 BeanFactoryAware 回调注入"></a>1.4.4 ACBF 可以借助 BeanFactoryAware 回调注入</h4><blockquote><p>You may also implement the org.springframework.beans.factory.BeanFactoryAware interface, which exposes the internal BeanFactory even when running in an ApplicationContext, to get access to an AutowireCapableBeanFactory: simply cast the passed-in BeanFactory to AutowireCapableBeanFactory.</p></blockquote><p>这部分告诉咱，其实通过 <code>BeanFactoryAware</code> 接口回调注入的 <code>BeanFactory</code> 也就是 <code>AutowireCapableBeanFactory</code> ，可以直接强转拿来用。</p><p>这个说实话，提不提这个都行，注入 <code>ApplicationContext</code> 一样可以拿到它。</p><h3 id="1-5-ConfigurableBeanFactory"><a href="#1-5-ConfigurableBeanFactory" class="headerlink" title="1.5 ConfigurableBeanFactory"></a>1.5 ConfigurableBeanFactory</h3><p>从类名中就能意识到，这个扩展已经具备了 “<strong>可配置</strong>” 的特性，这个概念咱要拿出来解释一下了。</p><h4 id="1-5-0-可读-amp-可写"><a href="#1-5-0-可读-amp-可写" class="headerlink" title="1.5.0 可读&amp;可写"></a>1.5.0 可读&amp;可写</h4><p>回想一开始学习面向对象编程时，就知道一个类的属性设置为 private 后，提供 <strong>get</strong> 方法则意味着该属性<strong>可读</strong>，提供 <strong>set</strong> 方法则意味着该属性<strong>可写</strong>。</p><p>同样的，在 SpringFramework 的这些 <code>BeanFactory</code> ，包括后面的 <code>ApplicationContext</code> 中，都会有这样的设计。</p><p>普通的 <code>BeanFactory</code> 只有 get 相关的操作，而 <strong>Configurable</strong> 开头的 <code>BeanFactory</code> 或者 <code>ApplicationContext</code> 就具有了 set 的操作：（节选自 <code>ConfigurableBeanFactory</code> 的方法列表）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBeanClassLoader</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader beanClassLoader)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setTypeConverter</span><span class="hljs-params">(TypeConverter typeConverter)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addBeanPostProcessor</span><span class="hljs-params">(BeanPostProcessor beanPostProcessor)</span></span>;<br></code></pre></td></tr></table></figure><p>理解了这个概念，咱可以来看 <code>ConfigurableBeanFactory</code> 的文档注释了。</p><h4 id="1-5-1-CBF-提供可配置的功能"><a href="#1-5-1-CBF-提供可配置的功能" class="headerlink" title="1.5.1 CBF 提供可配置的功能"></a>1.5.1 CBF 提供可配置的功能</h4><blockquote><p>Configuration interface to be implemented by most bean factories. Provides facilities to configure a bean factory, in addition to the bean factory client methods in the BeanFactory interface. 大多数 <code>BeanFactory</code> 的实现类都会实现这个带配置的接口。除了 <code>BeanFactory</code> 接口中的基础获取方法之外，还提供了配置 <code>BeanFactory</code> 的功能。</p></blockquote><p>一上来就说明白了，<code>ConfigurableBeanFactory</code> 已经提供了<strong>带配置的功能</strong>，可以调用它里面定义的方法来对 <code>BeanFactory</code> 进行修改、扩展等。</p><h4 id="1-5-2-CBF-不推荐给开发者使用"><a href="#1-5-2-CBF-不推荐给开发者使用" class="headerlink" title="1.5.2 CBF 不推荐给开发者使用"></a>1.5.2 CBF 不推荐给开发者使用</h4><blockquote><p>This bean factory interface is not meant to be used in normal application code: Stick to BeanFactory or org.springframework.beans.factory.ListableBeanFactory for typical needs. This extended interface is just meant to allow for framework-internal plug’n’play and for special access to bean factory configuration methods.</p><p><code>ConfigurableBeanFactory</code> 接口并不希望开发者在应用程序代码中使用，而是坚持使用 <code>BeanFactory</code> 或 <code>ListableBeanFactory</code> 。此扩展接口仅用于允许在框架内部进行即插即用，并允许对 <code>BeanFactory</code> 中的配置方法的特殊访问。</p></blockquote><p>下面又说了，SpringFramework 不希望开发者用 <code>ConfigurableBeanFactory</code> ，而是老实的用最根本的 <code>BeanFactory</code> ，原因也很简单，程序在运行期间按理不应该对 <code>BeanFactory</code> 再进行频繁的变动，此时只应该有读的动作，而不应该出现写的动作。</p><p>到这里，有关 <code>BeanFactory</code> 和它扩展的重要接口也就了解的差不多了，下面咱看看有关 <code>BeanFactory</code> 的实现类，看看 SpringFramework 是如何有层次的划分 <code>BeanFactory</code> 的功能职责的。</p><h2 id="2-BeanFactory-的实现类"><a href="#2-BeanFactory-的实现类" class="headerlink" title="2. BeanFactory 的实现类"></a>2. BeanFactory 的实现类</h2><p>跟前面一样，借助 IDEA ，可以将 <code>BeanFactory</code> 的实现类取出来，形成一张图：（当然，这里面不是所有的，只包含最核心的实现类）</p><p><img src="/2022/04/17/05-IOC%E7%9A%84BeanFactory/07b6807731d4430185d5ec7ea8483fbc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image.png" alt="img"></p><p>注意到这里面不止有 <code>BeanFactory</code> 接口，还出现了几个陌生的接口（ <code>SingletonBeanRegistry</code> 、<code>BeanDefinitionRegistry</code> ），这些咱暂时不关心，放到后面的章节再解释。</p><h3 id="2-1-AbstractBeanFactory"><a href="#2-1-AbstractBeanFactory" class="headerlink" title="2.1 AbstractBeanFactory"></a>2.1 AbstractBeanFactory</h3><p>为什么一上来先说它，而不是它的父类 <code>DefaultSingletonBeanRegistry</code> 呢？很简单，咱介绍的是 <code>BeanFactory</code> 的实现类，<code>DefaultSingletonBeanRegistry</code> 并没有实现。</p><p>从类名上就知道，它是 <code>BeanFactory</code> 最基本的抽象实现，当然作为一个抽象类，一定是只具备了部分功能，不是完整的实现。先看一眼文档注释，对这个类有一个大概的了解。</p><h4 id="2-1-1-ABF-是最终-BeanFactory-的基础实现"><a href="#2-1-1-ABF-是最终-BeanFactory-的基础实现" class="headerlink" title="2.1.1 ABF 是最终 BeanFactory 的基础实现"></a>2.1.1 ABF 是最终 BeanFactory 的基础实现</h4><blockquote><p>Abstract base class for BeanFactory implementations, providing the full capabilities of the ConfigurableBeanFactory SPI. Does not assume a listable bean factory: can therefore also be used as base class for bean factory implementations which obtain bean definitions from some backend resource (where bean definition access is an expensive operation).</p><p>它是 <code>BeanFactory</code> 接口最基础的抽象实现类，提供 <code>ConfigurableBeanFactory</code> SPI 的全部功能。我们不假定有一个可迭代的 <code>BeanFactory</code> ，因此也可以用作 <code>BeanFactory</code> 实现的父类，该实现可以从某些后端资源（其中 bean 定义访问是一项昂贵的操作）获取 bean 的定义。</p></blockquote><p>这段注释说好理解，但又有点不好理解。其实它就想表达一个意思：<code>AbstractBeanFactory</code>是作为 <code>BeanFactory</code> 接口下面的第一个抽象的实现类，它具有最基础的功能，并且它可以从配置源（之前看到的 xml 、LDAP 、RDBMS 等）获取 Bean 的定义信息，而这个 Bean 的定义信息就是 <code>BeanDefinition</code> ，已经提到了很多遍了，但是不要着急，咱后面会接触到的。</p><p>把这些都读完，剩下一个咱不认识的概念：<strong>SPI</strong> ，这是个什么东西呢？这里咱简单提一下，SPI 全称为 <strong>Service Provider Interface</strong>，是 JDK 内置的一种服务提供发现机制。说白了，它可以加载预先在特定位置下配置的一些类。关于 SPI 的部分，会在后面的 “模块装配高级” 中更详细的讲解。</p><h4 id="2-1-2-ABF-对-Bean-的支持"><a href="#2-1-2-ABF-对-Bean-的支持" class="headerlink" title="2.1.2 ABF 对 Bean 的支持"></a>2.1.2 ABF 对 Bean 的支持</h4><blockquote><p>This class provides a singleton cache (through its base class DefaultSingletonBeanRegistry), singleton/prototype determination, FactoryBean handling, aliases, bean definition merging for child bean definitions, and bean destruction (org.springframework.beans.factory.DisposableBean interface, custom destroy methods). Furthermore, it can manage a bean factory hierarchy (delegating to the parent in case of an unknown bean), through implementing the org.springframework.beans.factory.HierarchicalBeanFactory interface.</p><p>此类可以提供单实例 Bean 的缓存（通过其父类 <code>DefaultSingletonBeanRegistry</code>），单例/原型 Bean 的决定，<code>FactoryBean</code> 处理，Bean 的别名，用于子 bean 定义的 bean 定义合并以及 bean 销毁（ <code>DisposableBean</code> 接口，自定义 <code>destroy</code> 方法）。此外，它可以通过实现 <code>HierarchicalBeanFactory</code> 接口来管理 <code>BeanFactory</code> 层次结构（在未知 bean 的情况下委托给父工厂）。</p></blockquote><p>从这部分的描述中，咱看到除了在之前 <code>BeanFactory</code> 中介绍的功能和特性之外，它还扩展了另外一些功能：</p><ul><li>别名的处理（来源于 <code>AliasRegistry</code> 接口）；</li><li>Bean 定义的合并（涉及到 Bean 的继承，后续章节讲解）；</li><li>Bean 的销毁动作支持（ <code>DisposableBean</code> ）；</li></ul><p>等等，这些特性有一些咱已经见过了，有一些还没有接触，咱后面都会来展开介绍。</p><h4 id="2-1-3-ABF-定义了模板方法"><a href="#2-1-3-ABF-定义了模板方法" class="headerlink" title="2.1.3 ABF 定义了模板方法"></a>2.1.3 ABF 定义了模板方法</h4><blockquote><p>The main template methods to be implemented by subclasses are getBeanDefinition and createBean, retrieving a bean definition for a given bean name and creating a bean instance for a given bean definition, respectively. Default implementations of those operations can be found in DefaultListableBeanFactory and AbstractAutowireCapableBeanFactory.</p><p>子类要实现的主要模板方法是 <code>getBeanDefinition</code> 和 <code>createBean</code> ，分别为给定的 bean 名称检索 bean 定义信息，并根据给定的 bean 定义信息创建 bean 的实例。这些操作的默认实现可以在 <code>DefaultListableBeanFactory</code> 和 <code>AbstractAutowireCapableBeanFactory</code> 中找到。</p></blockquote><p>这一段告诉我们一个很关键的信息：</p><p>SpringFramework 中大量使用 <strong>模板方法模式</strong> 来设计核心组件，它的思路是：<strong>父类提供逻辑规范，子类提供具体步骤的实现</strong>。</p><p>在文档注释中，咱看到 <code>AbstractBeanFactory</code> 中对 <code>getBeanDefinition</code> 和 <code>createBean</code> 两个方法进行了规范上的定义，分别代表获取 Bean 的定义信息，以及创建 Bean 的实例，这两个方法都会在 SpringFramework 的 IOC 容器初始化阶段起到至关重要的作用。</p><p>多说一句，<code>createBean</code> 是 SpringFramework 能管控的所有 Bean 的创建入口。</p><h3 id="2-2-AbstractAutowireCapableBeanFactory"><a href="#2-2-AbstractAutowireCapableBeanFactory" class="headerlink" title="2.2 AbstractAutowireCapableBeanFactory"></a>2.2 AbstractAutowireCapableBeanFactory</h3><p>根据类名，可以看出来，它已经到了 <code>AutowireCapableBeanFactory</code> 接口的落地实现了，那就意味着，它可以实现组件的自动装配了。其实它的作用不仅仅是这么点，看小册标注的【掌握】也应该意识到它的重要，这个实现会比较详细的展开解释。</p><h4 id="2-2-1-AACBF-提供Bean的创建逻辑实现"><a href="#2-2-1-AACBF-提供Bean的创建逻辑实现" class="headerlink" title="2.2.1 AACBF 提供Bean的创建逻辑实现"></a>2.2.1 AACBF 提供Bean的创建逻辑实现</h4><blockquote><p>Abstract bean factory superclass that implements default bean creation, with the full capabilities specified by the RootBeanDefinition class. Implements the AutowireCapableBeanFactory interface in addition to AbstractBeanFactory’s createBean method.</p><p>它是实现了默认 bean 创建逻辑的的抽象的 <code>BeanFactory</code> 实现类，它具有 <code>RootBeanDefinition</code> 类指定的全部功能。除了 <code>AbstractBeanFactory</code> 的 <code>createBean</code> 方法之外，还实现 <code>AutowireCapableBeanFactory</code> 接口。</p></blockquote><p>一上来文档注释就告诉咱了，这个 <code>AbstractAutowireCapableBeanFactory</code> 继承了 <code>AbstractBeanFactory</code> 抽象类，还额外实现了 <code>AutowireCapableBeanFactory</code> 接口，那实现了这个接口就代表着，它可以 <strong>实现自动注入的功能</strong> 了。除此之外，它还把 <code>AbstractBeanFactory</code> 的 <code>createBean</code> 方法给实现了，代表它还具有<strong>创建 Bean 的功能</strong>。</p><p>这个地方要多说一嘴，其实 <strong><code>createBean</code> 方法也不是最终实现 Bean 的创建</strong>，而是有另外一个叫 <strong><code>doCreateBean</code></strong> 方法，它同样在 <code>AbstractAutowireCapableBeanFactory</code> 中定义，而且是 <strong>protected</strong> 方法，没有子类重写它，算是它独享的了。关于这个 <code>doCreateBean</code> 的实现，是相当复杂的，涉及到的知识点特别多，咱后面遇到时再解释，或者小伙伴可以参照<a href="https://juejin.cn/book/5da3bc3d6fb9a04e35597a76">《SpringBoot 源码解读与原理分析》</a>小册中的第 14 、15 章进行学习，本小册中对于该部分内容不会特别深的展开。</p><h4 id="2-2-2-AACBF-实现了属性赋值和组件注入"><a href="#2-2-2-AACBF-实现了属性赋值和组件注入" class="headerlink" title="2.2.2 AACBF 实现了属性赋值和组件注入"></a>2.2.2 AACBF 实现了属性赋值和组件注入</h4><blockquote><p>Provides bean creation (with constructor resolution), property population, wiring (including autowiring), and initialization. Handles runtime bean references, resolves managed collections, calls initialization methods, etc. Supports autowiring constructors, properties by name, and properties by type.</p><p>提供 Bean 的创建（具有构造方法的解析），属性填充，属性注入（包括自动装配）和初始化。处理运行时 Bean 的引用，解析托管集合，调用初始化方法等。支持自动装配构造函数，按名称的属性和按类型的属性。</p></blockquote><p>这一段已经把 <code>AbstractAutowireCapableBeanFactory</code> 中实现的最最核心功能全部列出来了：</p><ol><li>Bean 的创建；</li><li>属性填充和依赖的自动注入；</li><li>Bean 的初始化。</li></ol><p>这部分是<strong>创建 Bean 最核心的三个步骤</strong>，后续在讲解 Bean 的完整生命周期时，会详细深入的讲解这部分，小伙伴要做好思想准备哦。</p><h4 id="2-2-3-AACBF-保留了模板方法"><a href="#2-2-3-AACBF-保留了模板方法" class="headerlink" title="2.2.3 AACBF 保留了模板方法"></a>2.2.3 AACBF 保留了模板方法</h4><blockquote><p>The main template method to be implemented by subclasses is resolveDependency(DependencyDescriptor, String, Set, TypeConverter), used for autowiring by type. In case of a factory which is capable of searching its bean definitions, matching beans will typically be implemented through such a search. For other factory styles, simplified matching algorithms can be implemented.</p><p>子类要实现的主要模板方法是 <code>resolveDependency(DependencyDescriptor, String, Set, TypeConverter)</code> ，用于按类型自动装配。如果工厂能够搜索其 bean 定义，则通常将通过此类搜索来实现匹配的 bean 。对于其他工厂样式，可以实现简化的匹配算法。</p></blockquote><p>跟 <code>AbstractBeanFactory</code> 不太一样，<code>AbstractAutowireCapableBeanFactory</code> 没有把全部模板方法都实现完，它保留了文档注释中提到的 <code>resolveDependency</code> 方法，这个方法的作用是<strong>解析 Bean 的成员中定义的属性依赖关系</strong>。</p><h4 id="2-2-4-AACBF-不负责BeanDefinition的注册"><a href="#2-2-4-AACBF-不负责BeanDefinition的注册" class="headerlink" title="2.2.4 AACBF 不负责BeanDefinition的注册"></a>2.2.4 AACBF 不负责BeanDefinition的注册</h4><blockquote><p>Note that this class does not assume or implement bean definition registry capabilities. See DefaultListableBeanFactory for an implementation of the org.springframework.beans.factory.ListableBeanFactory and BeanDefinitionRegistry interfaces, which represent the API and SPI view of such a factory, respectively.</p><p>请注意，此类不承担或实现 bean 定义注册的功能。有关 <code>ListableBeanFactory</code> 和 <code>BeanDefinitionRegistry</code> 接口的实现，请参见<code>DefaultListableBeanFactory</code> ，它们分别表示该工厂的 API 和 SPI 视图。</p></blockquote><p>最后一段注释，它想表明的是，<code>AbstractAutowireCapableBeanFactory</code> 实现了对 Bean 的创建、赋值、注入、初始化的逻辑，但对于 Bean 的定义是如何进入 <code>BeanFactory</code> 的，它不负责。这里面涉及到两个流程：<strong>Bean 的创建</strong>、<strong>Bean 定义的进入</strong>，这个咱放到后面 <code>BeanDefinition</code> 和 Bean 的完整生命周期中再详细解释。</p><h3 id="2-3-DefaultListableBeanFactory"><a href="#2-3-DefaultListableBeanFactory" class="headerlink" title="2.3 DefaultListableBeanFactory"></a>2.3 DefaultListableBeanFactory</h3><p>这个类是<strong>唯一一个目前使用的 <code>BeanFactory</code> 的落地实现了</strong>，可想而知它的地位和重要性有多高，小伙伴一定要予以重视。</p><h4 id="2-3-1-DLBF-是BeanFactory最终的默认实现"><a href="#2-3-1-DLBF-是BeanFactory最终的默认实现" class="headerlink" title="2.3.1 DLBF 是BeanFactory最终的默认实现"></a>2.3.1 DLBF 是BeanFactory最终的默认实现</h4><blockquote><p>Spring’s default implementation of the ConfigurableListableBeanFactory and BeanDefinitionRegistry interfaces: a full-fledged bean factory based on bean definition metadata, extensible through post-processors.</p><p>Spring 的 <code>ConfigurableListableBeanFactory</code> 和 <code>BeanDefinitionRegistry</code> 接口的默认实现，它时基于 Bean 的定义信息的的成熟的 <code>BeanFactory</code> 实现，它可通过后置处理器进行扩展。</p></blockquote><p>翻看源码就知道，<code>DefaultListableBeanFactory</code> 已经没有 <strong>abstract</strong> 标注了，说明它可以算作一个<strong>成熟的落地实现</strong>了。</p><p>这里面要多注意的一个点：**<code>BeanDefinitionRegistry</code>** ，它又是个啥？字面意思理解为 <strong>“Bean 定义的注册器”</strong> ，它具体能干嘛咱先不用着急深入学习，先有个印象就好，下面的注释就解释它的用途了。</p><h4 id="2-3-2-DLBF-会先注册Bean定义信息再创建Bean"><a href="#2-3-2-DLBF-会先注册Bean定义信息再创建Bean" class="headerlink" title="2.3.2 DLBF 会先注册Bean定义信息再创建Bean"></a>2.3.2 DLBF 会先注册Bean定义信息再创建Bean</h4><blockquote><p>Typical usage is registering all bean definitions first (possibly read from a bean definition file), before accessing beans. Bean lookup by name is therefore an inexpensive operation in a local bean definition table, operating on pre-resolved bean definition metadata objects.</p><p>典型的用法是在访问 bean 之前先注册所有 bean 定义信息（可能是从有 bean 定义的文件中读取）。因此，按名称查找 Bean 是对本地 Bean 定义表进行的合理操作，该操作对预先解析的 Bean 定义元数据对象进行操作。</p></blockquote><p>由此可见，<code>DefaultListableBeanFactory</code> 在 <code>AbstractAutowireCapableBeanFactory</code> 的基础上，完成了注册 Bean 定义信息（BeanDefinition）的动作，而这个动作就是通过上面的 <strong><code>BeanDefinitionRegistry</code></strong> 来实现的。</p><p>所以咱就可以知道一点，完整的 BeanFactory 对 Bean 的管理，应该是<strong>先注册 Bean 的定义信息，再完成 Bean 的创建和初始化动作</strong>。这个流程，在后面讲解完整的 Bean 生命周期时会详细讲到。</p><h4 id="2-3-3-DLBF-不负责解析Bean定义文件"><a href="#2-3-3-DLBF-不负责解析Bean定义文件" class="headerlink" title="2.3.3 DLBF 不负责解析Bean定义文件"></a>2.3.3 DLBF 不负责解析Bean定义文件</h4><blockquote><p>Note that readers for specific bean definition formats are typically implemented separately rather than as bean factory subclasses: see for example PropertiesBeanDefinitionReader and org.springframework.beans.factory.xml.XmlBeanDefinitionReader.</p><p>请注意，特定 bean 定义信息格式的解析器通常是单独实现的，而不是作为 <code>BeanFactory</code> 的子类实现的，有关这部分的内容参见 <code>PropertiesBeanDefinitionReader</code> 和 <code>XmlBeanDefinitionReader</code> 。</p></blockquote><p>从这一段话上，小伙伴有木有愈发强烈的意识到，SpringFramework 对于<strong>组件的单一职责把控的非常好</strong>？</p><p><code>BeanFactory</code> 作为一个统一管理 Bean 组件的容器，它的核心工作就是<strong>控制 Bean 在创建阶段的生命周期</strong>，而对于 Bean 从哪里来，如何被创建，都有哪些依赖要被注入，这些统统与它无关，而是有专门的组件来处理（就是包括上面提到的 <code>BeanDefinitionReader</code> 在内的一些其它组件）。</p><h4 id="2-3-4-DLBF-的替代实现"><a href="#2-3-4-DLBF-的替代实现" class="headerlink" title="2.3.4 DLBF 的替代实现"></a>2.3.4 DLBF 的替代实现</h4><blockquote><p>For an alternative implementation of the org.springframework.beans.factory.ListableBeanFactory interface, have a look at StaticListableBeanFactory, which manages existing bean instances rather than creating new ones based on bean definitions.</p><p>对于 <code>ListableBeanFactory</code> 接口的替代实现，请看一下 <code>StaticListableBeanFactory</code> ，它管理现有的 bean 实例，而不是根据 bean 定义创建新的 bean 实例。</p></blockquote><p>这里它提了另一个实现 <code>StaticListableBeanFactory</code> ，它实现起来相对简单且功能也简单，因为它只能管理单实例 Bean ，而且没有跟 Bean 定义等相关的高级概念在里面，于是 SpringFramework 默认也不用它。</p><h3 id="2-4-XmlBeanFactory"><a href="#2-4-XmlBeanFactory" class="headerlink" title="2.4 XmlBeanFactory"></a>2.4 XmlBeanFactory</h3><p>可能到这里部分了解之前背景的小伙伴会有疑问：<code>XmlBeanFactory</code> 呢？这个地方咱做一个解释。</p><p>在 SpringFramework 3.1 之后，<code>XmlBeanFactory</code> 正式被标注为<strong>过时</strong>，代替的方案是使用 <code>DefaultListableBeanFactory + XmlBeanDefinitionReader</code> ，这种设计更<strong>符合组件的单一职责原则</strong></p><p>而且还有一点，自打 SpringFramework 3.0 之后出现了注解驱动的 IOC 容器，SpringFramework 就感觉这种 xml 驱动的方式不应该单独成为一种方案了，倒不如咱都各退一步，<strong>搞一个通用的容器，都组合它来用</strong>，这样就实现了<strong>配置源载体分离</strong>的目的了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>BeanFactory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04-IOC中DL/DI的区别</title>
    <link href="/2022/04/17/04-IOC%E4%B8%ADDL-DI%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/17/04-IOC%E4%B8%ADDL-DI%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ul><li>作用目标不同<ul><li>依赖注入的作用目标通常是类成员</li><li>依赖查找的作用目标可以是方法体内，也可以是方法体外</li></ul></li><li>实现方式不同<ul><li>依赖注入通常借助一个上下文被动的接收</li><li>依赖查找通常主动使用上下文搜索</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>DL</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03-IOC依赖注入DI</title>
    <link href="/2022/04/17/03-IOC%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5DI/"/>
    <url>/2022/04/17/03-IOC%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5DI/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖注入-DependencyInject"><a href="#依赖注入-DependencyInject" class="headerlink" title="依赖注入(DependencyInject)"></a>依赖注入(DependencyInject)</h1><p><a href>02-IOC依赖查找DL</a>：创建的 Bean 都是不带属性的，如果我要创建的 Bean 需要一些预设的属性，那该怎么办呢？</p><p>那就涉及到 IOC 的另外一种实现 <strong>依赖注入</strong>。延续 IOC 的思想，不要自己去找并Set，而是交给 IOC 容器，让容器帮我们查找并赋值。</p><p>场景如下：声明两个类：<code>Person</code> 与 <code>Cat</code> ，形成 “猫需要依赖饲主” 的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">// getter and setter ......</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Person master;<br>    <span class="hljs-comment">// getter and setter ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简普对象属性的注入"><a href="#简普对象属性的注入" class="headerlink" title="简普对象属性的注入"></a>简普对象属性的注入</h2><p>在 <code>resources</code> 目录下新建 <code>basic_di</code> 文件夹，并声明配置文件 <code>inject-set.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_di.a_quickstart_set.bean.Person&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_di.a_quickstart_set.bean.Cat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>回到包下，新增启动类 <code>QuickstartInjectBySetXmlApplication</code> ，并编写 <code>main</code> 方法初始化 <code>BeanFactory</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickstartInjectBySetXmlApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        BeanFactory beanFactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;basic_di/inject-set.xml&quot;</span>);<br>        Person person = beanFactory.getBean(Person.class);<br>        System.out.println(person);<br>        <br>        Cat cat = beanFactory.getBean(Cat.class);<br>        System.out.println(cat);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，发现打印的 person 与 cat 的所有属性都是 null ：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">age</span>=<span class="hljs-literal">null</span>&#125;<br>Cat&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">master</span>=<span class="hljs-literal">null</span>&#125;<br></code></pre></td></tr></table></figure><hr><p>在 person 的 <code>&lt;bean&gt;</code> 标签中声明 <code>property</code> 标签，这里面有两个属性：<strong>name - 属性名，value - 属性值</strong>。所以咱可以用如下方式来进行属性赋值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_di.a_quickstart_set.bean.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test-person-byset&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>声明之后，保存，回到启动类，重新运行，发现 person 已经有值了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;test-person-byset&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Cat&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-attribute">master</span>=<span class="hljs-literal">null</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="关联Bean对象的注入"><a href="#关联Bean对象的注入" class="headerlink" title="关联Bean对象的注入"></a>关联Bean对象的注入</h2><p>上面打印的结果明显 cat 还没有值，而且 master 的类型是 <code>Person</code> ，下面咱要给 cat 赋值。</p><p>使用 <code>property</code> 标签，声明另外一个属性：**<code>ref</code>** ，它代表要关联赋值的 Bean 的 id 。 由此，对于 cat 中的 master 属性，可以有如下赋值方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_di.a_quickstart_set.bean.Cat&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test-cat&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- ref引用上面的person对象 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;master&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;person&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>声明好后，重新运行启动类，发现 cat 也有属性了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;test-person-byset&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;<br>Cat&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;test-cat&#x27;</span>, <span class="hljs-attribute">master</span>=Person&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;test-person-byset&#x27;</span>, <span class="hljs-attribute">age</span>=18&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>DI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02-IOC依赖查找DL</title>
    <link href="/2022/04/17/02-IOC%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BEDL/"/>
    <url>/2022/04/17/02-IOC%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BEDL/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖查找-DependencyLookup-方式"><a href="#依赖查找-DependencyLookup-方式" class="headerlink" title="依赖查找(DependencyLookup)方式"></a>依赖查找(DependencyLookup)方式</h1><h2 id="一、通过Bean的名称查找-byName"><a href="#一、通过Bean的名称查找-byName" class="headerlink" title="一、通过Bean的名称查找 byName"></a>一、通过Bean的名称查找 byName</h2><p>只需要引入一个依赖即可：<code>spring-context</code> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面在 <code>com.example.spring.basic_dl.a_quickstart_byname</code> 包下创建一个 bean 包，随后创建一个 <code>Person</code> 类。</p><p>在 <code>quickstart-byname.xml</code> 中，使用 SpringFramework 的定义规则，将 <code>Person</code> 声明到配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_dl.a_quickstart_byname.bean.Person&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>main</code> 方法中要读这个配置文件，方法有很多种，咱快速入门中先来使用一种比较简单的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    BeanFactory factory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;basic_dl/quickstart-byname.xml&quot;</span>);<br>    Person person = (Person) factory.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、通过Bean的类型查找byType"><a href="#二、通过Bean的类型查找byType" class="headerlink" title="二、通过Bean的类型查找byType"></a>二、通过Bean的类型查找byType</h2><p>为了与上面的实验区分开，复制的 <code>quickstart-byname.xml</code> 内容到 <code>quickstart-bytype.xml</code> ，修改声明 bean 不再声明 id 属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_dl.b_bytype.bean.Person&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动类 <code>QuickstartByTypeApplication</code> 中，这次调用的方法不再是传 name 的 <code>getBean</code> 方法，而是直接传 <code>Class</code> 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    BeanFactory factory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;basic_dl/quickstart-bytype.xml&quot;</span>);<br>    Person person = factory.getBean(Person.class);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>factory.getBean(Person.class)</code>，这里不在需要强转了，因为程序已经知道getBean返回的类型了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.basic_dl</span><span class="hljs-selector-class">.b_bytype</span><span class="hljs-selector-class">.bean</span>.Person@<span class="hljs-number">6</span>d4b1c02<br></code></pre></td></tr></table></figure><p>通过byType，使用 <strong>接口类型</strong> 和 <strong>实现类类型</strong> 也可以查找到，之后在 <code>quickstart-bytype.xml</code> 中加入 <code>DemoDaoImpl</code> 的声明定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_dl.b_bytype.dao.impl.DemoDaoImpl&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>之后在启动类 <code>QuickstartByTypeApplication</code> 中，借助 <code>BeanFactory</code> 取出 <code>DemoDao</code> ，并打印 <code>findAll</code> 方法的返回数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    BeanFactory factory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;basic_dl/quickstart-bytype.xml&quot;</span>);<br>    Person person = factory.getBean(Person.class);<br>    System.out.println(person);<br><br>    DemoDao demoDao = factory.getBean(DemoDao.class);<br>    System.out.println(demoDao.findAll());<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个接口有多个实现，想一次性把这些都拿出来，那 <code>getBean</code> 方法显然就不够用了，需要使用额外的方式。</p><p>回到 <code>basic_dl</code> 包下，咱新创建一个 <code>oftype</code> 的包，来测试 <strong>ofType</strong> 的查找方式。</p><p>场景搭建：声明一个 <code>DemoDao</code> ，并声明 3 种对应的实现类，分别模拟操作 MySQL 、Oracle 、Postgres 数据库的实现类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoMySQLDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_dl.c_oftype.dao.impl.DemoMySQLDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoOracleDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_dl.c_oftype.dao.impl.DemoOracleDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demoPostgreDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.spring.basic_dl.c_oftype.dao.impl.DemoPostgresDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在启动类中，创建 <code>BeanFactory</code> 后，尝试一次性取出多个 Bean ，结果发现 <code>BeanFactory</code>中并没有这样的方法：</p><p><img src="/2022/04/17/02-IOC%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BEDL/0a59f26ff7a948ccad9c7ce57965d3a7~tplv-k3u1fbpfcp-watermark.image.png" alt="img"></p><hr><p>将 <code>BeanFactory</code> 接口换为 <code>ApplicationContext</code> ，再次尝试调用方法，发现了一个这样的方法：</p><p><img src="/2022/04/17/02-IOC%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BEDL/e52eadc4868f4085955d1d3cdef02b1f~tplv-k3u1fbpfcp-watermark.image.png" alt="img"></p><p>它可以传入一个类型，返回一个 Map，而 Map 中的 value 不难猜测就是传入的参数类型对应的那些类 / 实现类。那就拿出来，foreach 一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OfTypeApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;basic_dl/quickstart-oftype.xml&quot;</span>);<br>        Map&lt;String, DemoDao&gt; beans = ctx.getBeansOfType(DemoDao.class);<br>        beans.forEach((beanName, bean) -&gt; &#123;<br>            System.out.println(beanName + <span class="hljs-string">&quot; : &quot;</span> + bean.toString());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台真的打印了上面声明的那3个类：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">demoMySQLDao : com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.basic_dl</span><span class="hljs-selector-class">.c_oftype</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoMySQLDao@<span class="hljs-number">4883</span>b407<br>demoOracleDao : com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.basic_dl</span><span class="hljs-selector-class">.c_oftype</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoOracleDao@<span class="hljs-number">7</span>d9d1a19<br>demoPostgreDao : com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.basic_dl</span><span class="hljs-selector-class">.c_oftype</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoPostgresDao@<span class="hljs-number">39</span>c0f4a<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01-IOC是怎么来的</title>
    <link href="/2022/04/17/01-IOC%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/"/>
    <url>/2022/04/17/01-IOC%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Way-IoC"><a href="#Way-IoC" class="headerlink" title="Way IoC ?"></a>Way IoC ?</h1><h2 id="一、前菜-原生Servlet的三层架构"><a href="#一、前菜-原生Servlet的三层架构" class="headerlink" title="一、前菜-原生Servlet的三层架构"></a>一、前菜-原生Servlet的三层架构</h2><p>搭建一个在原生 Servlet 时代的 MVC 三层架构的工程，以此为背景板</p><h3 id="1-1-构建基于Maven的原生Servlet工程"><a href="#1-1-构建基于Maven的原生Servlet工程" class="headerlink" title="1.1 构建基于Maven的原生Servlet工程"></a>1.1 构建基于Maven的原生Servlet工程</h3><p>使用 Maven 构建项目那是最基本的能力了，咱使用 IDEA 快速搭建一个原生的 Servlet 工程。</p><p>pom 依赖中，只需要引入 Servlet 的 api 即可：（此处我使用了 Servlet3.1 ，这个倒是无所谓，只是用 <strong>Servlet3.0+</strong> 的版本可以基于注解开发，效率较快）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然，为了使工程的编译级别在 1.8 级别，还需要加入 Maven 的编译插件：（版本不要太老就好，此处我选用 3.2 版本）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后，不要忘记调整打包方式为 war 包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-将工程部署到Servlet容器"><a href="#1-2-将工程部署到Servlet容器" class="headerlink" title="1.2 将工程部署到Servlet容器"></a>1.2 将工程部署到Servlet容器</h3><p>先把工程部署到 Servlet 容器中，保证正常运行。这里使用 Tomcat 作为 Servlet 容器来运行工程。</p><p>在 IDEA 中依次打开 “File -&gt; Project Structure” ，选中 Artifacts 标签，并添加 Web Application: Exploded 类型的输出类型，配置好对应的路径与名称，即可设置好编译打包输出配置。</p><p>如下图所示：</p><p><img src="/2022/04/17/01-IOC%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/image-20220223221749138.png" alt="image-20220223221749138"></p><p>接下来，在 IDEA 的运行栏中选择 Add Configuration… ，并添加本地的 Tomcat ：</p><p><img src="/2022/04/17/01-IOC%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/image-20220223221624850.png" alt="image-20220223221624850"></p><p>接下来在新建的 Tomcat 中选择 Deployment ，并添加刚配置好的 Artifact ：</p><p><img src="/2022/04/17/01-IOC%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/image-20220223221837125.png" alt="image-20220223221837125"></p><p>添加完成后，即可保存确定。</p><h3 id="1-3-编写Servlet测试可用"><a href="#1-3-编写Servlet测试可用" class="headerlink" title="1.3 编写Servlet测试可用"></a>1.3 编写Servlet测试可用</h3><p>在 <code>src/main/java</code> 中新建一个 <code>DemoServlet</code> ，标注 <code>@WebServlet</code> 注解，并继承 <code>HttpServlet</code> ，重写 <code>doGet</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/demo1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        response.getWriter().println(<span class="hljs-string">&quot;DemoServlet1 run ......&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>编写完毕后直接启动 Tomcat ，此时 IDEA 会自动编译工程并部署到 Tomcat 中。</p><p>打开浏览器，地址栏输入 <a href="http://localhost:8080/demo_war/demo1%EF%BC%88%E6%AF%8F%E4%B8%AA%E4%BA%BA%E6%90%AD%E5%BB%BA%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%90%8D%E5%8F%AF%E8%83%BD%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%8Ccontext-path">http://localhost:8080/demo_war/demo1（每个人搭建的工程名可能不一致，context-path</a> 记得修改），发现可以正常打印 <code>DemoServlet1 run ......</code> 的输出，证明工程搭建并配置成功。</p><h3 id="1-4-编写Service与Dao"><a href="#1-4-编写Service与Dao" class="headerlink" title="1.4 编写Service与Dao"></a>1.4 编写Service与Dao</h3><p>此处的 Dao 只是空壳，并没有实际的 jdbc 相关操作，仅做代码演示。</p><p>在工程目录下新建以下几个类和接口：</p><p><img src="/2022/04/17/01-IOC%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/image-20220223222711818.png" alt="image-20220223222711818"></p><p>对应的三层架构中的组件及依赖就应该是这样：（ Dao 连接数据库的部分不实现）</p><p><img src="/2022/04/17/01-IOC%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/image-20220223223927914.png" alt="image-20220223223927914"></p><h4 id="1-4-1-Dao与DaoImpl"><a href="#1-4-1-Dao与DaoImpl" class="headerlink" title="1.4.1 Dao与DaoImpl"></a>1.4.1 Dao与DaoImpl</h4><p>简单定义一个 <code>DemoDao</code> 接口，并声明一个 <code>findAll</code> 方法模拟从数据库查询一组数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DemoDao</span> </span>&#123;<br>    <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写它对应的实现类 <code>DemoDaoImpl</code> ，由于没有引入数据库的相关驱动，故这里只是用写死的临时数据模拟 Dao 与数据库的交互：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoDao</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 此处应该是访问数据库的操作，用临时数据代替</span><br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-string">&quot;ccc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Dao 层的接口与实现类定义完成。</p><h4 id="1-4-2-Service与ServiceImpl"><a href="#1-4-2-Service与ServiceImpl" class="headerlink" title="1.4.2 Service与ServiceImpl"></a>1.4.2 Service与ServiceImpl</h4><p>编写一个 <code>DemoService</code> 接口，并声明 <code>findAll</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写它对应的实现类 <code>DemoServiceImpl</code> ，并在内部依赖 <code>DemoDao</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> DemoDao demoDao = <span class="hljs-keyword">new</span> DemoDaoImpl();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> demoDao.findAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Service 层的接口与实现类定义完成。</p><h3 id="1-5-修改DemoServlet"><a href="#1-5-修改DemoServlet" class="headerlink" title="1.5 修改DemoServlet"></a>1.5 修改DemoServlet</h3><p>由于要模拟整体的三层架构，故 <code>DemoServlet1</code> 要依赖 <code>DemoService</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/demo1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServlet1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <br>    DemoService demoService = <span class="hljs-keyword">new</span> DemoServiceImpl();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.getWriter().println(demoService.findAll().toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-重新运行应用并测试可用"><a href="#1-6-重新运行应用并测试可用" class="headerlink" title="1.6 重新运行应用并测试可用"></a>1.6 重新运行应用并测试可用</h3><p>重新部署到 Tomcat 并运行，访问 <code>/demo1</code> 路径，浏览器中会打印 <code>[&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;]</code>，说明编写正确且运行正常。</p><hr><p>以上部分是咱在 JavaWeb 基础中最熟悉不过的东西了，好了到这里咱停下来，代入一个场景。</p><h2 id="二、问题引入（1）-频繁的需求变更"><a href="#二、问题引入（1）-频繁的需求变更" class="headerlink" title="二、问题引入（1）-频繁的需求变更"></a>二、问题引入（1）-频繁的需求变更</h2><p>现在你的手头上已经基本上开发完成了，数据库用的 MySQL 很舒服，临近交付项目，客户一个电话打过来了：老板让换用 Oracle 的数据库！挂掉电话的你内心一万只草泥马呼啸而去，没招啊，客户是上帝啊，咱也是要恰饭的嘛，客户要啥咱就得改啥啊！</p><h3 id="2-1-修改数据库"><a href="#2-1-修改数据库" class="headerlink" title="2.1 修改数据库"></a>2.1 修改数据库</h3><p>咱都知道，对于 MySQL 跟 Oracle ，在有一些特定的 SQL 上是不一样的（比如分页），所以只把数据库连接池的相关配置改成Oracle的是不够的，每个 DaoImpl 也得改啊！</p><p>于是乎，你开始修改起工程里所有的 DaoImpl ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoDao</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟修改SQL的动作</span><br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;oracle&quot;</span>, <span class="hljs-string">&quot;oracle&quot;</span>, <span class="hljs-string">&quot;oracle&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-需求再次变更"><a href="#2-2-需求再次变更" class="headerlink" title="2.2 需求再次变更"></a>2.2 需求再次变更</h3><p>你好不容易熬夜两个晚上，头发掉了一把又一把，终于要给客户部署工程了，客户笑眯眯的跟你说了一句话，那个啥，最近炒股。。。呃不是，财务支出有点严重，这不有点囊中羞涩，数据库就换回 MySQL 吧！</p><p>你已经受够了这种改过来改过去的破事了，毕竟狗命要紧（杀死程序猿最简单的办法：改三次需求），那这个时候你就得想啊，怎么解决这个问题呢？</p><h3 id="2-3-【方案】引入静态工厂"><a href="#2-3-【方案】引入静态工厂" class="headerlink" title="2.3 【方案】引入静态工厂"></a>2.3 【方案】引入静态工厂</h3><p>苦思良久，你终于想到了一个好办法：</p><p>如果我事先把这些 Dao 都写好了，之后用一个静态工厂来创建特定类型的实现类，这样万一发生需求变更，是不是就可以做到只改一次代码就可以了！</p><p>于是按照这个想法，有如下改造：</p><h4 id="2-3-1-构造静态工厂"><a href="#2-3-1-构造静态工厂" class="headerlink" title="2.3.1 构造静态工厂"></a>2.3.1 构造静态工厂</h4><p>声明一个静态工厂，起个比较别致的名字吧：<code>BeanFactory</code> （不要问我为什么这么别致，这是一个伏笔）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DemoDao <span class="hljs-title">getDemoDao</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// return new DemoDaoImpl();</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DemoOracleDao();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-改造ServiceImpl"><a href="#2-3-2-改造ServiceImpl" class="headerlink" title="2.3.2 改造ServiceImpl"></a>2.3.2 改造ServiceImpl</h4><p>ServiceImpl 中引用的 Dao 不再是手动 new ，而是由 <code>BeanFactory</code> 的静态方法返回而得：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    <br>    DemoDao demoDao = BeanFactory.getDemoDao();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> demoDao.findAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如此这般，即便 ServiceImpl 再多，Dao 再多，<strong>发生需求更改</strong>，我也<strong>只需要改动 BeanFactory 中的静态方法返回值即可</strong>！</p><p>问题解决，皆大欢喜，客户也很满意，项目交付完成。</p><h2 id="三、问题引入（2）-紧耦合"><a href="#三、问题引入（2）-紧耦合" class="headerlink" title="三、问题引入（2）-紧耦合"></a>三、问题引入（2）-紧耦合</h2><p>项目上线运行一段时间后，客户对系统中的一些功能提出了优化和扩展需求，那这个时候你就来维护呗，毕竟你最熟悉这个项目。不过之前好一段时间你都去负责别的项目去了，维护工作都是由你同事负责着。</p><p>当你重新打开工程时，想先拉起来看看要扩展的需求具体的位置，居然发现项目连编译都无法通过了！（为演示无法编译的现象，删除 <code>DemoDaoImpl.java</code> ）</p><p>此时的你肯定是一脸黑人问号啊！怎么之前好使的现在就不好使了？再仔细一看报错位置，<code>BeanFactory</code> ！哎不大对劲啊，我这之前封装好的静态工厂就是偷懒用的，怎么会编译出错呢？打开代码看了一眼才知道，合着少了一个 <code>DemoDaoImpl</code> 的源文件，导致代码根本无法编译了！</p><p>场景演绎到这里，咱先稍微暂停一下，体会一下这里面出现的问题。</p><h3 id="3-1-【概念】紧耦合问题"><a href="#3-1-【概念】紧耦合问题" class="headerlink" title="3.1 【概念】紧耦合问题"></a>3.1 【概念】紧耦合问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DemoDao <span class="hljs-title">getDemoDao</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DemoDaoImpl(); <span class="hljs-comment">// DemoDaoImpl.java不存在导致编译失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当前的代码中，因为源码中真的缺少这个 <code>DemoDaoImpl</code> 类，导致编译都无法通过，这种现象就可以描述为 <strong>“ <code>BeanFactory</code> 强依赖于 <code>DemoDaoImpl</code> ”</strong> ，也就是咱可能听过也可能常说的“<strong>紧耦合</strong>”。</p><h3 id="3-2-【方案】解决紧耦合"><a href="#3-2-【方案】解决紧耦合" class="headerlink" title="3.2 【方案】解决紧耦合"></a>3.2 【方案】解决紧耦合</h3><p>回到刚才的场景中，你这直接懵逼了呀，没有这个 .java 文件，我没法编译，那我不用干活了呗？不行，咱可不能因为这个问题就耽误了整体呀！于是乎你开动脑筋，想一下在现有知识中，有没有一种办法能解决这个编译都没办法编译的问题？</p><p><strong>反射！反射可以声明一个类的全限定名，来获取它的字节码描述，这样也能构造对象！</strong></p><p>于是 <code>BeanFactory</code> 可以改造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DemoDao <span class="hljs-title">getDemoDao</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (DemoDao) Class.forName(<span class="hljs-string">&quot;com.example.architecture.c_reflect.dao.impl.DemoDaoImpl&quot;</span>).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;DemoDao instantiation error, cause: &quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>照这样一写，是不是编译的问题就解决了？尽管在 <code>DemoService</code> 的初始化时还是会出现问题，但最起码可以把项目拉起来了啊！</p><p>于是这个问题就暂时解决了，先放一边了。。。</p><h3 id="3-3-【概念对比】弱依赖"><a href="#3-3-【概念对比】弱依赖" class="headerlink" title="3.3 【概念对比】弱依赖"></a>3.3 【概念对比】弱依赖</h3><p>使用反射之后，错误现象不再是在编译器就出现，而是在工程启动后，由于 <code>BeanFactory</code> 要构造 <code>DemoDaoImpl</code> 时确实还没有该类，所以抛出 <code>ClassNotFoundException</code> 异常。这样 <strong><code>BeanFactory</code> 对 <code>DemoDaoImpl</code> 的依赖程度</strong>就相当于<strong>降低</strong>了，也就可以算作“<strong>弱依赖</strong>”了。</p><h2 id="四、问题引入（3）-硬编码"><a href="#四、问题引入（3）-硬编码" class="headerlink" title="四、问题引入（3）-硬编码"></a>四、问题引入（3）-硬编码</h2><p>躲得了初一躲不了十五，这个问题最终还是得解决，你费劲八道的终于把 <code>DemoDaoImpl.java</code> 找了回来，这下终于运行期也不报错了。但这样在切换 MySQL 和 Oracle 库时还是会出现一个问题：</p><p>由于类的全限定名是写死在 <code>BeanFactory</code> 的源码中，导致每次切换数据库后还得重新编译工程才可以正常运行，这显得貌似很没必要，应该有更好的处理方案。</p><h3 id="4-1-【改良】引入外部化配置文件"><a href="#4-1-【改良】引入外部化配置文件" class="headerlink" title="4.1 【改良】引入外部化配置文件"></a>4.1 【改良】引入外部化配置文件</h3><p>机智的你利用现有的 JavaSE 知识，立马能想到：可以借助 IO 来实现文件存储配置啊！这样每次 <code>BeanFactory</code> 初始化时，让它去读配置文件，这样就不会出现硬编码的现象了！</p><p>于是可有如下改造：</p><h4 id="4-1-1-加入factory-properties文件"><a href="#4-1-1-加入factory-properties文件" class="headerlink" title="4.1.1 加入factory.properties文件"></a>4.1.1 加入factory.properties文件</h4><p>在 <code>src/main/resource</code> 目录下新建 <code>factory.properties</code> 文件，并在其中声明如下内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">demoService</span>=<span class="hljs-string">com.example.demo.service.impl.DemoServiceImpl</span><br><span class="hljs-attr">demoDao</span>=<span class="hljs-string">com.example.demo.dao.impl.DemoDaoImpl</span><br></code></pre></td></tr></table></figure><p>为了方便回头取这些类的全限定名，给每一个类名都起一个“小名”，根据小名来找到对应的全限定类名。</p><h4 id="4-1-2-改造BeanFactory"><a href="#4-1-2-改造BeanFactory" class="headerlink" title="4.1.2 改造BeanFactory"></a>4.1.2 改造BeanFactory</h4><p>既然配置文件是 properties 类型，在 jdk 中刚好也有一个 API 叫 <code>Properties</code> ，它可以解析 <code>.properties</code> 文件。</p><p>于是可以在 <code>BeanFactory</code> 中加入一个静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Properties properties;<br></code></pre></td></tr></table></figure><p>下面要在工程刚启动的时候就初始化 <code>Properties</code> ，这咱可以使用静态代码块实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Properties properties;<br><br><span class="hljs-comment">// 使用静态代码块初始化properties，加载factord.properties文件</span><br><span class="hljs-keyword">static</span> &#123;<br>    properties = <span class="hljs-keyword">new</span> Properties();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 必须使用类加载器读取resource文件夹下的配置文件</span><br>        properties.load(BeanFactory.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;factory.properties&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// BeanFactory类的静态初始化都失败了，那后续也没有必要继续执行了</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExceptionInInitializerError(<span class="hljs-string">&quot;BeanFactory initialize error, cause: &quot;</span> + e.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件读取到之后，下面的 <code>getDao</code> 方法也可以进一步改了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DemoDao <span class="hljs-title">getDemoDao</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class&lt;?&gt; beanClazz = Class.forName(properties.getProperty(<span class="hljs-string">&quot;demoDao&quot;</span>));<br>        <span class="hljs-keyword">return</span> beanClazz.newInstance();<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;BeanFactory have not [&quot;</span> + beanName + <span class="hljs-string">&quot;] bean!&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;[&quot;</span> + beanName + <span class="hljs-string">&quot;] instantiation error!&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写到这里，是不是感觉怪怪的。。。都抽象化到这种地步了，还有必要在这里面写死 “demoDao” 吗？肯定没必要了吧，干脆做一个通用得了，你传什么别名，<code>BeanFactory</code> 就从配置文件中找对应的全限定类名，反射构造对象返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 从properties文件中读取指定name对应类的全限定名，并反射实例化</span><br>        Class&lt;?&gt; beanClazz = Class.forName(properties.getProperty(beanName));<br>        <span class="hljs-keyword">return</span> beanClazz.newInstance();<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;BeanFactory have not [&quot;</span> + beanName + <span class="hljs-string">&quot;] bean!&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;[&quot;</span> + beanName + <span class="hljs-string">&quot;] instantiation error!&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-改造ServiceImpl"><a href="#4-1-3-改造ServiceImpl" class="headerlink" title="4.1.3 改造ServiceImpl"></a>4.1.3 改造ServiceImpl</h4><p><code>DemoServiceImpl</code> 中不再需要调 <code>getDao</code> 方法了（因为被删了…），而是转用 <code>getBean</code> 方法，并指定需要获取的指定名称的类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    <br>    DemoDao demoDao = (DemoDao) BeanFactory.getBean(<span class="hljs-string">&quot;demoDao&quot;</span>);<br></code></pre></td></tr></table></figure><p>到这里，你突然发现一个现象：这下你可以把所有想抽取出来的组件都可以做成外部化配置了！</p><h3 id="4-2-【思想】外部化配置"><a href="#4-2-【思想】外部化配置" class="headerlink" title="4.2 【思想】外部化配置"></a>4.2 【思想】外部化配置</h3><p>对于这种可能会变化的配置、属性等，通常不会直接硬编码在源代码中，而是抽取为一些配置文件的形式（ properties 、xml 、json 、yml 等），配合程序对配置文件的加载和解析，从而达到动态配置、降低配置耦合的目的。</p><h2 id="五、问题引入（4）-对象重复创建"><a href="#五、问题引入（4）-对象重复创建" class="headerlink" title="五、问题引入（4）-对象重复创建"></a>五、问题引入（4）-对象重复创建</h2><p>改到这里可能你会感觉，是不是哪里不对劲，是不是还有改进的空间呢？这样，咱在 <code>ServiceImpl</code> 的构造方法中连续多次获取 <code>DemoDaoImpl</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    <br>    DemoDao demoDao = (DemoDao) BeanFactory.getBean(<span class="hljs-string">&quot;demoDao&quot;</span>);<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoServiceImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(BeanFactory.getBean(<span class="hljs-string">&quot;demoDao&quot;</span>));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>咱只来看打印的这些 <code>DemoDao</code> 的内存地址：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">44548059</span><br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">5</span>cab632f<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">24943</span>e59<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">3</span>f66e016<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">5</span>f50e9eb<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">58</span>e55b35<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">5</span>d06d086<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">55</span>e8ed60<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@daf5987<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">7</span>f6187f4<br></code></pre></td></tr></table></figure><p>可以发现每次打印的内存地址都不相同，证明是创建了10个不同的 <code>DemoDaoImpl</code> ！但是，真的有必要吗。。。</p><h3 id="5-1-【改良】引入缓存"><a href="#5-1-【改良】引入缓存" class="headerlink" title="5.1 【改良】引入缓存"></a>5.1 【改良】引入缓存</h3><p>如果对于这些没必要创建多个对象的组件，如果能有一种机制保证整个工程运行过程中只存在一个对象，那就可以大大减少资源消耗。于是可以在 <code>BeanFactory</code> 中加入一个缓存区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    <span class="hljs-comment">// 缓存区，保存已经创建好的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; beanMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>之后在 <code>getBean</code> 方法中，为了控制线程并发，需要引入双检锁保证对象只有一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// 双检锁保证beanMap中确实没有beanName对应的对象</span><br>    <span class="hljs-keyword">if</span> (!beanMap.containsKey(beanName)) &#123;<br>        <span class="hljs-keyword">synchronized</span> (BeanFactory.class) &#123;<br>            <span class="hljs-keyword">if</span> (!beanMap.containsKey(beanName)) &#123;<br>                <span class="hljs-comment">// 过了双检锁，证明确实没有，可以执行反射创建</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Class&lt;?&gt; beanClazz = Class.forName(properties.getProperty(beanName));<br>                    Object bean = beanClazz.newInstance();<br>                    <span class="hljs-comment">// 反射创建后放入缓存再返回</span><br>                    beanMap.put(beanName, bean);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;BeanFactory have not [&quot;</span> + beanName + <span class="hljs-string">&quot;] bean!&quot;</span>, e);<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;[&quot;</span> + beanName + <span class="hljs-string">&quot;] instantiation error!&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> beanMap.get(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>改良完成，重新测试，观察这一次打印的结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">4</span>a667700<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">4</span>a667700<br>com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl@<span class="hljs-number">4</span>a667700<br>......<br></code></pre></td></tr></table></figure><hr><p>到这里，整个场景的演绎就算结束了，下面咱来总结一下这里面出现的几个关键点：</p><ul><li>静态工厂可将多处依赖抽取分离</li><li>外部化配置文件+反射可解决配置的硬编码问题</li><li>缓存可控制对象实例数</li></ul><p>接下来，是时候引出这一章的主题了。</p><h2 id="六、-IOC的思想引入【重点】"><a href="#六、-IOC的思想引入【重点】" class="headerlink" title="六、 IOC的思想引入【重点】"></a>六、 IOC的思想引入【重点】</h2><p>对比上面的两种代码写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> DemoDao dao = <span class="hljs-keyword">new</span> DemoDaoImpl();<span class="hljs-comment">// 强依赖 / 紧耦合，在编译期就必须保证 `DemoDaoImpl` 存在；</span><br><br><span class="hljs-keyword">private</span> DemoDao dao = (DemoDao) BeanFactory.getBean(<span class="hljs-string">&quot;demoDao&quot;</span>);<span class="hljs-comment">// 弱依赖 / 松散耦合，只有到运行期反射创建时才知道 `DemoDaoImpl` 是否存在。</span><br></code></pre></td></tr></table></figure><blockquote><p>再对比看，上面的写法是主动声明了 <code>DemoDao</code> 的实现类，只要编译通过，运行一定没错；</p><ol><li>而下面的写法没有指定实现类，而是由 <code>BeanFactory</code> 去帮咱查找一个 name 为 <code>demoDao</code> 的对象，倘若 <code>factory.properties</code> 中声明的全限定类名出现错误，则会出现强转失败的异常 <code>ClassCastException</code> 。</li><li>仔细体会下面这种对象获取的方式，本来咱开发者可以使用上面的方式，主动声明实现类，但如果选择下面的方式，那就不再是咱自己去声明，而是将获取对象的方式交给了 <code>BeanFactory</code>。</li></ol></blockquote><p>这种<strong>将控制权交给别人</strong>的思想，就可以称作：<strong>控制反转（ Inverse of Control , IOC ）</strong>。</p><p>而 <code>BeanFactory</code> 根据指定的 <code>beanName</code> 去获取和创建对象的过程，就可以称作：<strong>依赖查找（ Dependency Lookup , DL ）</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>IOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14-AOP总结-面试整理</title>
    <link href="/2022/04/17/14-AOP%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    <url>/2022/04/17/14-AOP%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-AOP概念与基础"><a href="#1-AOP概念与基础" class="headerlink" title="1. AOP概念与基础"></a>1. AOP概念与基础</h2><p>与 IOC 一样，咱先回顾一下 AOP 中涉及到的概念。</p><h3 id="1-1-AOP概述"><a href="#1-1-AOP概述" class="headerlink" title="1.1 AOP概述"></a>1.1 AOP概述</h3><p><strong>AOP 面向切面编程，全称 Aspect Oriented Programming ，它是 OOP 的补充。OOP 关注的核心是对象，AOP 的核心是切面（Aspect）。AOP 可以在不修改功能代码本身的前提下，使用运行时动态代理的技术对已有代码逻辑增强。AOP 可以实现组件化、可插拔式的功能扩展，通过简单配置即可将功能增强到指定的切入点。</strong></p><blockquote><p>学完整个 AOP 部分后，是不是概述中的这些概念就更容易理解和接受了呢？所以咱一开始说这些概念不好理解没关系，随着学习的深入，小伙伴们自然会体会到 “拨开云雾见光明” 的感觉。</p></blockquote><h3 id="1-2-AOP的设计原理"><a href="#1-2-AOP的设计原理" class="headerlink" title="1.2 AOP的设计原理"></a>1.2 AOP的设计原理</h3><p>如果只是从咱最常见的角度出发的话，那这个问题可以这样回答：</p><p><strong>AOP的底层设计是由运行时动态代理支撑，在 bean 的初始化流程中，借助 BeanPostProcessor 将原始的目标对象织入通知，生成代理对象。</strong></p><p>但是咱通过 AOP 高级中了解到的知识，可以了解到 AOP 的通知织入分为三种情况，所以上面的回答只回答了一种情况，另外两种也可以提一下，就像这样：</p><p><strong>AOP 的设计原理是对原有业务逻辑的横切增强，使用不同的通知织入方式，它有不同的底层原理支撑（编译期、类加载器、对象创建期）。</strong></p><h3 id="1-3-jdk动态代理和Cglib动态代理的对比"><a href="#1-3-jdk动态代理和Cglib动态代理的对比" class="headerlink" title="1.3 jdk动态代理和Cglib动态代理的对比"></a>1.3 jdk动态代理和Cglib动态代理的对比</h3><ul><li>jdk 动态代理要求被代理的对象所属类至少实现一个接口，它是 jdk 内置的机制</li><li>Cglib 动态代理无此限制，使用字节码增强技术实现，需要依赖第三方 Cglib 包</li><li>jdk 动态代理的代理对象创建速度快，执行速度慢；Cglib 动态代理的代理对象创建速度慢，执行速度快</li></ul><h3 id="1-4-理解AOP的术语"><a href="#1-4-理解AOP的术语" class="headerlink" title="1.4 理解AOP的术语"></a>1.4 理解AOP的术语</h3><p>之前咱借助表情包的场景理解了 AOP 的术语，这里咱再回顾一下吧。</p><ul><li><strong>Target 目标对象：被代理的原始对象</strong></li><li><strong>Proxy 代理对象：目标对象被织入通知后的产物就是代理对象</strong></li><li><strong>JoinPoint 连接点：目标对象的所属类中，定义的所有方法均为连接点</strong></li><li><strong>Pointcut 切入点：被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</strong></li><li><strong>Advice 通知：增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情</strong></li><li><strong>Aspect 切面：切入点 + 通知</strong></li><li><strong>Weaving 织入：将通知应用到目标对象，进而生成代理对象的过程动作</strong></li><li><strong>Introduction 引介：特殊的通知类型，可以在不修改原有类的代码的前提下，在运行期为原始类动态添加新的属性 / 方法</strong></li></ul><h3 id="1-5-通知的类型"><a href="#1-5-通知的类型" class="headerlink" title="1.5 通知的类型"></a>1.5 通知的类型</h3><p>注意，这里说的通知类型并没有指具体谁的，AOP 联盟定义的通知类型，与 AspectJ 定义的通知类型是不一样的，小伙伴们注意区分。</p><h4 id="1-5-1-AspectJ定义的通知类型"><a href="#1-5-1-AspectJ定义的通知类型" class="headerlink" title="1.5.1 AspectJ定义的通知类型"></a>1.5.1 AspectJ定义的通知类型</h4><ul><li><p><strong>Before 前置通知</strong>：目标对象的方法调用之前触发</p></li><li><p><strong>After 后置通知</strong>：目标对象的方法调用之后触发</p></li><li><p><strong>AfterReturning 返回通知</strong>：目标对象的方法调用完成，在返回结果值之后触发</p></li><li><p>AfterThrowing 异常通知</p><p>：目标对象的方法运行中抛出 / 触发异常后触发</p><ul><li>注意一点，<strong>AfterReturning 与 AfterThrowing 两者是互斥的</strong>！如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li></ul></li><li><p><strong>Around 环绕通知</strong>：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</p></li></ul><h4 id="1-5-2-AOP联盟定义的通知类型"><a href="#1-5-2-AOP联盟定义的通知类型" class="headerlink" title="1.5.2 AOP联盟定义的通知类型"></a>1.5.2 AOP联盟定义的通知类型</h4><ul><li><strong>前置通知</strong> MethodBeforeAdvice</li><li>后置通知（<strong>返回通知</strong>）AfterReturningAdvice</li><li><strong>异常通知</strong> ThrowsAdvice</li><li><strong>环绕通知</strong> MethodInterceptor</li><li>引介通知 IntroductionAdvisor</li></ul><h2 id="2-AOP的编码与应用"><a href="#2-AOP的编码与应用" class="headerlink" title="2. AOP的编码与应用"></a>2. AOP的编码与应用</h2><h3 id="2-1-AOP的使用场景"><a href="#2-1-AOP的使用场景" class="headerlink" title="2.1 AOP的使用场景"></a>2.1 AOP的使用场景</h3><p>AOP 的使用范围还是非常广的，前面小册里咱只提了日志和事务，其实还是有蛮多的，咱这里可以简单列一下：</p><ul><li><strong>业务日志切面</strong>：可以记录业务方法调用的痕迹</li><li><strong>事务控制</strong>：通过切面可以声明式控制事务</li><li><strong>权限校验</strong>：执行方法之前先校验当前登录用户是否有权调用</li><li><strong>数据缓存</strong>：执行方法之前先从缓存中取，取到则直接返回不走业务方法</li><li>。。。。。。</li></ul><h3 id="2-2-多个切面的执行顺序如何控制"><a href="#2-2-多个切面的执行顺序如何控制" class="headerlink" title="2.2 多个切面的执行顺序如何控制"></a>2.2 多个切面的执行顺序如何控制</h3><ul><li>显式使用 <code>@Order</code> 注解，或者 <code>Ordered</code> 接口，声明切面的执行顺序（默认 <code>Integer.MAX_VALUE</code> ）</li><li>通过使用类名的 unicode 编码顺序，控制切面的执行顺序</li></ul><h3 id="2-3-AOP的失效场景"><a href="#2-3-AOP的失效场景" class="headerlink" title="2.3 AOP的失效场景"></a>2.3 AOP的失效场景</h3><p>对于这个失效的场景，由于还没有学到 SpringWebMvc 部分，所以可以解释的内容相对有限。不过考虑到可能有些小伙伴看小册是为了查缺补漏，或者备战面试，咱这里还是把常见的可能出现的几种情况都列出来。</p><ul><li><p>代理对象调用自身的方法</p><p>时，AOP 通知会失效</p><ul><li>即在代理对象中直接调用 <code>this.xxx</code> 方法</li><li>正确做法是借助 <code>AopContext</code> 取到当前代理对象并强转，之后调用，这样 AOP 通知依然会执行</li></ul></li><li><p>代理对象在后置处理器还没有初始化的时候，提前创建了</p><p>，则 AOP 通知不会织入</p><ul><li>由于 AOP 是借助 <code>BeanPostProcessor</code> 实现，如果 <code>BeanPostProcessor</code> 还没有初始化好，目标对象已经创建了，则不可能再生成代理对象</li></ul></li><li><p>WebMvc ：原始的 SSM 工程架构中，</p><p>AOP 配置的切入点表达式，切入的是一些 Controller</p><p>，导致通知失效</p><ul><li>传统的 SSM 项目中，SpringFramework 容器与 SpringWebMvc 容器是父子容器，如果在父容器中定义切面类，则 MVC 的子容器无法感知到父容器中的通知，也就没办法织入通知了</li><li>正确做法是将切面类注册到 spring-mvc.xml 中，并开启 AspectJ 注解 AOP</li></ul></li><li><p>WebMvc ：</p><p>Controller 依赖的 Service 同时被父容器和子容器扫描</p><p>，则 Service 的通知会失效</p><ul><li>如果父容器和子容器都扫描到 Service ，则父容器和子容器中都会有一个 Service 的 bean 对象，这样在 Controller 依赖注入时，会直接拿 MVC 子容器中没有经过 AOP 代理的 Service ，而不会去父容器拿经过了 AOP 代理的 Service</li><li>正确做法是避免两个包扫描的部分产生交集</li></ul></li></ul><h2 id="3-AOP的高级应用"><a href="#3-AOP的高级应用" class="headerlink" title="3. AOP的高级应用"></a>3. AOP的高级应用</h2><h3 id="3-1-AOP的底层原理机制"><a href="#3-1-AOP的底层原理机制" class="headerlink" title="3.1 AOP的底层原理机制"></a>3.1 AOP的底层原理机制</h3><p>AOP 在底层，借助 <code>AnnotationAwareAspectJAutoProxyCreator</code> 在 bean 的初始化流程，<code>postProcessAfterInitialization</code> 方法中将目标对象包装为代理对象。这里面涉及到几个核心步骤：</p><ol><li>检查当前初始化的 bean 是否可以被 AOP 代理（检查是否有匹配的增强器）</li><li>如果存在，则根据当前初始化的 bean 所属类有无实现接口，以及 AOP 的全局配置，决定使用哪种代理方案</li><li>将目标对象包装为 <code>TargetSource</code> ，并以此为原型生成代理对象</li></ol><h3 id="3-2-代理对象的通知逻辑是如何执行的"><a href="#3-2-代理对象的通知逻辑是如何执行的" class="headerlink" title="3.2 代理对象的通知逻辑是如何执行的"></a>3.2 代理对象的通知逻辑是如何执行的</h3><p>代理对象被构造后，执行方法会进入 <code>JdkDynamicAopProxy</code> / <code>CglibAopProxy</code> 中，并构造 <code>ReflectiveMethodInvocation</code> 并依次执行这些织入的通知。执行通知的逻辑是靠一个 <code>currentInterceptorIndex</code> 下标控制，并以此下标为依据顺序执行增强器的通知逻辑。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>13-AOP原理-代理对象底层执行逻辑</title>
    <link href="/2022/04/17/13-AOP%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91/"/>
    <url>/2022/04/17/13-AOP%E5%8E%9F%E7%90%86-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP原理-代理对象的底层执行逻辑"><a href="#AOP原理-代理对象的底层执行逻辑" class="headerlink" title="AOP原理-代理对象的底层执行逻辑"></a>AOP原理-代理对象的底层执行逻辑</h1><p>代理对象已经创建好了，接下来就到了正常的业务代码执行了。经过 AOP 的增强后，获取到目标对象的代理对象执行方法时，就会先执行 AOP 增强中的增强器逻辑。下面咱继续以 <code>com.linkedbear.spring.aop.b_aspectj.AnnotationAspectJApplication</code> 中的代码来测试，执行 <code>financeService.addMoney</code> 方法和 <code>orderService.getOrderById</code> 方法的底层逻辑。</p><h2 id="1-FinanceService-addMoney"><a href="#1-FinanceService-addMoney" class="headerlink" title="1. FinanceService#addMoney"></a>1. FinanceService#addMoney</h2><p>将断点打在 <code>addMoney</code> 方法的调用上，Debug 进入时，会发现它先来到了 <code>CglibAopProxy</code>的内部类 <code>DynamicAdvisedInterceptor</code> 中：（下面的源码有点长，小册把不太重要的注释都删掉，只留下重要的几个环节，小伙伴们注意留意）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    Object oldProxy = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> setProxyContext = <span class="hljs-keyword">false</span>;<br>    Object target = <span class="hljs-keyword">null</span>;<br>    TargetSource targetSource = <span class="hljs-keyword">this</span>.advised.getTargetSource();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果有在@EnableAspectJAutoProxy注解上配置exposeProxy属性为true，</span><br>        <span class="hljs-comment">// 则会把当前代理对象放入AOP上下文中</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) &#123;<br>            oldProxy = AopContext.setCurrentProxy(proxy);<br>            setProxyContext = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从TargetSource中取出目标对象</span><br>        target = targetSource.getTarget();<br>        Class&lt;?&gt; targetClass = (target != <span class="hljs-keyword">null</span> ? target.getClass() : <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 根据当前执行的方法，获取要执行的增强器，并以列表返回(链的思想)</span><br>        List&lt;Object&gt; chain = <span class="hljs-keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>        Object retVal;<br>        <br>        <span class="hljs-comment">// 如果没有要执行的增强器，则直接执行目标方法</span><br>        <span class="hljs-keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;<br>            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>            retVal = methodProxy.invoke(target, argsToUse);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则，构造增强器链，执行增强器的逻辑</span><br>            retVal = <span class="hljs-keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();<br>        &#125;<br>        retVal = processReturnType(proxy, target, method, retVal);<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125; <span class="hljs-comment">// finally ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>整个流程下来，核心步骤就两步：<strong>获取增强器链、执行增强器</strong>。同时这里也发现了之前咱讲过的一些小细节：<code>exposeProxy</code> 的实现、<code>TargetSource</code> 的使用等等。不过我们最需要关注的还是这两个核心部分，咱分别来研究。</p><h3 id="1-1-getInterceptorsAndDynamicInterceptionAdvice"><a href="#1-1-getInterceptorsAndDynamicInterceptionAdvice" class="headerlink" title="1.1 getInterceptorsAndDynamicInterceptionAdvice"></a>1.1 getInterceptorsAndDynamicInterceptionAdvice</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;<br>    MethodCacheKey cacheKey = <span class="hljs-keyword">new</span> MethodCacheKey(method);<br>    List&lt;Object&gt; cached = <span class="hljs-keyword">this</span>.methodCache.get(cacheKey);<br>    <span class="hljs-keyword">if</span> (cached == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 核心逻辑</span><br>        cached = <span class="hljs-keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<br>                <span class="hljs-keyword">this</span>, method, targetClass);<br>        <span class="hljs-keyword">this</span>.methodCache.put(cacheKey, cached);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cached;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显又是缓存的设计，第一次调用完成后，以后就直接从缓存中读了，不需要多次获取和解析。刨去这个不看，核心的方法还是 if 结构中的方法了，咱继续往里进。不过里面的逻辑有点长，咱拆开分段研究：</p><h4 id="1-1-1-前置准备"><a href="#1-1-1-前置准备" class="headerlink" title="1.1.1 前置准备"></a>1.1.1 前置准备</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Advised config, Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;<br>    <span class="hljs-comment">// 增强器适配器的注册器，它会根据增强器来解析，返回拦截器数组</span><br>    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();<br>    Advisor[] advisors = config.getAdvisors();<br>    List&lt;Object&gt; interceptorList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(advisors.length);<br>    Class&lt;?&gt; actualClass = (targetClass != <span class="hljs-keyword">null</span> ? targetClass : method.getDeclaringClass());<br>    Boolean hasIntroductions = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>在循环处理增强器之前，这里先进行了一些基本的前置处理，这里它初始化了一个 <code>AdvisorAdapterRegistry</code> ，意为<strong>增强器适配器的注册器</strong>，它的主要作用是将 AspectJ 类型的增强器，转换为 <code>MethodInterceptor</code> （ AOP 联盟的那个 <code>MethodInterceptor</code> ）并返回。此举的目的，会在接下来的 <code>CglibMethodInvocation</code> 中得以体现，咱这里先有个印象即可。</p><p>Debug 到此处，发现这里面有 3 个增强器的适配器，虽然没法 <code>toString</code> ，但看这个名也就知道，这大概就是 <code>Logger</code> 那个切面类中的那几个方法。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54fd49626c834176aa201c6a2bc4bfb6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h4 id="1-1-2-匹配增强器"><a href="#1-1-2-匹配增强器" class="headerlink" title="1.1.2 匹配增强器"></a>1.1.2 匹配增强器</h4><p>这部分开始循环匹配增强器了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">for</span> (Advisor advisor : advisors) &#123;<br>    <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) &#123;<br>        <span class="hljs-comment">// 此处拿到的就是AspectJ形式的通知方法封装</span><br>        PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;<br>        <span class="hljs-keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;<br>            <span class="hljs-comment">// 根据通知方法上的切入点表达式，判断是否可以匹配当前要执行的目标对象所属类</span><br>            MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();<br>            <span class="hljs-keyword">boolean</span> match;<br>            <span class="hljs-comment">// 引介匹配</span><br>            <span class="hljs-keyword">if</span> (mm <span class="hljs-keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;<br>                <span class="hljs-keyword">if</span> (hasIntroductions == <span class="hljs-keyword">null</span>) &#123;<br>                    hasIntroductions = hasMatchingIntroductions(advisors, actualClass);<br>                &#125;<br>                match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 方法匹配</span><br>                match = mm.matches(method, actualClass);<br>            &#125;<br>            <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>这部分的匹配逻辑也不难，它会把上面取出来的增强器依次与当前正在调用的目标对象做匹配，匹配的方式与之前一样，都是借助 <code>MethodMatcher</code> 进行。</p><p>Debug 可以发现此处把 <code>Logger</code> 中声明的 5 个通知方法，以及 SpringFramework 内置的那个增强器，一起都收集到了：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8502b08552ad4519bceba3620d2df08d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h4 id="1-1-3-匹配后的处理"><a href="#1-1-3-匹配后的处理" class="headerlink" title="1.1.3 匹配后的处理"></a>1.1.3 匹配后的处理</h4><p>匹配到增强器之后，接下来就是决定如何封装为 <code>MethodInterceptor</code> 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">// ......</span><br>        <span class="hljs-keyword">if</span> (match) &#123;<br>            MethodInterceptor[] interceptors = registry.getInterceptors(advisor);<br>            <span class="hljs-comment">// runtime的概念</span><br>            <span class="hljs-keyword">if</span> (mm.isRuntime()) &#123;<br>                <span class="hljs-keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;<br>                    interceptorList.add(<span class="hljs-keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                interceptorList.addAll(Arrays.asList(interceptors));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>这部分本身的添加并不难，不过这里面有一个 runtime 的概念，想必小伙伴们会比较懵，这里咱简单解释一下。</p><p>通常情况下，<code>MethodMatcher</code> 都是静态的匹配器，但 Spring 在此处做了一个设计，如果 <code>MethodMatcher</code> 被设置为动态的匹配器，则每次调用匹配方法时，可以提前拿到方法调用的参数值列表。说起来有点难理解，咱先看两个方法的签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span></span>;<br></code></pre></td></tr></table></figure><p>小册这样解释一下，你们都就立马明白了：<strong>静态匹配器只会做匹配，而动态的匹配器可以提前拿到方法调用的参数值列表</strong>（注意是参数值）。</p><h4 id="1-1-4-其他增强器的处理"><a href="#1-1-4-其他增强器的处理" class="headerlink" title="1.1.4 其他增强器的处理"></a>1.1.4 其他增强器的处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">// ......</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>            IntroductionAdvisor ia = (IntroductionAdvisor) advisor;<br>            <span class="hljs-keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;<br>                Interceptor[] interceptors = registry.getInterceptors(advisor);<br>                interceptorList.addAll(Arrays.asList(interceptors));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            Interceptor[] interceptors = registry.getInterceptors(advisor);<br>            interceptorList.addAll(Arrays.asList(interceptors));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> interceptorList;<br>&#125;<br></code></pre></td></tr></table></figure><p>在最下面，就是引介增强器，以及其它类型的增强器的处理了，这里咱一般都碰不到，AspectJ 风格的声明都是走上面的 <code>PointcutAdvisor</code> 判断逻辑，所以咱这里就不细展开了。</p><p>经过这个方法的处理之后，当前目标对象要执行的方法就都筛选出来了，接下来就是构建方法执行器了。</p><h3 id="1-2-CglibMethodInvocation"><a href="#1-2-CglibMethodInvocation" class="headerlink" title="1.2 CglibMethodInvocation"></a>1.2 CglibMethodInvocation</h3><p>下面是构造的 <code>CglibMethodInvocation</code> ，执行 <code>proceed</code> 方法了，咱先看看这个 <code>CglibMethodInvocation</code> 是个啥：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibMethodInvocation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReflectiveMethodInvocation</span></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ReflectiveMethodInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProxyMethodInvocation</span>, <span class="hljs-title">Cloneable</span></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">ProxyMethodInvocation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodInvocation</span></span><br></code></pre></td></tr></table></figure><p>得了，果然还是回到 AOP 联盟定义的那个 <code>MethodInvocation</code> 了，那咱就知道上面的那个适配的设计了，大家都是 <code>MethodInvocation</code> ，那就都好说了。</p><p>接下来，咱执行 <code>proceed</code> 方法，而在 <code>CglibMethodInvocation</code> 中，它只是单纯的调用父类的 <code>proceed</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.proceed();<br>    &#125; <span class="hljs-comment">// catch ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那往上调用，那就来到 <code>ReflectiveMethodInvocation</code> 类中了。</p><p>接下来的调用过程可能会很绕，小册尝试用过程的方式记录每一步的执行动作和逻辑，方便小伙伴们体会这里面的高深设计。</p><h4 id="1-2-0-方法概览"><a href="#1-2-0-方法概览" class="headerlink" title="1.2.0 方法概览"></a>1.2.0 方法概览</h4><p>先大概看一下 <code>proceed</code> 方法的设计吧，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> List&lt;?&gt; interceptorsAndDynamicMethodMatchers;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentInterceptorIndex = -<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-comment">// We start with an index of -1 and increment early.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 增强器全部执行完毕后，会执行目标方法</span><br>        <span class="hljs-keyword">return</span> invokeJoinpoint();<br>    &#125;<br><br>    <span class="hljs-comment">// 依次取出增强器封装的拦截器，并执行</span><br>    Object interceptorOrInterceptionAdvice =<br>            <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-keyword">this</span>.currentInterceptorIndex);<br>    <span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;<br>        <span class="hljs-comment">// 此处是动态匹配器构造的特殊逻辑</span><br>        InterceptorAndDynamicMethodMatcher dm =<br>                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;<br>        Class&lt;?&gt; targetClass = (<span class="hljs-keyword">this</span>.targetClass != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.targetClass : <span class="hljs-keyword">this</span>.method.getDeclaringClass());<br>        <span class="hljs-keyword">if</span> (dm.methodMatcher.matches(<span class="hljs-keyword">this</span>.method, targetClass, <span class="hljs-keyword">this</span>.arguments)) &#123;<br>            <span class="hljs-keyword">return</span> dm.interceptor.invoke(<span class="hljs-keyword">this</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> proceed();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 此处会调用增强器的逻辑</span><br>        <span class="hljs-keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里先解释一波动态匹配器的逻辑，看中间的 if 部分，如果 <code>MethodMatcher</code> 有被封装为动态匹配器，则这里会继续匹配，如果动态匹配器在匹配到方法调用的参数值列表发现匹配不上，则这个增强器不会执行。</p><p>其余的部分，就看接下来的执行逻辑咯，小伙伴们不要被小册搞晕哦。</p><h4 id="1-2-1-执行proceed方法"><a href="#1-2-1-执行proceed方法" class="headerlink" title="1.2.1 执行proceed方法"></a>1.2.1 执行proceed方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> invokeJoinpoint();<br>    &#125;<br></code></pre></td></tr></table></figure><p>此时的 <code>currentInterceptorIndex</code> 下标值为 -1 ：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fb2e2d79c254a5b9b175e103295b75a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>计算值：**<code>-1 ≠ 3 - 1</code>**，则不进入 <code>invokeJoinpoint</code> 方法，继续往下走。</p><h4 id="1-2-2-下标值"><a href="#1-2-2-下标值" class="headerlink" title="1.2.2 下标值++"></a>1.2.2 下标值++</h4><p>接下来，执行下面的 <code>this.interceptorsAndDynamicMethodMatchers.get</code> 动作，此时 <code>this.currentInterceptorIndex</code> 执行了一次自增操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentInterceptorIndex == <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> invokeJoinpoint();<br>&#125;<br><br>Object interceptorOrInterceptionAdvice =<br>        <span class="hljs-keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="hljs-keyword">this</span>.currentInterceptorIndex);<br><span class="hljs-keyword">if</span> (interceptorOrInterceptionAdvice <span class="hljs-keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;<br></code></pre></td></tr></table></figure><p>此时 <code>currentInterceptorIndex</code> 值为 0 。</p><h4 id="1-2-3-执行第一个增强器"><a href="#1-2-3-执行第一个增强器" class="headerlink" title="1.2.3 执行第一个增强器"></a>1.2.3 执行第一个增强器</h4><p>既然获取到了增强器对应的拦截器，那就执行它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    MethodInvocation oldInvocation = invocation.get();<br>    invocation.set(mi);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> mi.proceed();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        invocation.set(oldInvocation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>又看到这个 <code>invoke</code> 方法了，咱已经挺熟悉了，下一步肯定是继续执行 <code>proceed</code> 方法嘛。</p><h4 id="1-2-4-继续执行proceed方法"><a href="#1-2-4-继续执行proceed方法" class="headerlink" title="1.2.4 继续执行proceed方法"></a>1.2.4 继续执行proceed方法</h4><p>接下来执行 <code>proceed</code> 方法，会发现它又回到上面的 1.2.1 步了，只不过此时的 <code>currentInterceptorIndex</code> 值不再是 -1 ，而是 0 。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f16bc65284f042c4b78a4c9e1a727f52~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>计算值：**<code>0 ≠ 3 - 1</code>**，则不进入 <code>invokeJoinpoint</code> 方法，继续往下走。</p><h4 id="1-2-5-进入AspectJAroundAdvice中"><a href="#1-2-5-进入AspectJAroundAdvice中" class="headerlink" title="1.2.5 进入AspectJAroundAdvice中"></a>1.2.5 进入AspectJAroundAdvice中</h4><p>那既然计算结果不等，那就继续执行增强器逻辑嘛，由于接下来要执行的是一个环绕通知，咱来到 <code>AspectJAroundAdvice</code> 的 <code>invoke</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">if</span> (!(mi <span class="hljs-keyword">instanceof</span> ProxyMethodInvocation)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);<br>    &#125;<br>    ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;<br>    ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);<br>    JoinPointMatch jpm = getJoinPointMatch(pmi);<br>    <span class="hljs-keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>前面的获取都是很基本的了，最下面的 <code>invokeAdviceMethod</code> 才是关键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">invokeAdviceMethod</span><span class="hljs-params">(JoinPoint jp, <span class="hljs-meta">@Nullable</span> JoinPointMatch jpMatch,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Object returnValue, <span class="hljs-meta">@Nullable</span> Throwable t)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">invokeAdviceMethodWithGivenArgs</span><span class="hljs-params">(Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    Object[] actualArgs = args;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="hljs-number">0</span>) &#123;<br>        actualArgs = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ReflectionUtils.makeAccessible(<span class="hljs-keyword">this</span>.aspectJAdviceMethod);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.aspectJAdviceMethod.invoke(<span class="hljs-keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);<br>    &#125; <span class="hljs-comment">// catch ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>合着折腾到最后，还是个反射执行目标对象的方法。。。</p><h4 id="1-2-6-进入到Logger中"><a href="#1-2-6-进入到Logger中" class="headerlink" title="1.2.6 进入到Logger中"></a>1.2.6 进入到Logger中</h4><p>因为是环绕通知嘛，那就理所应当的进入到 <code>Logger</code> 中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;execution(public * com.linkedbear.spring.aop.b_aspectj.service.FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">aroundPrint</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger aroundPrint before run ......&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object retVal = joinPoint.proceed();<br>        System.out.println(<span class="hljs-string">&quot;Logger aroundPrint afterReturning run ......&quot;</span>);<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125; <span class="hljs-comment">// catch finally ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行了前置通知打印后，接下来的 <code>joinPoint.proceed</code> 方法的执行，想必不用小册解释，小伙伴们也能想得到了吧。</p><h4 id="1-2-7-继续执行proceed方法"><a href="#1-2-7-继续执行proceed方法" class="headerlink" title="1.2.7 继续执行proceed方法"></a>1.2.7 继续执行proceed方法</h4><p>想是想到了，但这个中间还有个小插曲。。。<code>proceed</code> 方法的执行，肯定是走的 <code>ProceedingJoinPoint</code> 的 <code>proceed</code> 方法呀，不是上面 <code>ReflectiveMethodInvocation</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.methodInvocation.invocableClone().proceed();<br>&#125;<br></code></pre></td></tr></table></figure><p>哎，这里的 <code>proceed</code> 方法，才是上面咱执行那些 <code>proceed</code> 方法，此时 <code>currentInterceptorIndex</code> 的值为 1 ：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93ba4ca0f9db40928acf50c6162d6196~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>然后，又是同样的获取、自增、执行。。。</p><h4 id="1-2-8-进入MethodBeforeAdviceInterceptor中"><a href="#1-2-8-进入MethodBeforeAdviceInterceptor中" class="headerlink" title="1.2.8 进入MethodBeforeAdviceInterceptor中"></a>1.2.8 进入MethodBeforeAdviceInterceptor中</h4><p>第三个通知方法的执行，是那个前置通知，它会来到 <code>MethodBeforeAdviceInterceptor</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());<br>    <span class="hljs-keyword">return</span> mi.proceed();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现还蛮简单的，它就是把前置通知的方法执行一下，然后继续执行 <code>MethodInvocation</code> 的 <code>proceed</code> 方法了。</p><h4 id="1-2-9-执行目标对象方法"><a href="#1-2-9-执行目标对象方法" class="headerlink" title="1.2.9 执行目标对象方法"></a>1.2.9 执行目标对象方法</h4><p>接下来，又回到 <code>proceed</code> 方法，此时 <code>currentInterceptorIndex</code> 的值为 2 ：</p><p>计算得 <strong><code>2 = 3 - 1</code></strong> ，终于相等了，那就可以执行目标方法了。</p><h4 id="1-2-10-流程小结"><a href="#1-2-10-流程小结" class="headerlink" title="1.2.10 流程小结"></a>1.2.10 流程小结</h4><p>好了，经过这个流程之后，咱终于走完这个全程，由此我们可以得出算法逻辑：</p><p><strong>利用一个全局索引值，决定每次执行的拦截器，当所有拦截器都执行完时，索引值刚好等于 <code>size() - 1</code>，此时就可以执行真正的目标方法了</strong> 。</p><p>最后用一张图来更好地理解这段逻辑：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb56cf9de64a46e7ba96a19df2f9da29~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h2 id="2-OrderService-getOrderById"><a href="#2-OrderService-getOrderById" class="headerlink" title="2. OrderService#getOrderById"></a>2. OrderService#getOrderById</h2><p>咱继续研究 jdk 动态代理的执行。将断点打在 <code>getOrderById</code> 方法的调用上，Debug 进入时它肯定就不跟上面的 Cglib 动态代理一样了，它进入的是 <code>JdkDynamicAopProxy</code> 中。不过由于这里面的 invoke 方法实在是有点长，小册在这里只截取关键部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    Object oldProxy = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> setProxyContext = <span class="hljs-keyword">false</span>;<br><br>    TargetSource targetSource = <span class="hljs-keyword">this</span>.advised.targetSource;<br>    Object target = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// equals方法不代理</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;<br>            <span class="hljs-comment">// The target does not implement the equals(Object) method itself.</span><br>            <span class="hljs-keyword">return</span> equals(args[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// hashCode方法不代理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;<br>            <span class="hljs-comment">// The target does not implement the hashCode() method itself.</span><br>            <span class="hljs-keyword">return</span> hashCode();<br>        &#125;<br>        <span class="hljs-comment">// 方法来自于DecoratingProxy接口的，也不代理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;<br>            <span class="hljs-comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br>            <span class="hljs-keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="hljs-keyword">this</span>.advised);<br>        &#125;<br>        <span class="hljs-comment">// 目标对象本身就是实现了Advised接口，也不代理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;<br>                method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;<br>            <span class="hljs-comment">// Service invocations on ProxyConfig with the proxy config...</span><br>            <span class="hljs-keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="hljs-keyword">this</span>.advised, method, args);<br>        &#125;<br><br>        Object retVal;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) &#123;<br>            oldProxy = AopContext.setCurrentProxy(proxy);<br>            setProxyContext = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        target = targetSource.getTarget();<br>        Class&lt;?&gt; targetClass = (target != <span class="hljs-keyword">null</span> ? target.getClass() : <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 根据当前执行的方法，获取要执行的增强器，并以列表返回(链的思想)</span><br>        List&lt;Object&gt; chain = <span class="hljs-keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>        <span class="hljs-keyword">if</span> (chain.isEmpty()) &#123;<br>            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            MethodInvocation invocation =<br>                    <span class="hljs-keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);<br>            <span class="hljs-comment">// 构造增强器链，执行增强器的逻辑</span><br>            retVal = invocation.proceed();<br>        &#125;<br>        <span class="hljs-comment">// 返回值的处理 ......</span><br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125; <span class="hljs-comment">// finally ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>先看下面的部分，是不是跟上面 <code>CglibAopProxy</code> 完全一致？所以 这两者其实在底层实现中都是一样的，包括这里它创建的直接就是 <code>ReflectiveMethodInvocation</code> ，与上面咱看到的那个家伙是同一个。</p><p>所以这个逻辑也是一模一样的吧，具体流程这个就留给小伙伴当课后作业了，小册只在这里附一张类似的流程图啦：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c268dcb3b2e1438fa80c5618055ca7f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h2 id="3-Aspect中的四种通知在源码中的实现"><a href="#3-Aspect中的四种通知在源码中的实现" class="headerlink" title="3. Aspect中的四种通知在源码中的实现"></a>3. Aspect中的四种通知在源码中的实现</h2><p>最后，咱对 AspectJ 中提到的四种声明式的通知，它的底层实现有一个简单的了解，前面咱看过环绕通知了，所以这个咱就不列出来了。</p><h4 id="3-1-Before"><a href="#3-1-Before" class="headerlink" title="3.1 @Before"></a>3.1 @Before</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodBeforeAdviceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><span class="hljs-keyword">private</span> MethodBeforeAdvice advice;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><span class="hljs-keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );<br><span class="hljs-keyword">return</span> mi.proceed();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先执行前置通知，再执行目标方法。</p><h4 id="3-2-After"><a href="#3-2-After" class="headerlink" title="3.2 @After"></a>3.2 @After</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJAfterAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAspectJAdvice</span></span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">AfterAdvice</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> mi.proceed();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>invokeAdviceMethod(getJoinPointMatch(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行目标方法后，在 finally 中执行后置方法（由此也说明了它的通知时机更靠后）。</p><h4 id="3-3-AfterReturning"><a href="#3-3-AfterReturning" class="headerlink" title="3.3 @AfterReturning"></a>3.3 @AfterReturning</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterReturningAdviceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">AfterAdvice</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AfterReturningAdvice advice;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>Object retVal = mi.proceed();<br><span class="hljs-keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());<br><span class="hljs-keyword">return</span> retVal;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回值后置处理中不设置 try-catch 块，说明不出现任何异常时才会触发该后置通知。</p><h4 id="3-4-AfterThrowing"><a href="#3-4-AfterThrowing" class="headerlink" title="3.4 @AfterThrowing"></a>3.4 @AfterThrowing</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJAfterThrowingAdvice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAspectJAdvice</span></span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">AfterAdvice</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> mi.proceed();<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;<br>invokeAdviceMethod(getJoinPointMatch(), <span class="hljs-keyword">null</span>, ex);<br>&#125;<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>出现异常时，进入该后置通知，因为设置了 try-catch ，所以这里 catch 中根据是否标注了异常通知，进行相应的后置处理。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>12-AOP原理-Bean如何被AOP代理的</title>
    <link href="/2022/04/17/12-AOP%E5%8E%9F%E7%90%86-Bean%E5%A6%82%E4%BD%95%E8%A2%ABAOP%E4%BB%A3%E7%90%86%E7%9A%84/"/>
    <url>/2022/04/17/12-AOP%E5%8E%9F%E7%90%86-Bean%E5%A6%82%E4%BD%95%E8%A2%ABAOP%E4%BB%A3%E7%90%86%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP原理-Bean是如何被AOP代理的"><a href="#AOP原理-Bean是如何被AOP代理的" class="headerlink" title="AOP原理-Bean是如何被AOP代理的"></a>AOP原理-Bean是如何被AOP代理的</h1><p>前面咱已经知道，最终 bean 的初始化会被 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 处理，进入到 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的 <code>postProcessAfterInitialization</code> 方法中，它又要调用 <code>wrapIfNecessary</code> 方法来尝试创建代理，咱深入方法内部来研究。</p><h2 id="1-wrapIfNecessary"><a href="#1-wrapIfNecessary" class="headerlink" title="1. wrapIfNecessary"></a>1. wrapIfNecessary</h2><p>源码咱在第 48 章已经见过一次了，咱再拿出来提一下印象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断决定是否是不会被增强的 bean</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-keyword">this</span>.advisedBeans.get(cacheKey))) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;<br>        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// Create proxy if we have advice.</span><br>    <span class="hljs-comment">// 如果上面的判断都没有成立，则决定是否需要进行代理对象的创建</span><br>    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<br>        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<br>        <span class="hljs-comment">// 创建代理对象的动作</span><br>        <span class="hljs-comment">// 注意此处它创建了一个SingletonTargetSource，将bean包装起来了</span><br>        Object proxy = createProxy(<br>                bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> SingletonTargetSource(bean));<br>        <span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里前面的筛选过滤懂还是蛮简单的，咱就不关注了，重点是关注一下中间的获取增强器，以及下面的创建代理对象，两个动作。</p><h3 id="1-1-getAdvicesAndAdvisorsForBean"><a href="#1-1-getAdvicesAndAdvisorsForBean" class="headerlink" title="1.1 getAdvicesAndAdvisorsForBean"></a>1.1 getAdvicesAndAdvisorsForBean</h3><p>这个方法很明显是根据当前正在初始化的 bean ，去匹配获取能切入的增强器，它的源码看上去不复杂：（当然也仅仅是看上去）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(<br>        Class&lt;?&gt; beanClass, String beanName, <span class="hljs-meta">@Nullable</span> TargetSource targetSource) &#123;<br><br>    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);<br>    <span class="hljs-keyword">if</span> (advisors.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> DO_NOT_PROXY;<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors.toArray();<br>&#125;<br></code></pre></td></tr></table></figure><p>毫无疑问，核心逻辑是 <code>findEligibleAdvisors</code> 方法咯，继续往里走：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findEligibleAdvisors</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取所有增强器</span><br>    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>    <span class="hljs-comment">// 筛选出可以切入当前bean的增强器</span><br>    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);<br>    <span class="hljs-comment">// 添加额外的增强器</span><br>    extendAdvisors(eligibleAdvisors);<br>    <span class="hljs-keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;<br>        <span class="hljs-comment">// 增强器排序</span><br>        eligibleAdvisors = sortAdvisors(eligibleAdvisors);<br>    &#125;<br>    <span class="hljs-keyword">return</span> eligibleAdvisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法就很复杂了，尽管只有几行，但都是封装好的方法，咱一个一个的展开来看。</p><h4 id="1-1-1-findCandidateAdvisors"><a href="#1-1-1-findCandidateAdvisors" class="headerlink" title="1.1.1 findCandidateAdvisors"></a>1.1.1 findCandidateAdvisors</h4><p>又回到 <code>AnnotationAwareAspectJAutoProxyCreator</code> 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Add all the Spring advisors found according to superclass rules.</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">super</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// Build Advisors for all AspectJ aspects in the bean factory.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder != <span class="hljs-keyword">null</span>) &#123;<br>        advisors.addAll(<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，这个方法只是把 SpringFramework 原生的 AOP 增强器，以及 AspectJ 形式封装的增强器都拿出来，仅此而已。</p><h4 id="1-1-2-findAdvisorsThatCanApply"><a href="#1-1-2-findAdvisorsThatCanApply" class="headerlink" title="1.1.2 findAdvisorsThatCanApply"></a>1.1.2 findAdvisorsThatCanApply</h4><p>所有的增强器获取到之后，下面要去匹配可以切入到当前 bean 的增强器了，咱进入到 <code>findAdvisorsThatCanApply</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findAdvisorsThatCanApply</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    ProxyCreationContext.setCurrentProxiedBeanName(beanName);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ProxyCreationContext.setCurrentProxiedBeanName(<span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法又交给 <code>AopUtils</code> 执行了，咱继续往里看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Advisor&gt; <span class="hljs-title">findAdvisorsThatCanApply</span><span class="hljs-params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (candidateAdvisors.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> candidateAdvisors;<br>    &#125;<br>    List&lt;Advisor&gt; eligibleAdvisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// 先匹配引介增强器</span><br>    <span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;<br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;<br>            eligibleAdvisors.add(candidate);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();<br>    <span class="hljs-comment">// 再匹配普通方法增强器</span><br>    <span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;<br>        <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>            <span class="hljs-comment">// already processed</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;<br>            eligibleAdvisors.add(candidate);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> eligibleAdvisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，整体逻辑分为两个部分，前面是针对引介通知的增强器作筛选，后面是普通的方法通知封装的增强器。</p><p>上面的引介增强器的匹配咱就不多研究了，本来平时就用得少，咱主要还是来看对于方法的增强器，它是如何去做匹配的。进入到下面的 <code>canApply</code> 方法中：（留意源码中标注的注释）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canApply</span><span class="hljs-params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="hljs-keyword">boolean</span> hasIntroductions)</span> </span>&#123;<br>    <span class="hljs-comment">// 对于引介增强器，它会直接强转，使用类级别的过滤器去匹配</span><br>    <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>        <span class="hljs-keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) &#123;<br>        <span class="hljs-comment">// 方法切入点的增强器匹配逻辑</span><br>        PointcutAdvisor pca = (PointcutAdvisor) advisor;<br>        <span class="hljs-keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// It doesn&#x27;t have a pointcut so we assume it applies.</span><br>        <span class="hljs-comment">// SpringFramework也不知道咋搞了，于是就直接让它可以匹配</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这个逻辑中就可以看出，底层针对不同种的增强器，分别会有不同的判断逻辑。对于方法增强器的判断，它又调用了下面的重载方法：（篇幅略长，小伙伴们只需要关心有注释的部分即可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canApply</span><span class="hljs-params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="hljs-keyword">boolean</span> hasIntroductions)</span> </span>&#123;<br>    Assert.notNull(pc, <span class="hljs-string">&quot;Pointcut must not be null&quot;</span>);<br>    <span class="hljs-comment">// 连类都切入不进去，那干脆没必要往下走了</span><br>    <span class="hljs-keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    MethodMatcher methodMatcher = pc.getMethodMatcher();<br>    <span class="hljs-keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 针对引介通知的匹配</span><br>    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (methodMatcher <span class="hljs-keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;<br>        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;<br>    &#125;<br><br>    Set&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;<br>        classes.add(ClassUtils.getUserClass(targetClass));<br>    &#125;<br>    classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));<br><br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;<br>        <span class="hljs-comment">// 逐个判断每个方法是否能被当前切入点表达式切入，切入则立即返回true</span><br>        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            <span class="hljs-keyword">if</span> (introductionAwareMethodMatcher != <span class="hljs-keyword">null</span> ?<br>                    introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :<br>                    methodMatcher.matches(method, targetClass)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体思路还是很清晰的吧，我们要理解的核心部分，是下面的这个双重循环，以此就能判断出来切入点表达式是否能对当前 bean 进行增强了。</p><p>Debug 下来，最终发现可以给 <code>OrderService</code> 匹配到的增强器一共有 2 个：（ <code>FinanceService</code> 就不看了，因为咱一开始学习的时候，就是拿它举的例子，所有的通知方法都切入它了）</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a87a9fe41e9b449c95f14a209fc118c3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h4 id="1-1-3-extendAdvisors"><a href="#1-1-3-extendAdvisors" class="headerlink" title="1.1.3 extendAdvisors"></a>1.1.3 extendAdvisors</h4><p>这个方法看上去蛮不起眼的，不过小伙伴们有自己 Debug 的话，过了这个方法会发现 <code>eligibleAdvisors</code> 集合中多了一个增强器：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4216759584e4627b3ff1cfc8523bd02~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>诶？它自己还有偷偷添加增强器啊，那咱看看它干了些啥：</p><h5 id="1-1-3-1-extendAdvisors方法的小动作"><a href="#1-1-3-1-extendAdvisors方法的小动作" class="headerlink" title="1.1.3.1 extendAdvisors方法的小动作"></a>1.1.3.1 extendAdvisors方法的小动作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extendAdvisors</span><span class="hljs-params">(List&lt;Advisor&gt; candidateAdvisors)</span> </span>&#123;<br>    AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);<br>&#125;<br><br><span class="hljs-comment">// AspectJProxyUtils</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">makeAdvisorChainAspectJCapableIfNecessary</span><span class="hljs-params">(List&lt;Advisor&gt; advisors)</span> </span>&#123;<br>    <span class="hljs-comment">// Don&#x27;t add advisors to an empty list; may indicate that proxying is just not required</span><br>    <span class="hljs-keyword">if</span> (!advisors.isEmpty()) &#123;<br>        <span class="hljs-keyword">boolean</span> foundAspectJAdvice = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (Advisor advisor : advisors) &#123;<br>            <span class="hljs-comment">// Be careful not to get the Advice without a guard, as this might eagerly</span><br>            <span class="hljs-comment">// instantiate a non-singleton AspectJ aspect...</span><br>            <span class="hljs-keyword">if</span> (isAspectJAdvice(advisor)) &#123;<br>                foundAspectJAdvice = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 发现有AspectJ包装的增强器，则添加一个ExposeInvocationInterceptor</span><br>        <span class="hljs-keyword">if</span> (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) &#123;<br>            advisors.add(<span class="hljs-number">0</span>, ExposeInvocationInterceptor.ADVISOR);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑不算复杂，它这个方法的关键是，判断当前可用的增强器中有没有 AspectJ 类型的，如果有的话，那就在整个增强器的列表的最前面，添加一个 <code>ExposeInvocationInterceptor.ADVISOR</code> 。</p><h5 id="1-1-3-2-ADVISOR是个啥？"><a href="#1-1-3-2-ADVISOR是个啥？" class="headerlink" title="1.1.3.2 ADVISOR是个啥？"></a>1.1.3.2 ADVISOR是个啥？</h5><p>那这个 <code>ADVISOR</code> 又是个啥子？咱继续往里走：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExposeInvocationInterceptor INSTANCE = <span class="hljs-keyword">new</span> ExposeInvocationInterceptor();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Advisor ADVISOR = <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(INSTANCE) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ExposeInvocationInterceptor.class.getName() +<span class="hljs-string">&quot;.ADVISOR&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>哦？合着它是个对所有 bean 都生效的增强器呗？传入的这个 <code>INSTANCE</code> 很明显是单例的设计，那到头来核心还是这个 <code>ExposeInvocationInterceptor</code> 本身。</p><h5 id="1-1-3-3-ExposeInvocationInterceptor又是个啥？"><a href="#1-1-3-3-ExposeInvocationInterceptor又是个啥？" class="headerlink" title="1.1.3.3 ExposeInvocationInterceptor又是个啥？"></a>1.1.3.3 ExposeInvocationInterceptor又是个啥？</h5><p>那新的问题就来了：<code>ExposeInvocationInterceptor</code> 这玩意的作用是什么呢？</p><p>翻开源码的核心 invoke 方法，发现它在向当前线程的 <code>ThreadLocal</code> 中放入了当前正在执行的代理对象的方法执行包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;MethodInvocation&gt; invocation =<br><span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">&quot;Current AOP method invocation&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    MethodInvocation oldInvocation = invocation.get();<br>    invocation.set(mi);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> mi.proceed();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        invocation.set(oldInvocation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次都在增强器链的第一个执行，并且放入 <code>ThreadLocal</code> 变量中，那这意图就很明显了：它可以让后面的增强器都拿到当前正在执行的 <code>MethodInvocation</code> 。至于哪里会用到 <code>MethodInvocation</code> ，咱目前还没有遇到，后面如果遇到了咱再留意。</p><p>或许会有小伙伴产生一个小小的疑惑：那你放就放呗，<code> MethodInvocation oldInvocation = invocation.get();</code> 这个操作是啥意思？原本就没有，你 <code>get</code> 个什么劲呢？？？</p><p>哎？真的没有吗？如果是一个 AOP 代理对象，调用了另外一个 AOP 代理对象的话，这个过程是在一个线程中执行的呀，那第二个代理对象的方法被调用时，是不是也会经过 <code>ExposeInvocationInterceptor</code> 呢？那是不是从 <code>ThreadLocal</code> 中就可以取出 <code>MethodInvocation</code> 了呢？所以小伙伴们一定要多想一层呀，多实践多思考才会更进步 ~</p><h3 id="1-2-createProxy"><a href="#1-2-createProxy" class="headerlink" title="1.2 createProxy"></a>1.2 createProxy</h3><p>上面结束之后，所有的增强器也就都准备好了，接下来就是创建代理对象的部分了，咱进入 <code>createProxy</code> 中：（方法略长，咱只关心关键部分的源码和注释即可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-meta">@Nullable</span> String beanName,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;<br>    <span class="hljs-comment">// 记录被代理bean的原始类型</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;<br>        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="hljs-keyword">this</span>.beanFactory, beanName, beanClass);<br>    &#125;<br><br>    <span class="hljs-comment">// 代理工厂的初始化</span><br>    ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>    proxyFactory.copyFrom(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">// 根据AOP的设计，决定是否强制使用Cglib</span><br>    <span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;<br>        <span class="hljs-keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;<br>            <span class="hljs-comment">// Cglib动态代理直接记录被代理bean的所属类即可</span><br>            proxyFactory.setProxyTargetClass(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 解析被代理bean所属类的所有实现的接口</span><br>            evaluateProxyInterfaces(beanClass, proxyFactory);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 1.2.1 构造整合所有增强器</span><br>    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);<br>    proxyFactory.addAdvisors(advisors);<br>    proxyFactory.setTargetSource(targetSource);<br>    customizeProxyFactory(proxyFactory);<br><br>    proxyFactory.setFrozen(<span class="hljs-keyword">this</span>.freezeProxy);<br>    <span class="hljs-keyword">if</span> (advisorsPreFiltered()) &#123;<br>        proxyFactory.setPreFiltered(<span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 1.2.2 创建代理对象</span><br>    <span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure><p>到了这里，咱就可以发现，这里面的逻辑已经基本上处理的差不多了，核心的动作就两个：<strong>收集整理要织入到目标对象的通知增强器</strong>，以及<strong>创建代理对象</strong>。前面的那些小细节小伙伴们可以自行研究，相对都是蛮简单的，小册带小伙伴们关注的是这两部分的核心逻辑。</p><h4 id="1-2-1-buildAdvisors"><a href="#1-2-1-buildAdvisors" class="headerlink" title="1.2.1 buildAdvisors"></a>1.2.1 buildAdvisors</h4><p>源码不算长，里面有一段日志的部分，小册在这里删掉了，咱只关心核心逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Advisor[] buildAdvisors(<span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> Object[] specificInterceptors) &#123;<br>    <span class="hljs-comment">// Handle prototypes correctly...</span><br>    <span class="hljs-comment">// 这个地方是适配Spring原生AOP的MethodInterceptor，感兴趣的小伙伴可自行研究</span><br>    Advisor[] commonInterceptors = resolveInterceptorNames();<br><br>    List&lt;Object&gt; allInterceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (specificInterceptors != <span class="hljs-keyword">null</span>) &#123;<br>        allInterceptors.addAll(Arrays.asList(specificInterceptors));<br>        <span class="hljs-comment">// 组合原生的方法拦截器，共同作为AOP的通知织入</span><br>        <span class="hljs-keyword">if</span> (commonInterceptors.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.applyCommonInterceptorsFirst) &#123;<br>                allInterceptors.addAll(<span class="hljs-number">0</span>, Arrays.asList(commonInterceptors));<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                allInterceptors.addAll(Arrays.asList(commonInterceptors));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// logger ......</span><br><br>    Advisor[] advisors = <span class="hljs-keyword">new</span> Advisor[allInterceptors.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; allInterceptors.size(); i++) &#123;<br>        <span class="hljs-comment">// 此处有一个原生AOP的适配动作</span><br>        advisors[i] = <span class="hljs-keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.get(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面整合 SpringFramework 原生 AOP 的内容咱小册就不提及了，毕竟是很久之前用的东西了，咱现在都是 AspectJ 的。在最下面，它有一个 <code>advisorAdapterRegistry.wrap</code> 的方法调用，它是干嘛的呢？咱可以去瞅一眼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title">wrap</span><span class="hljs-params">(Object adviceObject)</span> <span class="hljs-keyword">throws</span> UnknownAdviceTypeException </span>&#123;<br>    <span class="hljs-comment">// Advisor增强器可以直接返回</span><br>    <span class="hljs-keyword">if</span> (adviceObject <span class="hljs-keyword">instanceof</span> Advisor) &#123;<br>        <span class="hljs-keyword">return</span> (Advisor) adviceObject;<br>    &#125;<br>    <span class="hljs-comment">// 不支持非Advice的类型</span><br>    <span class="hljs-keyword">if</span> (!(adviceObject <span class="hljs-keyword">instanceof</span> Advice)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(adviceObject);<br>    &#125;<br>    Advice advice = (Advice) adviceObject;<br>    <span class="hljs-comment">// MethodInterceptor的支持</span><br>    <span class="hljs-keyword">if</span> (advice <span class="hljs-keyword">instanceof</span> MethodInterceptor) &#123;<br>        <span class="hljs-comment">// So well-known it doesn&#x27;t even need an adapter.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice);<br>    &#125;<br>    <span class="hljs-comment">// AdvisorAdapter的支持</span><br>    <span class="hljs-keyword">for</span> (AdvisorAdapter adapter : <span class="hljs-keyword">this</span>.adapters) &#123;<br>        <span class="hljs-comment">// Check that it is supported.</span><br>        <span class="hljs-keyword">if</span> (adapter.supportsAdvice(advice)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPointcutAdvisor(advice);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAdviceTypeException(advice);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个方法的参数和返回值：它可以是任意类型的入参，但返回的一定是 <code>Advisor</code> ，这也就呼应了 <code>wrap</code> 方法的含义：<strong>将可以支持转换 / 包装为 <code>Advisor</code> 类型的对象适配成 <code>Advisor</code></strong> 。至于它可以适配的类型，内置的只有 <code>MethodInterceptor</code> 和几种原生的 <code>Advice</code> （前面 Spring 原生 AOP 中提到的），不过它提供了一个 <code>AdvisorAdapter</code> 的接口，供我们扩展使用，以此来支持自定义的 <code>Advice</code> 类型。不过我们几乎都没有这么做的，所以这部分小伙伴们知道一下就可以了，没必要深究。</p><h4 id="1-2-2-proxyFactory-getProxy"><a href="#1-2-2-proxyFactory-getProxy" class="headerlink" title="1.2.2 proxyFactory.getProxy"></a>1.2.2 proxyFactory.getProxy</h4><p>下面就是真正创建代理对象的逻辑了，这个方法又分为两个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> createAopProxy().getProxy(classLoader);<br>&#125;<br></code></pre></td></tr></table></figure><p>咱一一来看。</p><h5 id="1-2-2-1-createAopProxy"><a href="#1-2-2-1-createAopProxy" class="headerlink" title="1.2.2.1 createAopProxy"></a>1.2.2.1 createAopProxy</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.active) &#123;<br>        activate();<br>    &#125;<br>    <span class="hljs-keyword">return</span> getAopProxyFactory().createAopProxy(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">activate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.active = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (AdvisedSupportListener listener : <span class="hljs-keyword">this</span>.listeners) &#123;<br>        listener.activated(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面有一个监听器的通知动作，由于这个动作涉及到的监听器 <code>AdvisedSupportListener</code> 只在 <code>ProxyCreatorSupport</code> 这个类中使用，咱们开发也基本不会碰这些东西，所以这个咱可以跳过了，关键的还是下面 <code>getAopProxyFactory().createAopProxy(this);</code> 的执行。</p><p><code>getAopProxyFactory</code> 方法返回的是当前 <code>ProxyCreatorSupport</code> 的成员 <code>aopProxyFactory</code>，借助 Debug 可以发现它的类型是 <code>DefaultAopProxyFactory</code> 。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a099480498f74ec19e5d3fbd7739c0ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>进入到它的 <code>createAopProxy</code> 方法中，终于发现了咱熟悉的 jdk 、Cglib 动态代理的字眼了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;<br>    <span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>        Class&lt;?&gt; targetClass = config.getTargetClass();<br>        <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>                    <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 如果要代理的本身就是接口，或者已经是被jdk动态代理了的代理对象</span><br>        <span class="hljs-comment">// 则使用jdk动态代理</span><br>        <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>        &#125;<br>        <span class="hljs-comment">// 否则使用Cglib动态代理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，咱就知道，使用 jdk 动态代理，还是 Cglib 动态代理，底层的选择是在这里决定的。</p><h5 id="1-2-2-2-AopProxy-getProxy"><a href="#1-2-2-2-AopProxy-getProxy" class="headerlink" title="1.2.2.2 AopProxy#getProxy"></a>1.2.2.2 AopProxy#getProxy</h5><p>创建完 <code>AopProxy</code> 后，下面就是创建代理对象的动作了，咱以 <code>JdkDynamicAopProxy</code> 为例进去看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>    <span class="hljs-comment">// logger ......</span><br>    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised, <span class="hljs-keyword">true</span>);<br>    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);<br>    <span class="hljs-comment">// jdk动态代理的API</span><br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>看，最底下，咱最最熟悉的 <code>Proxy.newProxyInstance</code> 方法出现了！！！所以由此咱就可以体会到，代理对象的底层创建还是依赖 jdk 动态代理，或者 Cglib 动态代理的核心 API 呀！</p><p>至于 Cglib 动态代理的创建，咱就不特别深入了，咱注意一下中间的核心部分即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-comment">// Configure CGLIB Enhancer...</span><br>Enhancer enhancer = createEnhancer();<br><span class="hljs-keyword">if</span> (classLoader != <span class="hljs-keyword">null</span>) &#123;<br>    enhancer.setClassLoader(classLoader);<br>    <span class="hljs-keyword">if</span> (classLoader <span class="hljs-keyword">instanceof</span> SmartClassLoader &amp;&amp;<br>            ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;<br>        enhancer.setUseCache(<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br>enhancer.setSuperclass(proxySuperClass);<br>enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised));<br>enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);<br>enhancer.setStrategy(<span class="hljs-keyword">new</span> ClassLoaderAwareGeneratorStrategy(classLoader));<br><br>Callback[] callbacks = getCallbacks(rootClass);<br>Class&lt;?&gt;[] types = <span class="hljs-keyword">new</span> Class&lt;?&gt;[callbacks.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; types.length; x++) &#123;<br>    types[x] = callbacks[x].getClass();<br>&#125;<br><span class="hljs-comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span><br>enhancer.setCallbackFilter(<span class="hljs-keyword">new</span> ProxyCallbackFilter(<br>        <span class="hljs-keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="hljs-keyword">this</span>.fixedInterceptorMap, <span class="hljs-keyword">this</span>.fixedInterceptorOffset));<br>enhancer.setCallbackTypes(types);<br><br><span class="hljs-comment">// Generate the proxy class and create a proxy instance.</span><br><span class="hljs-keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>可以看到，这也是对 Cglib 中的 <code>Enhancer</code> 进行操作，核心的思路是不变的，只是框架比咱考虑的更多罢了。</p><p>OK ，到此为止，代理对象也就成功创建了，整个 AOP 通知织入的流程也就结束了。</p><p>【 AOP 原理的最后一章，咱来看看实际的代理对象方法执行时，通知都是怎么执行的，它内部的调用链是如何设计的、如何调用执行的】</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>11-AOP原理-切面类收集封装</title>
    <link href="/2022/04/17/11-AOP%E5%8E%9F%E7%90%86-%E5%88%87%E9%9D%A2%E7%B1%BB%E6%94%B6%E9%9B%86%E5%B0%81%E8%A3%85/"/>
    <url>/2022/04/17/11-AOP%E5%8E%9F%E7%90%86-%E5%88%87%E9%9D%A2%E7%B1%BB%E6%94%B6%E9%9B%86%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP原理-AOP是如何收集切面类并封装的"><a href="#AOP原理-AOP是如何收集切面类并封装的" class="headerlink" title="AOP原理-AOP是如何收集切面类并封装的"></a>AOP原理-AOP是如何收集切面类并封装的</h1><p>承接着上一章的思路，这一章咱主要研究两个大问题：</p><ol><li><code>Advisor</code> 是什么，它是怎么构建的</li><li><code>TargetSource</code> 是什么，SpringFramework 的 AOP 为什么要代理它而不是原始对象</li></ol><h2 id="1-Advisor与切面类的收集"><a href="#1-Advisor与切面类的收集" class="headerlink" title="1. Advisor与切面类的收集"></a>1. Advisor与切面类的收集</h2><p>在上一章中，咱有看到一个 <code>shouldSkip</code> 的跳过动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AspectJAwareAdvisorAutoProxyCreator</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>    <span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;<br>        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;<br>                ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面它会先获取到一些候选的增强器，而这个方法的底层，其实就是解析切面类，构造 <code>Advisor</code> 增强器的过程，咱深入研究一下。</p><p><code>findCandidateAdvisors</code> 方法的源码还算简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Add all the Spring advisors found according to superclass rules.</span><br>    <span class="hljs-comment">// 根据父类的规则添加所有找到的Spring原生的增强器</span><br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">super</span>.findCandidateAdvisors();<br>    <span class="hljs-comment">// Build Advisors for all AspectJ aspects in the bean factory.</span><br>    <span class="hljs-comment">// 解析BeanFactory中所有的AspectJ切面，并构造增强器</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder != <span class="hljs-keyword">null</span>) &#123;<br>        advisors.addAll(<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>总共两个步骤，分别代表切面的两个来源：<strong>SpringFramework 原生 AOP 的增强器</strong>，以及<strong>解析完 AspectJ 切面类构造的增强器</strong>。咱一个一个来看。</p><h3 id="1-1-super-findCandidateAdvisors"><a href="#1-1-super-findCandidateAdvisors" class="headerlink" title="1.1 super.findCandidateAdvisors"></a>1.1 super.findCandidateAdvisors</h3><p>来到父类 <code>AbstractAdvisorAutoProxyCreator</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> BeanFactoryAdvisorRetrievalHelper advisorRetrievalHelper;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>&#123;<br>    Assert.state(<span class="hljs-keyword">this</span>.advisorRetrievalHelper != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;No BeanFactoryAdvisorRetrievalHelper available&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现它委托了一个 <code>advisorRetrievalHelper</code> 来处理 SpringFramework 原生的 AOP 增强器。而它这个方法的篇幅就比较长了，咱拆解出核心的主干逻辑研究。</p><h4 id="1-1-1-检查现有的增强器bean"><a href="#1-1-1-检查现有的增强器bean" class="headerlink" title="1.1.1 检查现有的增强器bean"></a>1.1.1 检查现有的增强器bean</h4><p>注意看源码中的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">findAdvisorBeans</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Determine list of advisor bean names, if not cached already.</span><br>    <span class="hljs-comment">// 确定增强器bean名称的列表（如果尚未缓存）</span><br>    String[] advisorNames = <span class="hljs-keyword">this</span>.cachedAdvisorBeanNames;<br>    <span class="hljs-keyword">if</span> (advisorNames == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br>        <span class="hljs-comment">// uninitialized to let the auto-proxy creator apply to them!</span><br>        <span class="hljs-comment">// 不要在这里初始化FactoryBeans：</span><br>        <span class="hljs-comment">// 我们需要保留所有未初始化的常规bean，以使自动代理创建者对其应用</span><br>        advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<br>                <span class="hljs-keyword">this</span>.beanFactory, Advisor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">this</span>.cachedAdvisorBeanNames = advisorNames;<br>    &#125;<br>    <span class="hljs-comment">// 如果当前IOC容器中没有任何增强器类型的bean，直接返回</span><br>    <span class="hljs-keyword">if</span> (advisorNames.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>这里的主要动作，是将 IOC 容器中所有类型为 <code>Advisor</code> 的实现类都找出来，看看到底有没有，如果没有，那就不用走下面的流程了。</p><p><code>BeanFactoryUtils</code> 的 <code>beanNamesForTypeIncludingAncestors</code> 方法，底层是用的 <code>getBeanNamesForType</code> 方法去找 bean 的名称（单纯的找 bean 的名称不会创建具体的 bean 对象，SpringFramework 在此做得很谨慎），感兴趣的小伙伴可以自己去看一下，小册在此就不展开了。</p><h4 id="1-1-2-初始化原生增强器"><a href="#1-1-2-初始化原生增强器" class="headerlink" title="1.1.2 初始化原生增强器"></a>1.1.2 初始化原生增强器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String name : advisorNames) &#123;<br>        <span class="hljs-keyword">if</span> (isEligibleBean(name)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;<br>                <span class="hljs-comment">// logger ......</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    advisors.add(<span class="hljs-keyword">this</span>.beanFactory.getBean(name, Advisor.class));<br>                &#125; <span class="hljs-comment">// catch ......</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的源码蛮长的，不过这里咱只关心主干流程的重点，那无非就是 <code>beanFactory.getBean</code>了，非常常规的 bean 初始化的动作。只不过我们自始至终都没有讲过 SpringFramework 原生的增强器，因为编写它实在是太复杂了，主流的编写还是以 AspectJ 形式为主，所以咱这里知道一下就可以了。</p><p>至于中间省略的 catch 块，其实流程还挺复杂的，里面做了循环依赖的异常处理，由于涉及的内容过于复杂，而且咱前面也说过了，循环依赖的部分可以在 SpringBoot 小册的第 15 章完整的学习，所以咱这里就不多展开了。</p><p>通过 Debug ，也可以发现并没有原生的增强器被创建：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64841df0332c410f88b9eb86b91d5177~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>以上就是在父类 <code>AbstractAdvisorAutoProxyCreator</code> 中的 <code>findCandidateAdvisors</code> 方法的逻辑，下面咱来看另一部分的委托：<code>aspectJAdvisorsBuilder</code> 。</p><h3 id="1-2-aspectJAdvisorsBuilder-buildAspectJAdvisors"><a href="#1-2-aspectJAdvisorsBuilder-buildAspectJAdvisors" class="headerlink" title="1.2 aspectJAdvisorsBuilder.buildAspectJAdvisors"></a>1.2 aspectJAdvisorsBuilder.buildAspectJAdvisors</h3><p>从方法名上理解，它就是<strong>将 Aspect 切面类，转换为一个一个的增强器</strong>。这个方法也是长得很，咱分段来研究。</p><h4 id="1-2-1-逐个解析IOC容器中所有的bean类型"><a href="#1-2-1-逐个解析IOC容器中所有的bean类型" class="headerlink" title="1.2.1 逐个解析IOC容器中所有的bean类型"></a>1.2.1 逐个解析IOC容器中所有的bean类型</h4><p>这段源码一下子把缩进拉上去了，阅读观感可能不是特别好，不过好在逻辑不算复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">buildAspectJAdvisors</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;String&gt; aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;<br><br>    <span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;<br>            <span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) &#123;<br>                List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                aspectNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                <span class="hljs-comment">// 获取IOC容器中的所有bean</span><br>                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<br>                        <span class="hljs-keyword">this</span>.beanFactory, Object.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>                    <span class="hljs-keyword">if</span> (!isEligibleBean(beanName)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// We must be careful not to instantiate beans eagerly as in this case they</span><br>                    <span class="hljs-comment">// would be cached by the Spring container but would not have been weaved.</span><br>                    <span class="hljs-comment">// 我们必须小心，不要急于实例化bean，因为在这种情况下，IOC容器会缓存它们，但不会被织入增强器</span><br>                    Class&lt;?&gt; beanType = <span class="hljs-keyword">this</span>.beanFactory.getType(beanName);<br>                    <span class="hljs-keyword">if</span> (beanType == <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>可以发现，这一段的核心逻辑，是将 IOC 容器，以及它的父 IOC 容器中，所有的 bean 的名称全部取出（直接声明父类型为 <code>Object</code> ，显然是取所有），之后，它会逐个解析这些 bean 对应的 <code>Class</code> 。</p><p>Debug 中也发现，它真的把包括内部的一些 bean （ environment ）在内的所有 bean 的名称全部拿了出来：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72661fed4645415bba02a8934d6393bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>注意一个细节，框架在这里控制的很好，它借助 <code>BeanFactory</code> 去取 bean 的类型，而不是先 <code>getBean</code> 后再取类型，这样可以保证 bean 不会被提前创建。而没有初始化 bean 实例的前提下，要想获取 bean 的 <code>Class</code> ，那就只能靠 <code>BeanDefinition</code> 了，所以我们可以在 <code>AbstractBeanFactory</code> 的 <code>getType</code> 方法中看到合并 <code>RootBeanDefinition</code> 的动作，随后调用 <code>RootBeanDefinition</code> 的 <code>getBeanClass</code> 方法获取 bean 的 <code>Class</code> 类型。</p><h4 id="1-2-2-解析Aspect切面类，构造增强器"><a href="#1-2-2-解析Aspect切面类，构造增强器" class="headerlink" title="1.2.2 解析Aspect切面类，构造增强器"></a>1.2.2 解析Aspect切面类，构造增强器</h4><p>这段缩进实在是太大了，我给调小了一点，小伙伴们看着还舒服点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ......</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;<br>    <span class="hljs-comment">// 当前解析bean的所属类型是一个切面类</span><br>    aspectNames.add(beanName);<br>    AspectMetadata amd = <span class="hljs-keyword">new</span> AspectMetadata(beanType, beanName);<br>    <span class="hljs-comment">// 下面是单实例切面bean会走的流程</span><br>    <span class="hljs-keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;<br>        MetadataAwareAspectInstanceFactory factory =<br>                <span class="hljs-keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);<br>        <span class="hljs-comment">// 解析生成增强器</span><br>        List&lt;Advisor&gt; classAdvisors = <span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.advisorsCache.put(beanName, classAdvisors);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);<br>        &#125;<br>        advisors.addAll(classAdvisors);<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>这一步就是判断当前解析的 bean 所属的 <code>Class</code> 是不是一个切面类了，如果是，则会进入到里面的结构体，把这个类中的通知方法都构造出来。</p><p>这两个小动作，咱拿出来解析一下。</p><h5 id="1-2-2-1-判断Class是通知类"><a href="#1-2-2-1-判断Class是通知类" class="headerlink" title="1.2.2.1 判断Class是通知类"></a>1.2.2.1 判断Class是通知类</h5><p>如何判断当前 Class 是不是通知类（切面类）呢？很简单，看看类上是不是有标注 <code>@Aspect</code>注解就完事了呗？但是源码中还多判断了一步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAspect</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-comment">// @Aspect注解并且不是被ajc编译器编译的</span><br>    <span class="hljs-keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意一点，它额外判断了是不是被 ajc 编译器编译，这是为什么呢？我们可以从文档注释中获取到一些信息：</p><blockquote><p>We consider something to be an AspectJ aspect suitable for use by the Spring AOP system if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test is that aspects written in the code-style (AspectJ language) also have the annotation present when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.</p><p>如果它有 @Aspect 注解，并且不是由 ajc 编译的，我们才认为这个 Class 类是适合 Spring AOP 系统使用的 AspectJ 切面。不用 ajc 编译的原因，是因为以代码风格（AspectJ 语言）编写的方面在由带有 -1.5 标志的 ajc 编译时也存在注解，但它们不能被 Spring AOP 使用。</p></blockquote><p>简单的理解来说，<strong>SpringFramework 的 AOP 有整合 AspectJ 的部分</strong>，而<strong>原生的 AspectJ 也可以编写 Aspect 切面</strong>，而<strong>这种切面在特殊的编译条件下，生成的字节码中类上也会标注 <code>@Aspect</code> 注解，但是 SpringFramework 并不能利用它</strong>，所以这里它做了一个额外的判断处理，避免了这种 Class 被误加载。</p><h5 id="1-2-2-2-advisorFactory-getAdvisors：构造增强器"><a href="#1-2-2-2-advisorFactory-getAdvisors：构造增强器" class="headerlink" title="1.2.2.2 advisorFactory.getAdvisors：构造增强器"></a>1.2.2.2 advisorFactory.getAdvisors：构造增强器</h5><p>这个方法又是好复杂呀，咱来到 <code>ReflectiveAspectJAdvisorFactory</code> 中来看：（注意标有注释的部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">getAdvisors</span><span class="hljs-params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// Aspect切面类的Class</span><br>    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();<br>    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();<br>    <span class="hljs-comment">// 再次校验一下切面类上是不是标注了@Aspect注解</span><br>    validate(aspectClass);<br><br>    <span class="hljs-comment">// 此处利用Decorator装饰者模式，目的是保证Advisor增强器不会被多次实例化</span><br>    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =<br>            <span class="hljs-keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);<br><br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// 逐个解析通知方法，并封装为增强器</span><br>    <span class="hljs-keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;<br>        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, <span class="hljs-number">0</span>, aspectName);<br>        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-keyword">null</span>) &#123;<br>            advisors.add(advisor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If it&#x27;s a per target aspect, emit the dummy instantiating aspect.</span><br>    <span class="hljs-comment">// 通过在装饰者内部的开始加入SyntheticInstantiationAdvisor增强器，达到延迟初始化切面bean的目的</span><br>    <span class="hljs-keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;<br>        Advisor instantiationAdvisor = <span class="hljs-keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);<br>        advisors.add(<span class="hljs-number">0</span>, instantiationAdvisor);<br>    &#125;<br><br>    <span class="hljs-comment">// Find introduction fields.</span><br>    <span class="hljs-comment">// 对@DeclareParent注解功能的支持(AspectJ的引介)</span><br>    <span class="hljs-keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;<br>        Advisor advisor = getDeclareParentsAdvisor(field);<br>        <span class="hljs-keyword">if</span> (advisor != <span class="hljs-keyword">null</span>) &#123;<br>            advisors.add(advisor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>整段源码阅读下来，思路倒是蛮明确，它果然与我们的推测一致，就是<strong>解析 Aspect 切面类中的通知方法</strong>，只不过它在上下文的逻辑中补充了一些额外的校验、处理等等逻辑。</p><p>重点关注这里面的两个小动作：1) 通知方法是怎么收集的；2) 增强器的创建都需要什么东西。</p><h5 id="1-2-2-3-切面类中通知方法的收集"><a href="#1-2-2-3-切面类中通知方法的收集" class="headerlink" title="1.2.2.3 切面类中通知方法的收集"></a>1.2.2.3 切面类中通知方法的收集</h5><p>进入到 <code>getAdvisorMethods</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Method&gt; <span class="hljs-title">getAdvisorMethods</span><span class="hljs-params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> List&lt;Method&gt; methods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;<br>        <span class="hljs-comment">// Exclude pointcuts</span><br>        <span class="hljs-keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut.class) == <span class="hljs-keyword">null</span>) &#123;<br>            methods.add(method);<br>        &#125;<br>    &#125;, ReflectionUtils.USER_DECLARED_METHODS);<br>    <span class="hljs-keyword">if</span> (methods.size() &gt; <span class="hljs-number">1</span>) &#123;<br>        methods.sort(METHOD_COMPARATOR);<br>    &#125;<br>    <span class="hljs-keyword">return</span> methods;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实会发现，这个方法很简单的，它就是把咱们定义的<strong>切面类中除了通用的切入点表达式抽取以外的所有方法</strong>都取出来！并且取出来之后又做了一个排序的动作，而排序的原则就是按照 Unicode 编码来的，这个咱已经研究过了。</p><h5 id="1-2-2-4-增强器的创建"><a href="#1-2-2-4-增强器的创建" class="headerlink" title="1.2.2.4 增强器的创建"></a>1.2.2.4 增强器的创建</h5><p><code>getAdvisor</code> 方法就是创建 <code>Advisor</code> 增强器了，可能有的小伙伴会产生疑惑，上面的方法只是取出了自己定义的非 <code>@Pointcut</code> 方法，那对于没有声明切入点表达式的方法，它岂不是也一起返回了？不过没关系，其实它在这里又做了一次过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Advisor <span class="hljs-title">getAdvisor</span><span class="hljs-params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;<br>    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());<br><br>    AspectJExpressionPointcut expressionPointcut = getPointcut(<br>            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());<br>    <span class="hljs-comment">// 没有声明通知注解的方法也会被过滤</span><br>    <span class="hljs-keyword">if</span> (expressionPointcut == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,<br>            <span class="hljs-keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现框架还是做得滴水不漏的。注意看下面的构造方法中传入的关键参数，它们分别是：</p><ul><li>expressionPointcut ：AspectJ 切入点表达式的封装</li><li>candidateAdviceMethod ：通知方法本体</li><li>this ：当前的 <code>ReflectiveAspectJAdvisorFactory</code></li><li>aspectInstanceFactory ：上面的那个装饰者 <code>MetadataAwareAspectInstanceFactory</code></li></ul><p>刨去工厂本身，其实增强器的结构就是<strong>一个切入点表达式 + 一个通知方法</strong>，与之前的推测完全一致。</p><h5 id="1-2-2-5-解析通知注解上的切入点表达式"><a href="#1-2-2-5-解析通知注解上的切入点表达式" class="headerlink" title="1.2.2.5 解析通知注解上的切入点表达式"></a>1.2.2.5 解析通知注解上的切入点表达式</h5><p>到此为止其实增强器本身已经没有什么问题了，咱再来关注一下这个切入点表达式的解析，进入到 <code>getPointcut</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> AspectJExpressionPointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;<br>    <span class="hljs-comment">// 检索通知方法上的注解</span><br>    AspectJAnnotation&lt;?&gt; aspectJAnnotation =<br>            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);<br>    <span class="hljs-keyword">if</span> (aspectJAnnotation == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据注解的类型，构造切入点表达式模型</span><br>    AspectJExpressionPointcut ajexp =<br>            <span class="hljs-keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> Class&lt;?&gt;[<span class="hljs-number">0</span>]);<br>    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>) &#123;<br>        ajexp.setBeanFactory(<span class="hljs-keyword">this</span>.beanFactory);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ajexp;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤很简单，先去找通知方法上标注的注解，然后把切入点表达式提取出来，返回。很明显 <code>findAspectJAnnotationOnMethod</code> 的逻辑是相对重要的，咱进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;<br>        Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class&#125;;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : ASPECTJ_ANNOTATION_CLASSES) &#123;<br>        AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) clazz);<br>        <span class="hljs-keyword">if</span> (foundAnnotation != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> foundAnnotation;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>果然，它在 <code>AbstractAspectJAdvisorFactory</code> 中已经提前定义好了所有可以声明切入点表达式的注解，并在此处一一寻找，找到就返回。</p><p>在此 Debug 会发现它只是把切入点表达式的内容，以及参数等信息，封装到 <code>AspectJExpressionPointcut</code> 中了：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2866e666bfcc46208f90ea18dabccda2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><h4 id="1-2-3-原型切面bean的处理"><a href="#1-2-3-原型切面bean的处理" class="headerlink" title="1.2.3 原型切面bean的处理"></a>1.2.3 原型切面bean的处理</h4><p>上面我们只是看到了单实例切面 bean 的处理和解析，下面的 else 部分是原型切面 bean 的处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">            <span class="hljs-comment">// ......</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Per target or per this.</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName +<br>                            <span class="hljs-string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);<br>                &#125;<br>                MetadataAwareAspectInstanceFactory factory =<br>                        <span class="hljs-keyword">new</span> PrototypeAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);<br>                <span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);<br>                <span class="hljs-comment">// 解析Aspect切面类，构造增强器</span><br>                advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.aspectBeanNames = aspectNames;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><p>可以发现，对于原型切面 bean 的解析，它的核心解析动作依然是 <code>advisorFactory.getAdvisors</code> 方法，只是这里面不会再用到 <code>advisorsCache</code> 这个缓存区了，这也说明原型切面 bean 的解析是多次执行的。</p><h4 id="1-2-4-增强器汇总"><a href="#1-2-4-增强器汇总" class="headerlink" title="1.2.4 增强器汇总"></a>1.2.4 增强器汇总</h4><p>最后一部分到了整理的环节了，前面已经把所有的切面类都解析完了，这里只需要把这些构造好的增强器都集中到一个 List 中，返回即可。源码很简单，小伙伴们扫一眼就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">if</span> (aspectNames.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Collections.emptyList();<br>    &#125;<br>    List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String aspectName : aspectNames) &#123;<br>        List&lt;Advisor&gt; cachedAdvisors = <span class="hljs-keyword">this</span>.advisorsCache.get(aspectName);<br>        <span class="hljs-keyword">if</span> (cachedAdvisors != <span class="hljs-keyword">null</span>) &#123;<br>            advisors.addAll(cachedAdvisors);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            MetadataAwareAspectInstanceFactory factory = <span class="hljs-keyword">this</span>.aspectFactoryCache.get(aspectName);<br>            advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> advisors;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，切入点表达式也就解析完了，通知方法也有了，<code>Advisor</code> 增强器也就顺理的创建出来了。</p><p>Debug 返回的时候，可以发现 <code>Logger</code> 中的 5 个增强器都封装好了：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb810b6e37244b16b024ac43b494cc76~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>所有的增强器创建完成后，接下来的内容就是承接上一章的 bean 匹配，决定是否跳过 bean 的增强的步骤了。</p><h2 id="2-TargetSource"><a href="#2-TargetSource" class="headerlink" title="2. TargetSource"></a>2. TargetSource</h2><p>上一章咱简单的提了一嘴，<strong>AOP 的代理其实不是代理的目标对象本身，而是目标对象包装后的 <code>TargetSource</code> 对象</strong>，SpringFramework 为什么要这么做，这样做有什么好处，咱这里也来深入研究一下。</p><h3 id="2-1-TargetSource的设计"><a href="#2-1-TargetSource的设计" class="headerlink" title="2.1 TargetSource的设计"></a>2.1 TargetSource的设计</h3><p>之前在复习动态代理的时候，咱说代理对象中直接组合了原始对象，直观一点的理解，就可以是这样子：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3a8cd45f59a413bb7065a0fb79807e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>但是在 SpringFramework 的 AOP 中，代理对象并没有直接代理 Target ，而是给 Target 加了一个壳，而加的这个壳就是 <strong><code>TargetSource</code></strong> ，用图示理解就是这样：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a44f8b3f5bf141f0a900612743752d3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>是不是一下子就容易理解了呢？<code>TargetSource</code> 可以看做是目标对象 Target 的一个包装、容器，原本代理对象要执行 <code>method.invoke(target, args)</code> 这样的逻辑时，本来要拿到的是目标对象，但被 <code>TargetSource</code> 包装之后，就只能调用 <code>method.invoke(targetSource.getTarget(), args)</code> 这样的形式了。</p><h3 id="2-2-TargetSource的好处"><a href="#2-2-TargetSource的好处" class="headerlink" title="2.2 TargetSource的好处"></a>2.2 TargetSource的好处</h3><p>既然每次调用代理对象的方法，最终会调用到 <code>TargetSource</code> 的 <code>getTarget</code> 方法，而这个 <code>getTarget</code> 方法是 <code>TargetSource</code> 决定如何返回的，那这里面可就大有文章了。举个最简单的例子：每次 <code>getTarget</code> 的值可以不一样吧？每次 <code>getTarget</code> 的时候可以从一个对象池中取吧？哎，是不是突然想到了数据库连接池？其实 <code>TargetSource</code> 也有基于池的实现。</p><p>所以咱可以总结出来，让 AOP 代理 <code>TargetSource</code> 的好处，是<strong>可以控制每次方法调用时作用的具体对象实例，从而让方法的调用更加灵活</strong>。</p><h3 id="2-3-TargetSource的结构"><a href="#2-3-TargetSource的结构" class="headerlink" title="2.3 TargetSource的结构"></a>2.3 TargetSource的结构</h3><p>翻开 <code>TargetSource</code> 的源码，可以发现它是一个接口，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TargetSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TargetClassAware</span> </span>&#123;<br>Class&lt;?&gt; getTargetClass();<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseTarget</span><span class="hljs-params">(Object target)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现除了 <code>getTarget</code> 方法之外，还有一个 <code>releaseTarget</code> ，咱也能很快的猜到它的作用是交回 / 释放目标对象之类的操作，它也是用于那些基于对象池的 <code>TargetSource</code> ，在目标对象调用方法完成后，紧接着调用 <code>releaseTarget</code> 方法来释放目标对象的。</p><p>另外还有一个 <code>isStatic</code> 方法，可能小伙伴们会疑惑：bean 哪来的静态一说？对于 Java 来讲，<code>Class</code> 与 object 的作用域可以分出来静态和非静态（ <code>Class</code> 级别的成员是静态的，object 级别的成员是非静态的），那对于 SpringFramework 来讲，单实例 bean 与原型 bean 的作用域也可以划分出静态和非静态的概念：单实例 bean 是一个 <code>ApplicationContext</code> 中只有一个实例，原型 bean 是每次获取都会拿到一个全新的实例，所以<strong>单实例 bean 就可以划为 “静态 bean ”</strong>，原型 bean 则为非静态 bean 。</p><h3 id="2-4-SpringFramework中提供的TargetSource"><a href="#2-4-SpringFramework中提供的TargetSource" class="headerlink" title="2.4 SpringFramework中提供的TargetSource"></a>2.4 SpringFramework中提供的TargetSource</h3><p>SpringFramework 中针对不同场景不同需求，预设了几个 <code>TargetSource</code> 的实现，咱可以稍微了解一下：</p><ul><li><code>SingletonTargetSource</code> ：每次 <code>getTarget</code> 都返回同一个目标对象 bean （与直接代理 target 无任何区别）</li><li><code>PrototypeTargetSource</code> ：每次 <code>getTarget</code> 都会从 <code>BeanFactory</code> 中创建一个全新的 bean （被它包装的 bean 必须为原型 bean ）</li><li><code>CommonsPool2TargetSource</code> ：内部维护了一个对象池，每次 <code>getTarget</code> 时从对象池中取（底层使用 apache 的 <code>ObjectPool</code> ）</li><li><code>ThreadLocalTargetSource</code> ：每次 <code>getTarget</code> 都会从它所处的线程中取目标对象（由于每个线程都有一个 <code>TargetSource</code> ，所以被它包装的 bean 也必须是原型 bean ）</li><li><code>HotSwappableTargetSource</code> ：内部维护了一个可以热替换的目标对象引用，每次 <code>getTarget</code> 的时候都返回它（它提供了一个线程安全的 <code>swap</code> 方法，以热替换 <code>TargetSource</code> 中被代理的目标对象）</li></ul><p>这些设计在底层都不算复杂，小伙伴们可以自行翻一把源码看看，小册就不大张旗鼓的贴源码了。</p><p>【OK 了解一下这些前置的知识，接下来咱就该研究，bean 对象的创建时，<code>AnnotationAwareAspectJAutoProxyCreator</code> 是如何把 bean 对象包装为代理对象的】</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10-AOP原理-底层核心后置处理器</title>
    <link href="/2022/04/16/10-AOP%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2022/04/16/10-AOP%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP原理-AOP代理的底层核心后置处理器"><a href="#AOP原理-AOP代理的底层核心后置处理器" class="headerlink" title="AOP原理-AOP代理的底层核心后置处理器"></a>AOP原理-AOP代理的底层核心后置处理器</h1><h2 id="1-EnableAspectJAutoProxy的作用"><a href="#1-EnableAspectJAutoProxy的作用" class="headerlink" title="1. @EnableAspectJAutoProxy的作用"></a>1. @EnableAspectJAutoProxy的作用</h2><p>翻开 <code>@EnableAspectJAutoProxy</code> 注解的源码，可以发现它 <code>@Import</code> 了一个注册器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(AspectJAutoProxyRegistrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAspectJAutoProxy &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exposeProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-AspectJAutoProxyRegistrar与后置处理器"><a href="#1-1-AspectJAutoProxyRegistrar与后置处理器" class="headerlink" title="1.1 AspectJAutoProxyRegistrar与后置处理器"></a>1.1 AspectJAutoProxyRegistrar与后置处理器</h3><p>这个注册器还挺有来头，点进去看一眼它的文档注释，会发现它已经把核心的后置处理器给说出来了：</p><blockquote><p>Registers an AnnotationAwareAspectJAutoProxyCreator against the current BeanDefinitionRegistry as appropriate based on a given @EnableAspectJAutoProxy annotation.</p><p>根据给定的 <code>@EnableAspectJAutoProxy</code> 注解，根据当前 <code>BeanDefinitionRegistry</code>在适当的位置注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> 。</p></blockquote><p>由此可知，AOP 的核心后置处理器是 <strong><code>AnnotationAwareAspectJAutoProxyCreator</code></strong> 。</p><p>先把它放在一边，咱先了解一下 <code>AspectJAutoProxyRegistrar</code> 是在什么时机下注册 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的。</p><h3 id="1-2-AspectJAutoProxyRegistrar注册后置处理器的时机"><a href="#1-2-AspectJAutoProxyRegistrar注册后置处理器的时机" class="headerlink" title="1.2 AspectJAutoProxyRegistrar注册后置处理器的时机"></a>1.2 AspectJAutoProxyRegistrar注册后置处理器的时机</h3><p>由于 <code>AspectJAutoProxyRegistrar</code> 实现了 <code>ImportBeanDefinitionRegistrar</code> 接口，所以我们可以直接找到 <code>registerBeanDefinitions</code> 方法，去寻找注册的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-comment">// 核心注册后置处理器的动作</span><br>    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br><br>    <span class="hljs-comment">// 解析@EnableAspectJAutoProxy的属性并配置</span><br>    AnnotationAttributes enableAspectJAutoProxy =<br>            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>    <span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;proxyTargetClass&quot;</span>)) &#123;<br>            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;exposeProxy&quot;</span>)) &#123;<br>            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一句就明示了它要注册后置处理器，也就是代理的创建器了。而这个方法也指明了它要注册的 bean 的类型就是 <code>AnnotationAwareAspectJAutoProxyCreator</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> </span>&#123;<br>    <span class="hljs-comment">// 此处已指定类型</span><br>    <span class="hljs-keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);<br>&#125;<br></code></pre></td></tr></table></figure><p>再往下，就是根据这个类型，构造 <code>BeanDefinition</code> ，并注册进 <code>BeanDefinitionRegistry</code>的动作了，逻辑相对简单，小伙伴们扫一眼就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title">registerOrEscalateApcAsRequired</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> </span>&#123;<br><br>    Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>        <span class="hljs-keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;<br>            <span class="hljs-keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());<br>            <span class="hljs-keyword">int</span> requiredPriority = findPriorityForClass(cls);<br>            <span class="hljs-keyword">if</span> (currentPriority &lt; requiredPriority) &#123;<br>                apcDefinition.setBeanClassName(cls.getName());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 构造BeanDefinition，注册进BeanDefinitionRegistry</span><br>    RootBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(cls);<br>    beanDefinition.setSource(source);<br>    beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);<br>    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<br>    <span class="hljs-keyword">return</span> beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑还是简单吧，经过 IOC 部分的洗礼，这些底层看起来是不是也就轻松许多了呢？</p><p>下面我们来着重研究这个核心的后置处理器，也就是代理对象的创建器 <strong><code>AnnotationAwareAspectJAutoProxyCreator</code></strong> 。</p><h2 id="2-AnnotationAwareAspectJAutoProxyCreator"><a href="#2-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="2. AnnotationAwareAspectJAutoProxyCreator"></a>2. AnnotationAwareAspectJAutoProxyCreator</h2><p>这么重要的 API ，javadoc 中一定有对它的描述吧，咱先来看一眼：</p><blockquote><p>AspectJAwareAdvisorAutoProxyCreator subclass that processes all AspectJ annotation aspects in the current application context, as well as Spring Advisors. Any AspectJ annotated classes will automatically be recognized, and their advice applied if Spring AOP’s proxy-based model is capable of applying it. This covers method execution joinpoints. If the <code>&lt;aop:include&gt;</code> element is used, only @AspectJ beans with names matched by an include pattern will be considered as defining aspects to use for Spring auto-proxying. Processing of Spring Advisors follows the rules established in org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.</p><p>它是 <code>AspectJAwareAdvisorAutoProxyCreator</code> 的子类，用于处理当前 ApplicationContext 中的所有基于 AspectJ 注解的切面，以及 Spring 原生的 <code>Advisor</code>。</p><p>如果 Spring AOP 基于代理的模型能够应用任何被 <code>@AspectJ</code> 注解标注的类，那么它们的增强方法将被自动识别。这涵盖了方法执行的切入点表达式。</p><p>如果使用 <code>&lt;aop:include&gt;</code> 元素，则只有名称与包含模式匹配的被 <code>@AspectJ</code> 标注的 bean 将被视为定义要用于 Spring 自动代理的方面。</p><p>Spring 中内置的 <code>Advisor</code> 的处理遵循 <code>AbstractAdvisorAutoProxyCreator</code> 中建立的规则。</p></blockquote><p>拆解看来，javadoc 中解释的核心内容是，<code>AnnotationAwareAspectJAutoProxyCreator</code> 它兼顾 AspectJ 风格的切面声明，以及 SpringFramework 原生的 AOP 编程。</p><h3 id="2-1-AnnotationAwareAspectJAutoProxyCreator的继承结构"><a href="#2-1-AnnotationAwareAspectJAutoProxyCreator的继承结构" class="headerlink" title="2.1 AnnotationAwareAspectJAutoProxyCreator的继承结构"></a>2.1 AnnotationAwareAspectJAutoProxyCreator的继承结构</h3><p>借助 IDEA ，可以很清楚的看到 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的继承结构，以及它其中的重要核心：</p><p><img src="/2022/04/16/10-AOP%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/img01.png" alt="img"></p><p>注意看最顶层的接口，它实现了几个重要的接口：</p><ul><li><code>BeanPostProcessor</code> ：用于在 <code>postProcessAfterInitialization</code> 方法中生成代理对象</li><li><code>InstantiationAwareBeanPostProcessor</code> ：拦截 bean 的正常 <code>doCreateBean</code> 创建流程</li><li><code>SmartInstantiationAwareBeanPostProcessor</code> ：提前预测 bean 的类型、暴露 bean 的引用（ AOP 、循环依赖等，太过于复杂，此处不作解释）</li><li><code>AopInfrastructureBean</code> ：实现了该接口的 bean 永远不会被代理（防止套娃）</li></ul><p>除此之外，咱们一定要注意到它最开始的抽象实现类是 <strong><code>AbstractAutoProxyCreator</code></strong> ，它也是极度重要的！咱后面的不少源码分析中都会遇到它的。</p><h3 id="2-2-AnnotationAwareAspectJAutoProxyCreator的初始化时机"><a href="#2-2-AnnotationAwareAspectJAutoProxyCreator的初始化时机" class="headerlink" title="2.2 AnnotationAwareAspectJAutoProxyCreator的初始化时机"></a>2.2 AnnotationAwareAspectJAutoProxyCreator的初始化时机</h3><p>既然在 <code>AspectJAutoProxyRegistrar</code> 中已经把 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的 <code>BeanDefinition</code> 注册到 <code>BeanDefinitionRegistry</code> 中了，那么接下来的后置处理器初始化部分，它一定会被创建，而这个时机我们在前面 IOC 原理部分也讲过了，咱这里回顾一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-comment">// ......</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            postProcessBeanFactory(beanFactory);<br>            invokeBeanFactoryPostProcessors(beanFactory);<br>            <span class="hljs-comment">// 6. 注册、初始化BeanPostProcessor</span><br>            registerBeanPostProcessors(beanFactory);<br>            initMessageSource();<br>            initApplicationEventMulticaster();<br>            <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面那个超级长的方法，还有印象吧！源码咱就不贴了，主要能让小伙伴们回忆起来就好。</p><p>注意一个小细节，<code>AnnotationAwareAspectJAutoProxyCreator</code> 实现了 <code>Ordered</code> 接口，它会提前于普通 <code>BeanPostProcessor</code> 创建，那是不是就代表着普通的 <code>BeanPostProcessor</code> 也会被 AOP 代理呢？答案是肯定的，小伙伴们可以自行测试一下。</p><h3 id="2-3-AnnotationAwareAspectJAutoProxyCreator的作用时机"><a href="#2-3-AnnotationAwareAspectJAutoProxyCreator的作用时机" class="headerlink" title="2.3 AnnotationAwareAspectJAutoProxyCreator的作用时机"></a>2.3 AnnotationAwareAspectJAutoProxyCreator的作用时机</h3><p>那既然 <code>ApplicationContext</code> 的 <code>refresh</code> 方法中，第 6 步 <code>registerBeanPostProcessors</code>方法把 <code>AnnotationAwareAspectJAutoProxyCreator</code> 初始化好了，接下来的 bean 就应该都会被它干预了。咱以 <code>com.linkedbear.spring.aop.b_aspectj</code> 中的示例来看，<code>FinanceService</code> 对象的创建流程中 <code>AnnotationAwareAspectJAutoProxyCreator</code> 如何插入干预的。</p><h4 id="2-3-1-getBean-→-doCreateBean"><a href="#2-3-1-getBean-→-doCreateBean" class="headerlink" title="2.3.1 getBean → doCreateBean"></a>2.3.1 getBean → doCreateBean</h4><p>bean 的创建流程咱前面 IOC 原理部分已经学过了，从 <code>getBean</code> 开始，依次是 <code>doGetBean</code>、<code>createBean</code> 、<code>doCreateBean</code> ，在 <code>doCreateBean</code> 方法中会真正的创建对象、属性赋值、依赖注入，以及初始化流程的执行。等 bean 本身的初始化流程全部执行完毕后，就该 <code>BeanPostProcessor</code> 的 <code>postProcessAfterIntialization</code> 方法了，这些咱都很熟悉。</p><p>不过，在这之前有一个小插曲，是 <code>createBean</code> 到 <code>doCreateBean</code> 这个动作中还有一个 <code>InstantiationAwareBeanPostProcessor</code> 的拦截初始化动作，咱需要来看一下。</p><h4 id="2-3-2-AnnotationAwareAspectJAutoProxyCreator-postProcessBeforeInstantiation"><a href="#2-3-2-AnnotationAwareAspectJAutoProxyCreator-postProcessBeforeInstantiation" class="headerlink" title="2.3.2 AnnotationAwareAspectJAutoProxyCreator#postProcessBeforeInstantiation"></a>2.3.2 AnnotationAwareAspectJAutoProxyCreator#postProcessBeforeInstantiation</h4><p>源码不是特别长，我们可以简单的来看一下这里面发生的核心动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    Object cacheKey = getCacheKey(beanClass, beanName);<br><br>    <span class="hljs-comment">// 决定是否要提前增强当前bean</span><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>        <span class="hljs-comment">// 被增强过的bean不会再次被增强</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 基础类型的bean不会被提前增强、被跳过的bean不会被提前增强</span><br>        <span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 原型bean的额外处理：TargetSource</span><br>    <span class="hljs-comment">// 此处的设计与自定义TargetSource相关，单实例bean必定返回null</span><br>    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);<br>    <span class="hljs-keyword">if</span> (targetSource != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) &#123;<br>            <span class="hljs-keyword">this</span>.targetSourcedBeans.add(beanName);<br>        &#125;<br>        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);<br>        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);<br>        <span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>纵读下来，这里面的逻辑其实并不复杂，甚至还蛮容易理解的，这里面涉及到几个小概念咱在这里解释一下。</p><h5 id="2-3-2-1-InfrastructureClass"><a href="#2-3-2-1-InfrastructureClass" class="headerlink" title="2.3.2.1 InfrastructureClass"></a>2.3.2.1 InfrastructureClass</h5><p>这个<strong>基础类型</strong>，可能小伙伴们不大理解这玩意是个啥，咱可以点进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">super</span>.isInfrastructureClass(beanClass) ||<br>            (<span class="hljs-keyword">this</span>.aspectJAdvisorFactory != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass)));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||<br>            Pointcut.class.isAssignableFrom(beanClass) ||<br>            Advisor.class.isAssignableFrom(beanClass) ||<br>            AopInfrastructureBean.class.isAssignableFrom(beanClass);<br>    <span class="hljs-comment">// logger ......</span><br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>得了，合着它说的这些<strong>基础类型，是切面、切入点、增强器等等的对象</strong>！那一切就解释的过去了，一个切入点的对象包装怎么会被 AOP 代理呢？它是作为 AOP 底层非常重要的组成成员，它不应该参与到具体的被增强对象中。</p><h5 id="2-3-2-2-被跳过的bean？"><a href="#2-3-2-2-被跳过的bean？" class="headerlink" title="2.3.2.2 被跳过的bean？"></a>2.3.2.2 被跳过的bean？</h5><p>这个被跳过的 bean ，似乎在之前我们学习 AOP 的过程中一直没有接触过，它是什么意思呢？咱可以先进到源码中看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AspectJAwareAdvisorAutoProxyCreator</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// 加载增强器</span><br>    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>    <span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;<br>        <span class="hljs-comment">// 逐个匹配，如果发现当前bean的名称与增强器的名称一致，则认为</span><br>        <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;<br>                ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);<br>&#125;<br><br><span class="hljs-comment">// AbstractAutoProxyCreator</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查beanName代表的是不是原始对象(以.ORIGINAL结尾)</span><br>    <span class="hljs-keyword">return</span> AutoProxyUtils.isOriginalInstance(beanName, beanClass);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的用注释一标，小伙伴们也不难理解这段逻辑吧，它要看看<strong>当前对象的名称是不是有跟增强器的名称撞车的</strong>，或者说<strong>它是不是一个还没有经过任何代理的原始对象</strong>。对于一般情况而言，我们构造的 bean 根本就不可能带有 <code>.ORIGINAL</code> 的后缀，所以这个地方相当于判断当前创建的 bean 是否名称与增强器撞车。</p><p>这里咱简单说下增强器的概念。一个 <code>Advisor</code> 可以视为<strong>一个切入点 + 一个通知方法的结合体</strong>，对于 Aspect 切面类中定义的通知方法，<strong>方法体 + 方法上的通知注解</strong>就可以看做一个 <code>Advisor</code> 增强器。更多相关的解释，咱放到下一章再研究。</p><p>至于上面的 <code>findCandidateAdvisors</code> 方法，里面的逻辑有点复杂，咱也放到下一章再研究。</p><p>不过在此 Debug 的时候，可以发现 <code>findCandidateAdvisors</code> 方法执行完成后，获取到了 5 个增强器，也都是在 <code>Logger</code> 类中定义的那 5 个通知方法：</p><p><img src="/2022/04/16/10-AOP%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8/aa955a366d1542d982d517d86c12b61d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image.png" alt="img"></p><p>（最后一个名太长了，实际上是 afterThrowing 的通知，引用的通用切入点表达式罢了。。。）</p><h5 id="2-3-2-3-TargetSource？"><a href="#2-3-2-3-TargetSource？" class="headerlink" title="2.3.2.3 TargetSource？"></a>2.3.2.3 TargetSource？</h5><p>这个概念咱之前在 IOC 部分没有见到过，当然它也不是 IOC 的东西。。。这个概念咱也是放到下一章再解释吧，这里咱可以先简单说一下，<strong>AOP 的代理其实不是代理的目标对象本身，而是目标对象包装后的 <code>TargetSource</code> 对象</strong>。至于为什么它会这么做，咱下一章也会展开解释的。</p><h4 id="2-3-3-AnnotationAwareAspectJAutoProxyCreator-postProcessAfterInitialization"><a href="#2-3-3-AnnotationAwareAspectJAutoProxyCreator-postProcessAfterInitialization" class="headerlink" title="2.3.3 AnnotationAwareAspectJAutoProxyCreator#postProcessAfterInitialization"></a>2.3.3 AnnotationAwareAspectJAutoProxyCreator#postProcessAfterInitialization</h4><p>前面的拦截判断结束后，<code>AnnotationAwareAspectJAutoProxyCreator</code> 再发挥作用就要等到最后一步的 <code>postProcessAfterInitialization</code> 方法了，这里面就是真正的生成代理对象。方法的实现很简单，咱跳转进来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>        Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;<br>            <span class="hljs-comment">// 核心：构造代理</span><br>            <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>小小的前戏后，最关键的动作是中间的 <code>wrapIfNecessary</code> 方法。</p><p>这个动作从方法名上就可以很容易的理解了，如果有必要的话，给这个对象包装生成代理对象。下面进入到源码的部分（小伙伴们只需要关注标注有注释的部分即可）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-keyword">this</span>.advisedBeans.get(cacheKey))) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;<br>        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// Create proxy if we have advice.</span><br>    <span class="hljs-comment">// 如果上面的判断都没有成立，则决定是否需要进行代理对象的创建</span><br>    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;<br>        <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);<br>        <span class="hljs-comment">// 创建代理对象的动作</span><br>        Object proxy = createProxy(<br>                bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> SingletonTargetSource(bean));<br>        <span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br><br>    <span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以由此可见，创建代理对象的核心动作其实就三个步骤：</p><ol><li>判断决定是否是不会被增强的 bean</li><li>根据当前正在创建的 bean 去匹配增强器</li><li>如果有增强器，创建 bean 的代理对象</li></ol><p>这里咱只是简单地看一下流程，具体的创建代理对象的动作，咱放到第 50 章再研究。</p><p>【到这里咱先整体的对 AOP 中的核心注解，以及后置处理器 <code>AnnotationAwareAspectJAutoProxyCreator</code> 有一个整体的认识，小伙伴们先把这部分消化好吧。接下来的两章，咱就要来具体的研究几个重要的环节了】</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>09-AOP高级-尝试自己实现AOP</title>
    <link href="/2022/04/16/09-AOP%E9%AB%98%E7%BA%A7-%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0AOP/"/>
    <url>/2022/04/16/09-AOP%E9%AB%98%E7%BA%A7-%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP高级-如果我们自己实现一个AOP？"><a href="#AOP高级-如果我们自己实现一个AOP？" class="headerlink" title="AOP高级-如果我们自己实现一个AOP？"></a>AOP高级-如果我们自己实现一个AOP？</h1><p>前面学习 IOC 高级的 <code>BeanPostProcessor</code> 中，咱就了解到 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法可以用于创建代理对象，那 Spring AOP 是如何实现的呢？</p><h2 id="1-前期分析"><a href="#1-前期分析" class="headerlink" title="1. 前期分析"></a>1. 前期分析</h2><p>先分析一下，一个完整的 AOP 机制需要的 支撑组件 和 它们的作用 分别都是什么。</p><h4 id="1-1-生成代理对象的时机"><a href="#1-1-生成代理对象的时机" class="headerlink" title="1.1 生成代理对象的时机"></a>1.1 生成代理对象的时机</h4><p>最先想到的，肯定是普通的 bean 在初始化阶段，被 <code>BeanPostProcessor</code> 影响后，在 <code>postProcessAfterInitialization</code> 方法中生成代理对象。这也是 AOP 的实现机制中最重要的环节之一。</p><h4 id="1-2-解析切入点表达式的时机"><a href="#1-2-解析切入点表达式的时机" class="headerlink" title="1.2 解析切入点表达式的时机"></a>1.2 解析切入点表达式的时机</h4><p>再想一个问题，<code>BeanPostProcessor</code> 怎么知道哪些 bean 在创建时需要织入通知，生成代理对象呢？</p><p>可能是在 bean 的初始化逻辑中检查的吧，可是检查的依据是什么呢？</p><p>依据是那些被 <code>@Aspect</code> 标注的切面类，里面定义的 pointcut 方法定义的切入点表达式吧！</p><p>但是什么时候解析这些切入点表达式呢？</p><ul><li>Aspect 切面类初始化的时候再解析？晚了吧，万一在解析之前已经有好多 bean 已经创建完了呢？那岂不是错过时机了？</li><li>Aspect 切面类加载进 <code>BeanFactory</code> 后再解析？哎这个可以，此时所有的 bean 还都没有创建，AOP 可以大展身手，但是再想一个问题：如果此时已经把 AOP 的东西全部准备好了，那回头后置处理器的初始化阶段咋办？这个通知是织入还是不织入呢？所以看来这个时机虽然很靠前了，但还是有点尴尬；</li><li>负责 AOP 的核心后置处理器初始化的时候再去 <code>BeanFactory</code> 中解析？哎这个看样子就能同时顾及到两方面了，此时所有的 <code>BeanDefinition</code> 都加载进 <code>BeanFactory</code> 了，而且后置处理器都初始化好了，普通 bean 也都没有创建，所以这个时机点是相对最合适的。</li></ul><p>所以我们得出结论：<strong>在 AOP 核心后置处理器的初始化阶段，解析容器中的所有切面类中的切入点表达式</strong>。</p><h4 id="1-3-通知织入的方式"><a href="#1-3-通知织入的方式" class="headerlink" title="1.3 通知织入的方式"></a>1.3 通知织入的方式</h4><p>接下来，通知如何织入呢？既然是动态代理，那就应该区分到底是使用 jdk 动态代理，还是 Cglib 动态代理了。</p><p>除此之外， <code>InvocationHandler</code> 或者 <code>MethodInterceptor</code> 的逻辑应该怎么写，这也是个问题，因为一个 bean 可能会被多个切面同时织入通知，所以这些因素我们也要考虑进去。</p><h2 id="2-开始编码吧！"><a href="#2-开始编码吧！" class="headerlink" title="2. 开始编码吧！"></a>2. 开始编码吧！</h2><p>好了，咱暂时就想到这么多，下面咱自己搞一个后置处理器，把这个思路实际运用一下。</p><blockquote><p>温馨提示：千万不要觉得思路都理清楚了，就要直接造一个简易版的出来，真的没必要，人家 SpringFramework 写的比咱好太多了，咱理解思路就好啦，后面马上咱研究原理就好，这只是个铺垫。</p></blockquote><h3 id="2-1-代码准备"><a href="#2-1-代码准备" class="headerlink" title="2.1 代码准备"></a>2.1 代码准备</h3><p>还是跟往常一样，咱先准备好代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;获取id为&quot;</span> + id + <span class="hljs-string">&quot;的用户。。。&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;保存name为&quot;</span> + name + <span class="hljs-string">&quot;的用户。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.h_imitate.service.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LogAspect beforePrint ......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这次不需要配置类了，因为不需要声明 <code>@EnableAspectJAutoProxy</code> 注解，我们通过自己编写的后置处理器，一样可以达到效果（理论上）。</p><h3 id="2-2-基本的后置处理器编写"><a href="#2-2-基本的后置处理器编写" class="headerlink" title="2.2 基本的后置处理器编写"></a>2.2 基本的后置处理器编写</h3><p>接下来的核心就是编写后置处理器，咱声明一个 <code>AopProxyPostProcessor</code> 吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopProxyPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面只需要实现 <code>postProcessAfterInitialization</code> 方法（ beforeProcessAfterInitialization 主要做属性赋值 以及 初始化等动作）。</p><h3 id="2-3-获得所有切面和切入点表达式"><a href="#2-3-获得所有切面和切入点表达式" class="headerlink" title="2.3 获得所有切面和切入点表达式"></a>2.3 获得所有切面和切入点表达式</h3><p>上面分析了，后置处理器的初始化阶段需要获取到容器中现有的所有切面和切入点表达式，而且要注意这个过程中不要把这些切面给初始化了（也就是不要调用 <code>getBean</code> 方法）。具体的步骤咱分解来看：</p><h4 id="2-3-1-获得BeanFactory"><a href="#2-3-1-获得BeanFactory" class="headerlink" title="2.3.1 获得BeanFactory"></a>2.3.1 获得BeanFactory</h4><p>实现上述逻辑的操作，需要提前获取到 <code>BeanFactory</code> ，所以咱在这里需要借助回调注入的机制，把 <code>BeanFactory</code> 注入进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopProxyPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span>, <span class="hljs-title">BeanFactoryAware</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> ConfigurableListableBeanFactory beanFactory;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-comment">// 这里强转为比较高级的类型，方便接下来拿BeanDefinition</span><br>        <span class="hljs-keyword">this</span>.beanFactory = (ConfigurableListableBeanFactory) beanFactory;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-筛选出切面类"><a href="#2-3-2-筛选出切面类" class="headerlink" title="2.3.2 筛选出切面类"></a>2.3.2 筛选出切面类</h4><p>然后，要获取这里面所有的切面类，就要先获取到 <code>BeanFactory</code> 中已经存在的所有 <code>BeanDefinition</code> ，而这个动作也比较简单，咱放到初始化方法的回调中做吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initAspectAndPointcuts</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 取到BeanFactory中的所有BeanDefinition</span><br>    String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames();<br>    <span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;<br>        <span class="hljs-comment">// 检查BeanDefinition对应的class上是否标注了@Aspect注解</span><br>        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanDefinitionName);<br>        String beanClassName = beanDefinition.getBeanClassName();<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanClassName)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        Class&lt;?&gt; clazz = ClassUtils.resolveClassName(beanClassName, ClassUtils.getDefaultClassLoader());<br>        <span class="hljs-keyword">if</span> (!clazz.isAnnotationPresent(Aspect.class)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 到此为止，说明当前BeanDefinition对应的bean是一个切面类，解析方法</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-解析切入点表达式"><a href="#2-3-3-解析切入点表达式" class="headerlink" title="2.3.3 解析切入点表达式"></a>2.3.3 解析切入点表达式</h4><p>接下来的工作就是解析 Aspect 切面类了，既然是切面类，那就需要解析这个类上的每个方法，在 SpringFramework 中提供了一个很方便的反射类，它可以很快速的对类中的方法进行访问和过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ReflectionUtils.doWithMethods(clazz, method -&gt; &#123;<br>    <span class="hljs-comment">// 此处要实现切入点表达式的解析</span><br>&#125;, method -&gt; &#123;<br>    <span class="hljs-comment">// 此处只过滤出通知方法</span><br>    <span class="hljs-keyword">return</span> method.isAnnotationPresent(Before.class)<br>            || method.isAnnotationPresent(After.class)<br>            || method.isAnnotationPresent(AfterReturning.class)<br>            || method.isAnnotationPresent(AfterThrowing.class)<br>            || method.isAnnotationPresent(Around.class);<br>&#125;);<br></code></pre></td></tr></table></figure><p>剩下的就是怎么解析这些注解了，这里面我不打算写的特别复杂，也不写那些乱七八糟的处理逻辑了，咱还是以 <code>@Before</code> 注解为例来演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 借助AspectJ中的切入点表达式解析器来搞定</span><br>PointcutParser pointcutParser = PointcutParser.<br>        getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();<br><span class="hljs-comment">// 到此为止，说明当前BeanDefinition对应的bean是一个切面类，解析方法</span><br>ReflectionUtils.doWithMethods(clazz, method -&gt; &#123;<br>    Before before = method.getAnnotation(Before.class);<br>    <span class="hljs-keyword">if</span> (before != <span class="hljs-keyword">null</span>) &#123;<br>        String pointcutExp = before.value();<br>        <span class="hljs-comment">// 借助pointcutParser解析切入点表达式</span><br>        PointcutExpression pointcutExpression = pointcutParser.parsePointcutExpression(pointcutExp);<br>        <br>    &#125;<br>&#125;, method -&gt; &#123; ... &#125;);<br></code></pre></td></tr></table></figure><p>到这里，咱就可以把切面类中的切入点表达式都拿出来了，并且还封装了一个 <code>PointcutExpression</code> 。</p><h4 id="2-3-4-缓存切入点表达式和通知方法"><a href="#2-3-4-缓存切入点表达式和通知方法" class="headerlink" title="2.3.4 缓存切入点表达式和通知方法"></a>2.3.4 缓存切入点表达式和通知方法</h4><p>表达式有了，怎么保存为好呢？很简单，放到一个 <code>Map</code> 中就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;PointcutExpression, Method&gt; beforePointcutMethodMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initAspectAndPointcuts</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ......</span><br>        <span class="hljs-comment">// 到此为止，说明当前BeanDefinition对应的bean是一个切面类，解析方法</span><br>        PointcutParser pointcutParser = PointcutParser.<br>                getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();<br>        ReflectionUtils.doWithMethods(clazz, method -&gt; &#123;<br>            Before before = method.getAnnotation(Before.class);<br>            <span class="hljs-keyword">if</span> (before != <span class="hljs-keyword">null</span>) &#123;<br>                String pointcutExp = before.value();<br>                <span class="hljs-comment">// 借助pointcutParser解析切入点表达式</span><br>                PointcutExpression pointcutExpression = pointcutParser.parsePointcutExpression(pointcutExp);<br>                <span class="hljs-comment">// 放入对应的缓存区</span><br>                beforePointcutMethodMap.put(pointcutExpression, method);<br>            &#125;<br>        &#125;, method -&gt; &#123; ... &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里面为了编写简单快速演示，我这里只用了一个 <code>Map</code> 保存所有的前置通知，但实际上的通知类型有 5 种，它们需要分别保存，或者封装为类似于 Metadata 的元信息，这里咱就不演示了。</p><h3 id="2-4-代理对象的创建"><a href="#2-4-代理对象的创建" class="headerlink" title="2.4 代理对象的创建"></a>2.4 代理对象的创建</h3><p>接下来，咱就要给普通的 bean 对象构造代理对象了。AspectJ 提供的 <code>PointcutExpression</code>已经足以搞定切入点表达式与目标类的匹配，所以我们编写起来会很容易。</p><p>具体来看，可以把这个部分的内容分为下面几个小步骤。</p><h4 id="2-4-1-排除的项"><a href="#2-4-1-排除的项" class="headerlink" title="2.4.1 排除的项"></a>2.4.1 排除的项</h4><p>首先！切面类不要代理了，否则会一直循环调用直到栈溢出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-comment">// 切面不增强</span><br>    <span class="hljs-keyword">if</span> (bean.getClass().isAnnotationPresent(Aspect.class)) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-切入点的匹配"><a href="#2-4-2-切入点的匹配" class="headerlink" title="2.4.2 切入点的匹配"></a>2.4.2 切入点的匹配</h4><p>然后，对于普通 bean 而言，要看看有没有能切入当前 bean 的切面，如果没有，则不需要创建代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>    <span class="hljs-comment">// 切面不增强</span><br>    <span class="hljs-keyword">if</span> (bean.getClass().isAnnotationPresent(Aspect.class)) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-comment">// 检查类是否能被切入点表达式切入</span><br>    List&lt;Method&gt; proxyMethods = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    beforePointcutMethodMap.forEach((pointcutExpression, method) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (pointcutExpression.couldMatchJoinPointsInType(bean.getClass())) &#123;<br>            proxyMethods.add(method);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 没有能匹配的切面，则直接返回普通对象</span><br>    <span class="hljs-keyword">if</span> (proxyMethods.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><h4 id="2-4-3-织入通知生成代理对象"><a href="#2-4-3-织入通知生成代理对象" class="headerlink" title="2.4.3 织入通知生成代理对象"></a>2.4.3 织入通知生成代理对象</h4><p>接下来，就是如何织入通知了，这里由于我们只演示了前置通知，这里只需要在方法调用之前反射执行切面类的前置通知方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 需要织入通知</span><br>    <span class="hljs-keyword">return</span> Enhancer.create(bean.getClass(), (MethodInterceptor) (proxy, method, args, methodProxy) -&gt; &#123;<br>        <span class="hljs-comment">// 依次执行前置通知</span><br>        <span class="hljs-keyword">for</span> (Method proxyMethod : proxyMethods) &#123;<br>            Object aspectBean = beanFactory.getBean(proxyMethod.getDeclaringClass());<br>            proxyMethod.invoke(aspectBean);<br>        &#125;<br>        <span class="hljs-keyword">return</span> methodProxy.invokeSuper(proxy, args);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个实现方式说实话很粗糙，小伙伴们只需要领会其中的思想即可。</p><h3 id="2-5-测试运行"><a href="#2-5-测试运行" class="headerlink" title="2.5 测试运行"></a>2.5 测试运行</h3><p>编写测试启动类，由于没有配置类，所以只需要用包扫描驱动 IOC 容器即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImitateAopApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<span class="hljs-string">&quot;com.linkedbear.spring.aop.h_imitate&quot;</span>);<br>        UserService userService = ctx.getBean(UserService.class);<br>        userService.get(<span class="hljs-string">&quot;abc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台可以打印前置通知，说明实现是可以执行的：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">LogAspect</span></span> beforePrint ......<br>获取id为abc的用户。。。<br></code></pre></td></tr></table></figure><p>这样我们就完成了一个自行实现的 AOP 后置处理器，小伙伴们要体会其中的思想，接下来的几章 AOP 原理中，会涉及到这里面的思想，以及更复杂的概念。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-AOP高级-其他AOP扩展</title>
    <link href="/2022/04/16/08-AOP%E9%AB%98%E7%BA%A7-%E5%85%B6%E4%BB%96AOP%E6%89%A9%E5%B1%95/"/>
    <url>/2022/04/16/08-AOP%E9%AB%98%E7%BA%A7-%E5%85%B6%E4%BB%96AOP%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP高级-AOP的其他扩展知识"><a href="#AOP高级-AOP的其他扩展知识" class="headerlink" title="AOP高级-AOP的其他扩展知识"></a>AOP高级-AOP的其他扩展知识</h1><h2 id="1-AOP的引介【了解】"><a href="#1-AOP的引介【了解】" class="headerlink" title="1. AOP的引介【了解】"></a>1. AOP的引介【了解】</h2><p>在学习 AOP 的术语时，就说过了引介只是了解即可，现在用的实在是太少了。不过还是会有对此感兴趣的小伙伴。</p><blockquote><p>考虑到整体的难度和使用情况来看，这里只介绍基于 AspectJ 的引介，对于 SpringFramework 原生的这里小册不作介绍，感兴趣的小伙伴自己查资料去。</p></blockquote><h3 id="1-1-引介的作用和目标"><a href="#1-1-引介的作用和目标" class="headerlink" title="1.1 引介的作用和目标"></a>1.1 引介的作用和目标</h3><p>引介的作用是<strong>给目标对象所在的类，动态的添加属性和方法</strong>，这种增强的类型区别于方法级别的通知，它不会影响已有的方法，而是直接给类添加新的方法和属性。</p><p>不过话又说回来，如果手头的项目，源码都好好的，谁会闲的没事用这种东西呢？而且即便是因为工程依赖的 jar 包中的代码没办法修改，我们也能把那个类拷出来，自己再任意改造呀，所以这个引介通知的使用就越来越少了。</p><p>但是，这样直接改造框架的源码，回头每个项目都要这么搞，本身就很麻烦；如果每个项目对于既定源码的扩展内容都不一样，那可就没法搞了。所以，引介通知还是能起到作用的。</p><p>注意，<strong>引介作为一种特殊的 AOP 通知，它的作用对象是目标对象所属类而不是目标对象本身</strong>，这也就意味着<strong>引介的织入是对类织入</strong>，而不是对方法的逻辑织入。</p><h3 id="1-2-Spring框架中的引介"><a href="#1-2-Spring框架中的引介" class="headerlink" title="1.2 Spring框架中的引介"></a>1.2 Spring框架中的引介</h3><p>SpringFramework 中原生的引介通知，是通过 <code>IntroductionInterceptor</code> 来创建的，它本身扩展了 <code>MethodInterceptor</code> ，以及 <code>DynamicIntroductionAdvice</code> 接口。</p><p>我们开发者可以通过实现 <code>IntroductionInterceptor</code> 的子接口 <code>DelegatintIntroductionInterceptor</code> ，来实现引介通知的编写。</p><h3 id="1-3-AspectJ的引介"><a href="#1-3-AspectJ的引介" class="headerlink" title="1.3 AspectJ的引介"></a>1.3 AspectJ的引介</h3><p>AspectJ 中的引介，有一个专门的注解 <strong><code>@DeclareParents</code></strong> 来很方便的实现目标对象所属类的属性和方法增强。</p><p>它可以指定被增强的类要扩展什么接口，以及扩展的实现类。这种声明引介通知的方式相对比较简单，下面咱来学习这种编写方式。</p><h4 id="1-3-1-代码准备"><a href="#1-3-1-代码准备" class="headerlink" title="1.3.1 代码准备"></a>1.3.1 代码准备</h4><p>这次的代码准备也不难，三个类就可以，分别是 Service 、切面类、配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinanceService</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Long source, Long target, <span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;转账完成！&quot;</span>);<br>        System.out.println(source + <span class="hljs-string">&quot; 为 &quot;</span> + target + <span class="hljs-string">&quot; 转钱&quot;</span> + money + <span class="hljs-string">&quot;元！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntroductionAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com..f_introduction.service.FinanceService.transfer(Long, Long, int))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrintLog</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;转账动作前置打印 。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.aop.f_introduction&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntroductionConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>最后，编写测试启动类，驱动 IOC 容器后获取 <code>FinanceService</code> 并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntroductionApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IntroductionConfiguration.class);<br>        FinanceService financeService = ctx.getBean(FinanceService.class);<br>        financeService.transfer(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台可以正常打印 <code>IntroductionAspect</code> 中的前置通知，这样代码就准备好了。</p><h4 id="1-3-2-需求说明"><a href="#1-3-2-需求说明" class="headerlink" title="1.3.2 需求说明"></a>1.3.2 需求说明</h4><p><strong>转账的动作中，金额一定不能是负的</strong>，而目前的代码中并没有这方面的校验逻辑。</p><p>相对简单的办法是，在前置通知中编写参数校验的逻辑即可，这个很好写不多说。这里咱学习的是如何用引介的方式解决这个问题。</p><h4 id="1-3-3-编写校验服务"><a href="#1-3-3-编写校验服务" class="headerlink" title="1.3.3 编写校验服务"></a>1.3.3 编写校验服务</h4><p>要用引介通知增强，首先需要一个<strong>新的接口</strong> + <strong>实现类</strong>，这里咱可以声明一个 <code>MoneyValidator</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MoneyValidator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">validate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>紧接着，编写一个 <code>MoneyValidator</code> 的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyValidatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MoneyValidator</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就有了一个金额的校验器。</p><h4 id="1-3-4-DeclareParents的使用"><a href="#1-3-4-DeclareParents的使用" class="headerlink" title="1.3.4 @DeclareParents的使用"></a>1.3.4 @DeclareParents的使用</h4><p>接下来就是给 <code>FinanceService</code> 织入引介通知了。首先咱要回到切面类中，在这里面添加一个 <code>MoneyValidator</code> 的成员，并标注 <code>@DeclareParents</code> 注解，这个 <code>@DeclareParents</code> 注解有两个参数，</p><ol><li><code>value</code> 是即将增强到原有目标类的全限定名;</li><li><code>defaultImpl</code> 是引介接口的默认实现类。</li></ol><p>所以我们可以在这里面这样声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntroductionAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@DeclareParents(value = &quot;com.linkedbear.spring.aop.f_introduction.service.FinanceService&quot;, </span><br><span class="hljs-meta">                    defaultImpl = MoneyValidatorImpl.class)</span><br>    <span class="hljs-keyword">private</span> MoneyValidator moneyValidator;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是话又说回来，现在的 <code>FinanceService</code> 是个类，那可以，如果这是个接口呢（FinanceServiceImpl implements FinanceService）？这次该怎么写呢？</p><p>AspectJ 当然也考虑到了这一点，只需要在整个接口的全限定名后面带一个 + 就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeclareParents(value = &quot;com.linkedbear.spring.aop.f_introduction.service.FinanceService+&quot;, // &lt;--看这里</span><br><span class="hljs-meta">                defaultImpl = MoneyValidatorImpl.class)</span><br><span class="hljs-keyword">private</span> MoneyValidator moneyValidator;<br></code></pre></td></tr></table></figure><p>这样就代表，<strong>对于这个 <code>FinanceService</code> 接口下面的所有实现类，全部织入引介通知</strong>。</p><p>效果上理解，就是代理类实现了 MoneyValidator 接口中的方法，实现的内容就是 MoneyValidatorImpl 中的实现。（具体是不是就是这样实现的，后面补充到这块知识的时候在补充）</p><h4 id="1-3-5-编写校验逻辑"><a href="#1-3-5-编写校验逻辑" class="headerlink" title="1.3.5 编写校验逻辑"></a>1.3.5 编写校验逻辑</h4><p>剩下的就是使用引介过去的 <code>MoneyValidatorImpl</code> 的逻辑了，这个逻辑也非常的简单，咱先理一下思路哈：</p><ol><li>首先把方法的请求参数先拿出来；</li><li>然后拿到<strong>目标对象的代理对象</strong>（注意此处必须要拿到代理对象，原始目标对象压根就没实现 <code>MoneyValidator</code> 接口），强转为 <code>MoneyValidator</code> 类型，就可以调用它的 <code>validate</code> 方法了。</li><li>如果 <code>validate</code> 方法返回 <code>true</code> ，则接下来的方法可以执行；如果返回 <code>false</code> ，则代表 <code>money</code> 参数不合法，抛出参数不合法的异常即可。</li></ol><p>用代码编写也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com..f_introduction.service.FinanceService.transfer(Long, Long, int))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrintLog</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> money = (<span class="hljs-keyword">int</span>) joinPoint.getArgs()[<span class="hljs-number">2</span>];<br>    MoneyValidator validator = (MoneyValidator) joinPoint.getThis();<br>    <span class="hljs-keyword">if</span> (validator.validate(money)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;转账动作前置打印 。。。&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;转账金额不合法！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-6-测试运行"><a href="#1-3-6-测试运行" class="headerlink" title="1.3.6 测试运行"></a>1.3.6 测试运行</h4><p>修改一下 <code>main</code> 方法的测试代码，我们把正常数据和错误数据都执行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(IntroductionConfiguration.class);<br>    FinanceService financeService = ctx.getBean(FinanceService.class);<br>    financeService.transfer(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">100</span>);<br>    System.out.println(<span class="hljs-string">&quot;------------------------------&quot;</span>);<br>    financeService.transfer(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, -<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台可以打印出 100 的成功，和 -1 的异常：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">转账动作前置打印 。。。<br>转账完成！<br>1 为 2 转钱100元！<br>------------------------------<br>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: 转账金额不合法！<br></code></pre></td></tr></table></figure><p>由此可以完成引介通知的增强。</p><h2 id="2-LoadTimeWeawer【了解】"><a href="#2-LoadTimeWeawer【了解】" class="headerlink" title="2. LoadTimeWeawer【了解】"></a>2. LoadTimeWeawer【了解】</h2><p>这个标签的作用是修改代理对象的构建时机为 类加载时期织入。与之相匹配的注解是 <code>@EnableLoadTimeWeaving</code> 。</p><h3 id="2-1-AOP增强的时机"><a href="#2-1-AOP增强的时机" class="headerlink" title="2.1 AOP增强的时机"></a>2.1 AOP增强的时机</h3><p>一开始讲解 AOP 的时候，说到 SpringFramework 的 AOP 底层是使用运行时动态代理的技术实现，其实这话并不绝对（所以咱一开始说的是<strong>可以</strong>，而不是一定），因为从原生的 AOP 设计角度来看，通知的织入是有三种时机的，它们分别是：</p><ul><li><strong>字节码编译织入</strong>：在 javac 的动作中，使用特殊的编译器，将通知直接织入到 Java 类的字节码文件中</li><li><strong>类加载时期织入</strong>：在类加载时期，使用特殊的类加载器，在目标类的字节码加载到 JVM 的时机中，将通知织入进去；</li><li><strong>运行时创建对象织入</strong>：在目标对象的创建时机，使用动态代理技术将通知织入到目标对象中，形成代理对象。</li></ul><p>我们前面编写的所有 AOP 的实例，全部都是基于运行时创建代理对象的方式织入通知的。除此之外，还有上面的两种方式可以选择，只是我们几乎都不用了。</p><h3 id="2-2-AspectJ-对于增强的时机"><a href="#2-2-AspectJ-对于增强的时机" class="headerlink" title="2.2 AspectJ 对于增强的时机"></a>2.2 AspectJ 对于增强的时机</h3><p>AspectJ 作为很早就出现的 AOP 框架，它可以说是非常强大了，以上三种方式它都有提供方案 / 支持：</p><ul><li><strong>对于字节码的编译期织入</strong>：它可以利用它自己定义的 AspectJ 语言编写好切面，并借助 Maven 等项目管理工具，在工程的编译期使用特殊的编译器（ajc等），将切面类中定义的通知织入到 Java 类中；</li><li><strong>对于类加载时期的织入</strong>：它的机制就是 <strong>LoadTimeWeaving</strong> （刚好就是字面意思）；</li><li><strong>对于运行时创建对象的织入</strong>：它在早期有整合一个叫 AspectWerkz 框架，也是在运行时动态代理产生代理对象，只不过我们现在学习的是 Spring 整合 AspectJ ，那最终还是用基于 SpringFramework 底层的动态代理搞定了。</li></ul><h3 id="2-3-AspectJ的-LoadTimeWeaving"><a href="#2-3-AspectJ的-LoadTimeWeaving" class="headerlink" title="2.3 AspectJ的 LoadTimeWeaving"></a>2.3 AspectJ的 LoadTimeWeaving</h3><p>下面咱还是通过一个简单的示例，来了解一下 LoadTimeWeaving 这个机制。</p><h4 id="2-3-1-代码准备"><a href="#2-3-1-代码准备" class="headerlink" title="2.3.1 代码准备"></a>2.3.1 代码准备</h4><p>一个 Service 一个 Aspect 一个 Configuration ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;获取id为&quot;</span> + id + <span class="hljs-string">&quot;的用户。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.g_weawer.service.UserService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LogAspect 前置通知 ......&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.aop.g_weawer&quot;)</span><br><span class="hljs-comment">//@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@EnableLoadTimeWeaving</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadTimeWeavingConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意！此处不再使用 <code>@EnableAspectJAutoProxy</code> 注解，它是启用运行时的动态代理织入通知，而开启类加载时期的织入就需要使用另外的注解了，也就是上面提到的 <code>@EnableLoadTimeWeaving</code> 注解（或者在 xml 中声明 <code>&lt;context:load-time-weaver/&gt;</code> 标签）。</p><p>最后，编写测试启动类，套路还是都一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadTimeWeavingApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(LoadTimeWeavingConfiguration.class);<br>        UserService userService = ctx.getBean(UserService.class);<br>        userService.get(<span class="hljs-string">&quot;aaa&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-只声明注解并不会生效"><a href="#2-3-2-只声明注解并不会生效" class="headerlink" title="2.3.2 只声明注解并不会生效"></a>2.3.2 只声明注解并不会生效</h4><p>此时运行 <code>main</code> 方法，控制台会抛出一个异常：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Caused <span class="hljs-keyword">by</span>: java.lang.IllegalStateException: ClassLoader [sun.misc.Launcher$AppClassLoader] does NOT provide <span class="hljs-keyword">an</span> <span class="hljs-string">&#x27;addTransformer(ClassFileTransformer)&#x27;</span> method. Specify <span class="hljs-keyword">a</span> custom LoadTimeWeaver <span class="hljs-keyword">or</span> <span class="hljs-built_in">start</span> your Java virtual machine <span class="hljs-keyword">with</span> Spring<span class="hljs-string">&#x27;s agent: -javaagent:spring-instrument-&#123;version&#125;.jar</span><br></code></pre></td></tr></table></figure><p>大概翻译一下，说是如果使用类加载器阶段的通知织入，要么自定义一个 LoadTimeWeaver ，要么导个 jar 包，而这个 jar 包叫 <code>spring-instrument</code> 。</p><p>这个家伙我们没见过，但它说了，那咱就导吧：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-instrument<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.framework.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入之后还不行，注意异常的提示中还需要一个 vm 启动参数，叫 <strong><code>-javaagent</code></strong> ，那好吧，我们也把它加上：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-javaagent:E:<span class="hljs-regexp">/maven/</span>repository<span class="hljs-regexp">/org/</span>springframework<span class="hljs-regexp">/spring-instrument/</span><span class="hljs-number">5.2</span>.<span class="hljs-number">8</span>.RELEASE/spring-instrument-<span class="hljs-number">5.2</span>.<span class="hljs-number">8</span>.RELEASE.jar<br></code></pre></td></tr></table></figure><blockquote><p>注意 jar 包的位置要使用绝对路径，且小伙伴要记得修改这个 jar 包的路径呀。</p></blockquote><p>这样声明好之后，重新运行 <code>main</code> 方法后发现还是不生效，控制台依然没有打印切面日志。。。</p><h4 id="2-3-3-aop-xml"><a href="#2-3-3-aop-xml" class="headerlink" title="2.3.3 aop.xml"></a>2.3.3 aop.xml</h4><p>在 SpringFramework 整合 AspectJ 的规则中，规定了一点：如果要使用类加载级别的 AOP ，需要在 <code>resources</code> 的 <strong><code>META-INF</code></strong> 下编写一个 <strong><code>aop.xml</code></strong> 的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">aspectj</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//AspectJ//DTD//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aspectj</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 要织入切面的目标类 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">weaver</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">within</span>=<span class="hljs-string">&quot;com.linkedbear.spring.aop.g_weaving..*&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">weaver</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 切面类 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aspects</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aspect</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.linkedbear.spring.aop.g_weaving.aspect.LogAspect&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aspects</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aspectj</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，<code>weaver</code> 中包含的类要把切面类一起包含进去！否则无法正常织入切面。</p><p>这样写完之后，就算是终于都搞完了。重新运行 <code>main</code> 方法，<code>LogAspect</code> 的通知就被织入到 <code>UserService</code> 中了：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">LogAspect 前置通知 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>获取id为aaa的用户。。。<br></code></pre></td></tr></table></figure><h4 id="2-3-4-不好使？"><a href="#2-3-4-不好使？" class="headerlink" title="2.3.4 不好使？"></a>2.3.4 不好使？</h4><p>可能有的小伙伴在实际编码时，会遇到按照上面步骤一步一步来，但最后仍然没有打印切面日志！这种情况就需要另加一个步骤了：</p><p>在 <code>vm-options</code> 中再加入一行 <code>javaagent</code> ：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">-javaagent:E:<span class="hljs-symbol">\m</span>aven<span class="hljs-symbol">\r</span>epository<span class="hljs-symbol">\o</span>rg<span class="hljs-symbol">\a</span>spectj<span class="hljs-symbol">\a</span>spectjweaver<span class="hljs-symbol">\1</span>.9.5<span class="hljs-symbol">\a</span>spectjweaver-1.9.5.jar<br></code></pre></td></tr></table></figure><p>这样再执行 main 方法，就可以成功打印切面日志了。不过这样写完之后，控制台会报一个警告：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[AppClassLoader@18b4aac2]</span> error at com\linkedbear\spring\aop\g_weaving\aspect\LogAspect<span class="hljs-selector-class">.java</span>::<span class="hljs-number">0</span> class com<span class="hljs-selector-class">.linkedbear</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.aop</span><span class="hljs-selector-class">.g_weaving</span><span class="hljs-selector-class">.aspect</span><span class="hljs-selector-class">.LogAspect</span> is already woven and has not been built <span class="hljs-keyword">in</span> reweavable mode <span class="hljs-selector-attr">[Xlint:nonReweavableTypeEncountered]</span><br></code></pre></td></tr></table></figure><p>这个警告的意思也很明确，<code>LogAspect</code> 这个切面已经被使用过了，已经织入成功了，所以就不要再搞了。</p><p>出现这个问题的原因，是因为上面的 javaagent 与 <code>@EnableLoadTimeWeaving</code> 同时存在了，所以导致通知织入了两次。解决方法很简单，把注解配置类上的 <code>@EnableLoadTimeWeaving</code>注解删掉即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>07-AOP进阶-实战AOP事务控制</title>
    <link href="/2022/04/16/07-AOP%E8%BF%9B%E9%98%B6-%E5%AE%9E%E6%88%98AOP%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/04/16/07-AOP%E8%BF%9B%E9%98%B6-%E5%AE%9E%E6%88%98AOP%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP进阶-实战：AOP实现事务控制"><a href="#AOP进阶-实战：AOP实现事务控制" class="headerlink" title="AOP进阶-实战：AOP实现事务控制"></a>AOP进阶-实战：AOP实现事务控制</h1><h2 id="1-代码准备"><a href="#1-代码准备" class="headerlink" title="1. 代码准备"></a>1. 代码准备</h2><p>咱先把基本的环境搭建一下哈，分为以下几个步骤。</p><h3 id="1-1-导入MySQL的依赖"><a href="#1-1-导入MySQL的依赖" class="headerlink" title="1.1 导入MySQL的依赖"></a>1.1 导入MySQL的依赖</h3><p>前面在 IOC 的工程中咱已经导入过一次 MySQL 的依赖了，不多赘述，直接导入即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-初始化数据库"><a href="#1-2-初始化数据库" class="headerlink" title="1.2 初始化数据库"></a>1.2 初始化数据库</h3><p>数据库就不搞那么复杂了，来一个简单的员工表得了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tbl_employee` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">12</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `dept_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `salary` <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p>然后，插入两条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tbl_employee(id, name, age, dept_id, salary) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1000.00</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tbl_employee(id, name, age, dept_id, salary) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1000.00</span>);<br></code></pre></td></tr></table></figure><p>很明显我们要搞转账的例子吧！这样数据库就算初始化好了。</p><h3 id="1-3-编写Dao和Service"><a href="#1-3-编写Dao和Service" class="headerlink" title="1.3 编写Dao和Service"></a>1.3 编写Dao和Service</h3><p>简单的准备一下 Dao 和 Service 吧，Dao 有一个加钱、一个减钱的方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinanceDao</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addMoney</span><span class="hljs-params">(Long id, <span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Connection connection = JdbcUtils.getConnection();<br>            PreparedStatement preparedStatement = connection<br>                    .prepareStatement(<span class="hljs-string">&quot;update tbl_employee set salary = salary + ? where id = ?&quot;</span>);<br>            preparedStatement.setInt(<span class="hljs-number">1</span>, money);<br>            preparedStatement.setLong(<span class="hljs-number">2</span>, id);<br>            preparedStatement.executeUpdate();<br>            preparedStatement.close();<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(Long id, <span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Connection connection = JdbcUtils.getConnection();<br>            PreparedStatement preparedStatement = connection<br>                    .prepareStatement(<span class="hljs-string">&quot;update tbl_employee set salary = salary - ? where id = ?&quot;</span>);<br>            preparedStatement.setInt(<span class="hljs-number">1</span>, money);<br>            preparedStatement.setLong(<span class="hljs-number">2</span>, id);<br>            preparedStatement.executeUpdate();<br>            preparedStatement.close();<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Service 只需要一个方法：转账。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinanceService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    FinanceDao financeDao;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Long source, Long target, <span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        financeDao.subtractMoney(source, money);<br>        financeDao.addMoney(target, money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-JdbcUtils的制作"><a href="#1-4-JdbcUtils的制作" class="headerlink" title="1.4 JdbcUtils的制作"></a>1.4 JdbcUtils的制作</h3><p>上面的 Dao 中有一个 <code>JdbcUtils</code> ，咱先简单的写一下（连接池咱就不弄了哈）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JDBC_URL = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&quot;</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        Connection connection;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = DriverManager.getConnection(JDBC_URL, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> connection;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-配置类"><a href="#1-5-配置类" class="headerlink" title="1.5 配置类"></a>1.5 配置类</h3><p>剩下的，就是配置类了，这里咱提前把 AOP 打开了，还有记得包扫描一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.transaction&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionAspectConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-测试运行"><a href="#1-6-测试运行" class="headerlink" title="1.6 测试运行"></a>1.6 测试运行</h3><p>先编写一下测试代码试一下是不是好使：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(<br>                TransactionAspectConfiguration.class);<br>        FinanceService financeService = ctx.getBean(FinanceService.class);<br>        financeService.transfer(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法后，数据库中的金额发生了变化，证明代码的编写一切正常：</p><p><img src="/2022/04/16/07-AOP%E8%BF%9B%E9%98%B6-%E5%AE%9E%E6%88%98AOP%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/img01.png" alt="img"></p><p>好，接下来咱开始搞一下麻烦。</p><h2 id="2-事务的引入"><a href="#2-事务的引入" class="headerlink" title="2. 事务的引入"></a>2. 事务的引入</h2><p>修改一下 <code>FinanceService</code> 的 <code>transfer</code> 方法，让它报一个运行时异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Long source, Long target, <span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>    financeDao.subtractMoney(source, money);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    financeDao.addMoney(target, money);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样再运行，<code>subtractMoney</code> 方法执行成功，<code>addMoney</code> 方法被异常阻止中断运行了，张三哭了，银行乐了。</p><p>这个运行结果当然不是我们想要的，整个转账的动作应该是一个<strong>原子操作</strong>才对。那我们就可以引入切面来实现事务控制。</p><h3 id="2-1-编写事务切面类"><a href="#2-1-编写事务切面类" class="headerlink" title="2.1 编写事务切面类"></a>2.1 编写事务切面类</h3><p>前面已经练习过的小伙伴，现在写起来肯定是飞快了吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Around(&quot;???&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doWithTransaction</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">return</span> joinPoint.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制事务，肯定用环绕通知比较合适，不过这个切入点表达式怎么写呢？直接拦截整个 Service 吗？</p><p>当然可以，但总感觉不是很妥：对于那些 <code>getXXX</code> 方法，它们根本不需要事务，那这个时候开启事务就显得很没必要。。。</p><p>正好，咱前面学过基于注解的切入点表达式，不如我们就用一个自定义注解来搞定吧！</p><h3 id="2-2-编写事务标识注解"><a href="#2-2-编写事务标识注解" class="headerlink" title="2.2 编写事务标识注解"></a>2.2 编写事务标识注解</h3><p>下面咱简单的编写一个事务注解，当方法标注了 <code>@Transactional</code> 注解后，即代表该方法需要事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span> <span class="hljs-comment">// </span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Transactional &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这样，切入点表达式也就可以写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;@annotation(com.linkedbear.spring.transaction.aspect.Transactional)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doWithTransaction</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">return</span> joinPoint.proceed();<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是怎么开启事务、提交事务、回滚事务了。</p><h3 id="2-3-【问题】全局事务唯一？"><a href="#2-3-【问题】全局事务唯一？" class="headerlink" title="2.3 【问题】全局事务唯一？"></a>2.3 【问题】全局事务唯一？</h3><p>可是现在问题就来了：切面里怎么拿到 service 方法中正在使用的 <code>Connection</code> 呢？而且两个 Dao 方法中获取的 <code>Connection</code> 也都是全新的，这个问题怎么解决为好呢？小伙伴们可以开动脑筋想一下有没有什么之间学过的东西能让两个 Dao 的方法执行期间，只有一个 <code>Connection</code> ？</p><p>既然是在同一个方法中执行，那就一定是同一个线程咯？那是不是可以用一下 <strong><code>ThreadLocal</code>**呀！</strong>使用 <code>ThreadLocal</code> ，可以实现一个线程中的对象资源共享**！</p><p>所以，方案也就有了，咱在 <code>JdbcUtils</code> 中添加一个 <code>ThreadLocal</code> 的成员，把当前线程使用的 <code>Connection</code> 放在这里即可。</p><p>下面咱改造一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JDBC_URL = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&quot;</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; connectionThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ThreadLocal中有，直接取出返回</span><br>        <span class="hljs-keyword">if</span> (connectionThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> connectionThreadLocal.get();<br>        &#125;<br>        <span class="hljs-comment">// 没有，则创建新的，并放入ThreadLocal中</span><br>        Connection connection;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = DriverManager.getConnection(JDBC_URL, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>            connectionThreadLocal.set(connection);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> connection;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>鉴于考虑到像 <code>getXXX</code> 这样的方法不需要事务，所以可以把创建新 <code>Connection</code> 的方法单独抽取出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (connectionThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> connectionThreadLocal.get();<br>    &#125;<br>    <span class="hljs-keyword">return</span> openConnection();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;<br>    Connection connection;<br>    <span class="hljs-keyword">try</span> &#123;<br>        connection = DriverManager.getConnection(JDBC_URL, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        connectionThreadLocal.set(connection);<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> connection;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，为了能让 <code>ThreadLocal</code> 中的 <code>Connection</code> 能正常移除，再添加一个 <code>remove</code> 的方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    connectionThreadLocal.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p>OK ，到此为止，<code>JdbcUtils</code> 的方法就全部设计好了。</p><h3 id="2-4-继续编写切面类"><a href="#2-4-继续编写切面类" class="headerlink" title="2.4 继续编写切面类"></a>2.4 继续编写切面类</h3><p>这次来到切面类，就可以在 <code>Service</code> 的方法执行之前，先获取到 <code>Connection</code> ，然后就是我们熟悉的那一套事务控制的套路了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;@annotation(com.linkedbear.spring.transaction.aspect.Transactional)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doWithTransaction</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    Connection connection = JdbcUtils.getConnection();<br>    <span class="hljs-comment">// 开启事务</span><br>    connection.setAutoCommit(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object retval = joinPoint.proceed();<br>        <span class="hljs-comment">// 方法执行成功，提交事务</span><br>        connection.commit();<br>        <span class="hljs-keyword">return</span> retval;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-comment">// 方法出现异常，回滚事务</span><br>        connection.rollback();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 最后关闭连接，释放资源</span><br>        JdbcUtils.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-编码测试"><a href="#2-5-编码测试" class="headerlink" title="2.5 编码测试"></a>2.5 编码测试</h3><p>在 <code>transfer</code> 方法上添加 <code>@Transactional</code> 注解，直接运行 <code>main</code> 方法，控制台会抛出除零异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Long source, Long target, <span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>    financeDao.subtractMoney(source, money);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    financeDao.addMoney(target, money);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是观察数据库，此时双方的钱均没有发生变化，证明事务已经起效果了。</p><p><img src="/2022/04/16/07-AOP%E8%BF%9B%E9%98%B6-%E5%AE%9E%E6%88%98AOP%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/img02.png" alt="img"></p><p>好了这一章的内容就这么多，内容不多，但几个关键的点希望小伙伴们能理解到位，这在后面的 <strong>Dao 编程事务</strong>部分会再次用到！</p><p>【基础也学了，实操也搞了，如果想继续学习 Dao 部分的小伙伴可以直接跳过后面的 AOP 高阶和原理了，直接去学 Dao ；对于要继续深入学习的小伙伴而言，下面的内容可能不是特别重要，仅当做扩展知识就好】</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>06-AOP进阶-延伸知识和进阶使用</title>
    <link href="/2022/04/16/06-AOP%E8%BF%9B%E9%98%B6-%E5%BB%B6%E4%BC%B8%E7%9F%A5%E8%AF%86%E5%92%8C%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/16/06-AOP%E8%BF%9B%E9%98%B6-%E5%BB%B6%E4%BC%B8%E7%9F%A5%E8%AF%86%E5%92%8C%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP进阶-AOP的延伸知识和进阶使用"><a href="#AOP进阶-AOP的延伸知识和进阶使用" class="headerlink" title="AOP进阶-AOP的延伸知识和进阶使用"></a>AOP进阶-AOP的延伸知识和进阶使用</h1><h2 id="1-AOP联盟【了解】"><a href="#1-AOP联盟【了解】" class="headerlink" title="1. AOP联盟【了解】"></a>1. AOP联盟【了解】</h2><p>在 SpringFramework 2.0 之前，它还没有整合 AspectJ ，当时的 SpringFramework 还有一套相对低层级的实现，它也是 SpringFramework 原生的实现，而我们要了解它，首先要先了解一个组织：<strong>AOP 联盟</strong>。</p><p>早在很久之前，AOP 的概念就被提出来了。同之前的 EJB 一样，作为一个概念、思想，它要有一批人来制定规范，于是就有了这样一个 AOP 联盟。这个联盟的人将 AOP 的这些概念都整理好，形成了一个规范 AOP 框架底层实现的 API ，并最终总结出了 5 种 AOP 通知类型。</p><p>咱要了解的，就是 AOP 联盟提出的这 5 种通知类型。</p><h3 id="1-1-AOP联盟制定的通知类型"><a href="#1-1-AOP联盟制定的通知类型" class="headerlink" title="1.1 AOP联盟制定的通知类型"></a>1.1 AOP联盟制定的通知类型</h3><p>5 种通知类型分别为：</p><ul><li><strong>前置通知</strong></li><li>后置通知（<strong>返回通知</strong>）</li><li><strong>异常通知</strong></li><li><strong>环绕通知</strong></li><li>引介通知</li></ul><p>注意它跟 AspectJ 规定的 5 种通知类型的区别：它<strong>多了一个引介通知，少了一个后置通知</strong>。而且还有一个要注意的，AOP 联盟定义的后置通知实际上是返回通知（ after-returning ），而 AspectJ 的后置通知是真的后置通知，与返回通知是两码事。</p><h3 id="1-2-SpringFramework中对应的通知接口"><a href="#1-2-SpringFramework中对应的通知接口" class="headerlink" title="1.2 SpringFramework中对应的通知接口"></a>1.2 SpringFramework中对应的通知接口</h3><p>AOP 联盟定义的 5 种通知类型在 SpringFramework 中都有对应的接口定义：</p><ul><li>前置通知：<code>org.springframework.aop.MethodBeforeAdvice</code></li><li>返回通知：<code>org.springframework.aop.AfterReturningAdvice</code></li><li>异常通知：<code>org.springframework.aop.ThrowsAdvice</code></li><li>环绕通知：<code>org.aopalliance.intercept.MethodInterceptor</code></li><li>引介通知：<code>org.springframework.aop.IntroductionAdvisor</code></li></ul><p>注意！<strong>环绕通知的接口是 AOP 联盟原生定义的接口</strong>（不是 cglib 的那个 <code>MethodInterceptor</code>）！小伙伴们可以先思考一下为什么会是这样。</p><p>其实答案不难理解，由于 SpringFramework 是基于 AOP 联盟制定的规范来的，所以自然会去兼容原有的方案。又由于咱之前写过原生的动态代理，知道它其实就是<strong>环绕通知</strong>，所以 SpringFramework 要在环绕通知上拆解结构，自然也会保留原本环绕通知的接口支持。</p><p>了解这部分的知识，在后面咱分析 Spring AOP 的原理时，看到一些特殊的 API 接口时，就不会觉得奇怪或者陌生了，现在小伙伴们只是有个基本的印象即可。</p><h2 id="2-切面类的通知方法参数【掌握】"><a href="#2-切面类的通知方法参数【掌握】" class="headerlink" title="2. 切面类的通知方法参数【掌握】"></a>2. 切面类的通知方法参数【掌握】</h2><p>在上一章的环绕通知编写中，咱提到了一个特殊的接口 <code>ProceedingJoinPoint</code> ，它的具体使用，以及切面类中的通知方法参数等等，咱都有必要来学习一下。</p><p>其实在之前的代码中，或许有的小伙伴就已经产生很强的不适感了：<strong>这所有的日志打印都是一样的，我也不知道哪个日志打印是哪个方法触发的，这咋区分呢？</strong> 所以，我们得想个办法，把被增强的方法，以及对应的目标对象的信息拿到才行。（原生动态代理都行，到 AOP 就不行了？这肯定不合理）</p><h3 id="2-1-JoinPoint的使用"><a href="#2-1-JoinPoint的使用" class="headerlink" title="2.1 JoinPoint的使用"></a>2.1 JoinPoint的使用</h3><p>其实切面类的通知方法，咱都可以在方法的参数列表上加上切入点的引用，就像这样：（咱以 <code>beforePrint</code> 方法为例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(public * com..FinanceService.*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写之后，重新运行程序不会有任何错误，说明这样写是被允许的，但咱更关心的是，能从这个 <code>JoinPoint</code> 中得到什么呢？</p><p>直接在方法中调用 <code>joinPoint</code> 的方法，可以发现它能获取到这么多东西：</p><p><img src="/2022/04/16/06-AOP%E8%BF%9B%E9%98%B6-%E5%BB%B6%E4%BC%B8%E7%9F%A5%E8%AF%86%E5%92%8C%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/joinpoint.png" alt="img"></p><p>这么多内容，咱选几个比较重要的来讲解。</p><h4 id="2-1-1-getTarget和getThis"><a href="#2-1-1-getTarget和getThis" class="headerlink" title="2.1.1 getTarget和getThis"></a>2.1.1 getTarget和getThis</h4><p><code>getTarget</code> 方法是最容易被理解的，咱可以简单的测试一下效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(public * com..FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    System.out.println(joinPoint.getTarget());<br>    System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台会打印 <code>FinanceService</code> 的信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">com</span>.linkedbear.spring.aop.c_joinpoint.service.FinanceService@<span class="hljs-number">4</span>c<span class="hljs-number">309</span>d<span class="hljs-number">4</span>d<br><span class="hljs-attribute">Logger</span> beforePrint run ......<br><span class="hljs-attribute">FinanceService</span> 收钱 === <span class="hljs-number">123</span>.<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p>包括使用 Debug 打断点，识别到的 <code>FinanceService</code> 也是未经过代理的原始对象：</p><p><img src="/2022/04/16/06-AOP%E8%BF%9B%E9%98%B6-%E5%BB%B6%E4%BC%B8%E7%9F%A5%E8%AF%86%E5%92%8C%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/getTarget.png" alt="img"></p><p>那相对的，<code>getThis</code> 方法返回的就是代理对象咯？咱也可以来打印一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(public * com..FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    System.out.println(joinPoint.getTarget());<br>    System.out.println(joinPoint.getThis());<br>    System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，控制台打印了两个一模一样的 <code>FinanceService</code> ：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">com</span>.linkedbear.spring.aop.c_joinpoint.service.FinanceService@<span class="hljs-number">4</span>c<span class="hljs-number">309</span>d<span class="hljs-number">4</span>d<br><span class="hljs-attribute">com</span>.linkedbear.spring.aop.c_joinpoint.service.FinanceService@<span class="hljs-number">4</span>c<span class="hljs-number">309</span>d<span class="hljs-number">4</span>d<br><span class="hljs-attribute">Logger</span> beforePrint run ......<br><span class="hljs-attribute">FinanceService</span> 收钱 === <span class="hljs-number">123</span>.<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p>怎么个情况？难道是我们推理错了吗？用 Debug 看一眼：</p><p><img src="/2022/04/16/06-AOP%E8%BF%9B%E9%98%B6-%E5%BB%B6%E4%BC%B8%E7%9F%A5%E8%AF%86%E5%92%8C%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/getThis.png" alt="img"></p><p>诶呦吓一跳，<code>getThis</code> 肯定还是获取到代理对象才是啦。那为什么原始的目标对象，与代理对象的控制台打印结果是一样的呢？</p><p>其实从上面的截图中也能猜到端倪：它增强了 <code>equals</code> 方法，增强了 <code>hashcode</code> 方法，就是没有增强 <code>toString</code> 方法，那当然就执行目标对象的方法啦，自然也就打印原来的目标对象的全限定名了。</p><h4 id="2-1-2-getArgs"><a href="#2-1-2-getArgs" class="headerlink" title="2.1.2 getArgs"></a>2.1.2 getArgs</h4><p>这个方法也是超级好理解，它可以获取到被拦截的方法的参数列表。快速的来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(public * com..FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    System.out.println(Arrays.toString(joinPoint.getArgs()));<br>    System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，控制台打印出了 <code>addMoney</code> 方法传入的 123.45 ：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">[<span class="hljs-number">123.45</span>]<br><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 收钱 === <span class="hljs-number">123.45</span><br></code></pre></td></tr></table></figure><h4 id="2-1-3-getSignature"><a href="#2-1-3-getSignature" class="headerlink" title="2.1.3 getSignature"></a>2.1.3 getSignature</h4><p>这个方法，从名上看是获取签名，关键是这个签名是个啥？不知道，猜不出来，干脆先打印一把吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(public * com..FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    System.out.println(joinPoint.getSignature());<br>    System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，控制台打印的是被拦截的方法的全限定名等信息：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void com.linkedbear.spring.aop.c_joinpoint.service.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FinanceService</span>.</span></span>add<span class="hljs-constructor">Money(<span class="hljs-params">double</span>)</span><br>Logger beforePrint run ......<br>FinanceService 收钱<span class="hljs-operator"> === </span><span class="hljs-number">123.45</span><br></code></pre></td></tr></table></figure><p>哦，突然明白了，合着它打印的是这个被拦截的方法的签名啊！那是不是还可以顺便拿到方法的信息呢？</p><p>直接调用 <code>getSignature()</code> 的方法，发现这里面只有类的信息，没有方法的信息：</p><p><img src="/2022/04/16/06-AOP%E8%BF%9B%E9%98%B6-%E5%BB%B6%E4%BC%B8%E7%9F%A5%E8%AF%86%E5%92%8C%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/getSignature.png" alt="img"></p><p>诶？那可奇了怪了，既然基于 AspectJ 的 AOP 是对方法的拦截，那理所应当的应该能拿到方法的信息才对呀！那当然，肯定能拿到，只是缺少了一点点步骤而已。</p><p>既然是基于方法的拦截，那获取到的 <code>Signature</code> 就应该可以强转为一种类似于 <code>Method</code> 的 <code>Signature</code> ，刚好还真就有这么一个 <code>MethodSignature</code> 的接口！</p><p>所以，咱就可以这样写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(public * com..FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    MethodSignature signature = (MethodSignature) joinPoint.getSignature();<br>    <br>    System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那既然是这样，<code>MethodSignature</code> 中一定能拿到方法的信息了！果不其然，这个接口还真就定义了获取 <code>Method</code> 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodSignature</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CodeSignature</span> </span>&#123;<br>    <span class="hljs-function">Class <span class="hljs-title">getReturnType</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Method <span class="hljs-title">getMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>so ，我们就可以打印出这个方法的信息了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(public * com..FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    MethodSignature signature = (MethodSignature) joinPoint.getSignature();<br>    Method method = signature.getMethod();<br>    System.out.println(method.getName());<br>    System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，控制台可以打印出方法的信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">addMoney</span><br><span class="hljs-attribute">Logger</span> beforePrint run ......<br><span class="hljs-attribute">FinanceService</span> 收钱 === <span class="hljs-number">123</span>.<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><blockquote><p>其实 <code>Signature</code> 的 <code>getName</code> 方法，就相当于拿到 <code>Method</code> 后再调 <code>getName</code> 方法了，小伙伴们可以自行测试一下。</p></blockquote><p>至此，其实我们就可以完成前面说的需求了。</p><h4 id="2-1-4-需求的改造"><a href="#2-1-4-需求的改造" class="headerlink" title="2.1.4 需求的改造"></a>2.1.4 需求的改造</h4><p>重新修改 <code>addMoney</code> 方法的逻辑，就可以很简单轻松的完成一开始说的 “不知道哪个日志打印是哪个方法触发” 的需求了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(public * com..FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;被拦截的类：&quot;</span> + joinPoint.getTarget().getClass().getName());<br>    System.out.println(<span class="hljs-string">&quot;被拦截的方法：&quot;</span> + ((MethodSignature) joinPoint.getSignature()).getMethod().getName());<br>    System.out.println(<span class="hljs-string">&quot;被拦截的方法参数：&quot;</span> + Arrays.toString(joinPoint.getArgs()));<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，控制台打印出了我们预期的需求效果：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>被拦截的类：com.linkedbear.spring.aop.c_joinpoint.service.FinanceService<br>被拦截的方法：addMoney<br>被拦截的方法参数：[<span class="hljs-number">123.45</span>]<br>FinanceService 收钱 === <span class="hljs-number">123.45</span><br></code></pre></td></tr></table></figure><h3 id="2-2-ProceedingJoinPoint的扩展"><a href="#2-2-ProceedingJoinPoint的扩展" class="headerlink" title="2.2 ProceedingJoinPoint的扩展"></a>2.2 ProceedingJoinPoint的扩展</h3><p>上一章中我们提前使用了 <code>ProceedingJoinPoint</code> 这个家伙，而它是基于 <code>JoinPoint</code> 的扩展，它扩展的方法只有 <code>proceed</code> 方法，也就是那个能让我们在环绕通知中显式执行目标对象的目标方法的那个 API 。</p><p>不过有一点要注意：<code>proceed</code> 方法还有一个带参数的重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">proceed</span><span class="hljs-params">(Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br></code></pre></td></tr></table></figure><p>由此可以说明一点：<strong>在环绕通知中，可以自行替换掉原始目标方法执行时传入的参数列表</strong>！</p><p>其实这个一点也不奇怪，想想在之前的动态代理案例中，咱不就是可以随便改参数的嘛。</p><h3 id="2-3-返回通知和异常通知的特殊参数"><a href="#2-3-返回通知和异常通知的特殊参数" class="headerlink" title="2.3 返回通知和异常通知的特殊参数"></a>2.3 返回通知和异常通知的特殊参数</h3><p>之前我们在写返回通知和异常通知时，还有一个小问题没有解决：<strong>返回通知中我们要拿到方法的返回值，异常通知中我们要拿到具体的异常抛出</strong>。这个呢，其实非常容易解决。</p><p>咱先把之前的代码再拿出来：（顺便简化了一下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(&quot;execution(* com..FinanceService.subtractMoney(double))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturningPrint</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger afterReturningPrint run ......&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@AfterThrowing(&quot;defaultPointcut()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowingPrint</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger afterThrowingPrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>想拿到返回值或者异常非常简单，两个步骤。</p><p>首先在方法的参数列表中声明一个 result 或者 e ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(&quot;execution(* com..FinanceService.subtractMoney(double))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturningPrint</span><span class="hljs-params">(Object retval)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger afterReturningPrint run ......&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;返回的数据：&quot;</span> + retval);<br>&#125;<br><br><span class="hljs-meta">@AfterThrowing(&quot;defaultPointcut()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowingPrint</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger afterThrowingPrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意只是这样写了之后，此时运行 <code>main</code> 方法是不好使的，是拿不到返回值的！</p><p>我们<strong>还需要告诉 SpringFramework</strong> ，我拿了一个名叫 retval 的参数来接这个方法返回的异常，拿一个名叫 e 的参数来接收方法抛出的异常，反映到代码上就应该是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning(value = &quot;execution(* com..FinanceService.subtractMoney(double))&quot;, returning = &quot;retval&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturningPrint</span><span class="hljs-params">(Object retval)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger afterReturningPrint run ......&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;返回的数据：&quot;</span> + retval);<br>&#125;<br><br><span class="hljs-meta">@AfterThrowing(value = &quot;defaultPointcut()&quot;, throwing = &quot;e&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowingPrint</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger afterThrowingPrint run ......&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;抛出的异常：&quot;</span> + e.getMessage());<br>&#125;<br></code></pre></td></tr></table></figure><p>这样再运行 <code>main</code> 方法，控制台才会打印出方法的返回值：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">FinanceService 付钱 === <span class="hljs-number">543.21</span><br>Logger <span class="hljs-keyword">after</span>ReturningPrint run ......<br>返回的数据：<span class="hljs-number">543.21</span><br></code></pre></td></tr></table></figure><p>异常的信息接收同理，小伙伴们可以自行测试。</p><h2 id="3-多个切面的执行顺序【熟悉】"><a href="#3-多个切面的执行顺序【熟悉】" class="headerlink" title="3. 多个切面的执行顺序【熟悉】"></a>3. 多个切面的执行顺序【熟悉】</h2><p>日常开发中，或许我们会碰到一些特殊的情况：一个方法被多个切面同时增强了，这个时候如何控制好各个切面的执行顺序，以保证最终的运行结果能符合最初设计，这个也是非常重要的，咱有必要来研究一下多个切面的执行顺序问题。</p><h3 id="3-1-代码准备"><a href="#3-1-代码准备" class="headerlink" title="3.1 代码准备"></a>3.1 代码准备</h3><p>咱先把测试的代码准备一下，很简单，咱只声明两个切面和一个 Service 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;UserService 保存用户&quot;</span> + id);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.d_order.service.UserService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LogAspect 打印日志 ......&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.d_order.service.UserService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beginTransaction</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;TransactionAspect 开启事务 ......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，编写配置类，开启注解 AOP ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.aop.d_order&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectOrderConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>最后，编写启动类，用上面的配置类驱动 IOC 容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectOrderApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AspectOrderConfiguration.class);<br>        UserService userService = ctx.getBean(UserService.class);<br>        userService.saveUser(<span class="hljs-string">&quot;abc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台可以打印出两个切面的前置通知：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">LogAspect 打印日志 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>TransactionAspect 开启事务 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>UserService 保存用户abc<br></code></pre></td></tr></table></figure><h3 id="3-2-预设的顺序？"><a href="#3-2-预设的顺序？" class="headerlink" title="3.2 预设的顺序？"></a>3.2 预设的顺序？</h3><p>观察这个打印的结果，它是打印日志在前，开启事务在后，这难不成是因为我先写的 <code>LogAspect</code> ，后写的 <code>TransactionAspect</code> ，它就按照我的顺序来了？那不可能啊，即便我后写 <code>TransactionAspect</code> ，也是日志打印在前啊！所以它一定有一个默认的预设规则。</p><p>小伙伴可以先猜测一下预设的规则是什么，小册在这里再写一个切面，想必写完这个切面后，基本上顺序就非常容易推理了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbcAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.d_order.service.UserService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abc</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;abc abc abc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，发现 <code>AbcAspect</code> 的前置通知打印在 <code>LogAspect</code> 之前！</p><p>由此是不是咱就可以推测出预设的顺序了：<strong>默认的切面执行顺序，是按照字母表的顺序来的</strong>！</p><p>严谨一点，排序规则其实是<strong>根据切面类的 unicode 编码，按照十六进制排序得来的</strong>，unicode 编码靠前的，那自然就会排在前面。（作者个人习惯称其为字典表顺序）</p><h3 id="3-3-显式声明执行顺序"><a href="#3-3-显式声明执行顺序" class="headerlink" title="3.3 显式声明执行顺序"></a>3.3 显式声明执行顺序</h3><p>那我们不能因为这个毛病，就搞得调整顺序就必须改类名吧，一定有更好的方案才对。</p><p>还记得之前在第 26 章，小册讲解 <code>BeanPostProcessor</code> 的 javadoc 中提到的 <code>Ordered</code> 接口吗？而且在 IOC 原理的 <code>BeanPostProcessor</code> 的初始化部分，也提到过有关排序的接口，也涉及到了这个 <code>Ordered</code> 接口。不过前面我们一直都没有实际演示 <code>Ordered</code> 接口的使用，这里咱就来搞一下。</p><p>现在咱希望让事务控制的切面提早执行，让它在所有切面之前，那么我们就可以这样写：给 <code>TransactionAspect</code> 实现 <code>Ordered</code> 接口，并声明 <code>getOrder</code> 的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Ordered</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.d_order.service.UserService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beginTransaction</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;TransactionAspect 开启事务 ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个值设置成多少呢？咱先放个 0 试试，运行 <code>main</code> 方法，观察控制台的打印：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">TransactionAspect 开启事务 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>abc abc abc<br>LogAspect 打印日志 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>UserService 保存用户abc<br></code></pre></td></tr></table></figure><p>咦，发现事务切面的前置通知已经提前执行了，说明 0 这个顺序已经是提早了的，那最晚的时机对应的 order 值是什么呢？</p><h4 id="3-3-1-默认的排序值？"><a href="#3-3-1-默认的排序值？" class="headerlink" title="3.3.1 默认的排序值？"></a>3.3.1 默认的排序值？</h4><p>很简单，<strong>Integer 的最大值</strong> 2147483647 嘛！其实在 <code>Ordered</code> 接口中，就有这两个常量的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Ordered</span> </span>&#123;<br><span class="hljs-keyword">int</span> HIGHEST_PRECEDENCE = Integer.MIN_VALUE;<br><span class="hljs-keyword">int</span> LOWEST_PRECEDENCE = Integer.MAX_VALUE;<br></code></pre></td></tr></table></figure><p>那我们把这个值调到最低试一下？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Ordered.LOWEST_PRECEDENCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，发现事务的切面又回去了：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">abc abc abc<br>LogAspect 打印日志 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>TransactionAspect 开启事务 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>UserService 保存用户abc<br></code></pre></td></tr></table></figure><p>那到底默认值是啥呢？咱把 order 值往上调一个点试试？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次重新运行 <code>main</code> 方法，事务的切面打印又上去了。。。</p><p>所以得出结论：在不显式声明 order 排序值时，默认的排序值是 <strong><code>Integer.MAX_VALUE</code></strong> 。</p><h4 id="3-3-2-另一种声明办法"><a href="#3-3-2-另一种声明办法" class="headerlink" title="3.3.2 另一种声明办法"></a>3.3.2 另一种声明办法</h4><p>除了使用 <code>Ordered</code> 接口，还有通过注解的方式声明：**<code>@Order</code>** 。</p><p>这次我们在 <code>LogAspect</code> 上标注 <code>@Order</code> 注解，并声明一下排序值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Order(0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.d_order.service.UserService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LogAspect 打印日志 ......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，发现日志切面的打印提到最早了：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">LogAspect 打印日志 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>TransactionAspect 开启事务 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>abc abc abc<br>UserService 保存用户abc<br></code></pre></td></tr></table></figure><p>说明 <code>@Order</code> 注解也可以实现同样的效果。</p><h2 id="4-同切面的多个通知执行顺序【熟悉】"><a href="#4-同切面的多个通知执行顺序【熟悉】" class="headerlink" title="4. 同切面的多个通知执行顺序【熟悉】"></a>4. 同切面的多个通知执行顺序【熟悉】</h2><p>除了多个切面的顺序问题，如果同一个切面定义了多个相同类型的通知，它的执行顺序又是怎么样呢？咱也来研究一下。</p><p>这次编码的内容就少多了，直接在 <code>AbsAspect</code> 中添加一个方法 <code>def</code> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.d_order.service.UserService.*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">def</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;def def def&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>直接重新运行 <code>main</code> 方法，控制台先后打印了 <code>abc</code> 和 <code>def</code> 的内容：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">LogAspect 打印日志 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>TransactionAspect 开启事务 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>abc abc abc<br>def def def<br>UserService 保存用户abc<br></code></pre></td></tr></table></figure><p>原因是什么呢？估计小伙伴们也能猜到了，跟上面的逻辑一样，都是根据<strong>unicode编码顺序</strong>（字典表顺序）来的。</p><p>至于怎么搞，小伙伴们立马想到办法了吧！直接在方法上标注 <strong><code>@Order</code></strong> 注解就 OK （方法没办法实现接口的嘛）！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.d_order.service.UserService.*(..))&quot;)</span><br><span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">def</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;def def def&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，发现 def 的通知内容并没有被提前执行。。。看来这个办法行不通。。。</p><p>那怎么办呢？哎，这还真没办法。。。只能靠方法名去区分了。。。（是不是很无奈）</p><p>好了，有关切面、通知的执行顺序的研究，咱就到这里了。</p><h2 id="5-代理对象调用自身的方法【熟悉】"><a href="#5-代理对象调用自身的方法【熟悉】" class="headerlink" title="5. 代理对象调用自身的方法【熟悉】"></a>5. 代理对象调用自身的方法【熟悉】</h2><p>有一些特殊的场景下，我们产生的这些代理对象，会出现自身调用自身的另外方法的。下面我们也来演示一下这个现象。</p><blockquote><p>本节源码位置：<code>com.linkedbear.spring.aop.e_aopcontext</code> 。</p></blockquote><h3 id="5-1-代码准备"><a href="#5-1-代码准备" class="headerlink" title="5.1 代码准备"></a>5.1 代码准备</h3><p>测试代码还是三个类，不再重复了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.get(id);<br>        System.out.println(<span class="hljs-string">&quot;修改指定id的name。。。&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;获取指定id的user。。。&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.linkedbear.spring.aop.e_aopcontext.service.UserService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LogAspect 前置通知 ......&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.aop.e_aopcontext&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopContextConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>然后，依然是编写测试启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopContextApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AopContextConfiguration.class);<br>        UserService userService = ctx.getBean(UserService.class);<br>        userService.update(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写完之后，运行 <code>main</code> 方法，发现控制台只打印了一次 <code>LogAspect</code> 的切面打印：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">LogAspect 前置通知 ......<br>获取指定<span class="hljs-built_in">id</span>的user。。。<br>修改指定<span class="hljs-built_in">id</span>的<span class="hljs-built_in">name</span>。。。<br></code></pre></td></tr></table></figure><p>如果需求是每次调用 <code>UserService</code> 的方法都需要打印切面日志，应该怎么处理呢？</p><h3 id="5-2-不优雅的解决方案"><a href="#5-2-不优雅的解决方案" class="headerlink" title="5.2 不优雅的解决方案"></a>5.2 不优雅的解决方案</h3><p>可能有的小伙伴想到了一个能行但不太优雅的解决方案，就是利用依赖注入的特性，把自己注入进来，之后不用 <code>this.get</code> ，换用 <code>userService.get</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String id, String name)</span> </span>&#123;<br>        <span class="hljs-comment">// this.get(id);</span><br>        userService.get(id);<br>        System.out.println(<span class="hljs-string">&quot;修改指定id的name。。。&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，控制台确实打印了两次切面日志：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">LogAspect 前置通知 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>LogAspect 前置通知 <span class="hljs-params">...</span><span class="hljs-params">...</span><br>获取指定id的user。。。<br>修改指定id的name。。。<br></code></pre></td></tr></table></figure><p>但是吧。。。这样写真的好吗。。。有木有感觉怪怪的。。。难不成SpringFramework 就没有考虑到这个问题吗？</p><h3 id="5-3-正确的解决方案：AopContext"><a href="#5-3-正确的解决方案：AopContext" class="headerlink" title="5.3 正确的解决方案：AopContext"></a>5.3 正确的解决方案：AopContext</h3><p>当然还是得有的，SpringFramework 从一开始就考虑到这个问题了，于是它提供了一个 AopContext 的类，使用这个类，可以在代理对象中取到自身，它的使用方法很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String id, String name)</span> </span>&#123;<br>    ((UserService) AopContext.currentProxy()).get(id);<br>    System.out.println(<span class="hljs-string">&quot;修改指定id的name。。。&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>AopContext.currentProxy()</code> 方法就可以取到代理对象的 this 了。</p><p>不过这样直接写完之后，运行是不好使的，它会抛出一个异常：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalStateException: Cannot find current proxy: <span class="hljs-built_in">Set</span> <span class="hljs-string">&#x27;exposeProxy&#x27;</span> property <span class="hljs-literal">on</span> Advised <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-keyword">to</span> make <span class="hljs-literal">it</span> available, <span class="hljs-keyword">and</span> ensure <span class="hljs-literal">that</span> AopContext.currentProxy() <span class="hljs-keyword">is</span> invoked <span class="hljs-keyword">in</span> the same thread <span class="hljs-keyword">as</span> the AOP invocation context.<br></code></pre></td></tr></table></figure><p>这个异常的大致含义是，没有开启一个 <code>exposeProxy</code> 的属性，导致无法暴露出代理对象，从而无法获取。那开启 <code>exposeProxy</code> 这个属性的位置在哪里呢？好巧不巧，它是在我们一开始学习注解 AOP 的那个 <code>@EnableAspectJAutoProxy</code> 上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.aop.e_aopcontext&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true)</span> <span class="hljs-comment">// 暴露代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopContextConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>它的默认值是 <code>false</code> ，改为 <code>true</code> 之后，再运行 <code>main</code> 方法，就可以达到同样的效果了，控制台会打印两次切面日志。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>05-AOP基础-基于AspectJ的AOP</title>
    <link href="/2022/04/16/05-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EAspectJ%E7%9A%84AOP/"/>
    <url>/2022/04/16/05-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EAspectJ%E7%9A%84AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP基础-基于AspectJ实现AOP"><a href="#AOP基础-基于AspectJ实现AOP" class="headerlink" title="AOP基础-基于AspectJ实现AOP"></a>AOP基础-基于AspectJ实现AOP</h1><h2 id="1-Spring-AOP与AspectJ【了解】"><a href="#1-Spring-AOP与AspectJ【了解】" class="headerlink" title="1. Spring AOP与AspectJ【了解】"></a>1. Spring AOP与AspectJ【了解】</h2><p>在 SpringFramework 的官方文档中，AOP 的介绍下面有一个段落，它说明了 Spring AOP 与 AspectJ 的关系：</p><p><a href="https://link.juejin.cn/?target=https://docs.spring.io/spring-framework/docs/5.2.x/spring-framework-reference/core.html%23aop">docs.spring.io/spring-fram…</a></p><blockquote><p>Spring provides simple and powerful ways of writing custom aspects by using either a schema-based approach or the @AspectJ annotation style. Both of these styles offer fully typed advice and use of the AspectJ pointcut language while still using Spring AOP for weaving.</p><p>Spring 通过使用基于模式的方法或 <code>@AspectJ</code> 注解样式，提供了编写自定义切面的简单而强大的方法。这两种样式都提供了完全类型化的通知，并使用了 AspectJ 切入点表达式语言，同时仍使用 Spring AOP 进行通知的织入。</p></blockquote><p>由此可知，SpringFramework 实现注解配置 AOP ，是整合了 AspectJ 完成的。</p><ul><li><strong>Before 前置通知</strong>：目标对象的方法调用之前触发</li><li><strong>After 后置通知</strong>：目标对象的方法调用之后触发</li><li><strong>AfterReturning 返回通知</strong>：目标对象的方法调用完成，在返回结果值之后触发</li><li><strong>AfterThrowing 异常通知</strong>：目标对象的方法运行中抛出 / 触发异常后触发</li><li><strong>Around 环绕通知</strong>：编程式控制目标对象的方法调用</li></ul><h2 id="2-基于注解的AOP配置【掌握】"><a href="#2-基于注解的AOP配置【掌握】" class="headerlink" title="2. 基于注解的AOP配置【掌握】"></a>2. 基于注解的AOP配置【掌握】</h2><p>好了咱下面可以开始学习基于注解的 AOP 配置了，跟上一章一样，咱还是分步骤进行。</p><h3 id="2-1-标注-Component注解"><a href="#2-1-标注-Component注解" class="headerlink" title="2.1 标注@Component注解"></a>2.1 标注@Component注解</h3><p>上一章中咱注册 Bean 是使用 <code>&lt;bean&gt;</code> 标签的方式注册，这一章咱使用注解驱动，那就在两个 Service 类上标注 <code>@Component</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinanceService</span> </span>&#123; ... &#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-修改Logger切面类"><a href="#2-2-修改Logger切面类" class="headerlink" title="2.2 修改Logger切面类"></a>2.2 修改Logger切面类</h3><p>这次使用 AspectJ 注解配置，切面类上也得做改动了。</p><p>首先，在 Logger 上标注 <code>@Component</code> 注解，将其注册到 IOC 容器中。然后还得标注一个 <strong><code>@Aspect</code></strong> 注解，代表该类是一个切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>接下来，就是给这些方法标注通知注解了。小册先写一个，小伙伴们一下子就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(public * com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嚯，这也太简单了是吧！那前置通知叫 <code>@Before</code> ，那后置通知就是 <code>@After</code> 咯？当然啦，相应的，返回通知 <code>@AfterReturning</code> ，异常通知 <code>@AfterThrowing</code> ，环绕通知 <code>@Around</code> 。</p><p>这些编写思路都是一样的，所以咱可以简单的这样写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(public * com.linkedbear.spring.aop.b_aspectj.service.FinanceService.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@After(&quot;execution(* com.linkedbear.spring.aop.b_aspectj.service.*.*(String)))</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">    public void afterPrint() &#123;</span><br><span class="hljs-string">        System.out.println(&quot;</span>Logger afterPrint run ......<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    @AfterReturning(&quot;</span>execution(* com.linkedbear.spring.aop.b_aspectj.service.*.*(String)))<span class="hljs-string">&quot;)</span><br><span class="hljs-string">    public void afterReturningPrint() &#123;</span><br><span class="hljs-string">        System.out.println(&quot;</span>Logger afterReturningPrint run ......<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    @AfterThrowing(&quot;</span>execution(* com.linkedbear.spring.aop.b_aspectj.service.*.*(String)))<span class="hljs-string">&quot;)</span><br><span class="hljs-string">    public void afterThrowingPrint() &#123;</span><br><span class="hljs-string">        System.out.println(&quot;</span>Logger afterThrowingPrint run ......<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-编写配置类"><a href="#2-3-编写配置类" class="headerlink" title="2.3 编写配置类"></a>2.3 编写配置类</h3><p>配置类中，无需做任何多余的操作，只需要几个注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.linkedbear.spring.aop.b_aspectj&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectJAOPConfiguration</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里用了一个新的注解：**<code>@EnableAspectJAutoProxy</code>** ，是不是突然产生了一点亲切感（模块装配 + 条件装配）！用它可以开启基于 AspectJ 的自动代理，简言之，就是<strong>开启注解 AOP</strong> 。</p><p>如果要使用 xml 配置文件开启注解 AOP ，则需要添加一个 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 的标签声明（它等价于 <code>@EnableAspectJAutoProxy</code> 注解）。</p><h3 id="2-4-测试运行"><a href="#2-4-测试运行" class="headerlink" title="2.4 测试运行"></a>2.4 测试运行</h3><p>好啦，编写测试启动类的步骤已经很简单了吧，咱就不啰嗦了，直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationAspectJApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AspectJAOPConfiguration.class);<br>        FinanceService financeService = ctx.getBean(FinanceService.class);<br>        financeService.addMoney(<span class="hljs-number">123.45</span>);<br>        financeService.subtractMoney(<span class="hljs-number">543.21</span>);<br>        financeService.getMoneyById(<span class="hljs-string">&quot;abc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台打印出了 <code>Logger</code> 的前置 、后置 、返回通知：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 收钱 === <span class="hljs-number">123.45</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 付钱 === <span class="hljs-number">543.21</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 查询账户，id为abc<br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterReturningPrint run ......<br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterPrint run ......<br></code></pre></td></tr></table></figure><h2 id="3-环绕通知的编写"><a href="#3-环绕通知的编写" class="headerlink" title="3. 环绕通知的编写"></a>3. 环绕通知的编写</h2><p>除了前面提到的 4 种基本的通知类型之外，还有环绕通知没有说。环绕通知的编写其实在第 40 章回顾动态代理的时候就已经写过了，对，<code>InvocationHandler</code> 和 <code>MethodInterceptor</code>的编写本身就是环绕通知的体现。换做使用 AspectJ 的写法，又要如何来编写呢？咱也要来学习一下。</p><h3 id="3-1-添加新的环绕通知方法"><a href="#3-1-添加新的环绕通知方法" class="headerlink" title="3.1 添加新的环绕通知方法"></a>3.1 添加新的环绕通知方法</h3><p>在 <code>Logger</code> 类中，咱添加一个 <code>aroundPrint</code> 方法：（切入的方法就不覆盖那么多了，一个就好）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;execution(public * com.linkedbear.spring.aop.b_aspectj.service.FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aroundPrint</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>然后咱回想一下，<code>InvocationHandler</code> 的结构是什么来着？得有入参，里面有对应的方法、参数，还得有返回值 <code>Object</code> 。。。可是这里啥也没有呀，这咱怎么写呢？</p><p>所以我们要先学习一个通知方法中的特殊参数：<code>ProceedingJoinPoint</code> 。</p><p>在 <code>aroundPrint</code> 方法的参数中添加 <code>ProceedingJoinPoint</code> ，并把方法的返回值类型改为 <code>Object</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;execution(public * com.linkedbear.spring.aop.b_aspectj.service.FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">aroundPrint</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>然后来看，<code>ProceedingJoinPoint</code> 有一个 <code>proceed</code> 方法，执行了它，就相当于之前咱在动态代理中写的 <code>method.invoke(target, args);</code> 方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;execution(public * com.linkedbear.spring.aop.b_aspectj.service.FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">aroundPrint</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-keyword">return</span> joinPoint.proceed(); <span class="hljs-comment">// 此处会抛出Throwable异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后剩下的部分，咱就很熟悉了，快速的来编写一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(&quot;execution(public * com.linkedbear.spring.aop.b_aspectj.service.FinanceService.addMoney(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">aroundPrint</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger aroundPrint before run ......&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object retVal = joinPoint.proceed();<br>        System.out.println(<span class="hljs-string">&quot;Logger aroundPrint afterReturning run ......&quot;</span>);<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logger aroundPrint afterThrowing run ......&quot;</span>);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logger aroundPrint after run ......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仔细观看小册的这种写法，是不是刚刚好就是上面 4 种通知的结合呀！</p><h3 id="3-2-测试运行"><a href="#3-2-测试运行" class="headerlink" title="3.2 测试运行"></a>3.2 测试运行</h3><p>直接重新运行 <code>main</code> 方法，可以发现在控制台有同时打印环绕通知和前置通知：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Logger</span></span> aroundPrint before run ......<br><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 收钱 === <span class="hljs-number">123.45</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> aroundPrint afterReturning run ......<br><span class="hljs-function"><span class="hljs-title">Logger</span></span> aroundPrint after run ......<br></code></pre></td></tr></table></figure><p>由此也得出了一个小小的结论：<strong>同一个切面类中，环绕通知的执行时机比单个通知要早</strong>。</p><h2 id="4-切入点表达式的更多使用方法【掌握】"><a href="#4-切入点表达式的更多使用方法【掌握】" class="headerlink" title="4. 切入点表达式的更多使用方法【掌握】"></a>4. 切入点表达式的更多使用方法【掌握】</h2><p>上一章咱只是在切入点表达式的学习中接触了一些比较简单的写法和用法，这一章咱继续学习更多的使用方法。</p><h3 id="4-1-抽取通用切入点表达式"><a href="#4-1-抽取通用切入点表达式" class="headerlink" title="4.1 抽取通用切入点表达式"></a>4.1 抽取通用切入点表达式</h3><p>注意上面咱在 <code>Logger</code> 类中标注的切入点表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@After(&quot;execution(* com.linkedbear.spring.aop.b_aspectj.service.*.*(String)))</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">public void afterPrint() &#123;</span><br><span class="hljs-string">    System.out.println(&quot;</span>Logger afterPrint run ......<span class="hljs-string">&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">@AfterReturning(&quot;</span>execution(* com.linkedbear.spring.aop.b_aspectj.service.*.*(String)))<span class="hljs-string">&quot;)</span><br><span class="hljs-string">public void afterReturningPrint() &#123;</span><br><span class="hljs-string">    System.out.println(&quot;</span>Logger afterReturningPrint run ......<span class="hljs-string">&quot;);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>这两个切入点表达式是一样的，如果这种同样的切入点表达式一多起来，回头修改起来那岂不是太费劲了？Spring 当然也为我们考虑到这一点了，所以它分别就 xml 和注解的方式提供了抽取通用表达式的方案。</p><h4 id="4-1-1-AspectJ注解抽取"><a href="#4-1-1-AspectJ注解抽取" class="headerlink" title="4.1.1 AspectJ注解抽取"></a>4.1.1 AspectJ注解抽取</h4><p>在注解 AOP 切面中，定义通用的切入点表达式只需要声明一个空方法，并标注 <code>@Pointcut</code>注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.linkedbear.spring.aop.b_aspectj.service.*.*(String)))</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">public void defaultPointcut() &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>其它的通知要引用这个切入点表达式，只需要标注方法名即可，效果是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@After(&quot;defaultPointcut()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPrint</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger afterPrint run ......&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@AfterReturning(&quot;defaultPointcut()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturningPrint</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Logger afterReturningPrint run ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可能有的小伙伴注意到了，在引用通用切入点表达式的时候，IDEA 会有特殊的提示：<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbd3c9ef4dce4e24a7b62f308cb9434a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image" alt="img"></p><p>可见 IDEA 还是强大的呀。</p></blockquote><h4 id="4-1-2-xml抽取"><a href="#4-1-2-xml抽取" class="headerlink" title="4.1.2 xml抽取"></a>4.1.2 xml抽取</h4><p>相应的，在 xml 配置文件中，也有一个专门的标签来抽取，那就是 <code>aop:pointcut</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loggerAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logger&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;defaultPointcut&quot;</span> </span><br><span class="hljs-tag">                      <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(public * com.linkedbear.spring.aop.a_xmlaspect.service.*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterReturningPrint&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;defaultPointcut&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，要引用 xml 的切入点表达式，需要使用 <code>pointcut-ref</code> 而不是 <code>pointcut</code> 属性！</p><h3 id="4-2-annotation的使用"><a href="#4-2-annotation的使用" class="headerlink" title="4.2 @annotation的使用"></a>4.2 @annotation的使用</h3><p>除了 <code>execution</code> 之外，还有一种切入点表达式也比较常用：<code>@annotation()</code> 。</p><p>它的使用方式就非常简单了，只需要在括号中声明注解的全限定名即可。下面咱简单演示一下。</p><p>咱还是使用 <code>Logger</code> 作为切面类，这次咱声明一个 <code>@Log</code> 注解，用于标注要打印日志的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>然后，切入点表达式中只需要以下声明即可：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@annotation(com<span class="hljs-selector-class">.linkedbear</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.aop</span><span class="hljs-selector-class">.b_aspectj</span><span class="hljs-selector-class">.component</span>.Log)<br></code></pre></td></tr></table></figure><p>以此法声明的切入点表达式会<strong>搜索整个 IOC 容器中标注了 @Log 注解的所有 bean 全部增强</strong>。</p><p>咱把这个切入点表达式代替之前的</p><p>接下来咱就在 <code>FinanceService</code> 的 <code>subtractMoney</code> 方法中标注一个 <code>@Log</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(<span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;FinanceService 付钱 === &quot;</span> + money);<br>    <span class="hljs-keyword">return</span> money;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新运行 <code>main</code> 方法，发现只有 <code>subtractMoney</code> 方法有打印后置通知的日志了：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 收钱 === <span class="hljs-number">123.45</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 付钱 === <span class="hljs-number">543.21</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterPrint run ......      <span class="hljs-comment">// 此处打印了</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 查询账户，id为abc<br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterReturningPrint run ......<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>04-AOP基础-基于XML的AOP</title>
    <link href="/2022/04/16/04-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP/"/>
    <url>/2022/04/16/04-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP基础-基于xml的aspect实现AOP"><a href="#AOP基础-基于xml的aspect实现AOP" class="headerlink" title="AOP基础-基于xml的aspect实现AOP"></a>AOP基础-基于xml的aspect实现AOP</h1><p>为了接下来的演示更具有通用性，咱这里造一个 Service 层的接口，一个接口的实现类，一个普通的 Service 类，以及一个切面类 Logger ：</p><p><code>OrderService</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteOrderById</span><span class="hljs-params">(String id)</span></span>;<br>    <br>    <span class="hljs-function">String <span class="hljs-title">getOrderById</span><span class="hljs-params">(String id)</span></span>;<br>    <br>    <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>OrderServiceImpl</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;OrderServiceImpl 创建订单。。。&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteOrderById</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;OrderServiceImpl 删除订单，id为&quot;</span> + id);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrderById</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;OrderServiceImpl 查询订单，id为&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;OrderServiceImpl 查询所有订单。。。&quot;</span>);<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FinanceService</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinanceService</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addMoney</span><span class="hljs-params">(<span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;FinanceService 收钱 === &quot;</span> + money);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(<span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;FinanceService 付钱 === &quot;</span> + money);<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getMoneyById</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;FinanceService 查询账户，id为&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> Math.random();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Logger</code> 切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforePrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Logger beforePrint run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Logger afterPrint run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturningPrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Logger afterReturningPrint run ......&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowingPrint</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Logger afterThrowingPrint run ......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，有了这些，咱就可以开干了！</p><h2 id="1-基础环境"><a href="#1-基础环境" class="headerlink" title="1. 基础环境"></a>1. 基础环境</h2><h3 id="1-1-导入Maven坐标依赖"><a href="#1-1-导入Maven坐标依赖" class="headerlink" title="1.1 导入Maven坐标依赖"></a>1.1 导入Maven坐标依赖</h3><p>既然是学习 SpringFramework 的 AOP ，那自然就要引入 Spring 的 AOP 模块对应的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，这里导入 aop 的依赖之后，借助 IDEA 的 Maven 窗口，可以发现 <code>spring-aop</code> 模块其实已经被 <code>spring-context</code> 模块依赖了：</p><p><img src="/2022/04/16/04-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP/9fe20aba68ef4a28b54902288b258fe5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.image.png" alt="img"></p><p>所以导不导 aop 的模块，当前工程中早就已经有 <code>spring-aop</code> 这个 jar 包的依赖啦。</p><h3 id="1-2-编写配置文件"><a href="#1-2-编写配置文件" class="headerlink" title="1.2 编写配置文件"></a>1.2 编写配置文件</h3><p>既然是基于 xml 配置文件的，那咱先把配置文件搞定。</p><p>在工程的 <code>resources</code> 目录下新建一个 <code>xmlaspect.xml</code> 文件，并首先把上面提到的几个类都注册进 IOC 容器中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;financeService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.aop.a_xmlaspect.service.impl.OrderServiceImpl&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logger&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.aop.a_xmlaspect.component.Logger&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-测试运行"><a href="#1-3-测试运行" class="headerlink" title="1.3 测试运行"></a>1.3 测试运行</h3><p>先不干任何多余的事情，直接编写启动类，驱动 IOC 容器并取出 <code>FinanceService</code> ，调用它的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlAspectApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;aop/xmlaspect.xml&quot;</span>);<br>        FinanceService financeService = ctx.getBean(FinanceService.class);<br>        financeService.addMoney(<span class="hljs-number">123.45</span>);<br>        System.out.println(financeService.getMoneyById(<span class="hljs-string">&quot;abc&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台打印原生的对象输出的结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FinanceService</span> 收钱 === <span class="hljs-number">123</span>.<span class="hljs-number">45</span><br><span class="hljs-attribute">FinanceService</span> 查询账户，id为abc<br><span class="hljs-attribute">0</span>.<span class="hljs-number">08681906193896294</span><br></code></pre></td></tr></table></figure><p>至此，这些都是在前面 IOC 的基础内容了，接下来才是正儿八经的基于 xml 的 AOP 。</p><h2 id="2-基于xml的AOP实现【掌握】"><a href="#2-基于xml的AOP实现【掌握】" class="headerlink" title="2. 基于xml的AOP实现【掌握】"></a>2. 基于xml的AOP实现【掌握】</h2><p>要配置 xml 的 AOP ，需要几个步骤，咱一步一步来。</p><h3 id="2-1-导入命名空间"><a href="#2-1-导入命名空间" class="headerlink" title="2.1 导入命名空间"></a>2.1 导入命名空间</h3><p>要编写 AOP 的配置，需要在 xml 上导入命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/beans/spring-beans.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">                           http://www.springframework.org/schema/aop </span></span><br><span class="hljs-tag"><span class="hljs-string">                           https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果小伙伴使用 IDEA 的话，该步骤可以跳过，IDEA 会帮我们加的。</p></blockquote><p>然后，在配置文件中按提示键，会发现多了 3 个 aop 开头的标签：</p><p><img src="/2022/04/16/04-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png" alt="img"></p><h3 id="2-2-编写aop配置"><a href="#2-2-编写aop配置" class="headerlink" title="2.2 编写aop配置"></a>2.2 编写aop配置</h3><p>接下来就要利用上面的这三个标签中的 <code>&lt;aop:config&gt;</code> 来配置 AOP 了。这个配置也比较简单，就两步。第一步要先声明一个切面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logger&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.aop.a_xmlaspect.component.Logger&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loggerAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logger&quot;</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一个 <strong>aspect</strong> 就是一个切面，<code>id</code> 随便起，只要是全局唯一即可；<code>ref</code> 跟 IOC 部分提到的 <code>ref</code> 一样，都是引用容器中的某个 bean ，这里咱要使用 <code>Logger</code> 作为切面类，所以 <code>ref</code>就引用 <code>logger</code> 这个 bean 。</p><p>接下来，咱要配置一下通知类型。上一章咱说过了 Spring 一共有 5 种通知类型，这里咱先配置一个前置通知：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logger&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.aop.a_xmlaspect.component.Logger&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loggerAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logger&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;beforePrint&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;??????&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有了通知（Advice）方法 <code>method</code> 了，切入点怎么搞定呢？哎，这里咱要学习一个新的知识点：<strong>切入点表达式</strong>。</p><h3 id="2-3-切入点表达式入门"><a href="#2-3-切入点表达式入门" class="headerlink" title="2.3 切入点表达式入门"></a>2.3 切入点表达式入门</h3><p>最开始学习切入点表达式，咱先介绍最最常用的一种写法，而且这种写法刚好对标的就是 AOP 术语中的<strong>切入点</strong>。</p><p>这样，小册先写一个，小伙伴们先瞅瞅这都什么含义：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">execution</span>(<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.addMoney(<span class="hljs-keyword">double</span>))<br></code></pre></td></tr></table></figure><p>是不是貌似还有点门道呢？下面咱来解释这个表达式的含义：</p><ul><li><strong>execution</strong>：以此法编写的切入点表达式，将<strong>使用方法定位的模式匹配连接点</strong>。说白了，用 execution 写出来的表达式，都是直接声明到类中的方法。</li><li><strong>public</strong> ：限定只切入 public 类型的方法</li><li><strong>void</strong> ：限定只切入返回值类型为 void 的方法</li><li><code>com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService</code> ：限定只切入 <code>FinanceService</code> 这个类的方法</li><li><strong>addMoney</strong> ：限定只切入方法名为 <code>addMoney</code> 的方法</li><li><strong>(double)</strong> ：限定只切入方法的参数列表为一个参数，且类型为 <code>double</code> 的方法</li></ul><p>所以，用这个表达式，就可以直接锁定到上面 <code>FinanceService</code> 的 <code>addMoney</code> 方法。</p><h3 id="2-4-应用切入点表达式"><a href="#2-4-应用切入点表达式" class="headerlink" title="2.4 应用切入点表达式"></a>2.4 应用切入点表达式</h3><p>接下来咱把上面写好的切入点表达式填到 <code>pointcut</code> 里：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;logger&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.linkedbear.spring.aop.a_xmlaspect.component.Logger&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loggerAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logger&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;beforePrint&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(public void com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.addMoney(double))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>写完之后，使用 IDEA 的小伙伴会发现在 <code>aop:before</code> 的左边多了一个标识：</p><p><img src="/2022/04/16/04-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP/%E5%88%87%E5%85%A5%E7%82%B9.png" alt="img"></p><p>点过去，会立马跳转到 <code>FinanceService</code> 的类中，并且 <code>addMoney</code> 方法的左边也有一个标识：</p><p><img src="/2022/04/16/04-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP/%E5%88%87%E5%85%A5%E7%82%B902.png" alt="img"></p><p>这说明 IDEA 也知道这个切入点表达式的作用范围了。所以接下来咱即便不运行代码，光看这个标识也能知道切入点表达式的作用范围了。</p></blockquote><h3 id="2-5-测试运行"><a href="#2-5-测试运行" class="headerlink" title="2.5 测试运行"></a>2.5 测试运行</h3><p>编写测试启动类，使用 xml 配置文件驱动 IOC 容器，并从 IOC 容器中取出 <code>FinanceService</code>，分别执行它的三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlAspectApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;aop/xmlaspect.xml&quot;</span>);<br>        FinanceService financeService = ctx.getBean(FinanceService.class);<br>        financeService.addMoney(<span class="hljs-number">123.45</span>);<br>        financeService.subtractMoney(<span class="hljs-number">543.21</span>);<br>        financeService.getMoneyById(<span class="hljs-string">&quot;abc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台打印了 <code>Logger</code> 的前置通知方法 <code>beforePrint</code> ：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Logger</span> beforePrint run ......<br><span class="hljs-attribute">FinanceService</span> 收钱 === <span class="hljs-number">123</span>.<span class="hljs-number">45</span><br><span class="hljs-attribute">FinanceService</span> 付钱 === <span class="hljs-number">543</span>.<span class="hljs-number">21</span><br><span class="hljs-attribute">FinanceService</span> 查询账户，id为abc<br></code></pre></td></tr></table></figure><p>确实，上面编写的切入点表达式已经生效了，AOP 的效果得以体现。</p><h2 id="3-切入点表达式的多种写法【掌握】"><a href="#3-切入点表达式的多种写法【掌握】" class="headerlink" title="3. 切入点表达式的多种写法【掌握】"></a>3. 切入点表达式的多种写法【掌握】</h2><p>咱继续讲解切入点表达式的编写方式哈。切入点表达式的写法比较多，咱先掌握 <strong>execution</strong> 风格写法，后面再学习更多的风格。</p><h3 id="3-1-基本通配符"><a href="#3-1-基本通配符" class="headerlink" title="3.1 基本通配符"></a>3.1 基本通配符</h3><p>把上面的切入点表达式改一下，看看小伙伴们是否能猜得到它的含义：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">execution</span>(<span class="hljs-keyword">public</span> * com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.*(<span class="hljs-keyword">double</span>))<br></code></pre></td></tr></table></figure><p>还是很好猜的吧！这里有两个地方替换成了<strong>通配符</strong> * ，咱解释一下它的含义：</p><ul><li><strong>void</strong> 的位置替换为 * ，代表不限制返回值类型，是什么都可以</li><li><code>FinanceService.*(double)</code> 这里面的方法值替换为 * ，代表不限制方法名，什么方法都可以切入</li></ul><p>所以，这样被切入的方法就变多了，除了 <code>addMoney</code> 方法之外，<code>subtractMoney</code> 也应该被切入了。</p><p>是不是这样呢，咱可以继续配置一个方法来检验一下。在 <code>aop:config</code> 中，继续添加后置通知：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loggerAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logger&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;beforePrint&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(public void com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.addMoney(double))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterPrint&quot;</span></span><br><span class="hljs-tag">                   <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(public * com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.*(double))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其它的不需要任何改动，直接运行 <code>main</code> 方法，控制台会打印两次 <code>afterPrint</code> 方法，分别是 <code>addMoney</code> 与 <code>subtractMoney</code> 方法的调用，证明确实切到了两个方法。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 收钱 === <span class="hljs-number">123.45</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterPrint run ......<br>FinanceService 付钱 === <span class="hljs-number">543.21</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterPrint run ......<br>FinanceService 查询账户，id为abc<br></code></pre></td></tr></table></figure><p>注意：这个方法参数中，对于基本数据类型，直接声明即可；<strong>引用数据类型则要写类的全限定名</strong>！</p><h3 id="3-2-方法通配符"><a href="#3-2-方法通配符" class="headerlink" title="3.2 方法通配符"></a>3.2 方法通配符</h3><p>继续修改上面的切入点表达式：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">execution(<span class="hljs-name">public</span> * com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.*(<span class="hljs-name">*</span>))<br></code></pre></td></tr></table></figure><p>这次的参数列表中标注了一个 * ，它代表方法的参数列表中<strong>必须有一个参数</strong>，至于类型那无所谓。</p><p>将 <code>aop:after</code> 的切入点表达式换为上面的写法，重新运行 <code>main</code> 方法，会发现 <code>getMoneyById</code> 方法也生效了：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Logger</span></span> beforePrint run ......<br>FinanceService 收钱 === <span class="hljs-number">123.45</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterPrint run ......<br>FinanceService 付钱 === <span class="hljs-number">543.21</span><br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterPrint run ......<br>FinanceService 查询账户，id为abc<br><span class="hljs-function"><span class="hljs-title">Logger</span></span> afterPrint run ......<br></code></pre></td></tr></table></figure><h3 id="3-3-类名通配符"><a href="#3-3-类名通配符" class="headerlink" title="3.3 类名通配符"></a>3.3 类名通配符</h3><p>咱继续变化切入点表达式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(public * com.linkedbear.spring.aop.a_xmlaspect.service.*.*(*)</span></span>)<br></code></pre></td></tr></table></figure><p>这次连类名都任意了，所以这下 <code>OrderService</code> 接口也会被切入了。</p><p>咱继续编写一个 <code>aop:after-returning</code> 的通知：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loggerAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;logger&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;beforePrint&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(public void com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.addMoney(double))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterPrint&quot;</span></span><br><span class="hljs-tag">                   <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(public * com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterReturningPrint&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(public * com.linkedbear.spring.aop.a_xmlaspect.service.*.*(..))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后咱点击 <code>aop:after-returning</code> 标签左边的通知标识，发现 <code>OrderService</code> 的实现类也被切入了！</p><p><img src="/2022/04/16/04-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP/img01.png" alt="img"></p><p>所以我们又得知一个关键点：<strong>如果切入点表达式覆盖到了接口，那么如果这个接口有实现类，则实现类上的接口方法也会被切入增强</strong>。</p><h3 id="3-3-方法任意通配"><a href="#3-3-方法任意通配" class="headerlink" title="3.3 方法任意通配"></a>3.3 方法任意通配</h3><p>如果我们重载一个 <code>subtractMoney</code> 方法，在方法的参数列表加上一个 <code>id</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(<span class="hljs-keyword">double</span> money, String id)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;FinanceService 付钱 === &quot;</span> + money);<br>    <span class="hljs-keyword">return</span> money;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意写完这个方法后，IDEA 的左边并没有切入点的影响：</p><p><img src="/2022/04/16/04-AOP%E5%9F%BA%E7%A1%80-%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP/img02.png" alt="img"></p><p>说明 (*) 并不能切入两个参数的方法。那如果我想无论方法参数有几个，甚至没有参数，我都想切入，那该怎么写呢？</p><p>答案是换用 <strong>..</strong> ，就像这样：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">execution(<span class="hljs-name">public</span> * com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.*(..))<br></code></pre></td></tr></table></figure><p>这样写完再切到 <code>FinanceService</code> 的类中，就发现所有方法都被切入了。</p><h3 id="3-4-包名通配符"><a href="#3-4-包名通配符" class="headerlink" title="3.4 包名通配符"></a>3.4 包名通配符</h3><p>与类名、方法名的通配符一样，一个 * 代表一个目录，比如下面的这个切入点表达式：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">execution(<span class="hljs-name">public</span> * com.linkedbear.spring.aop.a_xmlaspect.*.*.*(..))<br></code></pre></td></tr></table></figure><p>它代表的是切入 <code>com.linkedbear.spring.aop.a_xmlaspect</code> 包下的一级包下的任意类的任意方法（好绕。。。）。</p><p>注入 <code>com.linkedbear.spring.aop.a_xmlaspect.controller</code>、<code>com.linkedbear.spring.aop.a_xmlaspect.service</code>、<code>com.linkedbear.spring.aop.a_xmlaspect.dao</code> 等包下的所有类，都会被切到。</p><p>如果要切多级包怎么办呢？总不能一个 * 接着一个 * 写吧！所以方法参数列表中的 .. 在这里也能用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(public * com.linkedbear.spring..*.*(..)</span></span>)<br></code></pre></td></tr></table></figure><p>这个切入点表达式就代表 <code>com.linkedbear.spring</code> 包下的所有类的所有方法都会被切入。</p><p>最后多说一嘴，public 这个访问修饰符可以直接省略不写，代表切入所有访问修饰符的方法，那就相当于变成了这样：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">execution(<span class="hljs-name">*</span> com.linkedbear.spring..*.*(..))<br></code></pre></td></tr></table></figure><h3 id="3-5-抛出异常的切入"><a href="#3-5-抛出异常的切入" class="headerlink" title="3.5 抛出异常的切入"></a>3.5 抛出异常的切入</h3><p>最后说下抛出异常的切入，对于某些显式声明了会抛出异常的方法，可以使用异常通知来切入这部分方法。</p><p>例如咱给 <code>subtractMoney</code> 方法添加一个 <code>Exception</code> 的抛出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(<span class="hljs-keyword">double</span> money, String id)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;FinanceService 付钱 === &quot;</span> + money);<br>    <span class="hljs-keyword">return</span> money;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，在切入方法时，可以在类名方法名后面加上 throws 的异常类型即可：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(public * com.linkedbear.spring.aop.a_xmlaspect.service.FinanceService.*(..)</span></span> throws java<span class="hljs-selector-class">.lang</span>.Exception)<br></code></pre></td></tr></table></figure><p>好了，到这里基本上 execution 风格的切入点表达式写法就差不多了，小伙伴们多多练习几个写法，并配合着 IDE 和测试代码，一定要掌握呀。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03-AOP基础-概述和术语</title>
    <link href="/2022/04/16/03-AOP%E5%9F%BA%E7%A1%80-%E6%A6%82%E8%BF%B0%E5%92%8C%E6%9C%AF%E8%AF%AD/"/>
    <url>/2022/04/16/03-AOP%E5%9F%BA%E7%A1%80-%E6%A6%82%E8%BF%B0%E5%92%8C%E6%9C%AF%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP基础-AOP概述与术语"><a href="#AOP基础-AOP概述与术语" class="headerlink" title="AOP基础-AOP概述与术语"></a>AOP基础-AOP概述与术语</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 SpringFramework 的官方文档中，有专门的一章来介绍 Spring 的 AOP ：</p><p><a href="https://link.juejin.cn/?target=https://docs.spring.io/spring-framework/docs/5.2.x/spring-framework-reference/core.html%23aop">docs.spring.io/spring-fram…</a></p><blockquote><p>Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by providing another way of thinking about program structure. The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects enable the modularization of concerns (such as transaction management) that cut across multiple types and objects. (Such concerns are often termed “crosscutting” concerns in AOP literature.)</p><p>One of the key components of Spring is the AOP framework. While the Spring IoC container does not depend on AOP (meaning you do not need to use AOP if you don’t want to), AOP complements Spring IoC to provide a very capable middleware solution.</p></blockquote><p>面向切面编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象编程（OOP）。</p><p>AOP 面向切面编程，全称 Aspect Oriented Programming ，它是 OOP 的补充。OOP 关注的核心是对象，AOP 的核心是切面（Aspect）。</p><p>AOP 可以在不修改功能代码本身的前提下，使用运行时动态代理的技术对已有代码逻辑增强。</p><p>AOP 可以实现组件化、可插拔式的功能扩展，通过简单配置即可将功能增强到指定的切入点。</p><p>切面使关注点（如事务管理）的模块化可以跨越多种类型和对象（这种关注在 AOP 的文献中通常被称为 “跨领域” 关注）。</p><p>AOP 是 Spring 框架的关键组件之一。</p><p>尽管 Spring IoC 容器不依赖于 AOP（这意味着您不需要的话就不需要使用 AOP ），但 AOP 是对 Spring IoC 的补充，以提供功能强大的中间件解决方案。</p><hr><p>总结下来，AOP 要完成的核心工作还是一个：<strong>解耦</strong>。</p><p>AOP 将分散在各个类中方法的重复逻辑抽取为一个切面，并在运行时生成代理对象，将这些重复逻辑组合进原有的对象，这其实就是完成了原有业务与扩展逻辑之间的解耦。</p><p>通过这种解耦，最大的好处也就显而易见了：<strong>业务逻辑只需要关注业务逻辑，每个扩展逻辑也都只关心自己的逻辑，以及切入业务逻辑的位置即可</strong>。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="Target：目标对象"><a href="#Target：目标对象" class="headerlink" title="Target：目标对象"></a>Target：目标对象</h3><p>这个应该是最好理解的了，目标对象就是<strong>被代理的对象</strong>。</p><p>反映到前面的动态代理的例子中，这个 <code>partner</code> 就可以称作 <strong>Target</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Partner <span class="hljs-title">getPartner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>    <span class="hljs-comment">// partner即为目标对象</span><br>    Partner partner = partners.remove(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> (Partner) Proxy.newProxyInstance(......);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Proxy：代理对象"><a href="#Proxy：代理对象" class="headerlink" title="Proxy：代理对象"></a>Proxy：代理对象</h3><p>也是很好理解吧，代理对象就是上面代码中 <code>Proxy.newProxyInstance</code> 返回的结果。</p><h3 id="JoinPoint：连接点"><a href="#JoinPoint：连接点" class="headerlink" title="JoinPoint：连接点"></a>JoinPoint：连接点</h3><p>所谓连接点，可以简单的理解为<strong>目标对象的所属类中，定义的所有方法</strong>。由于 SpringFramework 支持的连接点只有方法，所以我们这样理解就没错。</p><p>反映到前面动态代理的例子中，**<code>Partner</code> 接口中的两个方法就叫连接点**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Partner</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiveMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">playWith</span><span class="hljs-params">(Player player)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Pointcut：切入点"><a href="#Pointcut：切入点" class="headerlink" title="Pointcut：切入点"></a>Pointcut：切入点</h3><p>切入点，它的含义是<strong>那些被拦截 / 被增强的连接点</strong>。可以这样去理解：<strong>代理层会选择目标对象的一部分连接点作为切入点，在目标对象的方法执行前 / 后作出额外的动作</strong>。</p><p>所以，由这个解释，是不是就比较容易理解了？切入点与连接点的关系应该是包含关系：<strong>切入点就是连接点的子集</strong>。注意，<strong>切入点一定是连接点，连接点不一定是切入点</strong>。</p><h3 id="Advice：通知"><a href="#Advice：通知" class="headerlink" title="Advice：通知"></a>Advice：通知</h3><p><strong>Advice</strong> 直接翻译过来叫<strong>通知</strong>，但这个概念似乎很抽象，所以我打算换一个词：<strong>增强的逻辑</strong>，也就是<strong>增强的代码</strong>。</p><p>由此可以得出一个这样的结论：<strong>Proxy 代理对象 = Target 目标对象 + Advice 通知</strong>。</p><p>所以是不是突然意识到一个问题，<strong>切入点和通知是要配合在一起使用的</strong>，有了切入点之后，需要搭配上增强的逻辑，才能算是给目标对象进行了代理、增强。</p><p>在 SpringFramework 的官方文档 AOP 术语的介绍之后，紧跟着就说了 Spring 中定义的通知的类型。SpringFramework 中支持的通知的类型包含 5 种，这些通知的类型是基于 <strong>AspectJ</strong>的先简单看一下：</p><ul><li><p><strong>Before 前置通知</strong>：目标对象的方法调用之前触发</p></li><li><p><strong>After 后置通知</strong>：目标对象的方法调用之后触发</p></li><li><p><strong>AfterReturning 返回通知</strong>：目标对象的方法调用完成，在返回结果值之后触发</p></li><li><p>AfterThrowing 异常通知</p><p>：目标对象的方法运行中抛出 / 触发异常后触发</p><ul><li>注意一点，<strong>AfterReturning 与 AfterThrowing 两者是互斥的</strong>！如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li></ul></li><li><p><strong>Around 环绕通知</strong>：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法。</p></li></ul><p>这几种通知的体现，目前我们只编写过环绕通知，而这些环绕通知，其实就是 <code>InvocationHandler</code> 或 <code>MethodInterceptor</code> 的匿名内部类：</p><p><img src="/2022/04/16/03-AOP%E5%9F%BA%E7%A1%80-%E6%A6%82%E8%BF%B0%E5%92%8C%E6%9C%AF%E8%AF%AD/image-20220416155839122.png" alt="image-20220416155839122"></p><p>在之前写的代码中，<code>method.invoke</code> 方法很明显是对目标方法的调用，而这之前和之后的代码，加到一起，就是环绕通知的内容。</p><h3 id="Aspect：切面"><a href="#Aspect：切面" class="headerlink" title="Aspect：切面"></a>Aspect：切面</h3><p>紧接着我们说切面，<strong>Aspect 切面 = PointCut 切入点 + Advice 通知</strong>，就这么简单。</p><p>前面我们写的 <code>InvocationHandler</code> 的匿名内部类也好，<code>MethodInterceptor</code> 的匿名内部类也好，这些都可以看作是<strong>切面</strong>。</p><blockquote><p>不过实际上切面不仅仅是包含通知，还有一个不常见的部分是引介，马上就说到了。</p></blockquote><h3 id="Weaving：织入"><a href="#Weaving：织入" class="headerlink" title="Weaving：织入"></a>Weaving：织入</h3><p>从名字上听起来，它有点像一个<strong>动作</strong>，而且我们先瞎猜一手，也能猜个八九不离十：<strong>织入就是将 Advice 通知应用到 Target 目标对象，进而生成 Proxy 代理对象的过程</strong>。</p><p><strong>Proxy 代理对象 = Target 目标对象 + Advice 通知</strong>，这个算式中的<strong>加号</strong>，就是<strong>织入</strong>。试想，目标对象和通知都有了，得需要一个动作将它们两个绑定到一起，就好比上面的场景中，主管找到这个在外招呼客人的经理后，也是要签了合同或者协议，经理才开始干活的呀。</p><p>所以，这个织入的动作，就比较容易理解了吧。</p><h3 id="Introduction：引介"><a href="#Introduction：引介" class="headerlink" title="Introduction：引介"></a>Introduction：引介</h3><p>引介 / 引入，这个概念对标的是<strong>通知</strong>，通知是针对切入点提供增强的逻辑，而<strong>引介</strong>是针对 Class 类，它<strong>可以在不修改原有类的代码的前提下，在运行期为原始类动态添加新的属性 / 方法</strong>。</p><p>这个引介吧，在目前的企业应用、场景中很少出现了，所以咱对它的重视程度一定要放低，当然感兴趣的话学习一下也是可以的，咱后面 AOP 高级部分会讲解到的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02-AOP基础-原生动态代理和Cglib动态代理</title>
    <link href="/2022/04/16/02-AOP%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%94%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2022/04/16/02-AOP%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%94%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP基础-原生动态代理与Cglib动态代理回顾"><a href="#AOP基础-原生动态代理与Cglib动态代理回顾" class="headerlink" title="AOP基础-原生动态代理与Cglib动态代理回顾"></a>AOP基础-原生动态代理与Cglib动态代理回顾</h1><p>关于动态代理，网络上有无数多的例子和场景，小册这里选用 【游戏陪玩】 的故事来演绎动态代理。</p><p>应该是 2017 年左右吧，网络上涌上了一批游戏陪玩的平台和服务，游戏玩家可以通过在平台上付费邀请 “小姐姐” 来一起组队玩游戏。</p><p>这种游戏陪玩平台的兴起，既满足了部门游戏玩家不能找到一起组排的队友的问题，也为一些游戏玩的不错 / 声音气质等很讨喜的玩家提供了收入的渠道。</p><p>本章咱要演绎的场景，是一个普通玩家寻找陪玩的过程。</p><p>首先我们要先有一名普通玩家：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个设计相当简单了，只有一个 name 作为标识就好啦。</p><p>然后要有一名游戏陪练，按照最简单的操作来看，陪玩应该有两个行为：<strong>收钱</strong>、<strong>陪玩</strong>。那我们就可以在 Partner 中定义这两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Partner</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 收钱</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;收到佣金：&quot;</span> + money + <span class="hljs-string">&quot;元 ~ &quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 陪玩</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> player</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playWith</span><span class="hljs-params">(Player player)</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;与&quot;</span> + player.getName() + <span class="hljs-string">&quot;一起愉快地玩耍 ~ &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就来演示真实场景了：假设有一个游戏玩家，名为 “郝武辽” ，他去找一个名为 “肖洁洁” 的陪玩陪他一起玩游戏。对应的代码就可以这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Player player = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">&quot;郝武辽&quot;</span>);<br>        Partner partner = <span class="hljs-keyword">new</span> Partner(<span class="hljs-string">&quot;肖洁洁&quot;</span>);<br>        <br>        partner.receiveMoney(<span class="hljs-number">200</span>);<br>        partner.playWith(player);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仔细观察一下上面的代码，先思考一个问题：这个 郝武辽 是怎么找到的 肖洁洁 呢？</p><p>很明显，是在 <code>Client</code> 的 <code>main</code> 方法中，由 <code>main</code> 方法把他们俩搞到一起的吧，那如果不看 <code>Client</code> 的话，那就可以理解为，<strong>郝武辽 直接去 肖洁洁 的家里找的她，然后让她陪她一起玩游戏</strong>。</p><p>但现实情况中，通常都是玩家去陪玩的平台上找陪玩，下面我们就来搞一个陪玩平台。</p><h2 id="原生动态代理"><a href="#原生动态代理" class="headerlink" title="原生动态代理"></a>原生动态代理</h2><p>陪玩平台中入驻了一些陪玩的选手，这里咱可以使用静态代码块来初始化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PartnerPlatform</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Partner&gt; partners = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        partners.add(<span class="hljs-keyword">new</span> Partner(<span class="hljs-string">&quot;肖洁洁&quot;</span>));<br>        partners.add(<span class="hljs-keyword">new</span> Partner(<span class="hljs-string">&quot;田苟&quot;</span>));<br>        partners.add(<span class="hljs-keyword">new</span> Partner(<span class="hljs-string">&quot;高总裁&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，陪玩平台要根据玩家的预算，推荐合适的陪玩。不过这里我们就不给 陪玩 的模型添加单价的设计了，只是做一下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Partner <span class="hljs-title">getPartner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>  Partner partner = partners.remove(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> partner;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在这里定义一个陪玩平台的额外规则：<strong>如果一开始指定预算后，但付费时没给够，则这个陪玩直接 “装死” 不干了</strong>。于是我们可以这样设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Partner <span class="hljs-title">getPartner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>    Partner partner = partners.remove(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> (Partner) Proxy.newProxyInstance(partner.getClass().getClassLoader(), partner.getClass().getInterfaces(), ......);<br>&#125;<br></code></pre></td></tr></table></figure><p>呃。。。等一下，<code>Partner</code> 还没有接口呢，所以我们需要给 <code>Partner</code> 抽取一个接口出来了。</p><p>新建一个包吧，在这个包中声明 <code>Partner</code> 的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Partner</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiveMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">playWith</span><span class="hljs-params">(Player player)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以及 <code>Partner</code> 的实现类 <code>IndividualPartner</code> ，代表个人陪玩：（个人的意思是区别于平台）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndividualPartner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Partner</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IndividualPartner</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;收到佣金：&quot;</span> + money + <span class="hljs-string">&quot;元 ~ &quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playWith</span><span class="hljs-params">(Player player)</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;与&quot;</span> + player.getName() + <span class="hljs-string">&quot;一起愉快地玩耍 ~ &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 <code>PartnerPlatform</code> 中修改静态代码块的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    partners.add(<span class="hljs-keyword">new</span> IndividualPartner(<span class="hljs-string">&quot;肖洁洁&quot;</span>));<br>    partners.add(<span class="hljs-keyword">new</span> IndividualPartner(<span class="hljs-string">&quot;田苟&quot;</span>));<br>    partners.add(<span class="hljs-keyword">new</span> IndividualPartner(<span class="hljs-string">&quot;高总裁&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就算抽取接口完成了。</p><p>抽取完接口后，就可以完成 <code>getPartner</code> 的逻辑编写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Partner <span class="hljs-title">getPartner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>    Partner partner = partners.remove(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> (Partner) Proxy.newProxyInstance(partner.getClass().getClassLoader(), partner.getClass().getInterfaces(),<br>            <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>                <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> budget = money;<br>                <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> status = <span class="hljs-keyword">false</span>;<br>                <br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;receiveMoney&quot;</span>)) &#123;<br>                        <span class="hljs-keyword">int</span> money = (<span class="hljs-keyword">int</span>) args[<span class="hljs-number">0</span>];<br>                        <span class="hljs-comment">// 平台需要运营，抽成一半</span><br>                        args[<span class="hljs-number">0</span>] = money / <span class="hljs-number">2</span>;<br>                        <span class="hljs-comment">// 如果在付钱时没给够，则标记budget为异常值</span><br>                        <span class="hljs-keyword">this</span>.status = money &gt;= budget;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (status) &#123;<br>                        <span class="hljs-keyword">return</span> method.invoke(partner, args);<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Client</code> 的测试代码中，只需要把 <code>Partner</code> 的获取动作由手动构造改为 <code>PartnerPlatform</code>获取，其余的代码均不需要变动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Player player = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">&quot;郝武辽&quot;</span>);<br>        Partner partner = PartnerPlatform.getPartner(<span class="hljs-number">50</span>);<br>    <br>        partner.receiveMoney(<span class="hljs-number">20</span>);<br>        partner.playWith(player);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一开始我们先不给足钱，运行 <code>main</code> 方法，发现控制台没有任何输出。。。</p><p>然后，将 20 改成 200 ，发现控制台可以打印输出了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">肖洁洁收到佣金：<span class="hljs-number">100</span>元 ~ <br>肖洁洁与郝武辽一起愉快地玩耍 ~ <br></code></pre></td></tr></table></figure><h3 id="jdk动态代理的核心API"><a href="#jdk动态代理的核心API" class="headerlink" title="jdk动态代理的核心API"></a>jdk动态代理的核心API</h3><p>jdk 的动态代理，要求被代理的对象所属类必须实现一个以上的接口，代理对象的创建使用 <code>Proxy.newProxyInstance</code> 方法，该方法中有三个参数：</p><ul><li><code>ClassLoader loader</code> ：被代理的对象所属类的类加载器</li><li><code>Class&lt;?&gt;[] interfaces</code> ：被代理的对象所属类实现的接口</li><li><code>InvocationHandler h</code> ：代理的具体代码实现</li></ul><p>在这三个参数中，前面两个都容易理解，最后一个 <code>InvocationHandler</code> 是一个接口，它的核心方法 <code>invoke</code> 中也有三个参数，一一来看：</p><ul><li><code>Object proxy</code> ：代理对象的引用（代理后的）</li><li><code>Method method</code> ：代理对象执行的方法</li><li><code>Object[] args</code> ：代理对象执行方法的参数列表</li></ul><p>具体的代理逻辑就在 <code>InvocationHandler</code> 的 <code>invoke</code> 方法中编写。</p><h2 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h2><p>前面场景都演绎完了，唯一一个让我们可能不爽的就是这个接口的抽取，不过还好 Cglib 可以直接使用字节码增强的技术，同样实现动态代理。下面我们也来回顾一下。</p><p>要使用 Cglib ，必须先引入 Cglib 的 jar 包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先，给原来的 <code>Partner</code> 添加一个无参构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Partner</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，修改 <code>PartnerPlatform</code> 获取 <code>Partner</code> 的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Partner <span class="hljs-title">getPartner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>    Partner partner = partners.remove(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 使用Cglib的Enhancer创建代理对象</span><br>    <span class="hljs-keyword">return</span> (Partner) Enhancer.create(partner.getClass(), <span class="hljs-keyword">new</span> MethodInterceptor() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> budget = money;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> status = <span class="hljs-keyword">false</span>;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span></span><br><span class="hljs-function">                <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            <span class="hljs-comment">// 如果在付钱时没给够，则标记budget为异常值</span><br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;receiveMoney&quot;</span>)) &#123;<br>                <span class="hljs-keyword">int</span> money = (<span class="hljs-keyword">int</span>) args[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">this</span>.status = money &gt;= budget;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (status) &#123;<br>                <span class="hljs-keyword">return</span> method.invoke(partner, args);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，在 <code>Client</code> 中修改获取代理的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Player player = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">&quot;郝武辽&quot;</span>);<br>        <span class="hljs-comment">// 此处的Partner是a_basic包下的，不是接口 是类</span><br>        Partner partner = PartnerPlatform.getPartner(<span class="hljs-number">50</span>);<br>        <br>        partner.receiveMoney(<span class="hljs-number">20</span>);<br>        partner.playWith(player);<br>        <br>        partner.receiveMoney(<span class="hljs-number">200</span>);<br>        partner.playWith(player);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>main</code> 方法，控制台只会打印拿到 200 之后的玩耍，证明已经成功构造了代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">肖洁洁收到佣金：200元 ~ <br>肖洁洁与郝武辽一起愉快地玩耍 ~ <br></code></pre></td></tr></table></figure><h3 id="Cglib动态代理的核心API"><a href="#Cglib动态代理的核心API" class="headerlink" title="Cglib动态代理的核心API"></a>Cglib动态代理的核心API</h3><p>同 jdk 动态代理相似，Cglib 动态代理的内容相对较少，它只需要传入两个东西：</p><ul><li><code>Class type</code> ：被代理的 </li><li><code>Callback callback</code> ：增强的代码实现</li></ul><p>由于一般情况下我们都是对类中的方法增强，所以在传入 <code>Callback</code> 时通常选择这个接口的子接口 <code>MethodInterceptor</code> （所以也就有了上面代码中 new 的 <code>MethodInterceptor</code> 的匿名内部类）。</p><p><code>MethodInterceptor</code> 的 <code>intercept</code> 方法中参数列表与 <code>InvocationHandler</code> 的 <code>invoke</code> 方法类似，唯独多了一个 <code>MethodProxy</code> ，它是对参数列表中的 <code>Method</code> 又做了一层封装，利用它可以直接执行被代理对象的方法，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行代理对象的方法</span><br>method.invoke(proxy, args);<br><br><span class="hljs-comment">// 执行原始对象(被代理对象)的方法</span><br>methodProxy.invokeSuper(proxy, args);<br></code></pre></td></tr></table></figure><p>除此之外也就没啥好说的了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01-AOP是怎么来的</title>
    <link href="/2022/04/16/01-AOP%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/"/>
    <url>/2022/04/16/01-AOP%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP是怎么来的"><a href="#AOP是怎么来的" class="headerlink" title="AOP是怎么来的"></a>AOP是怎么来的</h1><h2 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h2><p>继 <code>BeanFactory</code> 抽取完成之后，你负责的项目最终是稳定的在客户的服务器上运行，客户给予了你高度的赞赏，一期的项目也就告一段落了。项目运行了大半年之后，有一天客户突然给你打来了电话：</p><blockquote><p>靓仔啦，我们这边不知道咋回事，系统里出现了好多异常数据的啦，你有时间来帮我们看一下的啦 ~</p></blockquote><p>本来这会你也不忙，就开了远程软件连上服务器看了一下，果不其然，在<strong>这个系统的积分模块里，有几个用户的积分异于常人的多</strong>。但是吧，系统里一开始就没把这个积分当做很重要的模块来设计，所以也没有什么积分的流水记录，也就没办法查这些积分的来源了。</p><p>你跟客户说明这个事情之后，客户显得比较着急：这不大行啊，积分也是很重要滴，<strong>能不能帮我们把积分的变动都记录下来啊</strong>，这样我们回头查起来也方便一些。起初你也没觉得这事多麻烦，就一口答应了。</p><h3 id="1、代码预编写"><a href="#1、代码预编写" class="headerlink" title="1、代码预编写"></a>1、代码预编写</h3><p>为迎合接下来的剧情变动，我们需要做一些准备工作。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">demoService=com<span class="hljs-selector-class">.linkedbear</span><span class="hljs-selector-class">.architecture</span><span class="hljs-selector-class">.f_pointslog</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span>.DemoServiceImpl<br>demoDao=com<span class="hljs-selector-class">.linkedbear</span><span class="hljs-selector-class">.architecture</span><span class="hljs-selector-class">.f_pointslog</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.DemoDaoImpl<br></code></pre></td></tr></table></figure><p>还有 <code>BeanFactory</code> 中的 properties 加载路径改掉：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static &#123;<br>    properties = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Properties()</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 记得改这里</span><br>        properties.load(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BeanFactory</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">ClassLoader()</span>.get<span class="hljs-constructor">ResourceAsStream(<span class="hljs-string">&quot;factory_f.properties&quot;</span>)</span>);<br>    &#125; catch (IOException e) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ExceptionInInitializerError(<span class="hljs-string">&quot;BeanFactory initialize error, cause: &quot;</span> + <span class="hljs-params">e</span>.<span class="hljs-params">getMessage</span>()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，给 <code>DemoService</code> 添加几个方法，代表积分变动的逻辑：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> interface DemoService &#123;<br>    <span class="hljs-function">List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相应的，给 <code>DemoServiceImpl</code> 中添加对应的实现：（这里我们就不再拿着 <code>DemoDao</code> 折腾了，怪费劲的 … ）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> points;<br>&#125;<br><br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> points;<br>&#125;<br><br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> points;<br>&#125;<br><br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> points;<br>&#125;<br></code></pre></td></tr></table></figure><p>再复制一个相同的 <code>DemoServiceImpl</code> ，命名为 <code>DemoServiceImpl2</code> ，代码不需要变。</p><p>最后，在 <code>DemoServlet6</code> 中，添加对 <code>add</code> 和 <code>subtract</code> 方法的调用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Get(HttpServletRequest <span class="hljs-params">req</span>, HttpServletResponse <span class="hljs-params">resp</span>)</span> throws ServletException, IOException &#123;<br>    resp.get<span class="hljs-constructor">Writer()</span>.println(demoService.find<span class="hljs-constructor">All()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>    demoService.add(<span class="hljs-string">&quot;bearbear&quot;</span>, <span class="hljs-number">666</span>);<br>    demoService.subtract(<span class="hljs-string">&quot;bearbear&quot;</span>, <span class="hljs-number">666</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、积分变动逻辑添加"><a href="#2、积分变动逻辑添加" class="headerlink" title="2、积分变动逻辑添加"></a>2、积分变动逻辑添加</h3><p>答应完事之后，你缓缓的打开了原来的工程，仔细搜查了一遍之后，发现事情不简单了：<strong>涉及到积分变动的逻辑好多啊</strong>！虽然改起来难度不大，但这么多改起来也挺费劲啊！</p><p>既然是加日志记录，那就在每个方法执行的一开始，先把这个类的类名 + 执行的方法名，以及参数都打印出来吧：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;DemoServiceImpl add ...&quot;</span>);<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;user: &quot;</span> + userId + <span class="hljs-string">&quot;, points: &quot;</span> + points);<br>    <span class="hljs-keyword">return</span> points;<br>&#125;<br><br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;DemoServiceImpl subtract ...&quot;</span>);<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;user: &quot;</span> + userId + <span class="hljs-string">&quot;, points: &quot;</span> + points);<br>    <span class="hljs-keyword">return</span> points;<br>&#125;<br><br><span class="hljs-comment">// 省略multiply与divide......</span><br></code></pre></td></tr></table></figure><p>这代码写的，你是一边写一边骂啊，得亏这业务方法不多，要是来上个百儿八十个，那我不又得跟之前那帮孙子改数据库似的？</p><p>可是。。。聪明的你在写的时候，越来越感觉这事不对劲：哎这不对劲啊，<strong>这些日志的打印，它们的逻辑几乎都是一样的</strong>诶！我干嘛非得一个一个的这样写呢？最起码的，我<strong>封装个工具类</strong>也好啊！</p><h3 id="3、工具类封装"><a href="#3、工具类封装" class="headerlink" title="3、工具类封装"></a>3、工具类封装</h3><p>于是，你的脑海中出现了这样的一个工具类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogUtils</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(<span class="hljs-keyword">String</span> className, <span class="hljs-keyword">String</span> methodName, <span class="hljs-keyword">String</span> userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(className + <span class="hljs-string">&quot; &quot;</span> + methodName + <span class="hljs-string">&quot; ...&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;user: &quot;</span> + userId + <span class="hljs-string">&quot;, points: &quot;</span> + points);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可是转头又一想，这工具类做的也太离谱了，就单纯的为了这一个需求搞，不大合适，我可以做成通用的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> LogUtils &#123;<br>    public static void print<span class="hljs-constructor">Log(String <span class="hljs-params">className</span>, String <span class="hljs-params">methodName</span>, Object<span class="hljs-operator">...</span> <span class="hljs-params">args</span>)</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(className + <span class="hljs-string">&quot; &quot;</span> + methodName + <span class="hljs-string">&quot; ...&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;参数列表: &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">args</span>)</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样改完之后，<code>DemoServiceImpl</code> 中就变成了这样子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public <span class="hljs-built_in">int</span> add(String userId, <span class="hljs-built_in">int</span> points) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>print<span class="hljs-constructor">Log(<span class="hljs-string">&quot;DemoServiceImpl&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-params">userId</span>, <span class="hljs-params">points</span>)</span>;<br>    return points;<br>&#125;<br><br>@Override<br>public <span class="hljs-built_in">int</span> subtract(String userId, <span class="hljs-built_in">int</span> points) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>print<span class="hljs-constructor">Log(<span class="hljs-string">&quot;DemoServiceImpl&quot;</span>, <span class="hljs-string">&quot;subtract&quot;</span>, <span class="hljs-params">userId</span>, <span class="hljs-params">points</span>)</span>;<br>    return points;<br>&#125;<br><br><span class="hljs-comment">// 省略multiply与divide......</span><br></code></pre></td></tr></table></figure><p>好歹的少了一行代码吧，最起码复制粘贴起来能轻快点。。。</p><p>可是。。。也仅仅是少了一点吧，每个方法还是得写 <code>LogUtils.printLog</code> 方法，相当于没改！</p><p><img src="/2022/04/16/01-AOP%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/image-20220416135048973.png" alt="image-20220416135048973"></p><p>所以，<strong>有没有什么方法，能让这个日志打印的代码从核心 Service 中移除掉，但同样实现这个效果呢？</strong>（毕竟，当 Service 一旦大量增加之后，核心 Service 的逻辑会跟这些附加的动作混为一起，实在太过臃肿，代码会变得很难维护）</p><h2 id="设计模式引入"><a href="#设计模式引入" class="headerlink" title="设计模式引入"></a>设计模式引入</h2><p>在 GoF23 设计模式中，其实有一些设计模式，是能解决一部分当下的这个问题的。</p><h3 id="1、尝试引入装饰器模式"><a href="#1、尝试引入装饰器模式" class="headerlink" title="1、尝试引入装饰器模式"></a>1、尝试引入装饰器模式</h3><p>在行为型模式中，装饰者模式就可以给原有的逻辑上扩展额外的动作，看样子装饰者是可以解决这个问题的！所以我们可以尝试着这样改造一下原有的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 装饰者实现被装饰者同样的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> DemoService target;<br>    <br>    <span class="hljs-comment">// 构造方法中需要传入被装饰的原对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoServiceDecorator</span><span class="hljs-params">(DemoService target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> target.findAll();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(String userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>        <span class="hljs-comment">// 在原对象执行方法之前打印日志，完成日志与业务逻辑的分离</span><br>        LogUtils.printLog(<span class="hljs-string">&quot;DemoService&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, userId, points);<br>        <span class="hljs-keyword">return</span> target.add(userId, points);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(String userId, <span class="hljs-keyword">int</span> points)</span> </span>&#123;<br>        LogUtils.printLog(<span class="hljs-string">&quot;DemoService&quot;</span>, <span class="hljs-string">&quot;subtract&quot;</span>, userId, points);<br>        <span class="hljs-keyword">return</span> target.subtract(userId, points);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 省略multiply与divide......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>经过这样一包装后，在 <code>DemoServlet</code> 再获取 <code>DemoService</code> 的时候，就可以用 <code>DemoServiceDecorator</code> 包装一下了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">&quot;/demo8&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServlet8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <br>    <span class="hljs-type">DemoService</span> demoService = <span class="hljs-keyword">new</span> <span class="hljs-type">DemoServiceDecorator</span>((<span class="hljs-type">DemoService</span>) <span class="hljs-type">BeanFactory</span>.getBean(<span class="hljs-string">&quot;demoService&quot;</span>));<br></code></pre></td></tr></table></figure><p>而且利用装饰者模式的特性，可以对原对象<strong>反复装饰</strong>！换言之， <code>DemoService</code> 可以增强的逻辑不仅仅是日志记录了，如果有事务也可以加入事务控制，如果有其它校验等逻辑也可以编写装饰者来包装它！</p><p>装饰器模式的弊端：</p><p>想法虽好，可到了编码实行的时候，才发现装饰者的一个最大的弊端：<strong>每个业务层接口都要写一个装饰者！</strong></p><p>现在只有积分变动逻辑需要添加日志记录，回头用户修改密码也要加日志记录，那 <code>UserService</code> 也要写装饰者；</p><p>部门发生变动也要加日志记录，那 <code>DepartmentService</code> 也就需要写装饰者，这编码量未免也太大了吧！</p><p>不行，装饰者模式解决这个问题不是上乘之选，那还有没有更简单的办法了呢？</p><h3 id="2、尝试使用模板方法"><a href="#2、尝试使用模板方法" class="headerlink" title="2、尝试使用模板方法"></a>2、尝试使用模板方法</h3><p>行为型模式中还有一个可以抽取逻辑的模式，那就是<strong>模板方法模式</strong>。在之前 IOC 部分的学习中，我们也看到了，SpringFramework 中大量运用了模板方法模式来控制底层的逻辑结构。</p><p>那如果用模板方法模式来改造代码的话，我们倒是可以加一个 <code>AbstractDemoService</code> 类来抽取出日志的打印逻辑：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public abstract <span class="hljs-keyword">class</span> AbstractDemoService implements DemoService &#123;<br>    <br>    @Override<br>    public <span class="hljs-built_in">int</span> add(String userId, <span class="hljs-built_in">int</span> points) &#123;<br>        <span class="hljs-comment">// 父类执行额外的逻辑</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>print<span class="hljs-constructor">Log(<span class="hljs-string">&quot;DemoService&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-params">userId</span>, <span class="hljs-params">points</span>)</span>;<br>        return <span class="hljs-keyword">do</span><span class="hljs-constructor">Add(<span class="hljs-params">userId</span>, <span class="hljs-params">points</span>)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 子类负责业务功能实现</span><br>    protected abstract <span class="hljs-built_in">int</span> <span class="hljs-keyword">do</span><span class="hljs-constructor">Add(String <span class="hljs-params">userId</span>, <span class="hljs-params">int</span> <span class="hljs-params">points</span>)</span>;<br>    <br>    <span class="hljs-comment">// 省略其余方法......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的抽取倒是也可以解决问题啦，<code>DemoServiceImpl</code> 就不再需要实现 <code>DemoService</code> 接口的 add 方法，而是只需要实现 <code>doAdd</code> 方法即可：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDemoService</span> <span class="hljs-title">implements</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>    <br>    <span class="hljs-type">DemoDao</span> demoDao = (<span class="hljs-type">DemoDao</span>) <span class="hljs-type">BeanFactory</span>.getBean(<span class="hljs-string">&quot;demoDao&quot;</span>);<br>    <br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt; findAll() &#123;<br>        <span class="hljs-keyword">return</span> demoDao.findAll();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 只需要实现父类留下的doXXX方法即可</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> int doAdd(<span class="hljs-type">String</span> userId, int points) &#123;<br>        <span class="hljs-keyword">return</span> points;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 省略其余方法......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>模板方法的弊端：</p><p>感觉这样写下来，代码量比装饰者模式更多了。而且，还有一个很棘手的点：由于模板方法模式使用了<strong>继承</strong>，一个 <code>DemoService</code> <strong>只能扩展一个功能</strong>了！这灵活性还不如装饰者模式呢！</p><p>不行，模板方法模式也解决不了这个问题，还有别的办法吗？</p><h3 id="3、尝试引入责任链模式"><a href="#3、尝试引入责任链模式" class="headerlink" title="3、尝试引入责任链模式"></a>3、尝试引入责任链模式</h3><p>行为型模式中还有一种可以抽取逻辑的模式，那就是<strong>责任链模式</strong>。</p><p>责任链最大的特点是将一个动作的请求放在一条对象的链子上传播，直到职责链上的某个对象能处理该请求时终止。</p><p>用这种设计模式的话，针对多种不同功能的扩展，似乎这不像是责任链，更像是装饰者。。。所以我们可以这样理解，对于功能的扩展，装饰者跟责任链能实现的最终效果是几乎一致的。</p><p>但是。。。（又但是了），前面我们已经看过了，装饰者模式要编写的代码已经好多了，能不能省省了。。。少写点，真的好累哦！</p><h3 id="4、尝试适用代理模式"><a href="#4、尝试适用代理模式" class="headerlink" title="4、尝试适用代理模式"></a>4、尝试适用代理模式</h3><p>好了，前面那么多铺垫，就是为了引出代理模式。从代理的生成方式来看，代理分为静态代理和动态代理：</p><ol><li>静态代理需要自行编写代理类，组合原有的目标对象，并实现原有目标对象实现的接口，以此来做到对原有对象的方法功能的增强；</li><li>动态代理只需要编写增强逻辑类，在运行时动态将增强逻辑类组合进原有的目标对象，即可生成代理对象，完成对目标对象的方法功能增强。</li></ol><blockquote><p>在实际编写中，可能会有小伙伴产生一种错觉：代理和装饰者的编写几乎一样啊，它俩有什么不同呢？</p><p>是这样，代理模式侧重的是对原有目标对象的访问权限控制，而装饰者是在原有对象之上增强功能。</p></blockquote><h2 id="OOP的不足和横切思想"><a href="#OOP的不足和横切思想" class="headerlink" title="OOP的不足和横切思想"></a>OOP的不足和横切思想</h2><p>从上面的几个设计模式的尝试和分析中，我们发现了一个 OOP 的很大的不足之处：</p><p>诸如上面的这种相同、重复的逻辑，OOP 没有办法将这些逻辑分离出去，<strong>OOP 只能尽可能的减少这些重复的代码量，却无法避免重复代码的出现</strong>。</p><p>再观察一下上面的代码和示意图，我们很明显可以发现，四个方法中的起始动作都是日志打印的方法，它们可以用一个横截的框 框起来：</p><p><img src="/2022/04/16/01-AOP%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/image-20220416140625735.png" alt="image-20220416140625735"></p><p>这种框可以是一个类的几个方法，可以是多个类的不同方法。只要这些方法的开始 / 结束都有相同的逻辑，那我们就可以把这些逻辑都拿出来视为一体，这个思想就叫<strong>横切</strong>，提取出来的逻辑组成的虚拟的结构，我们可以称之为<strong>横切面</strong>（上图的红框就可以理解为一个横切面）。</p><h2 id="最终方案-动态代理"><a href="#最终方案-动态代理" class="headerlink" title="最终方案-动态代理"></a>最终方案-动态代理</h2><p>好了终于可以引出动态代理了，Java 早在 jdk 1.3 中就引入动态代理了，具体的用法，以及 Cglib 的动态代理，咱下一章会作一个复习和回顾，这里咱先写一下看看效果。</p><h3 id="1、使用JDK动态代理的实现"><a href="#1、使用JDK动态代理的实现" class="headerlink" title="1、使用JDK动态代理的实现"></a>1、使用JDK动态代理的实现</h3><p>既然是 Servlet 要依赖 <code>DemoService</code> ，那我们可以先这样，让 Servlet 在初始化的时候，从 <code>BeanFactory</code> 中获取 <code>DemoService</code> ，然后借助 jdk 动态代理生成 <code>DemoService</code> 的代理对象，并给其中的方法增强：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/demo10&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServlet10</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <br>    DemoService demoService;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        DemoService demoService = (DemoService) BeanFactory.getBean(<span class="hljs-string">&quot;demoService&quot;</span>);<br>        Class&lt;? extends DemoService&gt; clazz = demoService.getClass();<br>        <span class="hljs-comment">// 使用jdk动态代理，生成代理对象</span><br>        <span class="hljs-keyword">this</span>.demoService = (DemoService) Proxy<br>                .newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), (proxy, method, args) -&gt; &#123;<br>                    LogUtils.printLog(<span class="hljs-string">&quot;DemoService&quot;</span>, method.getName(), args);<br>                    <span class="hljs-keyword">return</span> method.invoke(demoService, args);<br>                &#125;);<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1、指定方法增强"><a href="#1-1、指定方法增强" class="headerlink" title="1.1、指定方法增强"></a>1.1、指定方法增强</h4><p>上面这段代码将DemoService的所有方法都进行了增强，但我们一开始的需求，是只给 <code>add</code> 、<code>subtract</code> 等积分变动的方法增强，这个要怎么办呢？</p><p>解决方案倒是很简单，在 <code>DemoService</code> 的代理对象创建逻辑中，添加方法名称的判断就 OK 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    DemoService demoService = (DemoService) BeanFactory.getBean(<span class="hljs-string">&quot;demoService&quot;</span>);<br>    Class&lt;? extends DemoService&gt; clazz = demoService.getClass();<br>    <span class="hljs-keyword">this</span>.demoService = (DemoService) Proxy<br>            .newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), (proxy, method, args) -&gt; &#123;<br>                List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;subtract&quot;</span>, <span class="hljs-string">&quot;multiply&quot;</span>, <span class="hljs-string">&quot;divide&quot;</span>);<br>                <span class="hljs-keyword">if</span> (list.contains(method.getName())) &#123;<br>                    LogUtils.printLog(<span class="hljs-string">&quot;DemoService&quot;</span>, method.getName(), args);<br>                &#125;<br>                <span class="hljs-keyword">return</span> method.invoke(demoService, args);<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2、配置化增强"><a href="#1-2、配置化增强" class="headerlink" title="1.2、配置化增强"></a>1.2、配置化增强</h4><p>上面这段代码并不完美，又是硬编码了啊！这些东西很明显可以分离到<strong>外部化配置</strong>中！所以我们可以在 <code>resources</code> 目录下再创建一个 <code>proxy.properties</code> ，在这个文件中定义日志打印的增强代理方法：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">log</span>.methods=<span class="hljs-built_in">add</span>,<span class="hljs-built_in">subtract</span>,<span class="hljs-built_in">multiply</span>,<span class="hljs-built_in">divide</span><br></code></pre></td></tr></table></figure><p>然后，由 Servlet 负责加载该配置文件，并创建 <code>DemoService</code> 的代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>    <span class="hljs-comment">// 读取proxy.properties</span><br>    Properties proxyProp = <span class="hljs-keyword">new</span> Properties();<br>    <span class="hljs-keyword">try</span> &#123;<br>        proxyProp.load(<span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;proxy.properties&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExceptionInInitializerError(<span class="hljs-string">&quot;DemoServlet11 initialize error, cause: &quot;</span> + e.getMessage());<br>    &#125;<br><br>    DemoService demoService = (DemoService) BeanFactory.getBean(<span class="hljs-string">&quot;demoService&quot;</span>);<br>    Class&lt;? extends DemoService&gt; clazz = demoService.getClass();<br>    <span class="hljs-keyword">this</span>.demoService = (DemoService) Proxy<br>            .newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), (proxy, method, args) -&gt; &#123;<br>                <span class="hljs-comment">// 从配置文件中取出要增强的方法名</span><br>                List&lt;String&gt; list = Arrays.asList(proxyProp.getProperty(<span class="hljs-string">&quot;log.methods&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>));<br>                <span class="hljs-keyword">if</span> (list.contains(method.getName())) &#123;<br>                    LogUtils.printLog(<span class="hljs-string">&quot;DemoService&quot;</span>, method.getName(), args);<br>                &#125;<br>                <span class="hljs-keyword">return</span> method.invoke(demoService, args);<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，基本上 AOP 的概念就快出来了，不过小伙伴先不要着急，咱继续往下推演。</p><h3 id="2、动态代理对象的创建"><a href="#2、动态代理对象的创建" class="headerlink" title="2、动态代理对象的创建"></a>2、动态代理对象的创建</h3><p>上面的代码编写中，小伙伴是否有一种感觉：代理对象应该由 Servlet 创建吗？那回头如果有好多个 Servlet 都依赖了这个 Service ，那岂不是要重复创建好多次？</p><p>很明显，<strong>Servlet 要拿到的 Service 应该是被代理过的</strong>吧！那这个问题应该如何解决呢？</p><p>当然是<strong>由 <code>BeanFactory</code> 帮忙创建</strong>啦！按道理讲，<strong>如果引入了代理的机制，那么 <code>BeanFactory</code> 创建的对象就应该是被增强过的代理对象</strong>！好，明确了需求之后，下面我们来试着改造一下原有的 <code>BeanFactory</code> 。</p><h4 id="2-1、重新设计properties"><a href="#2-1、重新设计properties" class="headerlink" title="2.1、重新设计properties"></a>2.1、重新设计properties</h4><p>之前的 <code>factory.properties</code> 中，我们只定义过 bean 的名称对应的类的全限定名：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">demoService</span>=<span class="hljs-string">com.linkedbear.architecture.l_proxyfactory.service.impl.DemoServiceImpl</span><br><span class="hljs-attr">demoDao</span>=<span class="hljs-string">com.linkedbear.architecture.l_proxyfactory.dao.impl.DemoDaoImpl</span><br></code></pre></td></tr></table></figure><p>这次加入代理的增强后，这些很明显就不够了，我们可以试着这样写一下代理的声明：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">demoService</span>=<span class="hljs-string">com.linkedbear.architecture.l_proxyfactory.service.impl.DemoServiceImpl</span><br><span class="hljs-meta">demoService.proxy.class</span>=<span class="hljs-string">com.linkedbear.architecture.l_proxyfactory.proxy.LogAdvisor</span><br><span class="hljs-meta">demoService.proxy.methods</span>=<span class="hljs-string">add,subtract,multiply,divide</span><br><br><span class="hljs-attr">demoDao</span>=<span class="hljs-string">com.linkedbear.architecture.l_proxyfactory.dao.impl.DemoDaoImpl</span><br></code></pre></td></tr></table></figure><p>看，我在 properties 中额外定义了 <code>demoService</code> 的增强类的全限定名，也声明了这个增强类要增强的方法列表，这样 <code>BeanFactory</code> 加载到 properties 中就能拿到这两个信息。</p><h4 id="2-2、编写LogAdvisor"><a href="#2-2、编写LogAdvisor" class="headerlink" title="2.2、编写LogAdvisor"></a>2.2、编写LogAdvisor</h4><p>既然这次要把增强的 <code>InvocationHandler</code> 拿到外面单独实现，那就必须要编写新的类了，咱新建一个 <code>proxy</code> 包，把这个 <code>LogAdvisor</code> 放在这里。（这个类的命名也是一个伏笔啊）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAdvisor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">return</span> method.invoke(???, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等一下，这个 method 的 invoke 方法中，不是要拿被代理的对象吗？可是这里还没有呢，那我们用成员属性 + 构造器的方式，把原来的被代理对象传进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAdvisor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Object target;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogAdvisor</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">return</span> method.invoke(target, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就做到全方法的增强了，不过咱前面还封装了 <code>methods</code> 呢（不要忘记需求哦），所以相应的，咱把 <code>methods</code> 也引入进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAdvisor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Object target;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;String&gt; methods;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogAdvisor</span><span class="hljs-params">(Object target, String[] methods)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>        <span class="hljs-keyword">this</span>.methods = Arrays.asList(methods);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.methods.contains(method.getName())) &#123;<br>            LogUtils.printLog(target.getClass().getName(), method.getName(), args);<br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(target, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样 <code>LogAdvisor</code> 的逻辑就写完了，相对还是比较简单的哈。</p><blockquote><p>为了保持风格统一，在本章中如果编写其他的 Advisor ，也必须是像上面一样，声明一个两参数的构造方法。</p></blockquote><h4 id="2-3、修改BeanFactory"><a href="#2-3、修改BeanFactory" class="headerlink" title="2.3、修改BeanFactory"></a>2.3、修改BeanFactory</h4><p>最后咱把 <code>BeanFactory</code> 修改一下，前面的需求中咱说了，要在 <code>getBean</code> 的时候把代理对象创建出来，所以此处要做一些逻辑的扩展了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; beanClazz = Class.forName(properties.getProperty(beanName));<br>Object bean = beanClazz.newInstance();<br>beanMap.put(beanName, bean);<br></code></pre></td></tr></table></figure><p>这是原来的 <code>getBean</code> 方法中，通过了双检锁后真正创建 bean 对象的逻辑，这里咱要扩展了。</p><p>要使用动态代理生成代理对象，那么在创建完 bean 后，先不要着急放入 <code>beanMap</code> ，去看一看 properties 中是否有定义 <strong>proxy</strong> 相关的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; beanClazz = Class.forName(properties.getProperty(beanName));<br>Object bean = beanClazz.newInstance();<br><br><span class="hljs-comment">// 检查properties中是否有定义代理增强</span><br>String proxyAdvisorClassName = properties.getProperty(beanName + <span class="hljs-string">&quot;.proxy.class&quot;</span>);<br><span class="hljs-keyword">if</span> (proxyAdvisorClassName != <span class="hljs-keyword">null</span> &amp;&amp; proxyAdvisorClassName.trim().length() &gt; <span class="hljs-number">0</span>) &#123;<br><br>&#125;<br><br>beanMap.put(beanName, bean);<br></code></pre></td></tr></table></figure><p>可见，如果获取到的 <code>proxyAdvisorClassName</code> 不为空，则代表这个 bean 有定义代理增强，需要反射创建 <code>InvocationHandler</code> 的实现类。</p><p>接下来，反射到 <code>InvocationHandler</code> 的实现类后，还要从 properties 中获取这个 bean 要增强（被代理）的方法列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; beanClazz = Class.forName(properties.getProperty(beanName));<br>Object bean = beanClazz.newInstance();<br><br><span class="hljs-comment">// 检查properties中是否有定义代理增强</span><br>String proxyAdvisorClassName = properties.getProperty(beanName + <span class="hljs-string">&quot;.proxy.class&quot;</span>);<br><span class="hljs-keyword">if</span> (proxyAdvisorClassName != <span class="hljs-keyword">null</span> &amp;&amp; proxyAdvisorClassName.trim().length() &gt; <span class="hljs-number">0</span>) &#123;<br>  Class&lt;?&gt; proxyAdvisorClass = Class.forName(proxyAdvisorClassName);<br>  String[] methods = properties.getProperty(beanName + <span class="hljs-string">&quot;.proxy.methods&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>&#125;<br><br>beanMap.put(beanName, bean);<br></code></pre></td></tr></table></figure><p>这样写完之后，就可以创建对象了吧！由于前面我们在 <code>LogAdvisor</code> 中有定义过编码风格，所以这里一定可以获取到一个构造方法，而且是两个参数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogAdvisor</span><span class="hljs-params">(Object target, String[] methods)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.target = target;<br>    <span class="hljs-keyword">this</span>.methods = Arrays.asList(methods);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们在 <code>BeanFactory</code> 中就可以这样反射创建 <code>LogAdvisor</code> 的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; beanClazz = Class.forName(properties.getProperty(beanName));<br>Object bean = beanClazz.newInstance();<br><br><span class="hljs-comment">// 检查properties中是否有定义代理增强</span><br>String proxyAdvisorClassName = properties.getProperty(beanName + <span class="hljs-string">&quot;.proxy.class&quot;</span>);<br><span class="hljs-keyword">if</span> (proxyAdvisorClassName != <span class="hljs-keyword">null</span> &amp;&amp; proxyAdvisorClassName.trim().length() &gt; <span class="hljs-number">0</span>) &#123;<br>    Class&lt;?&gt; proxyAdvisorClass = Class.forName(proxyAdvisorClassName);<br>    String[] methods = properties.getProperty(beanName + <span class="hljs-string">&quot;.proxy.methods&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>    <br>    <span class="hljs-comment">// 要求InvocationHandler的实现类必须声明两参数构造方法</span><br>    <span class="hljs-comment">// 其中第一个参数是被代理的目标对象，第二个参数是要增强的方法列表</span><br>    InvocationHandler proxyHandler = (InvocationHandler) proxyAdvisorClass<br>            .getConstructors()[<span class="hljs-number">0</span>].newInstance(bean, methods);<br>&#125;<br><br>beanMap.put(beanName, bean);<br></code></pre></td></tr></table></figure><p>经过这样的创建之后，原始对象、<code>InvocationHandler</code> 都有了，接下来就可以使用动态代理，创建代理对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; beanClazz = Class.forName(properties.getProperty(beanName));<br>Object bean = beanClazz.newInstance();<br><br><span class="hljs-comment">// 检查properties中是否有定义代理增强</span><br>String proxyAdvisorClassName = properties.getProperty(beanName + <span class="hljs-string">&quot;.proxy.class&quot;</span>);<br><span class="hljs-keyword">if</span> (proxyAdvisorClassName != <span class="hljs-keyword">null</span> &amp;&amp; proxyAdvisorClassName.trim().length() &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 有定义代理增强，需要反射创建InvocationHandler的实现类</span><br>    Class&lt;?&gt; proxyAdvisorClass = Class.forName(proxyAdvisorClassName);<br>    <br>    <span class="hljs-comment">// 从properties中找出当前bean需要增强的方法列表</span><br>    String[] methods = properties.getProperty(beanName + <span class="hljs-string">&quot;.proxy.methods&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>    <br>    <span class="hljs-comment">// 要求InvocationHandler的实现类必须声明两参数构造方法</span><br>    <span class="hljs-comment">// 其中第一个参数是被代理的目标对象，第二个参数是要增强的方法列表</span><br>    InvocationHandler proxyHandler = (InvocationHandler) proxyAdvisorClass.getConstructors()[<span class="hljs-number">0</span>]<br>            .newInstance(bean, methods);<br>    <span class="hljs-comment">// 动态代理创建对象</span><br>    Object proxy = Proxy.newProxyInstance(bean.getClass().getClassLoader(),<br>            bean.getClass().getInterfaces(), proxyHandler);<br>    bean = proxy;<br>    <span class="hljs-comment">// 经过该步骤后，放入beanMap的对象就是已经被增强过的代理对象</span><br>&#125;<br><br>beanMap.put(beanName, bean);<br></code></pre></td></tr></table></figure><h4 id="2-4、还原Servlet"><a href="#2-4、还原Servlet" class="headerlink" title="2.4、还原Servlet"></a>2.4、还原Servlet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">最后，把 Servlet 的逻辑改回之前的样子：<br><br><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/demo12&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServlet12</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <br>    DemoService demoService = (DemoService) BeanFactory.getBean(<span class="hljs-string">&quot;demoService&quot;</span>);<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.getWriter().println(demoService.findAll().toString());<br>        demoService.add(<span class="hljs-string">&quot;bearbear&quot;</span>, <span class="hljs-number">666</span>);<br>        demoService.subtract(<span class="hljs-string">&quot;bearbear&quot;</span>, <span class="hljs-number">666</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 Tomcat ，重新访问 Servlet 的路径，发现控制台依旧能正常打印日志：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.linkedbear</span><span class="hljs-selector-class">.architecture</span><span class="hljs-selector-class">.l_proxyfactory</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.DemoServiceImpl</span> add ...<br>参数列表: <span class="hljs-selector-attr">[bearbear, 666]</span><br>com<span class="hljs-selector-class">.linkedbear</span><span class="hljs-selector-class">.architecture</span><span class="hljs-selector-class">.l_proxyfactory</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.DemoServiceImpl</span> subtract ...<br>参数列表: <span class="hljs-selector-attr">[bearbear, 666]</span><br></code></pre></td></tr></table></figure><p>证明 Servlet 拿到的 <code>DemoService</code> 已经是代理对象了。</p><p>到这里，整个场景也都演绎完毕了，跟 IOC 的引入一样，咱先总结一下整个过程中出现的几个关键点：</p><ul><li>传统的 GoF23 设计模式中可以一定程度上解决重复代码，但整体上编码量会激增</li><li>使用动态代理可以在不改变原有逻辑的前提下，对已有方法增强</li><li>创建代理对象应由 IOC 容器负责，而不是使用者本身</li></ul><h2 id="AOP思想引入"><a href="#AOP思想引入" class="headerlink" title="AOP思想引入"></a>AOP思想引入</h2><p><img src="/2022/04/16/01-AOP%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/image-20220416140625735.png" alt="image-20220416140625735"></p><p>这个图中的红框我们说它称为<strong>横切面</strong>，英文表示为 <strong>Aspect</strong> ，它表示的是<strong>分布在一个 / 多个类的多个方法中的相同逻辑</strong>。</p><p>利用<strong>动态代理</strong>，将这部分<strong>相同的逻辑</strong>抽取为一个<strong>独立的 Advisor</strong> 增强器，并在原始对象的初始化过程中，<strong>动态组合原始对象并产生代理对象</strong>，同样能完成一样的功能增强。</p><p>在此基础上，通过指定增强的类名、方法名（甚至方法参数列表类型等），可以更细粒度的对方法增强。</p><p>使用这种方式，可以在<strong>不修改原始代码的前提下，对已有任意代码的功能增强</strong>。而这种<strong>针对相同逻辑的扩展和抽取</strong>，就是所谓的<strong>面向切面编程（Aspect Oriented Programming，AOP）</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL普通索引和唯一索引的选择</title>
    <link href="/2022/04/16/MySQL%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <url>/2022/04/16/MySQL%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="普通索引和唯一索引，应该怎么选择？"><a href="#普通索引和唯一索引，应该怎么选择？" class="headerlink" title="普通索引和唯一索引，应该怎么选择？"></a>普通索引和唯一索引，应该怎么选择？</h1><p>在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了唯一索引和普通索引 的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一索引？</p><p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写 入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语 句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> CUser <span class="hljs-keyword">where</span> id_card = <span class="hljs-string">&#x27;xxxxxxxyyyyyyzzzzz&#x27;</span>;<br></code></pre></td></tr></table></figure><p>所以，你一定会考虑在id_card字段上建索引。</p><p>由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择：</p><ol><li>要么给 id_card字段创建唯一索引</li><li>要么创建一个普通索引。</li></ol><p>如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</p><p>现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么 呢？</p><p><img src="/2022/04/16/MySQL%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9/image-20220416101623658.png" alt="image-20220416101623658"></p><p>接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。</p><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><p>假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先 是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ol><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰 到第一个不满足k=5条件的记录。 </li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继 续检索。</li></ol><p><strong>那么，这个不同带来的性能差距会有多少呢？答案是，<u>微乎其微</u>。</strong></p><p>你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候， 并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p><p>因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。 那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针 寻找和一次计算。</p><p>当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下 一个数据页，这个操作会稍微复杂一些。</p><p>但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概 率会很低。<strong>所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以 忽略不计。</strong></p><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下change buffer。</p><h3 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h3><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中 的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样 就不需要从磁盘中读入这个数据页了。</p><h4 id="CB数据一致性"><a href="#CB数据一致性" class="headerlink" title="CB数据一致性"></a>CB数据一致性</h4><p>在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p><h4 id="CB-merge"><a href="#CB-merge" class="headerlink" title="CB merge"></a>CB merge</h4><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为merge。</p><p>merge 动作的时机：</p><ol><li>除了访问这个数据页会触发merge外，系统有后台线程会定期merge。</li><li>在数据库正常关闭（shutdown）的过程中， 也会执行merge操作。 </li></ol><p>显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。 </p><p>那么，什么条件下可以使用 change buffer呢？</p><blockquote><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。</p><p>比如，要插入 (4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存 才能判断。</p><p>如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer 了。 </p><p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。 </p><p>change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。</p><p>这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p></blockquote><p>现在，你已经理解了change buffer的机制，那么我们再一起来看看如果要在这张表中插入一个新记录 (4,400)的话， InnoDB的处理流程是怎样的。</p><p>第一种情况是，这个记录要更新的<strong>目标页在内存中</strong> 。这时，InnoDB的处理流程如下： </p><ol><li>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束； </li><li>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。 </li></ol><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU时间。 但，这不是我们关注的重点。 </p><p>第二种情况是，这个记录要更新的<strong>目标页不在内存中</strong> 。这时，InnoDB的处理流程如下：</p><ol><li><p>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</p></li><li><p>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。 </p></li></ol><p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。 </p><p>之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p><h3 id="change-buffer-适用场景"><a href="#change-buffer-适用场景" class="headerlink" title="change buffer 适用场景"></a>change buffer 适用场景</h3><p>通过上面的分析，你已经清楚了使用change buffer对更新过程的加速作用，也清楚了change buffer只限于用在普通索引的场景下，而不适用于唯一索引。</p><p>那么，现在有一个问题就是：普通索引的所有场景，使用change buffer都可以起到加速作用吗？</p><p>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动 作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记 录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问 IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p><h2 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h2><p>回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上 是没差别的，主要考虑的是对更新性能的影响。<strong>所以，我建议你尽量选择普通索引。</strong></p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p><p>在实际使用中，你会发现，普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p><p>特别地，在使用机械硬盘时，change buffer这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p><h2 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h2><p>理解了change buffer的原理，你可能会联想到我在前面文章中和你介绍过的redo log和WAL。</p><p>在前面文章的评论中，我发现有同学混淆了redo log和change buffer。WAL 提升性能的核心机 制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个流程里来说明，便于你区分这两个概念。</p><p>现在，我们要在表上执行这个插入语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; insert into t(id,k) values(id<span class="hljs-number">1</span>,k<span class="hljs-number">1</span>),(id<span class="hljs-number">2</span>,k<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。</p><p><img src="/2022/04/16/MySQL%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9/image-20220416103828278.png" alt="image-20220416103828278"></p><p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1在内存中，直接更新内存；</li><li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息 </li><li>将上述两个动作记入redo log中（图中3和4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了 两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p><p>那在这之后的读请求，要怎么处理呢？</p><p>比如，我们现在要执行 select * from t where k in (k1, k2)。这里，我画了这两个读请求的流程 图。</p><p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表 空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。</p><p><img src="/2022/04/16/MySQL%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9/image-20220416104242008.png" alt="image-20220416104242008"></p><p>从图中可以看到：</p><ol><li><p>读Page 1的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</p></li><li><p>要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。</p></li></ol><p>可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。</p><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随机写磁盘的 IO消耗（转成顺序写）， 而 change buffer主要节省的则是随机读磁盘的 IO消耗。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天，我从普通索引和唯一索引的选择开始，和你分享了数据的查询和更新过程，然后说明了 change buffer的机制以及应用场景，最后讲到了索引选择的实践。</p><p>由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发我建 议你优先考虑非唯一索引。</p><p>补充：</p><p>大家对“是否使用唯一索引 有比较多的讨论，主要是纠结在 业务可能无法确保 的情况。 这里，我再说明一下：</p><ol><li>首先，业务正确性优先。咱们这篇文章的前提是“业务代码已经保证不会写入重复数据”的情况 下，讨论性能问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选， 必须创建唯一索引。这种情况下，<strong>本篇文章的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，可以给你多提供一个排查思路。</strong> </li><li>然后，在一些“归档库”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半 年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高 归档效率，可以考虑把表里面的唯一索引改成普通索引。</li></ol><p>通过图2你可以看到，change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不 会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了merge过程，就等于是数据丢失了。会不会出现这种情况呢？</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务隔离:事务到底是不是隔离的</title>
    <link href="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/"/>
    <url>/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="事务到底是隔离的还是不隔离的？"><a href="#事务到底是隔离的还是不隔离的？" class="headerlink" title="事务到底是隔离的还是不隔离的？"></a>事务到底是隔离的还是不隔离的？</h1><p>讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</p><p>但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外 一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。</p><p>问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p><p>我给你举一个例子吧。下面是一个只有两行的表的初始化语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE &#96;t&#96; ( <br>  &#96;id&#96; int(11) NOT NULL, <br>  &#96;k&#96; int(11) DEFAULT NULL, <br>  PRIMARY KEY (&#96;id&#96;) <br>) ENGINE&#x3D;InnoDB; <br><br>insert into t(id, k) values(1,1),(2,2);<br></code></pre></td></tr></table></figure><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220415204008177.png" alt="image-20220415204008177"></p><p>这里，我们需要注意的是事务的启动时机：</p><ul><li><p>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令。</p></li><li><p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认 autocommit=1。</p></li><li><p>在这个例子中，事务C没有显式地使用begin/commit，表示这个update语句本身就是一个事务， 语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。</p></li></ul><p>这时，如果我告诉你 事务B 查到的 k 的值是3，而 事务A 查到的 k 的值是1，你是不是感觉有点晕呢？</p><p>所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能 够帮助你对InnoDB的事务和锁有更进一步的理解。</p><p>在MySQL里，有两个“视图”的概念：</p><ol><li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。 创建视图的语法是create view …，而它的查询方法与表一样。 </li><li>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持 RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</li></ol><h2 id="“快照-”在-MVCC里是怎么工作的？"><a href="#“快照-”在-MVCC里是怎么工作的？" class="headerlink" title="“快照 ”在 MVCC里是怎么工作的？"></a>“快照 ”在 MVCC里是怎么工作的？</h2><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。 </p><p>这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷 贝100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。 </p><h3 id="事务ID"><a href="#事务ID" class="headerlink" title="事务ID"></a>事务ID</h3><p>实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。 InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。</p><p>它是在事务开始的时候向 InnoDB的事务系统申请的，是按申请顺序严格递增的。 </p><h3 id="数据版本"><a href="#数据版本" class="headerlink" title="数据版本"></a>数据版本</h3><p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且 把 transaction id 赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留， 并且在新的数据版本中，能够有信息可以直接拿到它。 </p><p>也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。 </p><p>如图2所示，就是一个记录被多个事务连续更新后的状态。</p><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220415204821924.png" alt="image-20220415204821924"></p><p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</p><h3 id="undo-log回滚日志"><a href="#undo-log回滚日志" class="headerlink" title="undo log回滚日志"></a>undo log回滚日志</h3><p>你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，undo log 在哪呢？</p><p>实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p><hr><p>明白了多版本和row trx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照 的。</p><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这 个事务执行期间，其他事务的更新对它不可见。</p><p>因此，一个事务只需要在启动的时候声明说，以我启动的时刻为准：</p><ol><li>如果一个数据版本是在我启动之前生成的，就认；</li><li>如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本。 </li></ol><p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数 据，它自己还是要认的。 </p><h3 id="一致性视图"><a href="#一致性视图" class="headerlink" title="一致性视图"></a>一致性视图</h3><p>在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。 </p><p>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水 位。 </p><p>这个<strong>视图数组</strong>和<strong>高水位（<del>个人理解，刚刚开启的这个事务就是属于高水位</del>，不能这样理解了）</strong>，就组成了当前事务的一致性视图（read-view）。 </p><p>而数据版本的可见性规则，就是基于<strong>数据的row trx_id</strong>和<strong>这个一致性视图的对比结果</strong>得到的。 </p><p>这个视图数组把所有的row trx_id 分成了几种不同的情况。</p><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220415205424935.png" alt="image-20220415205424935"></p><p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能： </p><ol><li><p>如果落在绿色部分，表示这个版本是<strong>已提交的事务</strong>或者是<strong>当前事务自己</strong>生成的，这个数据是 可见的； </p></li><li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p></li><li><p>如果落在黄色部分，那就包括两种情况：</p><ol><li>若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li><li>若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol></li></ol><p>比如，对于图2中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据 时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。 </p><p>你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？ 因为之后的更新，生成的版本一定属于上面的2或者3(1)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。 </p><p>所以你现在知道了，InnoDB利用了 “ 所有数据都有多个版本 ” 的这个特性， 实现了 “ 秒级创建 快照 ” 的能力。 </p><p>接下来，我们继续看一下图1中的三个事务，分析下事务A的语句返回的结果，为什么是k=1。 这里，我们不妨做如下假设：</p><ol><li><p>事务A开始前，系统里面只有一个活跃事务ID是99；</p></li><li><p>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</p></li><li><p>三个事务开始前，(1,1）这一行数据的row trx_id是90。</p></li></ol><p>这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是</p><p>[99,100,101,102]。</p><p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220415210032120.png" alt="image-20220415210032120"></p><p>从图中可以看到：</p><ol><li>第一个有效更新是事务C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的row trx_id是102，而 row trx_id = 90这个版本已经成为了历史版本。 </li><li>第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</li></ol><p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。 </p><p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起 的。所以，事务A查询语句的读数据流程是这样的：</p><ol><li>找到(1,3)的时候，判断出row trx_id=101，比高水位大，处于红色区域，不可见； </li><li>接着，找到上一个历史版本，一看row trx_id=102，比高水位大，处于红色区域，不可见； </li><li>再往前找，终于找到了（1,1)，它的row trx_id=90，比低水位小，处于绿色区域，可见。</li></ol><p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据 的结果都是一致的，所以我们称之为<strong>一致性读</strong>。 </p><p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。 所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以 外，有三种情况：</p><ol><li><p>版本未提交，不可见；</p></li><li><p>版本已提交，但是是在视图创建后提交的，不可见；</p></li><li><p>版本已提交，而且是在视图创建前提交的，可见。</p></li></ol><p>现在，我们用这个规则来判断图4中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：</p><ol><li><p>(1,3)还没提交，属于情况1，不可见；</p></li><li><p>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</p></li><li><p>(1,1)是在视图数组创建之前提交的，可见。 </p></li></ol><p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们 就都用这个规则来分析。</p><h2 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h2><p>细心的同学可能有疑问了：事务事务 B的 update语句， 如果按照一致性读， 好像结果不对哦？</p><p>你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能 算出(1,3)来？</p><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220415210851534.png" alt="image-20220415210851534"></p><p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。 </p><p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。 因此，事务B此时的set k=k+1是在（1,2）的基础上进行的操作。 </p><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>所以，这里就用到了这样一条规则：更新数据都是先读后写的，更新数据都是先读后写的， 而这个读， 只能读当前的 值， 称为 “ 当前读 ” （ current read）。 </p><p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本 的row trx_id是101。</p><p>所以，在执行 事务B 查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是 自己的更新，可以直接使用，所以查询得到的 k 的值是3。 </p><p>这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select 语句如果加锁，也是 当前读，事务未提交这里被会阻塞。 </p><p>所以，如果把事务A的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。</p><p>下面这两个select语句，就是 分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">select</span> k <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share mode</span>; <br>mysql&gt; <span class="hljs-keyword">select</span> k <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？</p><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220415211259800.png" alt="image-20220415211259800"></p><p>与 事务C 的不同是，事务C’ 更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。</p><p>前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p><p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了：</p><ol><li>事务C’没提交，也就是说(1,2) 这个版本上的写锁还没释放。</li><li>而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。</li></ol><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220415211557148.png" alt="image-20220415211557148"></p><p>到这里，我们把一致性读、当前读和行锁就串起来了。 </p><p>现在，我们再回到文章开头的问题：事务的可重复读的能力是怎么实现的？</p><ol><li>可重复读的核心就是一致性读（consistent read）；</li><li>而事务更新数据的时候，只能用当前读。如 果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。 </li></ol><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ol><li><p>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</p></li><li><p>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。 </p></li></ol><p>那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的 k，分别应该是多 少呢？ </p><p>这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创 建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于 普通的start transaction。 </p><p>下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图 中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）</p><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220415211744973.png" alt="image-20220415211744973"></p><p>这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成 时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p><ol><li>(1,3)还没提交，属于情况1，不可见； </li><li>(1,2)提交了，属于情况3，可见。</li></ol><p>所以，这时候事务A查询语句返回的是k=2。</p><p>显然地，事务B查询结果k=3。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>InnoDB的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的 可见性。</p><ol><li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据； </li><li>对于读提交，查询只承认在语句启动前就已经提交完成的数据； 而当前读，总是读取已经提交完成的最新版本。 </li></ol><p>你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。 </p><p>当然，MySQL 8.0已经可以把表结构放在InnoDB字典里了，也许以后会支持表结构的可重复 读。</p><p>我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。 现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情 况。请你构造出这种情况，并说明其原理。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`t1`</span> ( <br>    <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-symbol">`c`</span> int(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>) <br>) ENGINE=InnoDB; <br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t(id, c) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码 会不会掉进这个“坑”里，你又是怎么解决的呢？</p><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220416105102702.png" alt="image-20220416105102702"></p><p>其实，还有另外一种场景：</p><p><img src="/2022/04/15/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84/image-20220416105507894.png" alt="image-20220416105507894"></p><p>这个操作序列跑出来，session A看的内容也是能够复现我截图的效果的。这个session B’启动的 事务比A要早，其实是上期我们描述事务版本的可见性规则时留的彩蛋，因为规则里还有一个“活 跃事务的判断”，我是准备留到这里再补充的。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL行锁功过</title>
    <link href="/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/"/>
    <url>/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="行锁功过：怎么减少行锁对性能的影响？"><a href="#行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="行锁功过：怎么减少行锁对性能的影响？"></a>行锁功过：怎么减少行锁对性能的影响？</h1><p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM引擎就不支持行锁。</p><p>不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的， 这也是MyISAM被InnoDB替代的重要原因之一。 </p><p>我们今天就主要来聊聊InnoDB的行锁，以及如何通过减少锁冲突来提升业务并发度。 </p><p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。 </p><p>当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导 致程序出现非预期行为，比如两阶段锁。</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p>先给你举个例子。在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字段id是表 t 的主键。</p><p><img src="/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/image-20220415164532375.png" alt="image-20220415164532375"></p><p>这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。 你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p><p><img src="/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/image-20220415165255776.png" alt="image-20220415165255776"></p><p><img src="/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/image-20220415165426000.png" alt="image-20220415165426000"></p><p><img src="/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/image-20220415165839745.png" alt="image-20220415165839745"></p><p><img src="/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/image-20220415170306435.png" alt="image-20220415170306435"></p><blockquote><p>为什么上面 Session A 更新  a = 1 为 a = a + 1，Session B 更新 a = 1 为 a = a + 2，现象是Session B 的更新动作是失败的？</p><p>这里理解一下：更新是先执行引擎，在更新视图，都是在一个事务内。</p></blockquote><p><img src="/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/image-20220415171338385.png" alt="image-20220415171338385"></p><blockquote></blockquote><p>知道了这个答案，你一定知道了事务A持有的两个记录的行锁，都是在commit的时候才释放的。 </p><p>也就是说，在 InnoDB事务中， 行锁是在需要的时候才加上的， 但并不是不需要了就立刻释放， 而是要等到事务结束时才释放。 这个就是两阶段锁协议。 </p><p>知道了这个设定，对我们使用事务有什么帮助呢？</p><p>那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p>我给你举个例子。 假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p><ol><li><p>从顾客A账户余额中扣除电影票价；</p></li><li><p>给影院B的账户余额增加这张电影票价；</p></li><li><p>记录一条交易日志。</p></li></ol><p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交 易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的 顺序呢？</p><p>试想如果<strong>同时</strong>有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为 它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才 释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p><p>好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是， 这并没有完全解决你的困扰。</p><p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动 时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库 每秒就执行不到100个事务。这是什么原因呢？</p><p>这里，我就要说到死锁和死锁检测了。</p><h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致 这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p><p><img src="/2022/04/15/MySQL%E8%A1%8C%E9%94%81%E5%8A%9F%E8%BF%87/image-20220415172753425.png" alt="image-20220415172753425"></p><p>这时候，事务A在等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁。 事务A和 事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ol><li><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout来设置。</p></li><li><p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事 务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</p></li></ol><p>在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现 死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p><p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确 实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会 出现很多误伤。</p><h3 id="主动死锁检测策略"><a href="#主动死锁检测策略" class="headerlink" title="主动死锁检测策略"></a>主动死锁检测策略</h3><h4 id="innodb-deadlock-detect"><a href="#innodb-deadlock-detect" class="headerlink" title="innodb_deadlock_detect"></a>innodb_deadlock_detect</h4><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p><p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁 住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级 的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到 CPU利用率很高，但是每秒却执行不了几个事务。</p><p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结 在于，死锁检测要耗费大量的CPU资源。</p><h4 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h4><h5 id="关闭死锁检测"><a href="#关闭死锁检测" class="headerlink" title="关闭死锁检测"></a>关闭死锁检测</h5><p>一种头痛医头的方法， 就是如果你能确保这个业务一定不会出现死锁， 可以临时把死锁检测关掉。 </p><ol><li>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。</li><li>而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</li></ol><h5 id="并发度控制"><a href="#并发度控制" class="headerlink" title="并发度控制"></a>并发度控制</h5><p>另一个思路是控制并发度。 根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。</p><p>一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。</p><h5 id="中间件控制"><a href="#中间件控制" class="headerlink" title="中间件控制"></a>中间件控制</h5><p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的 团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新， 在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。</p><p>可能你会问，如果团队里暂时没有数据库方面的专家， 不能实现这样的方案， 能不能从设计上优化这个问题呢？</p><h5 id="锁压力分摊"><a href="#锁压力分摊" class="headerlink" title="锁压力分摊"></a>锁压力分摊</h5><p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多 条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账 户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等 待个数，也就减少了死锁检测的CPU消耗。</p><p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会 减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处 理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了MySQL的行锁，涉及了两阶段锁协议、死锁和死锁检测这两大部分内容。 </p><p>其中，我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句。这里的 原则/我给你的建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。</p><p>但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了 三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事 务量。</p><p>如果你要删除一个表里面的前10000行数据，有以下三种方法可 以做到：</p><ol><li>第一种，直接执行delete from T limit 10000; </li><li>第二种，在一个连接中循环执行20次 delete from T limit 500;</li><li>第三种，在20个连接中同时执行delete from T limit 500。</li></ol><p>你会选择哪一种方法呢？为什么呢？</p><p>第二种方式是相对较好的。</p><p>第一种方式（即：直接执行delete from T limit 10000）里面，单个语句占用时间长，锁的时间也 比较长；而且大事务还会导致主从延迟。 </p><p>第三种方式（即：在20个连接中同时执行delete from T limit 500），会人为造成锁冲突。如果可以加上特定条件，将这10000行天然分开，可以考虑第三种。是的，实际上在操作的时候我也建议你尽量拿到ID再删除。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL全局锁和表锁</title>
    <link href="/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/"/>
    <url>/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="全局锁和表锁-：给表加个字段怎么有这么多阻碍？"><a href="#全局锁和表锁-：给表加个字段怎么有这么多阻碍？" class="headerlink" title="全局锁和表锁 ：给表加个字段怎么有这么多阻碍？"></a>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h1><p>数据库锁设计的初衷是处理并发问题。作为多用户共享的资 源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用 来实现这些访 问规则的重要数据结构。</p><p>根据加锁的范围， MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类 。今天这篇文 章，我会和你分享全局锁和表级锁。</p><p>这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是 碰到锁时的现象和其背后的原理。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。</p><p>当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：</p><ol><li>数据更新语句（数据的增删改）、</li><li>数据定义语句（包括 建表、修改表结构等）和</li><li>更新类事务的提交语句。</li></ol><p>全局锁的典型使用场景是， 做全库逻辑备份。 也就是把整库每个表都select出来存成文本。</p><p>以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。 注意，在备份过程中整个库完全处于只读状态。</p><p>但是让整库都只读，听上去就很危险： </p><ol><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆； </li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。 </li></ol><p>看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问 题。 </p><p>假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。 现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。 </p><p>如果时间顺序上是先备份账户余额表(u_account)，然后用户购买 user_buy() ，然后备份用户课程表 (u_course)，会怎么样呢？你可以看一下这个图：</p><p><img src="/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/image-20220415105617341.png" alt="image-20220415105617341"></p><p>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了 一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。 </p><p>作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程 表再备份账户余额表，又可能会出现什么结果？</p><p>也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致 的。</p><p>说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视 图的，对吧？</p><p>是的，就是在可重复读隔离级别下开启一个事务。</p><hr><p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导 数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？一致性读是好， 但<strong>前提是引擎要支持这个隔离级别</strong>。 比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就只能够使用FTWRL命令了。</p><p>所以，single-transaction方法只适用于所有的表使用事务引擎的库。 这往往是DBA要求业务开发人员使用 InnoDB替代MyISAM的原因之一。</p><p>你也许会问，既然要全库只读， 为什么不使用 set global readonly=true的方式呢 ？确实 readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p><ol><li><p>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。 </p></li><li><p>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么 MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。</p><p>而将整个库设置为 readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</p></li></ol><p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><p>但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍 的表级锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁的语法是 lock tables … read/write。 与FTWRL类似，可以用unlock tables主动释放锁， 也可以在客户端断开连接的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>举个例子, 如果在某个线程A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读 写t2的语句都会被阻塞。</p><p><img src="/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/image-20220415162937992.png" alt="image-20220415162937992"></p><p>同时，线程A在执行unlock tables之前，也只能 ( 当前会话 LOCK TABLES 之后，在释放表锁之前只能访问上了锁的这些表 ) 执行读 t1、读写 t2 的操作。连写t1都不允许，自然也不能访问其他表。</p><p><img src="/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/image-20220415163333508.png" alt="image-20220415163333508"></p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>另一类表级的锁是 MDL（ metadata lock)。 MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。</p><p>你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在MySQL 5.5版本中引入了MDL：</p><ol><li>当对一个表做增删改查操作的时候，加 MDL 读锁；</li><li>当要对表做<strong>结构变更</strong>操作的时候，加 MDL 写锁。</li></ol><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p><p>虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。</p><p>你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操 作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也 会出问题。</p><p>我们来看一下下面的操作序列，假设表t是一个小表。备注：这里的实验环境是MySQL 5.6。</p><p><img src="/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/image-20220415153108154.png" alt="image-20220415153108154"></p><p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是 MDL读锁，因此可以正常执行。</p><p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写 锁，因此只能被阻塞。</p><p><img src="/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/image-20220415160429137.png" alt="image-20220415160429137"></p><p><img src="/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/image-20220415160452917.png" alt="image-20220415160452917"></p><p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也 会被session C阻塞。</p><p><img src="/2022/04/15/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/image-20220415161028817.png" alt="image-20220415161028817"></p><p>前面我们说了，<strong>所有对表数据的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表结构现在完全不可读写了。</strong> </p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话（原先的 Session 仍处于Blocked状态并没有关闭），这个库的线程很快就会爆满。 </p><p>你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。 </p><p><strong>基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？</strong> </p><p>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者 kill 掉这个长事务。 </p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p><p>这时候kill可能未必管用，因为新的请求马上就来了。<strong>比较理想的机制是，在alter table语句里面 设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。</strong>之后开发人员或者DBA再通过重试命令重复这个过程。</p><p>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name NOWAIT <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ... <br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name WAIT N <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ...<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–singletransaction参数，对应用会更友好。</p><p>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock tables这样的语句，你需要追查一下，比较可能的情况是：</p><ol><li>要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎； </li><li>要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</li></ol><p>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</p><p>备份一般都会在备库上执行，你在用–single-transaction方法做逻 辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</p><p>假设这个DDL是针对表t1的， 这里我把备份过程中几个关键的语句列出来：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Q1:<span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">REPEATABLE</span> <span class="hljs-keyword">READ</span>; <br>Q2:<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">WITH</span> CONSISTENT <span class="hljs-keyword">SNAPSHOT</span>； <br><span class="hljs-comment">/* other tables */</span> <br>Q3:<span class="hljs-keyword">SAVEPOINT</span> sp; <br><span class="hljs-comment">/* 时刻 1 */</span> <br>Q4:<span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `t1`; <br><span class="hljs-comment">/* 时刻 2 */</span> <br>Q5:<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> `t1`; <br><span class="hljs-comment">/* 时刻 3 */</span> <br>Q6:<span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> <span class="hljs-keyword">SAVEPOINT</span> sp; <br><span class="hljs-comment">/* 时刻 4 */</span> <br><span class="hljs-comment">/* other tables */</span><br></code></pre></td></tr></table></figure><p>在备份开始的时候，为了确保RR（可重复读）隔离级别，再设置一次RR隔离级别(Q1); </p><p>启动事务，这里用 WITH CONSISTENT SNAPSHOT确保这个语句执行完就可以得到一个一致性视图（Q2)； </p><p>设置一个保存点，这个很重要（Q3）； </p><p>show create 是为了拿到表结构(Q4)，然后正式导数据 （Q5），回滚到SAVEPOINT sp，在这里的作用是释放 t1的MDL锁 （Q6。当然这部分属于“超纲”，上文正文里面都没提到。 </p><p>DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后， 如果开始执行，则很快能够执行完成。</p><p>参考答案如下：</p><ol><li><p>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。</p></li><li><p>如果在“时刻 2”到达，则表结构被改过，Q5执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump终止；</p></li><li><p>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：  主从延迟，直到Q6执行完成。 </p></li><li><p>从“时刻4”开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引深入浅出(下)</title>
    <link href="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8B/"/>
    <url>/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出索引（下）"><a href="#深入浅出索引（下）" class="headerlink" title="深入浅出索引（下）"></a>深入浅出索引（下）</h1><p>上一篇文章中，我和你介绍了InnoDB索引的数据结构模型，今天我们再继续聊聊跟MySQL索 引有关的概念。</p><p>我们先来看一下这个问题：</p><p>在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？ 下面是这个表的初始化语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T ( <br>    ID <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key, <br>    k <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>, <br>    s <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>, <br>    index k(k)<br>) engine<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> T <span class="hljs-keyword">values</span>(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;aa&#x27;</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;bb&#x27;</span>),(<span class="hljs-number">300</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;cc&#x27;</span>),(<span class="hljs-number">500</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;ee&#x27;</span>),(<span class="hljs-number">600</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;ff&#x27;</span>),(<span class="hljs-number">700</span>,<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;gg&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8B/image-20220414232248464.png" alt="image-20220414232248464"></p><p>现在，我们一起来看看这条SQL查询语句的执行流程：</p><ol><li><p>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</p></li><li><p>再到ID索引树查到 ID=300 对应的R3；</p></li><li><p>在 k 索引树取下一个值 k=5，取得 ID=500；</p></li><li><p>再回到ID索引树查到 ID=500 对应的 R4；</p></li><li><p>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</p></li></ol><p>在这个过程中，第 2、3 步回到主键索引树搜索的过程， 我们称为回表 。可以看到，这个查询过程读了k 索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。 在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值 已经在k索引树上了，因此可以直接提供查询结果，不需要回表。</p><p>也就是说，在这个查询里面， 索引 k 已经 “覆盖了” 我们的查询需求，我们称为覆盖索引。</p><p>由于覆盖索引可以减少树的搜索次数， 显著提升查询性能， 所以使用覆盖索引是一个常用的性能优化手段。</p><p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。</p><p>备注：关于如何查看扫描行数的问题，我将会在第16文章《如何正确地显示随机消息？》 中，和你详细讨论。</p><p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上， 是否有必要将身份证号和名字建立联合索引？</p><p>在一个市民信息表上，假设这个市民表的定义是这样的：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`tuser`</span> ( <br>    <span class="hljs-symbol">`id`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-symbol">`id_card`</span> varchar(<span class="hljs-number">32</span>) DEFAULT <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">32</span>) DEFAULT <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-symbol">`age`</span> int(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-symbol">`ismale`</span> tinyint(<span class="hljs-number">1</span>) DEFAULT <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>), <br>    <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`id_card`</span> (<span class="hljs-symbol">`id_card`</span>), <br>    <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`name_age`</span> (<span class="hljs-symbol">`name`</span>,<span class="hljs-symbol">`age`</span>) <br>) ENGINE=InnoDB<br></code></pre></td></tr></table></figure><p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求， 我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是 不是浪费空间？</p><p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它 可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p><p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑 了。这正是业务DBA，或者称为业务数据架构师的工作。</p><h2 id="最左前缀匹配"><a href="#最左前缀匹配" class="headerlink" title="最左前缀匹配"></a>最左前缀匹配</h2><p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现 在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但 总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的 索引又感觉有点浪费。应该怎么做呢？</p><p>这里，我先和你说结论吧。B+树这种索引结构， 可以利用索引的 “ 最左前缀 ” ， 来定位记录。</p><p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p><p><img src="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8B/image-20220414234154466.png" alt="image-20220414234154466"></p><p>可以看到，索引项（如 (”李四“, 20)）是按照索引定义 ( KEY name_age (name, age) ) 里面出现的字段顺序排序的。</p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p><p>如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p><p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左 前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。 </p><h3 id="索引定义的字段顺序安排"><a href="#索引定义的字段顺序安排" class="headerlink" title="索引定义的字段顺序安排"></a>索引定义的字段顺序安排</h3><p>基于上面对最左前缀索引的说明，我们来讨论一个问题：</p><p>在建立联合索引的时候， 如何安排索引内的字段顺序。 这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。</p><h4 id="第一原则：索引复用原则"><a href="#第一原则：索引复用原则" class="headerlink" title="第一原则：索引复用原则"></a>第一原则：索引复用原则</h4><p>因此，<strong>第一原则</strong>是， 如果通过调整顺序， 可以少维护一个索引， 那么这个顺序往往就是需要优先考虑采用的。 </p><p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索引，并用这个索引支持 “根据身份证号查询地址” 的需求。 </p><hr><p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使 用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、 (b) 这两个索引。 </p><h4 id="第二原则：最小成本原则"><a href="#第二原则：最小成本原则" class="headerlink" title="第二原则：最小成本原则"></a>第二原则：最小成本原则</h4><p>这时候，我们要考虑的<strong>第二原则</strong>就是空间考虑的原则就是空间 了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name, age) 的联合索引和一个(age)的单字段索引。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能 要问，那些不符合最左前缀的部分，会怎么样呢？ </p><p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一 个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tuser <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;张%&#x27;</span> <span class="hljs-keyword">and</span> age=<span class="hljs-number">10</span> <span class="hljs-keyword">and</span> ismale=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张” （age 为什吗没用到？先这样理解，在姓名和年龄上建立联合索引，就相当于是以 <strong>姓名+年龄拼接作为KEY</strong>，这个KEY是一个整体，不能把姓名和年龄分开看。），找到第一个满足 条件的记录 ID3。当然，这还不错，总比全表扫描要好。</p><p>然后是判断其他条件是否满足。 </p><p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。 </p><p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 </p><p>图3和图4，是这两个过程的执行流程图。</p><p><img src="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8B/%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%B5%81%E7%A8%8B.png" alt="图-3"></p><p><img src="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8B/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E8%BF%87%E7%A8%8B.png" alt="图-4"></p><p>在这两个图里面，每一个虚线箭头表示回表一次。</p><p>图 3 中，在 (name,age) 索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值， 只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p><p>图 4 跟图 3 的区别是，InnoDB在 (name,age) 索引内部就判断了age 是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我 们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。</p><h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><p>实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维 护的库里面，有这么一个表，表结构定义类似这样的：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`geek`</span> ( <br>    <span class="hljs-symbol">`a`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-symbol">`b`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-symbol">`c`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-symbol">`d`</span> int(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>, <br>    <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`a`</span>,<span class="hljs-symbol">`b`</span>), <br>    <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`c`</span> (<span class="hljs-symbol">`c`</span>), <br>    <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`ca`</span> (<span class="hljs-symbol">`c`</span>,<span class="hljs-symbol">`a`</span>), <br>    <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`cb`</span> (<span class="hljs-symbol">`c`</span>,<span class="hljs-symbol">`b`</span>) <br>) ENGINE=InnoDB;<br></code></pre></td></tr></table></figure><p>公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。</p><p>但是，学过本章内容的小吕又纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建 “ca”、“cb” 这两个索引？</p><p>同事告诉他，是因为他们的业务里面有这样的两种语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> geek <span class="hljs-keyword">where</span> c=N <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>; <br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> geek <span class="hljs-keyword">where</span> c=N <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？</p><p>表记录：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">–a--|–b--|–c--|–d-<br>1    <span class="hljs-number"> 2 </span>  <span class="hljs-number"> 3 </span>   d <br>1    <span class="hljs-number"> 3 </span>  <span class="hljs-number"> 2 </span>   d  <br>14<span class="hljs-number"> 3 </span>   d <br>2    <span class="hljs-number"> 1 </span>  <span class="hljs-number"> 3 </span>   d <br>2    <span class="hljs-number"> 2 </span>  <span class="hljs-number"> 2 </span>   d <br>2    <span class="hljs-number"> 3 </span>  <span class="hljs-number"> 4 </span>   d<br></code></pre></td></tr></table></figure><p>主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。</p><p>索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">–c</span>--<span class="hljs-comment">|–a</span>--<span class="hljs-comment">|–</span> <span class="hljs-comment">主键部分b</span>-- <span class="hljs-comment">（注意，这里不是ab，而是只有b）</span><br><span class="hljs-comment">213</span><br><span class="hljs-comment">222</span><br><span class="hljs-comment">312</span><br><span class="hljs-comment">314</span><br><span class="hljs-comment">321</span><br><span class="hljs-comment">423</span><br></code></pre></td></tr></table></figure><p>这个跟索引c的数据是一模一样的。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">–c</span>--<span class="hljs-comment">|–主键部分a</span>--<span class="hljs-comment">|–</span> <span class="hljs-comment">主键部分b</span>-- <span class="hljs-comment">（注意，这里不是ab，而是只有b）</span><br><span class="hljs-comment">21</span> <span class="hljs-comment">3</span><br><span class="hljs-comment">22</span> <span class="hljs-comment">2</span><br><span class="hljs-comment">31</span> <span class="hljs-comment">2</span><br><span class="hljs-comment">31</span> <span class="hljs-comment"></span> <span class="hljs-comment">4</span><br><span class="hljs-comment">32</span> <span class="hljs-comment">1</span><br><span class="hljs-comment">42</span> <span class="hljs-comment">3</span><br></code></pre></td></tr></table></figure><p>索引 cb 的组织是先按c排序，在按b排序，同时记录主键</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">–c</span>--<span class="hljs-comment">|–b</span>--<span class="hljs-comment">|–</span> <span class="hljs-comment">主键部分a</span>-- <span class="hljs-comment">（同上）</span><br><span class="hljs-comment">222</span><br><span class="hljs-comment">231</span><br><span class="hljs-comment">312</span><br><span class="hljs-comment">321</span><br><span class="hljs-comment">341</span><br><span class="hljs-comment">432</span><br></code></pre></td></tr></table></figure><p>所以，结论是ca可以去掉，cb需要保留。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引深入浅出(上)</title>
    <link href="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8A/"/>
    <url>/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出索引（上）"><a href="#深入浅出索引（上）" class="headerlink" title="深入浅出索引（上）"></a>深入浅出索引（上）</h1><p>提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个SQL查询比较慢， 分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引， 索引又是如何工作的呢？</p><p>索引是数据库系统里面最重要的概念之一， 所以我希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识 点，加深你对数据库索引的理解。</p><p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一 会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><h2 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h2><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模 型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的 数据结构，它们分别是哈希表、有序数组和搜索树。</p><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找 到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个 确定的位置，然后把value放在数组的这个位置。</p><p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方 法是，拉出一个链表。</p><p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应 的哈希索引的示意图如下所示：</p><p><img src="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8A/image-20220414171650039.png" alt="image-20220414171650039"></p><p>图中，User2 和 User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设， 这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：</p><ol><li>首先，将ID_card_n2通过哈希函数算出N；</li><li>然后，按顺序遍历，找到User2。</li></ol><p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的 User 时速度会 很快，只需要往后追加。但缺点是，因为不是有序的，所以<strong>哈希索引做区间查询的速度是很慢 的。</strong></p><p>你可以设想下，如果你现在要找身份证号在 <strong>[ID_card_X, ID_card_Y]</strong> 这个区间的所有用户，就必 须全部扫描一遍了。</p><p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong> ，比如<strong>Memcached</strong>及其他一些NoSQL引 擎。</p><h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p>而有序数组在等值查询和范围查询场景中的性能就都非常优秀有序数组在等值查询和范围查询场景中的性能就都非常优秀 。</p><p>还是上面这个根据身份证号 查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p><p><img src="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8A/image-20220414172037107.png" alt="image-20220414172037107"></p><p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你 要查ID_card_n2对应的名字，用<strong>二分法</strong>就可以快速得到，这个**时间复杂度是O(log(N))**。</p><p>同时很显然，这个索引结构支持范围查询：</p><ol><li>你要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，</li><li>可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User）</li><li>然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</li></ol><p><strong>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦 了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</strong></p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong> ，比如你要保存的是2017年某个城市的所有人口 信息，这类不会再修改的数据。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二 叉搜索树来实现的话，示意图如下所示：</p><p><img src="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8A/image-20220414172215088.png" alt="image-20220414172215088"></p><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。</p><p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更 新的时间复杂度也是O(log(N))。</p><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右 递增。</p><p>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在 机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该 使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。 </p><p>以 InnoDB 的一个整数字段索引为例，这个N差不多是1200。这棵树高是 4 的时候，就可以存1200 的 3 次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p>N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中 了。</p><p>不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数 据库技术发展到今天，<strong>跳表</strong>、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开 了。</p><p><strong>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我 们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</strong></p><p>建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。</p><p>在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索 引的工作方式并不一样。</p><p>而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和你分析一下其中的索引模型。</p><h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。 又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p>InnoDB采用的B+树结构，以及为什么 InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</p><p>每一个索引在InnoDB里面对应一棵B+树。</p><p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。</p><p>这个表的建表语句是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T( <br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key, <br>    k <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>, <br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>), <br>    index (k)<br>)engine<span class="hljs-operator">=</span>InnoDB;<br></code></pre></td></tr></table></figure><p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。</p><p><img src="/2022/04/14/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E4%B8%8A/image-20220414172515741.png" alt="image-20220414172515741"></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。</p><ol><li><p>主键索引的叶子节点存的是整行数据。在InnoDB里，<strong>主键索引也被称为聚簇索引</strong>（clustered index）。</p></li><li><p>非主键索引的叶子节点内容是主键（<strong>如果一个表上没有设置主键，这个非主键索引的节点中应该存的啥呢？InnoDB必须有唯一索引（主键），如果没有指定的话InnoDB会自己生成一个隐藏列Row_id充当默认主键</strong>）的值。在InnoDB里，<strong>非主键索引也被称为二级索引</strong> （secondary index）。</p></li></ol><p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？ </p><ol><li>如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID 的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ol><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主 键查询。</p><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p><p>以上面这个图为例：</p><ol><li>如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。</li><li>如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</li></ol><h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中， 整体空间利用率降低大约50%。 </p><h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合 并的过程，可以认为是分裂过程的逆过程。 </p><p>基于上面的索引维护过程说明，我们来讨论一个案例：</p><blockquote><p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p></blockquote><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。 插入新记录的时候可以不指定 ID 的值，系统会获取当前ID最大值加 1 作为下一条记录的 ID 值。 </p><p>也就是说，<strong>自增主键的插入数据模式</strong>，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都<strong>不涉及到挪动</strong>其他记录，也<strong>不会触发叶子节点的分裂</strong>。</p><p>而由业务逻辑的字段做主键，则往往不容易保证有序插入，可能会涉及到其他记录挪动和触发叶节点分裂，写数据成本相对较高。 </p><p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如 字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？ </p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的 叶子节点占用约 20 个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是 8个字节。 显然， 主键长度越小， 普通索引的叶子节点就越小， 普通索引占用的空间也就越小。 所以，<strong>从性能和存储空间方面考量，自增主键往往是更合理的选择</strong>。 </p><p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样 的：</p><ol><li><p>只有一个索引；</p></li><li><p>该索引必须是唯一索引。</p></li></ol><p>你一定看出来了，这就是典型的KV场景。 由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。 这时候我们就要优先考虑上一段提到的 “尽量使用主键查询” 原则，直接将这个索引设置为主键， 可以避免每次查询需要搜索两棵树。</p><h2 id="索引重建"><a href="#索引重建" class="headerlink" title="索引重建"></a>索引重建</h2><p>对于上面例子中的InnoDB表T，如果你要重建索引 k，你的两个 SQL语句可以这么写：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> T <span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> k; <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> T <span class="hljs-keyword">add</span> <span class="hljs-keyword">index</span>(k);<br></code></pre></td></tr></table></figure><p>如果你要重建主键索引，也可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> T <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key; <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> T <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(id);<br></code></pre></td></tr></table></figure><p>问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好 的方法是什么？</p><p>重建索引 k 的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。</p><p>不论是<strong>删除主键还是创建主键</strong>，都会将整个表的索引重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。在专栏的第12篇文章 《为什么表数据删掉一半，表文件大小不变？》中，我会和你分析这条语句的执行流程。</p><p>有同学问到为什么要重建索引 ？</p><p>我们文章里面有提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务隔离：为什么你改了我还看不见</title>
    <link href="/2022/04/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/"/>
    <url>/2022/04/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/</url>
    
    <content type="html"><![CDATA[<h1 id="事务隔离：为什么你改了我还看不见？"><a href="#事务隔离：为什么你改了我还看不见？" class="headerlink" title="事务隔离：为什么你改了我还看不见？"></a>事务隔离：为什么你改了我还看不见？</h1><p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转 账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必 须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时 间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事 务”这个概念了。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引 擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p><p>今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给 出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。</p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一 致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non- repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要 在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、 读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ol><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 </li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 </li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 </li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突 的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ol><p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中 只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(c <span class="hljs-type">int</span>) engine<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> T(c) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><img src="/2022/04/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/image-20220413223020855.png" alt="image-20220413223020855"></p><p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3 的返回值分别是什么：</p><ol><li>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被 A看到了。因此，V2、V3也都是2。 </li><li>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。 </li><li>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求： 事务在执行期间看到的数据前后必须是一致的。 </li><li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后， 事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li></ol><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准：</p><ol><li>在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li><li>在“读提交”隔离级别下，这个视图是在每条SQL语句开始执行的时候创建的。</li><li>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</li><li>而“串行化”隔离级别下直接用加锁的方式来避 免并行访问。</li></ol><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其 实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致， 你一定要记得将MySQL的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用 show variables来查看当前的值。</p><p><img src="/2022/04/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/image-20220413223603241.png" alt="image-20220413223603241"></p><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。 我想你可能会问那什么时候需要你可能会问那什么时候需要 “ 可重复读 ” 的场景呢 ？我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时 候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。 你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。<strong>事务启动时的视图可以认为是静态的，不受其他事务 更新的影响。</strong></p><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复 读”。</p><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通 过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="/2022/04/13/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81/image-20220413223914931.png" alt="image-20220413223914931"></p><p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看 到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多 个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的 事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。 也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数 据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终 提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候 展开。</p><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并 不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p><ol><li><p>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</p></li><li><p>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</p></li></ol><p>有些客户端连接框架会默认连接成功后先执行一个set autocommit=0的命令。这就导致接下来的 查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，我会建议你总是使用set autocommit=1, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式 每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾 虑，我建议你使用 commit work and chain 命令。</p><p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查 找持续时间超过60s的事务。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章里面，介绍了MySQL的事务隔离级别的现象和实现，根据实现原理分析了长事务存 在的风险，以及如何用正确的方式避免长事务。希望我举的例子能够帮助你理解事务，并更好地 使用MySQL的事务特性。 </p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？ </p><p>这个问题，我们可以从应用开发端和数据库端来看。</p><p>首先， 从应用开发端来看：</p><ol><li><p>确认是否使用了set autocommit=0。这个确认工作可以在测试环境中开展，把MySQL的 general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</p></li><li><p>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。我 见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务 可以去掉。</p></li><li><p>业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后 续的文章中会提到这类案例）</p></li></ol><p>其次， 从数据库端来看： </p><ol><li><p>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill；</p></li><li><p>Percona的pt-kill这个工具不错，推荐使用；</p></li><li><p>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；</p></li><li><p>如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础架构:更新操作的执行</title>
    <link href="/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <url>/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="日志系统：一条SQL更新语句是如何执行的？"><a href="#日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="日志系统：一条SQL更新语句是如何执行的？"></a>日志系统：一条SQL更新语句是如何执行的？</h1><p>一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后 到达存储引擎。那么，一条更新语句的执行流程又是怎样的呢？</p><p>之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你 是不是心中也会不免会好奇，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个 整型字段c：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(ID <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key, c <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>如果要将ID=2这一行的值加1，SQL语句就会这么写：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql&gt; update T <span class="hljs-builtin-name">set</span> <span class="hljs-attribute">c</span>=c+1 where <span class="hljs-attribute">ID</span>=2;<br></code></pre></td></tr></table></figure><p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看 这个图回顾下。<strong>首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</strong></p><p><img src="/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C/image-20220413215515778.png" alt="image-20220413215515778"></p><p>你执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，<strong>在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会 把表T上所有缓存结果都清空。</strong>这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。 然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主 角：</p><ol><li>redo log（重做日志）和 </li><li>binlog（归档日志）</li></ol><p>如果接触MySQL，那这两个词肯定是绕不过 的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p><h2 id="redo-log模块"><a href="#redo-log模块" class="headerlink" title="redo log模块"></a>redo log模块</h2><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记 录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会 有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。 </p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ol><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉； </li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ol><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到 这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老 花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的 帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到 对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问 题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><h3 id="WAL技术"><a href="#WAL技术" class="headerlink" title="WAL技术"></a>WAL技术</h3><p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是WriteAhead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里 面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作 记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的 事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎 么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把 这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C/image-20220413220100367.png" alt="image-20220413220100367"></p><p>类似快慢指针的思想：</p><ol><li>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。</li><li>checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</li><li>write pos 到 checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。</li><li>checkpoint 到 write pos 之间的是“粉板”上已经记录的日志。</li><li>如果write pos 追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</li></ol><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个 能力称为crash-safe。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或 写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板 上的数据明确赊账账目。</p><h2 id="binlog日志模块"><a href="#binlog日志模块" class="headerlink" title="binlog日志模块"></a>binlog日志模块</h2><p>前面我们讲过，MySQL整体来看，其实就有两块：</p><ol><li>一块是Server层，它主要做的是MySQL功能层面的事情；</li><li>还有一块是引擎层，负责存储相关的具体事宜。</li></ol><p>上面我们聊到的粉板redo log是 InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有 crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统—— 也就是 redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。 </p><ol><li><p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</p></li><li><p>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。</p></li><li><p>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 </p></li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语 句时的内部流程。</p><ol><li>执行器先找引擎取ID=2这一行数据。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行 数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处 于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更 新完成。 </li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><p><img src="/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E6%89%A7%E8%A1%8C/image-20220413221114648.png" alt="image-20220413221114648"></p><p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><h3 id="redolog-的-2PC-两阶段提交"><a href="#redolog-的-2PC-两阶段提交" class="headerlink" title="redolog 的 2PC-两阶段提交"></a>redolog 的 2PC-两阶段提交</h3><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。</p><p>要说明这个问题，我们得 从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？怎样让数据库恢复到半个月内任意一秒的状态？</p><p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承 诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期 做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数 据，那你可以这么做：</p><ol><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库； </li><li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li><li>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢 复到线上库去。</li></ol><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法 来进行解释。</p><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语 句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><ol><li><p>先写 redo log后写 binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回 来，所以恢复后这一行c的值是1。 但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。 然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p></li><li><p>先写 binlog后写 redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日 志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</p></li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的 状态不一致。 </p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？ 其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。 </p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保 持逻辑上的一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证 MySQL异常重启之后数据不丢失。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建 议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><p>我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑 一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p><p>一天一备比一周一备的优势在于 “最长恢复时间” 更短。 </p><p>在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天 0 点做一次全量备份， 而要恢复出一个到昨天晚上23点的备份。</p><p> 一周一备最坏情况就要应用一周的binlog了。 </p><p>系统的对应指标就是 RTO（恢复目标时间）。 </p><p>当然一天一备份是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个较短的 RTO是拿存储成本换来的，需要你根据业务重要性来评估是一天一备份还是一周一备份了。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础架构:查询的执行</title>
    <link href="/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <url>/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="基础架构：一条SQL查询语句是如何执行的？"><a href="#基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="基础架构：一条SQL查询语句是如何执行的？"></a>基础架构：一条SQL查询语句是如何执行的？</h1><p>有个最简 单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID=<span class="hljs-number">10</span>；<br></code></pre></td></tr></table></figure><p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p><p>所以今天我想和你一起把MySQL拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程， 让你对MySQL有更深入的理解。这样当我们碰到MySQL的一些异常或者问题时，就能够直戳本 质，更为快速地定位并解决问题。</p><p>下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功 能模块中的执行过程。</p><p><img src="/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C/MySQL%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="MySQL架构图"></p><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p><ol><li><strong>Server层</strong>：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等。</li><li><strong>存储引擎层</strong>：负责数据的<strong>存储</strong>和<strong>提取</strong>。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li></ol><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不 过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine=memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。</p><p>从图中不难看出，不同的存储引擎共用一个Server层 ，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条SQL语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，要先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连 接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp">mysql -h<span class="hljs-variable">$ip</span> -<span class="hljs-keyword">P</span><span class="hljs-variable">$port</span> -u<span class="hljs-variable">$user</span> -p<br></code></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行 中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器 就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li><p>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序 结束执行。</p></li><li><p>如果用户名密码认证通过，连接器会到权限表里面查出这个登录用户拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p></li></ul><p>这就意味着，<strong>一个用户成功建立连接后并在连接断开之前，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。</strong>修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命 令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="/2022/04/13/MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84-%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C/%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5.png" alt="空闲连接"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制 的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接 则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是 尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为 MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开 连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p></li></ol><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过 的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。</p><p>如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存 中。</p><p>可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结 果，这个效率会很高。</p><p>但是大多数情况下我会建议你不要使用查询缓存， 为什么呢？因为查询缓存往往弊大于利。</p><ol><li>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此 很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。</li><li>对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</li></ol><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">mysql&gt; <span class="hljs-keyword">select</span> SQL_CACHE * <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID=<span class="hljs-number">10</span>；<br></code></pre></td></tr></table></figure><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识 别出里面的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别 成“表名T”，把字符串“ID”识别成“列ID”。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>做完了词法分析以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则， 判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个 语句select少打了开头的字母“s”。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">mysql&gt; elect * from t where ID=1;<br><br>ERROR 1064 (42000): You have an error in your SQ<span class="hljs-class">L syntax;</span><span class="hljs-built_in"> check </span>the manual that corresponds to your MyS<br></code></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join） 的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span>&gt; select * from t<span class="hljs-number">1</span> join t<span class="hljs-number">2</span> using(ID) where t<span class="hljs-number">1</span>.c=<span class="hljs-number">10</span> and t<span class="hljs-number">2</span>.d=<span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li><p>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是 否等于20。</p></li><li><p>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否 等于10。</p></li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择 使用哪一个方案。 </p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些 疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单 独展开说明优化器的内容。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。 </p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有 权限的错误，如下所示。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID=<span class="hljs-number">10</span>;<br><br>ERROR <span class="hljs-number">1142</span> (<span class="hljs-number">42000</span>): <span class="hljs-keyword">SELECT</span> command denied <span class="hljs-keyword">to</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;b&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;T&#x27;</span><br></code></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引 擎提供的接口。 </p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多:</p><ol><li>第一次调用的是“取满足条件的第一行” 这个接口，</li><li>之后循环取“满足条件的下一行” 这个接口，</li><li>这些接口都是引擎中已经定义好的。 </li></ol><p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了 多少行。这个值就是<strong>在执行器每次调用引擎获取数据行的时候累加的</strong>。 </p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数</strong>跟 rows_examined并不是完全相同的。 我们后面会专门有一篇文章来讲存储引擎的内部机制， 里面会有详细的说明。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那 肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是</p><p>在我们上面提到的哪个阶段报出来的呢？</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O模型</title>
    <link href="/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="何为-I-O"><a href="#何为-I-O" class="headerlink" title="何为 I/O?"></a>何为 I/O?</h3><p>即<strong>I</strong>nput输入/<strong>O</strong>utput输出，我们先从计算机结构的角度来解读一下 I/O。</p><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p><ul><li>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。</li><li>网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</li></ul><p><img src="/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA.png" alt="冯诺依曼体系结构"></p><p>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。我们再先从应用程序的角度来解读一下 I/O。</p><p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 ：</p><ul><li><strong>用户空间（User space）</strong> ：像我们平常运行的应用程序都是运行在用户空间</li><li><strong>内核空间（Kernel space ）</strong>：只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</li></ul><p>并且，用户空间的程序不能直接访问内核空间。要执行 IO 操作时，由于用户空间没有执行这些操作的权限，只能发起<strong>系统调用</strong>请求操作系统帮忙完成。因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间。</p><p>在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><h3 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h3><p>UNIX 系统下， IO 模型一共有 5 种： </p><ol><li><strong>同步阻塞 I/O</strong></li><li><strong>同步非阻塞 I/O</strong></li><li><strong>I/O 多路复用</strong></li><li><strong>信号驱动 I/O</strong> </li><li><strong>异步 I/O</strong></li></ol><p>这也是我们经常提到的 5 种 IO 模型。</p><h2 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><p><img src="/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B.png" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>，也有很多人认为，Java 中的 NIO 属于<strong>同步非阻塞 IO 模型</strong>。跟着我的思路往下看看，相信你会得到答案！</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><p><img src="/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><p>同步非阻塞 IO 模型中，<strong>应用程序会一直轮询发起 read 调用（系统调用会立即返回数据准备情况：准备中，或者准备完成）直至内核反馈数据准备完成</strong>，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><hr><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进，通过轮询操作，避免了一直阻塞。但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p><p><img src="/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt="img"></p><p>IO 多路复用模型中，线程首先发起 select 调用（个人理解：事件），询问内核数据是否准备就绪（个人理解：回调）<strong>「个人理解（不过这个理解好像也不太对，区别AIO）这里是通过事件回调机制，否则不就退化阻塞IO模型了」</strong>，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p><img src="/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/JavaNIOSelector%E6%A6%82%E5%BF%B5.png" alt="img"></p><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。异步 IO 是<strong>基于事件和回调机制实现</strong>的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/AIO%E6%A8%A1%E5%9E%8B.png" alt="img"></p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><p><img src="/2022/04/13/I-O%E6%A8%A1%E5%9E%8B/BIONIOAIO%E5%AF%B9%E6%AF%94.png" alt="img"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入拆解 Tomcat &amp; Jetty》</li><li>如何完成一次 IO：<a href="https://llc687.top/post/%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1-io/">https://llc687.top/post/如何完成一次-io/open in new window</a></li><li>程序员应该这样理解 IO：<a href="https://www.jianshu.com/p/fa7bdc4f3de7">https://www.jianshu.com/p/fa7bdc4f3de7open in new window</a></li><li>10 分钟看懂， Java NIO 底层原理：<a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html">https://www.cnblogs.com/crazymakercircle/p/10225159.html</a></li><li>IO 模型知多少 | 理论篇：<a href="https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html">https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html</a></li><li>《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD-领域驱动设计</title>
    <link href="/2021/10/07/DDD-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/10/07/DDD-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="DDD-领域驱动设计"><a href="#DDD-领域驱动设计" class="headerlink" title="DDD-领域驱动设计"></a>DDD-领域驱动设计</h1><p>互联网大厂的未来架构之道：DDD-领域驱动设计</p><p>用于：</p><p>1、提升代码质量，优化系统结构；</p><p>2、体系化提升架构思维；</p><p>3、用DDD来提升自己的软实力；</p><p>4、架构师成长之道。</p><h2 id="什么是DDD"><a href="#什么是DDD" class="headerlink" title="什么是DDD"></a>什么是DDD</h2><p>书：领域驱动设计-软件核心复杂性应对之道</p><p>话：成功的想目有一个共同的特征，那就是都有一个丰富的领域模型，这个模型在迭代设计过程中不断演变，而且成为项目不可分割的一部分。</p><p>思潮：技术主动理解业务，业务如何运行，成程序就如何构建。让不怎么使用技术语言的领域专家一起参与软件的设计。</p><h3 id="系统老化"><a href="#系统老化" class="headerlink" title="系统老化"></a>系统老化</h3><p>需求难：我又不知道你这个系统怎么实现的，系统越来越复杂，需求要怎么提？</p><p>开发难：一个类上千行代码，怎么看？这段代码有什么用？能不能去掉？</p><p>创新难：外面新技术越来越多，我们这个老系统没有时间重构，越拖越烂；</p><p>测试难：没办法进行单元测试，一个小需求又要回归测试。</p><p><img src="/2021/10/07/DDD-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/Snipaste_2021-10-07_21-29-32.png"></p><p>DDD 被认为是目前最理想的方式</p><p><img src="/2021/10/07/DDD-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/Snipaste_2021-10-07_21-37-32.png"></p><p><img src="/2021/10/07/DDD-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/Snipaste_2021-10-07_21-41-14.png"></p><p><img src="/2021/10/07/DDD-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/Snipaste_2021-10-07_22-00-52.png"></p><p><img src="/2021/10/07/DDD-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/Snipaste_2021-10-07_22-37-53.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>领域驱动设计</tag>
      
      <tag>架构设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL性能问题:慢SQL问题分析</title>
    <link href="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="慢SQL问题分析"><a href="#慢SQL问题分析" class="headerlink" title="慢SQL问题分析"></a>慢SQL问题分析</h1><p>今天和大家聊一个常见的问题：慢SQL。</p><p>通过本文你将了解到以下内容：</p><ul><li>慢SQL的危害</li><li>SQL语句的执行过程</li><li>存储引擎和索引的那些事儿</li><li>慢SQL解决之道</li></ul><p>后续均以MySQL默认存储引擎InnoDB为例进行展开，话不多说，开搞！</p><hr><h2 id="一、慢SQL-的危害"><a href="#一、慢SQL-的危害" class="headerlink" title="一、慢SQL 的危害"></a>一、慢SQL 的危害</h2><p>今天和大家聊一个常见的问题：慢SQL。通过本文你将了解到以下内容：</p><ol><li>慢SQL的危害</li><li>SQL语句的执行过程</li><li>存储引擎和索引的那些事儿</li><li>慢SQL解决之道</li></ol><p>后续均以MySQL默认存储引擎InnoDB为例进行展开，话不多说，开搞！</p><hr><p>慢SQL，就是跑得很慢的SQL语句，你可能会问慢SQL会有啥问题吗？试想一个场景：</p><blockquote><p>大白和小黑端午出去玩，机票太贵于是买了高铁，火车站的人真是乌央乌央的。</p><p>马上检票了，大白和小黑准备去厕所清理下库存，坑位不多，排队的人还真不少。</p><p>小黑发现其中有3个坑的乘客贼慢，其他2个坑位换了好几波人，这3位坑主就是不出来。</p><p>等在外面的大伙，心里很是不爽，长期占用公共资源，后面的人没法用。</p><p>小黑苦笑道：这不就是厕所版的慢SQL嘛！</p></blockquote><p>这是实际生活中的例子，换到MySQL服务器也是一样的，毕竟科技源自生活嘛。</p><hr><p>MySQL服务器的资源(CPU、IO、内存等)是有限的，尤其在高并发场景下需要快速处理掉请求，否则一旦出现慢SQL就会阻塞掉很多正常的请求，造成大面积的失败/超时等。</p><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_22-51-28.png"></p><hr><h2 id="二、SQL执行过程"><a href="#二、SQL执行过程" class="headerlink" title="二、SQL执行过程"></a>二、SQL执行过程</h2><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_22-53-18.png"></p><p>客户端和MySQL服务端的交互过程简介：</p><blockquote><ol><li>客户端发送一条SQL语句给服务端，服务端的连接器先进行账号/密码、权限等环节验证，有异常直接拒绝请求。</li><li>服务端查询缓存，如果SQL语句命中了缓存，则返回缓存中的结果，否则继续处理。</li><li>服务端对SQL语句进行词法解析、语法解析、预处理来检查SQL语句的合法性。</li><li>服务端通过优化器对之前生成的解析树进行优化处理，生成最优的物理执行计划。</li><li>将生成的物理执行计划调用存储引擎的相关接口，进行数据查询和处理。</li><li>处理完成后将结果返回客户端。</li></ol></blockquote><hr><p>客户端和MySQL服务端的交互过程简图：</p><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_22-54-20.png"></p><p>俗话说”条条大路通罗马”，优化器的作用就是找到这么多路中最优的那一条。<strong>存储引擎更是决定SQL执行的核心组件，适当了解其中原理十分有益</strong>。</p><hr><h2 id="三、存储引擎和索引那些事儿"><a href="#三、存储引擎和索引那些事儿" class="headerlink" title="三、存储引擎和索引那些事儿"></a>三、存储引擎和索引那些事儿</h2><h3 id="1、存储引擎"><a href="#1、存储引擎" class="headerlink" title="1、存储引擎"></a>1、存储引擎</h3><p>InnoDB存储引擎(Storage Engine)是MySQL默认之选。<strong>存储引擎的主要作用是进行数据的存取和检索，也是真正执行SQL语句的组件。</strong></p><p>InnoDB的整体架构分为两个部分：内存架构和磁盘架构，如图：</p><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_22-55-46.png"></p><blockquote><p>存储引擎的内容非常多，并不是一篇文章能说清楚的，本文不过多展开，我们在此只需要了解内存架构和磁盘架构的大致组成即可。</p></blockquote><p>InnoDB 引擎是<strong>面向行存储</strong>的，数据都是存储在磁盘的数据页中，数据页里面按照固定的行格式存储着每一行数据。</p><blockquote><p>行格式主要分为四种类型Compact、Redundant、Dynamic和Compressed，<strong>默认为Compact格式</strong>。</p></blockquote><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_22-56-56.png"></p><h4 id="1-1、磁盘预读机制和局部性原理"><a href="#1-1、磁盘预读机制和局部性原理" class="headerlink" title="1.1、磁盘预读机制和局部性原理"></a>1.1、磁盘预读机制和局部性原理</h4><p>当计算机访问一个数据时，不仅会加载当前数据所在的数据页，还会将当前数据页相邻的数据页一同加载到内存，磁盘预读的长度一般为页的整倍数，从而有效降低磁盘IO的次数。</p><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_22-57-48.png"></p><h4 id="1-2、磁盘和内存的交互"><a href="#1-2、磁盘和内存的交互" class="headerlink" title="1.2、磁盘和内存的交互"></a>1.2、磁盘和内存的交互</h4><p>MySQL中磁盘的数据需要被交换到内存，才能完成一次SQL交互，大致如图：</p><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_22-58-27.png"></p><ul><li>扇区是硬盘的读写的基本单位，通常情况下每个扇区的大小是 512B</li><li>磁盘块文件系统读写数据的最小单位，相邻的扇区组合在一起形成一个块，一般是4KB</li><li>页（操作系统页）是内存的最小存储单位，页的大小通常为磁盘块大小的 2^n 倍</li><li>InnoDB页面（MySQL数据页）的默认大小是16KB，是数倍个操作系统的页</li></ul><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_22-59-21.png"></p><h4 id="1-3、随机磁盘IO"><a href="#1-3、随机磁盘IO" class="headerlink" title="1.3、随机磁盘IO"></a>1.3、随机磁盘IO</h4><p>MySQL的数据是一行行存储在磁盘上的，并且这些数据并非物理连续地存储，这样的话要查找数据就无法避免随机在磁盘上读取和写入数据。</p><p>对于MySQL来说，当出现大量磁盘随机IO时，大部分时间都被浪费到寻道上，磁盘呼噜呼噜转，就是传输不了多少数据。</p><blockquote><p>一次磁盘访问由三个动作组成：</p><ul><li>寻道：磁头移动定位到指定磁道</li><li>旋转：等待指定扇区从磁头下旋转经过</li><li>数据传输：数据在磁盘与内存之间的实际传输</li></ul></blockquote><p><strong>对于存储引擎来说，如何有效降低随机IO是个非常重要的问题</strong>。</p><h3 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h3><p>可以实现增删改查的数据结构非常多，包括：哈希表、二叉搜索树、AVL、红黑树、B树、B+树等，这些都是可以作为索引的候选数据结构。</p><p>结合MySQL的实际情况：磁盘和内存交互、随机磁盘IO、排序和范围查找、增删改的复杂度等等，综合考量之下B+树脱颖而出。</p><p>B+树作为多叉平衡树，对于范围查找和排序都可以很好地支持，并且更加矮胖，访问数据时的平均磁盘IO次数取决于树的高度，因此<strong>B+树可以让磁盘的查找次数更少</strong>。</p><p>在InnoDB中B+树的高度一般都在2<del>4层，并且根节点常驻内存中，也就是说查找某值的行记录时最多只需要1</del>3次磁盘I/O操作。</p><p><strong>MyISAM是将数据和索引分开存储</strong>的，<strong>InnoDB存储引擎的数据和索引没有分开存储</strong>，这也就是为什么有人说<strong>Innodb索引即数据，数据即索引</strong>，如图：</p><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_23-15-01.png"></p><p>说到<strong>InnoDB的数据和索引的存储</strong>，就提到一个名词：<strong>聚集索引</strong>。</p><h4 id="1、聚集索引"><a href="#1、聚集索引" class="headerlink" title="1、聚集索引"></a>1、聚集索引</h4><p>聚集索引将索引和数据完美地融合在一起，是每个Innodb表都会有的一个特殊索引，<u>一般来说是借助于表的主键来构建的B+树</u>。</p><p>假设我们有student表，将id作为主键索引，那么聚集索引的B+树结构，如图：</p><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_23-16-49.png"></p><ul><li>非叶子节点不存数据，只有主键和相关指针</li><li>叶子节点包含主键、行数据、指针</li><li>叶子节点之间由双向指针串联形成有序双向链表，叶子节点内部也是有序的</li></ul><hr><p>聚集索引按照如下规则创建：</p><ul><li>有主键时InnoDB利用主键来生成</li><li>没有主键，InnoDB会选择一个非空的唯一索引来创建</li><li>无主键且非NULL唯一索引时，InnoDB会隐式创建一个自增的列来创建</li></ul><hr><p>假如我们要查找id=10的数据，大致过程如下：</p><ul><li>索引的根结点在内存中，10&gt;9 因此找到P3指针</li><li>P3指向的数据并没有在内存中，因此产生1次磁盘IO读取磁盘块3到内存</li><li>在内存中对磁盘块3进行二分查找，找到ID=9的全部值</li></ul><h4 id="2、非聚集索引"><a href="#2、非聚集索引" class="headerlink" title="2、非聚集索引"></a>2、非聚集索引</h4><p>非聚集索引的叶子节点中存放的是<strong>二级索引值</strong>和<strong>主键键值</strong>，<strong>非叶子节点和叶子节点都没有存储整行数据值</strong>。</p><p>假设我们有student表，将<strong>name作为二级索引</strong>，那么非聚集索引的B+树结构，如图：</p><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_23-18-08.png"></p><p>由于非聚集索引的叶子节点没有存储行数据，如果通过非聚集索引来查找非二级索引值，需要分为两步：</p><ul><li>第一步：通过非聚集索引的叶子节点来确定数据行对应的主键</li><li>第二步：通过相应的主键值在聚集索引中查询到对应的行记录</li></ul><p>我们把通过非聚集索引找到主键值，再根据主键值从聚集索引找对于行数据的过程称为：<strong>回表查询</strong>。</p><p>换句话说：<code>select * from student where name = &#39;Bob&#39;</code> 将产生回表查询，因为在name索引的叶子节点没有其他值，只能从聚集索引获得。</p><p>所以如果查找的字段在非聚集索引就可以完成，就可以避免一次回表过程，<u>这种称为：覆盖索引，所以select * 并不是好习惯，需要什么拿什么就好。</u></p><hr><p>假如我们要查找name=Tom的记录的所有值，大致过程如下：</p><ol><li>从非聚集索引开始，根节点在内存中，按照name的字典序找到P3指针</li><li>P3指针所指向的磁盘块不在内存中，产生1次磁盘IO加载到内存</li><li>在内存中对磁盘块3的数据进行搜索，获得name=tom的记录的主键值为4</li><li>根据主键值4从聚集索引的根节点中获得P2指针</li><li>P2指针所指向的磁盘块不在内存中，产生第2次磁盘IO加载到内存</li><li>将上一步获得的数据，在内存中进行二分查找获得全部行数据</li></ol><p>上述查询就包含了一次回表过程，因此性能比主键查询慢了一倍，因此尽量使用主键查询，一次完事。</p><h2 id="四、慢SQL解决思路"><a href="#四、慢SQL解决思路" class="headerlink" title="四、慢SQL解决思路"></a>四、慢SQL解决思路</h2><p>出现慢SQL的原因很多，我们抛开单表数亿记录和无索引的特殊情况，来讨论一些更有普遍意义的慢SQL原因和解决之道。</p><p>我们从两个方面来进行阐述：</p><ul><li>数据库表索引设置不合理</li><li>SQL语句有问题，需要优化</li></ul><p><img src="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E6%85%A2SQL%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Snipaste_2021-09-28_23-19-46.png"></p><h3 id="1、索引设置原则"><a href="#1、索引设置原则" class="headerlink" title="1、索引设置原则"></a>1、索引设置原则</h3><p>程序员的角度和存储引擎的角度是不一样的，索引写的好，SQL跑得快。</p><ul><li><strong>索引区分度低</strong></li></ul><p>假如表中有1000w记录，其中有status字段表示状态，可能90%的数据status=1，可以不将status作为索引，因为其对数据记录区分度很低。</p><ul><li><strong>切忌过多创建索引</strong></li></ul><p>每个索引都需要占用磁盘空间，修改表数据时会对索引进行更新，索引越多，更新越复杂。</p><blockquote><p>因为每添加一个索引，.ibd文件中就需要多维护一个B+Tree索引树，如果某一个table中存在10个索引，那么就需要维护10棵B+Tree，写入效率会降低，并且会浪费磁盘空间。</p></blockquote><ul><li><strong>常用查询字段建索引</strong></li></ul><p>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度，属于热门字段，为其建立索引非常必要。</p><ul><li><strong>常排序/分组/去重字段建索引</strong></li></ul><p>对于需要经常使用ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段建立索引，可以有效借助B+树的特性来加速执行。</p><ul><li><strong>主键和外键建索引</strong></li></ul><p>主键可以用来创建聚集索引，外键也是唯一的且常用于表关联的字段，也需要建索引来提高性能。</p><h3 id="2、SQL的优化"><a href="#2、SQL的优化" class="headerlink" title="2、SQL的优化"></a>2、SQL的优化</h3><p>如果数据库表的索引设置比较合理，SQL语句书写不当会造成索引失效，甚至造成全表扫描，迅速拉低性能。</p><h4 id="2-1、索引失效"><a href="#2-1、索引失效" class="headerlink" title="2.1、索引失效"></a>2.1、索引失效</h4><p>我们在写SQL的时候在某些情况下会出现索引失效的情况：</p><ul><li><strong>对索引使用函数</strong></li></ul><blockquote><p>select id from std upper(name) = ‘JIM’;</p></blockquote><ul><li><strong>对索引进行运算</strong></li></ul><blockquote><p>select id from std where id+1=10;</p></blockquote><ul><li><strong>对索引使用&lt;&gt; 、not in 、not exist、!=</strong></li></ul><blockquote><p>select id from std where name != ‘jim’;</p></blockquote><ul><li><strong>对索引进行前导模糊查询</strong></li></ul><blockquote><p>select id from std name like ‘%jim’;</p></blockquote><ul><li><strong>隐式转换会导致不走索引</strong></li></ul><blockquote><p>比如：字符串类型索引字段不加引号，select id from std name = 100;保持变量类型与字段类型一致</p></blockquote><ul><li><strong>非索引字段的or连接</strong></li></ul><blockquote><p>并不是所有的or都会使索引失效，如果or连接的所有字段都设置了索引，是会走索引的，一旦有一个字段没有索引，就会走全表扫描。</p></blockquote><ul><li><strong>联合索引仅包含复合索引非前置列</strong></li></ul><blockquote><p>联合索引包含key1，key2，key3三列，但SQL语句没有key1，根据联合索引的最左匹配原则，不会走联合索引。<br>select name from table where key2=1 and key3=2;</p></blockquote><hr><h4 id="2-2、好的建议"><a href="#2-2、好的建议" class="headerlink" title="2.2、好的建议"></a>2.2、好的建议</h4><ul><li><strong>使用连接代替子查询</strong></li></ul><blockquote><p>对于数据库来说，在绝大部分情况下，连接会比子查询更快，使用连接的方式，MySQL优化器一般可以生成更佳的执行计划，更高效地处理查询<br>而子查询往往需要运行重复的查询，子查询生成的临时表上也没有索引， 因此效率会更低。</p></blockquote><ul><li><strong>LIMIT偏移量过大的优化</strong></li></ul><blockquote><p>禁止分页查询偏移量过大，如limit 100000,10</p></blockquote><ul><li><strong>使用覆盖索引</strong><br>减少select * 借助覆盖索引，减少回表查询次数。</li><li><strong>多表关联查询时，小表在前，大表在后</strong></li></ul><blockquote><p>在MySQL中，执行from后的表关联查询是从左往右执行的，第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。</p></blockquote><ul><li><strong>调整Where字句中的连接顺序</strong></li></ul><blockquote><p>MySQL采用从左往右的顺序解析where子句，可以将过滤数据多的条件放在前面，最快速度缩小结果集。</p></blockquote><ul><li><strong>使用小范围事务，而非大范围事务</strong></li><li><strong>遵循最左匹配原则</strong></li><li><strong>使用联合索引，而非建立多个单独索引</strong></li></ul><h3 id="3、慢SQL的分析"><a href="#3、慢SQL的分析" class="headerlink" title="3、慢SQL的分析"></a>3、慢SQL的分析</h3><p>在分析慢SQL之前需要通过MySQL进行相关设置：</p><ul><li>开启慢SQL日志</li><li>设置慢SQL的执行时间阈值</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">开启：<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log = <span class="hljs-number">1</span>;<br>开启状态：<span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%slow_query_log%&#x27;</span>;<br>设置阈值：<span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> long_query_time=<span class="hljs-number">3</span>;<br>查看阈值：<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;long_query_time%&#x27;</span>; <br></code></pre></td></tr></table></figure><h4 id="3-1、explain分析SQL"><a href="#3-1、explain分析SQL" class="headerlink" title="3.1、explain分析SQL"></a>3.1、explain分析SQL</h4><p>explain命令只需要加在select之前即可，例如:</p><blockquote><p>explain select * from std where id &lt; 100;</p></blockquote><p>该命令会展示sql语句的详细执行过程，帮助我们定位问题，网上关于explain的用法和讲解很多，本文不再展开。</p><h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">sysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> t_user;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">Table</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">Create</span> <span class="hljs-keyword">Table</span>                                                                                                                                                                                                                                                                                                                                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> t_user <span class="hljs-operator">|</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `nam` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `sex` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `dept` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `indx_nam` (`nam`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_bin <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mysql&gt; select * from t_user\G<br>*************************** 1. row ***************************<br>  id: 1<br> nam: hello<br> age: 13<br> sex: male<br>dept: 软开<br>1 row in <span class="hljs-keyword">set</span> <span class="hljs-params">(0.00 sec)</span><br><br>mysql&gt; explain select * from t_user;<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>|  1 | SIMPLE      | t_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>1 row in <span class="hljs-keyword">set</span>, 1 warning <span class="hljs-params">(0.00 sec)</span><br><br>mysql&gt; mysql&gt; explain select * from t_user where id = 1;<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>|  1 | SIMPLE      | t_user | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>1 row in <span class="hljs-keyword">set</span>, 1 warning <span class="hljs-params">(0.00 sec)</span><br><br>mysql&gt; explain select * from t_user t_user where nam = &#x27;hello&#x27;;<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>| id | select_type | table  | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>|  1 | SIMPLE      | t_user | NULL       | ref  | indx_nam      | indx_nam | 1023    | const |    1 |   100.00 | NULL  |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>1 row in <span class="hljs-keyword">set</span>, 1 warning <span class="hljs-params">(0.00 sec)</span><br><br>mysql&gt; explain select * from t_user t_user where sex = &#x27;male&#x27;;<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>|  1 | SIMPLE      | t_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | Using where |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">--------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>1 row in <span class="hljs-keyword">set</span>, 1 warning <span class="hljs-params">(0.01 sec)</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>慢SQL</tag>
      
      <tag>SQL性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL性能问题:隐式转换导致索引失效</title>
    <link href="/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
    <url>/2021/09/28/SQL%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h1 id="隐式转换导致索引失效"><a href="#隐式转换导致索引失效" class="headerlink" title="隐式转换导致索引失效"></a>隐式转换导致索引失效</h1><p>在排查系统页面响应时间长的问题时，考虑是否存在隐式转换导致索引失效的问题。这类问题解决后，响应速度会成百上千倍的提升。</p><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> <br>c_zdgl_info czi <span class="hljs-comment">-- 38000 条记录</span><br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <br>c_staff_cbspdeptinfo csd<br><span class="hljs-keyword">on</span> czi.resp_office <span class="hljs-operator">=</span> csd.org_no;<br></code></pre></td></tr></table></figure><p>SQL执行耗时：2.5min</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><h3 id="索引排查"><a href="#索引排查" class="headerlink" title="索引排查"></a>索引排查</h3><p>TABLE c_zdgl_info 索引 index_resp_office(resp_office)</p><p>TABLE c_staff_cbspdeptinfo 索引 orgno_index(orgn_no)</p><p>resp_office、orgn_no均是字符类型varchar</p><h3 id="执行计划排查"><a href="#执行计划排查" class="headerlink" title="执行计划排查"></a>执行计划排查</h3><p>Explain SQL，发现两张表全部都是全表扫描，索引完全没派上用场。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>索引</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java项目jar包依赖冲突及解决方案</title>
    <link href="/2021/09/27/Java%E9%A1%B9%E7%9B%AEjar%E5%8C%85%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/09/27/Java%E9%A1%B9%E7%9B%AEjar%E5%8C%85%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Java项目Jar包冲突及解决方案"><a href="#Java项目Jar包冲突及解决方案" class="headerlink" title="Java项目Jar包冲突及解决方案"></a>Java项目Jar包冲突及解决方案</h1><blockquote><p>描述Java项目中产生的Jar包冲突，分析冲突原因并提供解决方案。</p></blockquote><p>Java程序员，日常开发过程中几乎都遇到过Jar包冲突的问题，通常都是因为在Maven传递依赖的过程中，多个不同版本的Jar包被引入进项目中导致的，普遍使用的解决方案是通过以来排除来解决问题。</p><h2 id="一、什么是Jar包冲突"><a href="#一、什么是Jar包冲突" class="headerlink" title="一、什么是Jar包冲突"></a>一、什么是Jar包冲突</h2><p>Java程序因某种因素，加载不到正确的类，从而导致的程序实际行为与预期的不一致。具体来说可以分为两种情况：</p><ol><li>同一个jar包在项目中存在多个不同版本，JVM加载时未选择正确的版本，导致找不到需要的类或者加载错误的类；– ①</li><li>同样的类（类的全限定名完全一样）出现在多个不同的依赖Jar包中，即该类存在多个不同版本，由于Jar包加载的先后顺序导致JVM加载了错误版本的类。 – ②</li></ol><h3 id="1-1、多个不同版本Jar包"><a href="#1-1、多个不同版本Jar包" class="headerlink" title="1.1、多个不同版本Jar包"></a>1.1、多个不同版本Jar包</h3><p>随着Jar包的升级迭代，我们所依赖的开源的或公司内部的Jar包工具都会存在若干不同的版本，由于Maven的传递依赖机制而导致同一个Jar包出现了多个版本，当Maven的仲裁机制选择了错误的版本时，导致我们需要的类、方法不存在或者类的方法被修改，就会出现上述① Jar包冲突的问题。总结①类冲突发生的必要条件：</p><ol><li>由于Maven传递依赖导致依赖树中出现了同一个Jar包的多个版本；</li><li>该Jar包的多个版本之间存在接口差异，如类名替换、方法签名调整等，且应用程序依赖了其中有变动的类和方法；</li><li>Maven的仲裁机制选择了错误的版本。</li></ol><h3 id="1-2、不同Jar包相同类名和路径"><a href="#1-2、不同Jar包相同类名和路径" class="headerlink" title="1.2、不同Jar包相同类名和路径"></a>1.2、不同Jar包相同类名和路径</h3><p>相同的类出现在应用程序所依赖的不同的Jar包中，这会导致什么问题？在JVM进行类加载时，同一个类加载器对于同一个类只会加载一次，那么当一个类出现在了多个Jar包中，假设有A、B、C等，由于Jar包依赖的路径长短、声明的先后顺序或者文件系统文件的加载顺序等原因，类加载器首先从Jar包A中加载了该类后，就不会加载其余Jar包中的这个类。</p><p>如果应用程序此时需要的是Jar包B中的这个类版本，并且该类在Jar包A和B中存在差异，而JVM加载的是A中类版本，这与我们所期望的相悖，导致出现因为Jar包冲突导致的各种各样的问题。</p><p>总结②类冲突的必要条件：</p><ol><li>同一个类在依赖的不同的jar保重存在；</li><li>这些类在不同的Jar包中存在差异，比如方法、签名、成员变量不同等；</li><li>加载的类不是所期望的版本，即加载了错误的Jar包。</li></ol><h2 id="二、冲突的产生"><a href="#二、冲突的产生" class="headerlink" title="二、冲突的产生"></a>二、冲突的产生</h2><h3 id="2-1、Maven的仲裁机制"><a href="#2-1、Maven的仲裁机制" class="headerlink" title="2.1、Maven的仲裁机制"></a>2.1、Maven的仲裁机制</h3><p>传递依赖是Maven2.0引入的新特性，通常我们在项目中只需要在pom.xml中定义我们需要的直接依赖Jar包，对于间接依赖的Jar包，Maven会通过解析从远程仓库获取的依赖包的pom文件来隐式地将其引入；这一特性极大的方便了对依赖包的管理，但是也带来了一个常见的问题——版本冲突。为解决这个问题，Maven提供了一套仲裁机制来决定最终选用哪个版本，仲裁机制如下：</p><ol><li>优先按照依赖管理元素中指定的版本声明进行仲裁，此时下面的两个原则都无效；</li><li>若未进行版本声明，则按照”最短路径优先“的原则（Maven2.0）进行仲裁，即选择依赖树中路径最短的版本；</li><li>若路径长度一致，则按照”第一声明优先“的原则进行仲裁，即选择POM中最先声明的版本；</li></ol><p>从Maven仲裁机制发现，除了第一条仲裁规则外，对于同一个Jar包不同版本的选择，都是有Maven来决定，但是Maven选择的并不一定是项目所希望使用的版本，导致Jar包冲突。因为每一个应用都有其特殊性，改依赖哪个版本，Maven没办法帮你们完全搞定，如果你没有使用第一种仲裁来进行管理，就极大可能产生第一类的Jar包冲突。</p><h3 id="2-2、Jar包的加载顺序"><a href="#2-2、Jar包的加载顺序" class="headerlink" title="2.2、Jar包的加载顺序"></a>2.2、Jar包的加载顺序</h3><p>对于第二种Jar包冲突，这相对于第一类问题就显得更极为棘手了。两个不同的Jar包，假设A、B，这两个Jar包的名称完全不同、甚至相互完全不沾边，如果不是出现冲突问题（出现问题才可能会发现），可能都不会发现他们有公共类。对于A、B这两个Jar包、已经超出Maven的依赖管理范畴。此时，当A、B都出现在程序的类路径下是，就会存在冲突风险，即A、B的加载先后顺序就决定着JVM最终选择的类版本，如果选错了，就会出现第二类冲突问题。</p><p>下面简单说明Java的类加载机制：</p><ul><li>Jar包所处的加载路径。或者换个说法就是加载该Jar包的类加载器在JVM类加载器树结构中所处层级。由于JVM类加载的双亲委派机制，层级越高的类加载器越优先加载其加载路径下的类。顾名思义，引导类加载器（bootstrap classloader，启动类加载器）是最先加载其路径下的Jar包的，其次是扩展类加载器（extension classloader），再次是系统类加载器（system classloader，application classloader），Jar包所处加载路径不同，决定了它的加载顺序不同。</li><li>文件系统的文件加载顺序。这个因素很容易被忽略，我们经常会遇到因环境不一致而导致各种诡异冲突问题。因tomcat、resin等容器的ClassLoader获取加载路径下的文件列表时是不排序的，这就依赖于底层文件系统返回的顺序，那么当不同环境之间的文件系统不一致时，就会出现有的环境没问题，有的环境出现冲突。例如，对于Linux操作系统，返回顺序则是由iNode的顺序来决定的，如果说测试环<br>境的Linux系统与线上环境不一致时，就极有可能出现典型案例：测试环境怎么测都没问题，但一上线就出现冲突问题，规避这种问题的最佳办法就是尽量保证测试环境与线上一致。</li></ul><h2 id="三、冲突的表象"><a href="#三、冲突的表象" class="headerlink" title="三、冲突的表象"></a>三、冲突的表象</h2><p>Jar包冲突可能会导致哪些问题？通常发生在编译或运行时，主要分为两类问题：一类是比较直观的也是最为常见的错误是抛出各种运行时异常，还有一类就是比较隐晦的问题，它不会报错，其表现开式是应用程序的行为跟预期不一致，分条罗列如下：</p><ol><li>java.lang.ClassNotFoundException，即Java类找不到。这类典型异常通常是由于，没有在依赖管理中声明版本，Maven的仲裁的时候选取了错误的版本，而这个版本缺少我们需要的某个class而导致该错误。例如httpclient-4.4.jar升级到httpclient-4.6.jar时，类org.apache.http.conn.ssl.NoopHostnameVerifier被去掉了，如果此时我们本来需要的是4.4版本，旦用到了NoopHostnameVerifier这个类，而Maven仲裁时选择了4.6，则会导致ClassNotFoundException异常。</li><li>java.lang.NoSuchMethodError，即找不到特定方法，第一类冲宾和第二类冲突都可能导致该问题加载的类不正确。若是第一类冲突，则是由于错误版本的jar包与所需要版本的jar包中的类接口不—致导致，例如antl-2.7.2.jar升级到antl-2.7.6.jar时，接口antlr.collections.AST.getLine()发生变动，当Maven仲裁选择了错误版本而加载了错误版本的类AST，则会导致该异常；若是第二类冲突，则是由于不同jar包含有的同名类接口不一致导致：典型的案例：Apache的commons-lang包，2x升级到了3.×时，包名直接从commons-ang改为commons-lang3，部分接口也有所改动，由于包名不同和传递性依赖，经常会出现两种jar包同时在classpath 下，org.apache.commons.lang.StringUtils.isBlank就是其中有差异的接口之一，由于Jar包的加载顺序，导致加载了错误版本的StringUtils类，就可能出现NoSuchMethodError异常。</li><li>java.lang.NoclassDefFoundError, java.lang.LinkageError等，原因和上述雷同，就不作具体案例分析。</li><li>没有报错异常，但应用的行为跟预期不一致。这类问题同样也是由于运行时加载了错误版本的类导致，但跟前面不同的是，冲交的类接口都是一致的，但具体实现逻辑有差异，当我们加载的类版本不是我们需要的实现逻辑，就会出现行为跟预期不一致问题。这类问题通常发生在我们自己内部实现的多个Jar包中，由于包路径和类名命名不规范等问题，导致两个不同的Jar包出现了接口一致但实现逻辑又各不相同的同名类，从而引发此问题。</li></ol><h2 id="四、排除和解决冲突"><a href="#四、排除和解决冲突" class="headerlink" title="四、排除和解决冲突"></a>四、排除和解决冲突</h2><p>如果有异常堆栈信息，根据错误信息即可定位导致冲突的类名，然后在 <strong>eclipse</strong> 中<code>CTRL+SHIFT+T</code>或者在 <strong>idea</strong> 中<code>CTRL+N</code> 就可发现该类存在于多个依赖 Jar 包中 若步骤①无法定位冲突的类来自哪个jar包，可在应用程序启动时加上 JVM 参数 -verbose:class 或者 -XX:+ TraceClassLoading，日志里会打印出每个类的加载信息， 如来自哪个Jar包。</p><p>定位了冲突类的Jar包之后，通过mvn dependency:tree -Dverbose -Dincludes=: 查看是哪些地方引入的Jar包的这个版本。</p><p>确定Jar包来源之后，如果是第①类Jar包冲突，则可用排除不需要的Jar包版本或者在依赖管埋中申明版本；若是第二类Jar包冲突，如果可排除，则用排掉不需要的那个Jar包，若不能排，则需考虑Jar包的升级或换个别的Jar包。当然，除了这些方法，还可以从类加载器的角度来解決该问题。</p><h2 id="五、如何避免冲突"><a href="#五、如何避免冲突" class="headerlink" title="五、如何避免冲突"></a>五、如何避免冲突</h2><p>从上一节的解决方案可以发现，当出现第二类Jar包冲突，且冲突的Jar包又无法排除时，问题变得相当棘手，这时候要处理该冲突问题就需要较大成本了，所以，最好的方式是在冲突发生之前能有效地规避之！就好比数据库死锁问题，死锁避免和死锁预防就显得相当重要，若是等到真正发生死锁了，常规的做法也只能是回滚并重启部分事务，这就捉襟见肘了。那么怎样才能有效地规避Jar包冲突呢？</p><h3 id="5-1、良好的习惯：依赖管理"><a href="#5-1、良好的习惯：依赖管理" class="headerlink" title="5.1、良好的习惯：依赖管理"></a>5.1、良好的习惯：依赖管理</h3><p>对于第一类Jar包沖突问题，通常的做法是用排除不需要的版本，但这种做法带来的问题是每次引入带有传递性依赖的Jar包时，都需要<br>一一进行排除，非常麻烦。Maven为此提供了集中管理依赖信息的机制，即依赖管理元素，对依赖Jar包进行统一版本管理，一劳永逸。通常的做法是，在parent模块的pom文件中尽可能地声明所有相关依赖Jar包的版本，并在子pom中简单引用该构件即可。</p><p>来看个示例，当开发时确定使用的httpclient版本为4.5.1时，可在父pom中配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">httpclient.version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">httpclient.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;httpclient.version)<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后各个需要依赖该Jar包的子pom中配置如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httoclient<span class="hljs-tag">&lt;/<span class="hljs-name">antifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-2、冲突检测插件"><a href="#5-2、冲突检测插件" class="headerlink" title="5.2、冲突检测插件"></a>5.2、冲突检测插件</h3><p>对于第二类Jar包冲突问题，前面也提到过，其核心在于同名类出现在了多个不同的Jar包中，如果人工来排查该问题，则需要逐个点开每个Jar包，然后相互对比看有没同名的类，那得多么浪费精力啊？！</p><p>好在这种费时费力的体力活能交给程序去干。Maven-enforcer-plugin， 这个强大的Maven插件，配合extra-enforcer-rules 工具，能自动扫描Jar包将冲突检测并打印出来。其原理其实也比较简单，通过扫描Jar包中的class，记录每个class对应的Jar包列表，如果有多个即是冲突了，故不必深究，我们只需要关注如何用它即可。</p><p>在最终需要打包运行的应用模块pom中，引入Maven-enforcer-plugin的依赖，在build阶段即可发现问题，并解决它。比如对于具有parent pom的多模块项目，需要将插件依赖声明在应用模块的pom中。</p><p>这里有童鞋可能会疑词，为什么不把插件依赖声明在parent pom中呢？那样依赖它的应用子模块岂不是都能复用了？这里之所以强调”<strong>打包运行的应用模块pom</strong>“是因为冲突检测针对的是最终集成的应用，关注的是应用运行时是杏会出现冲突问题，而每个不同的应用模块，各自依赖的Jar包集合是不同的，由此而产生的列表也是有差异的，因此只能针对应用模块pom分别引入该插件。</p><p>先看示例用法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. apache Maven- plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Maven-enforcer-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>enforce<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">rules</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyConvergence</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">rules</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>enforce<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>enforce-ban-duplicate-classes<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>enforce<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">rules</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">banDuplicateClasses</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">ignoreClasses</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">ignoreClass</span>&gt;</span>javax.*<span class="hljs-tag">&lt;/<span class="hljs-name">ignoreClass</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">ignoreClass</span>&gt;</span>org.junit.*<span class="hljs-tag">&lt;/<span class="hljs-name">ignoreClass</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">ignoreClass</span>&gt;</span>net.sf.cglib.*<span class="hljs-tag">&lt;/<span class="hljs-name">ignoreclass</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">ignoreClass</span>&gt;</span>org.apache.commons.logging.*<span class="hljs-tag">&lt;/<span class="hljs-name">ignoreClass</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">ignoreClass</span>&gt;</span>org.springframework.remoting.rmi.RmiInvocationHandler<span class="hljs-tag">&lt;/<span class="hljs-name">ignoreclass</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">ignoreclasses</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">findAlIDuplicates</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">findAllDuplicates</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">banDuplicateClasses</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">rules</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">fail</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fail</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>extra-enforcer-rules<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-beta-6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Maven-enforcer-plugin是通过很多预定义的标准规则 (standard rules）和用户自定义规则，来约束Maven的环境因素，如Maven版本<br>JDK版本等等，它有很多好用的特性，具体可参见官网。而Extra Enforcer Rules则是MojoHaus 项目 下的针对Maven-enforcer-plugin而开发的提供额外规则的插件，这其中就包含前面所提的重复类检测功能，县体用法可参见官网。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Maven</tag>
      
      <tag>Jar包冲突</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL-开窗函数指南</title>
    <link href="/2021/09/12/SQL-%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0%E6%8C%87%E5%8D%97/"/>
    <url>/2021/09/12/SQL-%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是开窗函数"><a href="#什么是开窗函数" class="headerlink" title="什么是开窗函数"></a>什么是开窗函数</h1><p>开窗函数/分析函数：也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。</p><p>开窗函数也叫分析函数，有两类：一类是聚合开窗函数，一类是排序开窗函数。</p><p>开窗函数的调用格式为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">函数名(列名) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> 列名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名)<br></code></pre></td></tr></table></figure><p>如果你没听说过开窗函数，看到上面开窗函数的调用方法，你可能还会有些疑惑。但只要你了解聚合函数，那么理解开窗函数就非常容易了。</p><p>我们知道聚合函数对一组值执行计算并返回单一的值，如sum()，count()，max()，min()， avg()等，这些函数常与group by子句连用。除了 COUNT 以外，聚合函数忽略空值。</p><p>但有时候一组数据只返回一组值是不能满足需求的，如我们经常想知道各个地区的前几名、各个班或各个学科的前几名。这时候需要每一组返回多个值。用开窗函数解决这类问题非常方便。</p><blockquote><p>语法中的‹窗口函数› 主要由专用窗口函数（rank、dense_rank和row_number等组成）与聚合函数（sum、avg、count、max和min等）作为窗口函数组成。</p><p>从窗口函数组成上看，它是group by 和 order by的功能组合，既然我们已经学了group by和order by，为什么还要学窗口函数呢？group by分组汇总后改变了表的行数，一行只有一个类别，而partiition by则不会减少原表中的行数。</p><p>恰如窗口函数的组成，它同时具有分组和排序的功能，且不减少原表的行数。</p></blockquote><p><strong>开窗函数和聚合函数的区别如下：</strong></p><p>（1）SQL 标准允许将所有聚合函数用作开窗函数，<strong>用OVER 关键字区分开窗函数和聚合函数</strong>。</p><p>（2）聚合函数每组只返回一个值，开窗函数每组可返回多个值。</p><p>注：常见主流数据库目前都支持开窗函数，但mysql数据库目前还不支持。</p><p><strong>二、常见面试题</strong></p><p><strong>1. 分区排序：row_number () over()</strong></p><p>有如下学生成绩表：students_grades</p><table><thead><tr><th>id</th><th>stu_name</th><th>course_name</th><th>grades</th></tr></thead><tbody><tr><td>1</td><td>Ada</td><td>Chinese</td><td>53</td></tr><tr><td>2</td><td>Ada</td><td>English</td><td>87</td></tr><tr><td>3</td><td>Ada</td><td>Math</td><td>83</td></tr><tr><td>4</td><td>Ada</td><td>Physics</td><td>99</td></tr><tr><td>5</td><td>Emma</td><td>Chinese</td><td>90</td></tr><tr><td>6</td><td>Emma</td><td>English</td><td>78</td></tr><tr><td>7</td><td>Emma</td><td>Math</td><td>86</td></tr></tbody></table><p>查询每门课程course_name前三名的学生姓名及成绩，要求输出列格式如下：</p><p>course_name, number, stu_name, grades</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br><span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> <br>(<span class="hljs-keyword">select</span> course_name,<br>  <span class="hljs-built_in">row_number</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> course_name <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> grades <span class="hljs-keyword">desc</span>) number,<br>  stu_name,<br>  grades<br>  <span class="hljs-keyword">from</span> student_grades) a<br><span class="hljs-keyword">where</span><br>a.number <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><strong>2. 几个排序函数row_number() over()、rank() over()、dense_rank() over()、ntile() over()的区别</strong></p><p>（1） row_number() over()：对相等的值不进行区分，相等的值对应的排名相同，序号从1到n连续。</p><p>（2） rank() over()：相等的值排名相同，但若有相等的值，则序号从1到n不连续。如果有两个人都排在第3名，则没有第4名。</p><p>（3） dense_rank() over()：对相等的值排名相同，但序号从1到n连续。如果有两个人都排在第一名，则排在第2名（假设仅有1个第二名）的人是第3个人。</p><p>（4） ntile( n ) over()：可以看作是把有序的数据集合平均分配到指定的数量n的桶中，将桶号分配给每一行，排序对应的数字为桶号。如果不能平均分配，则较小桶号的桶分配额外的行，并且各个桶中能放的数据条数最多相差1。</p><p><a href="https://zhuanlan.zhihu.com/p/187558823">https://zhuanlan.zhihu.com/p/187558823</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-创建型模式</title>
    <link href="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。</p><h2 id="工厂方法-FactoryMethod"><a href="#工厂方法-FactoryMethod" class="headerlink" title="工厂方法 FactoryMethod"></a>工厂方法 FactoryMethod</h2><p>在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。</p><p>又称：虚拟构造函数、Virtual Constructor、 Factory Method</p><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。</p><p>一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-50-05.png"></p><p>这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。</p><p>最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-52-32.png"></p><p><strong>乍看之下， 这种更改可能毫无意义</strong>： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型（这样好像意义也没有多大，个人拙见——LGW「意见一」）。</p><p>但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_20-59-38.png"></p><p>举例来说，  卡车Truck和 轮船Ship类都必须实现 运输Trans­port接口， 该接口声明了一个名为 deliver交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  陆路运输Road­Logis­tics类中的工厂方法返回卡车对象， 而 海路运输Sea­Logis­tics类则返回轮船对象。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-00-33.png"></p><p>调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-02-48.png"></p><ol><li><p>产品 （Prod­uct） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p></li><li><p>具体产品 （Con­crete Prod­ucts） 是产品接口的不同实现。</p></li><li><p>创建者 （Cre­ator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p><p>你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</p><p>注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p></li><li><p>具体创建者 （Con­crete Cre­ators） 将会重写基础工厂方法， 使其返回不同类型的产品。</p><p>注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p></li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>以下示例演示了如何使用工厂方法开发跨平台 UI （用户界面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-06-11.png"></p><p>基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Win­dows 系统中的按钮在 Linux 系统中仍然是按钮。</p><p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Win­dows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Win­dows 样式渲染按钮。</p><p>如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p><p><strong>你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。</strong></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供</span><br><span class="hljs-comment">// 该方法的实现。</span><br><span class="hljs-keyword">class</span> Dialog <span class="hljs-keyword">is</span><br>  <span class="hljs-comment">// 创建者还可提供一些工厂方法的默认实现。</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button<br><br>  <span class="hljs-comment">// 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务</span><br>  <span class="hljs-comment">// 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方</span><br>  <span class="hljs-comment">// 法并使其返回不同类型的产品来间接修改业务逻辑。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 调用工厂方法创建一个产品对象。</span><br><span class="hljs-function">    <span class="hljs-title">Button</span> <span class="hljs-title">okButton</span> = <span class="hljs-title">createButton</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    // 现在使用产品。</span><br><span class="hljs-function">    <span class="hljs-title">okButton</span>.<span class="hljs-title">onClick</span><span class="hljs-params">(closeDialog)</span></span><br><span class="hljs-function">    <span class="hljs-title">okButton</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 具体创建者将重写工厂方法以改变其所返回的产品类型。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WindowsDialog</span> <span class="hljs-title">extends</span> <span class="hljs-title">Dialog</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> WindowsButton()<br><br><span class="hljs-keyword">class</span> WebDialog extends Dialog <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> HTMLButton()<br><br><br><span class="hljs-comment">// 产品接口中将声明所有具体产品都必须实现的操作。</span><br><span class="hljs-keyword">interface</span> Button <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 具体产品需提供产品接口的各种实现。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WindowsButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">render</span><span class="hljs-params">(a, b)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">Windows</span> 样式渲染按钮。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 绑定本地操作系统点击事件。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">HTMLButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">render</span><span class="hljs-params">(a, b)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 返回一个按钮的 <span class="hljs-title">HTML</span> 表述。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">onClick</span><span class="hljs-params">(f)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 绑定网络浏览器的点击事件。</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Application</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">dialog</span>:</span> Dialog<br><br>  <span class="hljs-comment">// 程序根据当前配置或环境设定选择创建者的类型。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">config</span> = <span class="hljs-title">readApplicationConfigFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Windows&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">dialog</span> = <span class="hljs-title">new</span> <span class="hljs-title">WindowsDialog</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Web&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">dialog</span> = <span class="hljs-title">new</span> <span class="hljs-title">WebDialog</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span></span><br><span class="hljs-function">      <span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-title">Exception</span><span class="hljs-params">(&quot;错误！未知的操作系统。&quot;)</span></span><br><span class="hljs-function">  // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口</span><br><span class="hljs-function">  // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子</span><br><span class="hljs-function">  // 类传递给客户端。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">initialize</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">dialog</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h3 id="适用应用场景"><a href="#适用应用场景" class="headerlink" title="适用应用场景"></a>适用应用场景</h3><ol><li><p><strong>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</strong></p><p>工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。</p><p>例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。</p></li><li><p><strong>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</strong></p><p> 继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？</p></li><li><p><strong>解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。</strong></p><p>让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 圆形按钮Round­But­ton子类来继承标准的 按钮But­ton类。 但是， 你需要告诉 UI框架UIFrame­work类使用新的子类按钮代替默认按钮。</p><p>为了实现这个功能， 你可以根据基础框架类开发子类 圆形按钮 UIUIWith­Round­But­tons ， 并且重写其 create­Button创建按钮方法。 基类中的该方法返回 按钮对象， 而你开发的子类返回 圆形按钮对象。 现在， 你就可以使用 圆形按钮 UI类代替 UI框架类。 就是这么简单！</p></li><li><p><strong>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。</strong></p><p>在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。</p><p>让我们思考复用现有对象的方法：</p><ul><li>首先， 你需要创建存储空间来存放所有已经创建的对象。</li><li>当他人请求一个对象时， 程序将在对象池中搜索可用对象。</li><li>…然后将其返回给客户端代码。</li><li>如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。</li></ul><p>这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。</p><p>可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实例。</p><p>因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。</p></li></ol><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</p></li><li><p>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</p></li><li><p>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。</p><p>工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 switch分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。</p></li><li><p>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。</p></li><li><p>如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。</p><p>例如， 设想你有以下一些层次结构的类。 基类 邮件及其子类 航空邮件和 陆路邮件 ；  运输及其子类 飞机, 卡车和 火车 。  航空邮件仅使用 飞机对象， 而 陆路邮件则会同时使用 卡车和 火车对象。 你可以编写一个新的子类 （例如 火车邮件 ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 陆路邮件类传递一个参数， 用于控制其希望获得的产品。</p></li><li><p>如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。</p></li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>你可以避免创建者和具体产品之间的紧密耦合。</li><li>单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li><li>开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li></ol><p>缺点：</p><ol><li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li></ol><h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol><li><p>在许多设计工作的初期都会使用<strong>工厂方法</strong> （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用<strong>抽象工厂</strong>、 <strong>原型</strong>或<strong>生成器</strong> （更灵活但更加复杂）。</p></li><li><p><strong>抽象工厂</strong>模式通常基于一组工厂方法， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</p></li><li><p>你可以同时使用<strong>工厂方法</strong>和<strong>迭代器</strong>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p></li><li><p><strong>原型</strong>并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 <strong>工厂方法</strong>基于继承， 但是它不需要初始化步骤。</p></li><li><p><strong>工厂方法</strong>是<strong>模板方法</strong>的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。</p></li></ol><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>工厂方法应用于如，不同风格的对话框使用不同风格的按钮，不同风格对话框具体使用何种风格按钮由其具体对话框自己决定。（意见同一）</p><h2 id="抽象工厂-AbstractFactory"><a href="#抽象工厂-AbstractFactory" class="headerlink" title="抽象工厂 AbstractFactory"></a>抽象工厂 AbstractFactory</h2><p>让你能够创建一系列相关的对象，而无需指定具体类。</p><h3 id="问题提出-1"><a href="#问题提出-1" class="headerlink" title="问题提出"></a>问题提出</h3><p>假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：</p><ol><li><p>一系列相关产品， 例如 椅子Chair 、  沙发Sofa和 咖啡桌Cof­fee­Table 。</p></li><li><p>系列产品的不同变体。 例如， 你可以使用 现代Mod­ern 、  维多利亚Vic­to­ri­an 、  装饰风艺术Art­Deco等风格生成 椅子 、  沙发和 咖啡桌 。</p></li></ol><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-47-18.png"></p><p>你需要设法单独生成每件家具对象， 这样才能确保其风格一致。 如果顾客收到的家具风格不一样， 他们可不会开心。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-48-15.png"></p><p>此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 椅子接口； 所有风格的咖啡桌都实现 咖啡桌接口， 以此类推。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-49-47.png"></p><p>接下来， 我们需要声明抽象工厂——包含系列中所有产品构造方法的接口。 例如 create­Chair创建椅子 、  create­Sofa创建沙发和 create­Coffee­Table创建咖啡桌 。 这些方法必须返回抽象产品类型， 即我们之前抽取的那些接口：  椅子 ，  沙发和 咖啡桌等等。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-51-11.png" alt="每个具体工厂类都对应一个特定的产品变体"></p><p>那么该如何处理产品变体呢？ 对于系列产品的每个变体， 我们都将基于 抽象工厂接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如，  现代家具工厂Mod­ern­Fur­ni­ture­Fac­to­ry只能创建 现代椅子Mod­ern­Chair 、  现代沙发Mod­ern­Sofa和 现代咖啡桌Mod­ern­Cof­fee­Table对象。</p><p>客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-52-16.png"></p><p>假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调用抽象 椅子接口就可以了。 这样一来， 客户端只需知道椅子以某种方式实现了 sit­On坐下方法就足够了。 此外， 无论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。</p><p>最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-53-45.png"></p><ol><li><p>抽象产品 （Abstract Prod­uct） 为构成系列产品的一组不同但相关的产品声明接口。</p></li><li><p>具体产品 （Con­crete Prod­uct） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。</p></li><li><p>抽象工厂 （Abstract Fac­to­ry） 接口声明了一组创建各种抽象产品的方法。</p></li><li><p>具体工厂 （Con­crete Fac­to­ry） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</p></li><li><p>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 客户端 （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。</p></li></ol><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>下面例子通过应用抽象工厂模式， 使得客户端代码无需与具体 UI 类耦合， 就能创建跨平台的 UI 元素， 同时确保所创建的元素与指定的操作系统匹配。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-13_21-56-00.png"></p><p>跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Win­dows 系统下运行的应用程序中显示 macOS 的控件。</p><p>抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。</p><p>其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。</p><p>使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。</p><p>这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。 </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列</span><br><span class="hljs-comment">// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产</span><br><span class="hljs-comment">// 品可有多个变体，但不同变体的产品不能搭配使用。</span><br><span class="hljs-keyword">interface</span> GUIFactory <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button<br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createCheckbox</span><span class="hljs-params">()</span>:</span>Checkbox<br><br><br><span class="hljs-comment">// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配</span><br><span class="hljs-comment">// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进</span><br><span class="hljs-comment">// 行实例化。</span><br><span class="hljs-keyword">class</span> WinFactory <span class="hljs-keyword">implements</span> GUIFactory <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> WinButton()<br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createCheckbox</span><span class="hljs-params">()</span>:</span>Checkbox <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> WinCheckbox()<br><br><span class="hljs-comment">// 每个具体工厂中都会包含一个相应的产品变体。</span><br><span class="hljs-keyword">class</span> MacFactory <span class="hljs-keyword">implements</span> GUIFactory <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createButton</span><span class="hljs-params">()</span>:</span>Button <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> MacButton()<br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">createCheckbox</span><span class="hljs-params">()</span>:</span>Checkbox <span class="hljs-keyword">is</span><br>    return <span class="hljs-keyword">new</span> MacCheckbox()<br><br><br><span class="hljs-comment">// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。</span><br><span class="hljs-keyword">interface</span> Button <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 具体产品由相应的具体工厂创建。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WinButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">Windows</span> 样式渲染按钮。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">MacButton</span> <span class="hljs-title">implements</span> <span class="hljs-title">Button</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">macOS</span> 样式渲染按钮</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产</span><br><span class="hljs-function">// 品之间才能够正确地进行交互。</span><br><span class="hljs-function"><span class="hljs-title">interface</span> <span class="hljs-title">Checkbox</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">WinCheckbox</span> <span class="hljs-title">implements</span> <span class="hljs-title">Checkbox</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">Windows</span> 样式渲染复选框。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">MacCheckbox</span> <span class="hljs-title">implements</span> <span class="hljs-title">Checkbox</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 根据 <span class="hljs-title">macOS</span> 样式渲染复选框。</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 客户端代码仅通过抽象类型（<span class="hljs-title">GUIFactory</span>、<span class="hljs-title">Button</span> 和 <span class="hljs-title">Checkbox</span>）使用工厂和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Application</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">private</span> <span class="hljs-title">field</span> <span class="hljs-title">factory</span>:</span> GUIFactory<br>  <span class="hljs-keyword">private</span> field button: Button<br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Application</span><span class="hljs-params">(factory: GUIFactory)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">factory</span> = <span class="hljs-title">factory</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">createUI</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">button</span> = <span class="hljs-title">factory</span>.<span class="hljs-title">createButton</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">paint</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">button</span>.<span class="hljs-title">paint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初</span><br><span class="hljs-function">// 始化阶段）。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">ApplicationConfigurator</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">config</span> = <span class="hljs-title">readApplicationConfigFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Windows&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">factory</span> = <span class="hljs-title">new</span> <span class="hljs-title">WinFactory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(config.OS == &quot;Mac&quot;)</span> <span class="hljs-title">then</span></span><br><span class="hljs-function">      <span class="hljs-title">factory</span> = <span class="hljs-title">new</span> <span class="hljs-title">MacFactory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">else</span></span><br><span class="hljs-function">      <span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-title">Exception</span><span class="hljs-params">(&quot;错误！未知的操作系统。&quot;)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">Application</span> <span class="hljs-title">app</span> = <span class="hljs-title">new</span> <span class="hljs-title">Application</span><span class="hljs-params">(factory)</span></span><br></code></pre></td></tr></table></figure><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li><p>如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。</p><p>抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。</p></li><li><p>如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。</p><p>在设计良好的程序中， 每个类仅负责一件事。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。</p></li></ol><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>以不同的产品类型与产品变体为维度绘制矩阵；</p></li><li><p>为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口；</p></li><li><p>声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法；</p></li><li><p>为每种产品变体实现一个具体工厂类；</p></li><li><p>在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类；</p></li><li><p>找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。</p></li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>你可以确保同一工厂生成的产品相互匹配；</li><li>你可以避免客户端和具体产品代码的耦合；</li><li>单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护；</li><li>开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</li></ol><p>缺点</p><ol><li>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</li></ol><h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol><li><p>在许多设计工作的初期都会使用工厂方法 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂、 原型或生成器 （更灵活但更加复杂）。</p></li><li><p>生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。</p></li><li><p>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</p></li><li><p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观。</p></li><li><p>你可以将抽象工厂和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p></li><li><p>抽象工厂、 生成器和原型都可以用单例来实现。</p></li></ol><h2 id="生成器-Builder"><a href="#生成器-Builder" class="headerlink" title="生成器 Builder"></a>生成器 Builder</h2><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-45-54.png"></p><p>使你能够分步骤创建复杂对象。该模式允许使用相同的创建代码生成不同类型和形式的对象。</p><h3 id="问题提出-2"><a href="#问题提出-2" class="headerlink" title="问题提出"></a>问题提出</h3><p>假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-47-54.png"></p><p>例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？</p><p>最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型） 都会让这个层次结构更加复杂。</p><p>另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 这种方法确实可以避免生成子类， 但它却会造成另外一个问题。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-48-49.png"></p><p>通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-50-09.png"></p><p>“该模式会将对象构造过程划分为一组步骤， 比如 build­Walls创建墙壁和 build­Door创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。</p><p>当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。</p><p>在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-51-09.png"></p><p>“例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后， 第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但是， 只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。</p><p>主管：你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-52-20.png"></p><p>严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。</p><p>此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。</p><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-54-09.png"></p><ol><li><p>生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</p></li><li><p>具体生成器 （Con­crete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</p></li><li><p>产品 （Prod­ucts） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</p></li><li><p>主管 （Direc­tor） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</p></li><li><p>客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</p></li></ol><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-56-05.png"></p><p>汽车是一个复杂对象， 有数百种不同的制造方法。 我们没有在 汽车类中塞入一个巨型构造函数， 而是将汽车组装代码抽取到单独的汽车生成器类中。 该类中有一组方法可用来配置汽车的各种部件。</p><p>如果客户端代码需要组装一辆与众不同、 精心调教的汽车， 它可以直接调用生成器。 或者， 客户端可以将组装工作委托给主管类， 因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。</p><p>你或许会感到吃惊， 但确实每辆汽车都需要一本使用手册 （说真的， 谁会去读它们呢？）。 使用手册会介绍汽车的每一项功能， 因此不同型号的汽车， 其使用手册内容也不一样。 因此， 你可以复用现有流程来制造实际的汽车及其对应的手册。当然， 编写手册和制造汽车不是一回事， 所以我们需要另外一个生成器对象来专门编写使用手册。 该类与其制造汽车的兄弟类都实现了相同的制造方法， 但是其功能不是制造汽车部件， 而是描述每个部件。 将这些生成器传递给相同的主管对象， 我们就能够生成一辆汽车或是一本使用手册了。</p><p>最后一个部分是获取结果对象。 尽管金属汽车和纸质手册存在关联， 但它们却是完全不同的东西。 我们无法在主管类和具体产品类不发生耦合的情况下， 在主管类中提供获取结果对象的方法。 因此， 我们只能通过负责制造过程的生成器来获取结果对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。下面的两个</span><br><span class="hljs-comment">// 产品尽管没有同样的接口，但却相互关联。</span><br><span class="hljs-keyword">class</span> Car is<br>  <span class="hljs-comment">// 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车（</span><br>  <span class="hljs-comment">// 运动型轿车、SUV 和敞篷车）可能会安装或启用不同的功能。</span><br><br><span class="hljs-keyword">class</span> Manual is<br>  <span class="hljs-comment">// 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。</span><br><br><br><span class="hljs-comment">// 生成器接口声明了创建产品对象不同部件的方法。</span><br>interface Builder is<br>  <span class="hljs-keyword">method</span> reset<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Seats(<span class="hljs-operator">...</span>)</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Engine(<span class="hljs-operator">...</span>)</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">TripComputer(<span class="hljs-operator">...</span>)</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">GPS(<span class="hljs-operator">...</span>)</span><br><br><span class="hljs-comment">// 具体生成器类将遵循生成器接口并提供生成步骤的具体实现。你的程序中可能会</span><br><span class="hljs-comment">// 有多个以不同方式实现的生成器变体。</span><br><span class="hljs-keyword">class</span> CarBuilder implements Builder is<br>  <span class="hljs-keyword">private</span> field car:Car<br><br>  <span class="hljs-comment">// 一个新的生成器实例必须包含一个在后续组装过程中使用的空产品对象。</span><br>  constructor <span class="hljs-constructor">CarBuilder()</span> is<br>    this.reset<span class="hljs-literal">()</span><br>  <span class="hljs-comment">// reset（重置）方法可清除正在生成的对象。</span><br>  <span class="hljs-keyword">method</span> reset<span class="hljs-literal">()</span> is<br>    this.car = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Car()</span><br><br>  <span class="hljs-comment">// 所有生成步骤都会与同一个产品实例进行交互。</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Seats(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 设置汽车座位的数量。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Engine(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 安装指定的引擎。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">TripComputer(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 安装行车电脑。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">GPS(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 安装全球定位系统。</span><br><br>  <span class="hljs-comment">// 具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能</span><br>  <span class="hljs-comment">// 会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中</span><br>  <span class="hljs-comment">// 声明这些方法（至少在静态类型的编程语言中是这样的）。</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// 通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的</span><br>  <span class="hljs-comment">// 准备。因此生成器实例通常会在 `getProduct（获取产品）`方法主体末尾</span><br>  <span class="hljs-comment">// 调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确</span><br>  <span class="hljs-comment">// 调用重置方法后再去处理之前的结果。</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Product()</span>:Car is<br>    product = this.car<br>    this.reset<span class="hljs-literal">()</span><br>    return product<br><br><span class="hljs-comment">// 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。</span><br><span class="hljs-keyword">class</span> CarManualBuilder implements Builder is<br>  <span class="hljs-keyword">private</span> field manual:Manual<br><br>  constructor <span class="hljs-constructor">CarManualBuilder()</span> is<br>    this.reset<span class="hljs-literal">()</span><br><br>  <span class="hljs-keyword">method</span> reset<span class="hljs-literal">()</span> is<br>    this.manual = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Manual()</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Seats(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 添加关于汽车座椅功能的文档。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Engine(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 添加关于引擎的介绍。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">TripComputer(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 添加关于行车电脑的介绍。</span><br><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">GPS(<span class="hljs-operator">...</span>)</span> is<br>    <span class="hljs-comment">// 添加关于 GPS 的介绍。</span><br><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Product()</span>:Manual is<br>    <span class="hljs-comment">// 返回使用手册并重置生成器。</span><br><br><br><span class="hljs-comment">// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时</span><br><span class="hljs-comment">// 会很有帮助。由于客户端可以直接控制生成器，所以严格意义上来说，主管类并</span><br><span class="hljs-comment">// 不是必需的。</span><br><span class="hljs-keyword">class</span> Director is<br>  <span class="hljs-keyword">private</span> field builder:Builder<br><br>  <span class="hljs-comment">// 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通</span><br>  <span class="hljs-comment">// 过这种方式改变最新组装完毕的产品的最终类型。</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Builder(<span class="hljs-params">builder</span>:Builder)</span><br>    this.builder = builder<br><br>  <span class="hljs-comment">// 主管可使用同样的生成步骤创建多个产品变体。</span><br>  <span class="hljs-keyword">method</span> construct<span class="hljs-constructor">SportsCar(<span class="hljs-params">builder</span>: Builder)</span> is<br>    builder.reset<span class="hljs-literal">()</span><br>    builder.set<span class="hljs-constructor">Seats(2)</span><br>    builder.set<span class="hljs-constructor">Engine(<span class="hljs-params">new</span> SportEngine()</span>)<br>    builder.set<span class="hljs-constructor">TripComputer(<span class="hljs-params">true</span>)</span><br>    builder.set<span class="hljs-constructor">GPS(<span class="hljs-params">true</span>)</span><br><br>  <span class="hljs-keyword">method</span> construct<span class="hljs-constructor">SUV(<span class="hljs-params">builder</span>: Builder)</span> is<br>    <span class="hljs-comment">// ...</span><br><br><br><span class="hljs-comment">// 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果</span><br><span class="hljs-comment">// 将需要从生成器对象中获取。</span><br><span class="hljs-keyword">class</span> Application is<br><br>  <span class="hljs-keyword">method</span> make<span class="hljs-constructor">Car()</span> is<br>    director = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Director()</span><br><br>    CarBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CarBuilder()</span><br>    director.construct<span class="hljs-constructor">SportsCar(<span class="hljs-params">builder</span>)</span><br>    Car car = builder.get<span class="hljs-constructor">Product()</span><br><br>    CarManualBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CarManualBuilder()</span><br>    director.construct<span class="hljs-constructor">SportsCar(<span class="hljs-params">builder</span>)</span><br><br>    <span class="hljs-comment">// 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和</span><br>    <span class="hljs-comment">// 产品的存在，也不会对其产生依赖。</span><br>    Manual manual = builder.get<span class="hljs-constructor">Product()</span><br>    <br></code></pre></td></tr></table></figure><h3 id="适合应用场景"><a href="#适合应用场景" class="headerlink" title="适合应用场景"></a>适合应用场景</h3><p>1、使用生成器模式可避免 “重叠构造函数 （tele­scop­ic con­struc­tor）” 的出现。</p><p>假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Pizza &#123;<br>  <span class="hljs-constructor">Pizza(<span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span> &#123;<span class="hljs-operator"> ... </span>&#125;<br>  <span class="hljs-constructor">Pizza(<span class="hljs-params">int</span> <span class="hljs-params">size</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">cheese</span>)</span> &#123;<span class="hljs-operator"> ... </span>&#125;<br>  <span class="hljs-constructor">Pizza(<span class="hljs-params">int</span> <span class="hljs-params">size</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">cheese</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">pepperoni</span>)</span> &#123;<span class="hljs-operator"> ... </span>&#125;<br>  <span class="hljs-comment">// ...</span><br>  <br></code></pre></td></tr></table></figure><blockquote><p>只有在 C# 或 Java 等支持方法重载的编程语言中才能写出如此复杂的构造函数。</p></blockquote><p>生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。</p><p>2、当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。</p><p>如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。</p><p>基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。</p><p>3、使用生成器构造组合树或其他复杂对象。</p><p>生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。</p><p>生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ol><li><p>清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。</p></li><li><p>在基本生成器接口中声明这些步骤。</p></li><li><p>为每个形式的产品创建具体生成器类， 并实现其构造步骤。</p><p>不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。</p></li><li><p>考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式。</p></li><li><p>客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。</p></li><li><p>只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。</p></li></ol><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li><li>生成不同形式的产品时， 你可以复用相同的制造代码。</li><li>单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。</li></ol><p>缺点：</p><ol><li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li></ol><h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li><p>在许多设计工作的初期都会使用工厂方法 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂、 原型或生成器 （更灵活但更加复杂）。</p></li><li><p>生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。</p></li><li><p>你可以在创建复杂组合树时使用生成器， 因为这可使其构造步骤以递归的方式运行。</p></li><li><p>你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p></li><li><p>抽象工厂、 生成器和原型都可以用单例来实现。</p></li></ul><h2 id="原型-Prototype"><a href="#原型-Prototype" class="headerlink" title="原型 Prototype"></a>原型 Prototype</h2><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-19_19-56-05.png"></p><p>让你能够复制已有对象，而又无需使用代码依赖他们所属的类。</p><h3 id="问题提出-3"><a href="#问题提出-3" class="headerlink" title="问题提出"></a>问题提出</h3><p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p><p>不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_20-54-49.png"></p><p>直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。</p><p>所有的类对 克隆方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p><p>支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_20-56-38.png"></p><p>其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。</p><h3 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p>现实生活中， 产品在得到大规模生产前会使用原型进行各种测试。 但在这种情况下， 原型只是一种被动的工具， 不参与任何真正的生产活动。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_20-57-54.png" alt="一个细胞的分裂。"></p><p>由于工业原型并不是真正意义上的自我复制， 因此细胞有丝分裂 （还记得生物学知识吗？） 或许是更恰当的类比。 有丝分裂会产生一对完全相同的细胞。 原始细胞就是一个原型， 它在复制体的生成过程中起到了推动作用。</p><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_20-58-45.png"></p><ol><li><p>原型 （Pro­to­type） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。</p></li><li><p>具体原型 （Con­crete Pro­to­type） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</p></li><li><p>客户端 （Client） 可以复制实现了原型接口的任何对象。</p></li></ol><p>原型注册表实现</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_21-10-16.png"></p><ol><li>原型注册表 （Pro­to­type Reg­istry） 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 名称 → 原型的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。</li></ol><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 原型模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-15_21-12-19.png" alt="克隆一系列位于同一类层次结构中的对象"></p><p>所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// 基础原型。</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> Shape <span class="hljs-keyword">is</span><br>  field X: int<br>  field Y: int<br>  field color: <span class="hljs-keyword">string</span><br><br>  <span class="hljs-comment">// 常规构造函数。</span><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Shape</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// ...</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-comment">// 原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">Shape</span><span class="hljs-params">(source: Shape)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">X</span> = <span class="hljs-title">source</span>.<span class="hljs-title">X</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">Y</span> = <span class="hljs-title">source</span>.<span class="hljs-title">Y</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">color</span> = <span class="hljs-title">source</span>.<span class="hljs-title">color</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-comment">// clone（克隆）操作会返回一个形状子类。</span></span><br><span class="hljs-function">  <span class="hljs-title">abstract</span> <span class="hljs-title">method</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span>:</span>Shape<br><br><br><span class="hljs-comment">// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span><br><span class="hljs-comment">// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span><br><span class="hljs-comment">// 成的克隆对象。这可以保持克隆结果的一致。</span><br><span class="hljs-keyword">class</span> Rectangle extends Shape <span class="hljs-keyword">is</span><br>  field width: int<br>  field height: int<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(source: Rectangle)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 需要调用父构造函数来复制父类中定义的私有成员变量。</span></span><br><span class="hljs-function">    <span class="hljs-title">super</span><span class="hljs-params">(source)</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">width</span> = <span class="hljs-title">source</span>.<span class="hljs-title">width</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">height</span> = <span class="hljs-title">source</span>.<span class="hljs-title">height</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span>:</span>Shape <span class="hljs-keyword">is</span><br>    return new Rectangle(this)<br><br><br><span class="hljs-keyword">class</span> Circle extends Shape <span class="hljs-keyword">is</span><br>  field radius: int<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Circle</span><span class="hljs-params">(source: Circle)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">super</span><span class="hljs-params">(source)</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">radius</span> = <span class="hljs-title">source</span>.<span class="hljs-title">radius</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span>:</span>Shape <span class="hljs-keyword">is</span><br>    return new Circle(this)<br><br><span class="hljs-comment">// 客户端代码中的某个位置。</span><br><span class="hljs-keyword">class</span> Application <span class="hljs-keyword">is</span><br>  field shapes: <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> Shape<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Application</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">Circle</span> <span class="hljs-title">circle</span> = <span class="hljs-title">new</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">circle</span>.<span class="hljs-title">X</span> = 10</span><br><span class="hljs-function">    <span class="hljs-title">circle</span>.<span class="hljs-title">Y</span> = 10</span><br><span class="hljs-function">    <span class="hljs-title">circle</span>.<span class="hljs-title">radius</span> = 20</span><br><span class="hljs-function">    <span class="hljs-title">shapes</span>.<span class="hljs-title">add</span><span class="hljs-params">(circle)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">Circle</span> <span class="hljs-title">anotherCircle</span> = <span class="hljs-title">circle</span>.<span class="hljs-title">clone</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">shapes</span>.<span class="hljs-title">add</span><span class="hljs-params">(anotherCircle)</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 容完全一样。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">Rectangle</span> <span class="hljs-title">rectangle</span> = <span class="hljs-title">new</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">rectangle</span>.<span class="hljs-title">width</span> = 10</span><br><span class="hljs-function">    <span class="hljs-title">rectangle</span>.<span class="hljs-title">height</span> = 20</span><br><span class="hljs-function">    <span class="hljs-title">shapes</span>.<span class="hljs-title">add</span><span class="hljs-params">(rectangle)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">businessLogic</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 其完全相同的复制品。</span></span><br><span class="hljs-function">    <span class="hljs-title">Array</span> <span class="hljs-title">shapesCopy</span> = <span class="hljs-title">new</span> <span class="hljs-title">Array</span> <span class="hljs-title">of</span> <span class="hljs-title">Shapes</span>.</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-comment">// 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span><br><span class="hljs-function">    <span class="hljs-title">foreach</span> <span class="hljs-params">(s <span class="hljs-keyword">in</span> shapes)</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">      <span class="hljs-title">shapesCopy</span>.<span class="hljs-title">add</span><span class="hljs-params">(s.clone()</span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-comment">// `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 子元素的复制品。</span></span><br></code></pre></td></tr></table></figure><h3 id="适合应用场景-1"><a href="#适合应用场景-1" class="headerlink" title="适合应用场景"></a>适合应用场景</h3><ol><li><p>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</p><p>这一点考量通常出现在代码需要处理<strong>第三方代码通过接口传递过来的对象</strong>时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息（包括私有成员的信息）。</p><p>原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。</p></li><li><p>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</p><p>在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。</p><p>客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。</p></li></ol><h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>创建原型接口， 并在其中声明 克隆方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。</p></li><li><p>原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。</p><p>如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。</p></li><li><p>克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 否则， 克隆方法可能会生成父类的对象。</p></li><li><p>你还可以创建一个中心化原型注册表， 用于存储常用原型。</p><p>你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。</p><p>最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</p></li></ol><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>你可以克隆对象， 而无需与它们所属的具体类相耦合。</li><li>你可以克隆预生成原型， 避免反复运行初始化代码。</li><li>你可以更方便地生成复杂对象。</li><li>你可以用继承以外的方式来处理复杂对象的不同配置。</li></ol><p>缺点：</p><ol><li>克隆包含循环引用的复杂对象可能会非常麻烦。</li></ol><h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol><li><p>在许多设计工作的初期都会使用工厂方法 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂、 原型或生成器 （更灵活但更加复杂）。</p></li><li><p>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</p></li><li><p>原型可用于保存命令的历史记录。</p></li><li><p>大量使用组合和装饰的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。”</p></li><li><p>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。</p></li><li><p>有时候原型可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</p></li><li><p>抽象工厂、 生成器和原型都可以用单例来实现。</p></li></ol><h2 id="单例-Singleton"><a href="#单例-Singleton" class="headerlink" title="单例 Singleton"></a>单例 Singleton</h2><p>让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p><h3 id="问题提出-4"><a href="#问题提出-4" class="headerlink" title="问题提出"></a>问题提出</h3><p>单例模式同时解决了两个问题， 所以违反了_单一职责原则_：</p><ol><li><p><strong>保证一个类只有一个实例。</strong> 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</p><p>它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p><p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-44-54.png"></p></li><li><p><strong>为该实例提供一个全局访问节点。</strong> 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</p><p>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</p><p>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</p></li></ol><p>如今， 单例模式已经变得非常流行， 以至于人们会将只解决上文描述中任意一个问题的东西称为单例。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>所有单例的实现都包含以下两个相同的步骤：</p><ul><li>将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。</li><li>新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</li></ul><p>如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。</p><h3 id="真实世界类比-1"><a href="#真实世界类比-1" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p>政府是单例模式的一个很好的示例。 一个国家只有一个官方政府。 不管组成政府的每个人的身份是什么，  “某政府” 这一称谓总是鉴别那些掌权者的全局访问节点。</p><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_21-51-03.png"></p><ul><li>单例 （Sin­gle­ton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。</li><li>单例的构造函数必须对客户端 （Client） 代码隐藏（通过private）。 调用 获取实例方法必须是获取单例对象的唯一方式。</li></ul><h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 数据库连接类即是一个单例。</p><p>该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处</span><br><span class="hljs-comment">// 都能访问相同的数据库连接实例。</span><br><span class="hljs-keyword">class</span> Database is<br>  <span class="hljs-comment">// 保存单例实例的成员变量必须被声明为静态类型。</span><br>  <span class="hljs-keyword">private</span> static field instance: Database<br><br>  <span class="hljs-comment">// 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构</span><br>  <span class="hljs-comment">// 造方法。</span><br>  <span class="hljs-keyword">private</span> constructor <span class="hljs-constructor">Database()</span> is<br>    <span class="hljs-comment">// 部分初始化代码（例如到数据库服务器的实际连接）。</span><br>    <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-comment">// 用于控制对单例实例的访问权限的静态方法。</span><br>  public static <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Instance()</span> is<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<span class="hljs-operator"> == </span>null) <span class="hljs-keyword">then</span><br>      acquire<span class="hljs-constructor">ThreadLock()</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">// 确保在该线程等待解锁时，其他线程没有初始化该实例。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<span class="hljs-operator"> == </span>null) <span class="hljs-keyword">then</span><br>          <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Database()</span><br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>instance<br><br>  <span class="hljs-comment">// 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span><br>  public <span class="hljs-keyword">method</span> query(sql) is<br>    <span class="hljs-comment">// 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以</span><br>    <span class="hljs-comment">// 在这里添加限流或缓冲逻辑。</span><br>    <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> Application is<br>  <span class="hljs-keyword">method</span> main<span class="hljs-literal">()</span> is<br>    Database foo = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br>    foo.query(<span class="hljs-string">&quot;SELECT ...&quot;</span>)<br>    <span class="hljs-comment">// ...</span><br>    Database bar = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Database</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br>    bar.query(<span class="hljs-string">&quot;SELECT ...&quot;</span>)<br>    <span class="hljs-comment">// 变量 `bar` 和 `foo` 中将包含同一个对象。</span><br></code></pre></td></tr></table></figure><h3 id="适合应用场景-2"><a href="#适合应用场景-2" class="headerlink" title="适合应用场景"></a>适合应用场景</h3><p>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。</p><p>单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</p><p>如果你需要更加严格地控制全局变量， 可以使用单例模式。</p><p>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p><p>请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例方法， 即 getInstance 中的代码即可实现。</p><h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>在类中添加一个私有静态成员变量用于保存单例实例。</p></li><li><p>声明一个公有静态构建方法用于获取单例实例。</p></li><li><p>在静态方法中实现”延迟初始化”（注意存在Check Than Act现象，注意线程安全问题）。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</p></li><li><p>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</p></li><li><p>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。</p></li></ol><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>你可以保证一个类只有一个实例。</li><li>你获得了一个指向该实例的全局访问节点。</li><li>仅在首次请求单例对象时对其进行初始化。</li></ol><p>缺点：</p><ol><li>违反了_单一职责原则_。 该模式同时解决了两个问题。</li><li>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li><li>该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li><li>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li></ol><h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol><li><strong>外观</strong>类通常可以转换为<strong>单例</strong>类， 因为在大部分情况下一个外观对象就足够了。</li><li>如果你能将对象的所有共享状态简化为一个享元对象， 那么<strong>享元</strong>就和<strong>单例</strong>类似了。 但这两个模式有两个根本性的不同。<ul><li>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</li><li>单例对象可以是可变的。 享元对象是不可变的。</li></ul></li><li>抽象工厂、 生成器和原型都可以用单例来实现。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-结构性模式</title>
    <link href="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效</p><h2 id="适配器-Adapter"><a href="#适配器-Adapter" class="headerlink" title="适配器 Adapter"></a>适配器 Adapter</h2><p>让接口不兼容的对象能够相互合作</p><p>亦称：封装器模式、Wapper、Adapter</p><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>倘若你正在开发一款股票市场检测程序，它会从不同来源下载XML格式的股票数据，然后向用户呈现出美观的图表。在开发过程中，你决定在程序中整合使用一个第三方的智能分析函数库。但是现在遇到一个问题，那就是这个第三方的分析函数库只兼容JSON格式的数据。</p><p><img src="https://i.loli.net/2021/09/12/PU6lbR7SEVIiQY8.png" alt="你无法 “直接” 使用分析函数库，因为它所需的输入数据格式与你的程序不兼容。 "></p><p>一种方式是，你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>你可以创建一个适配器。 这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。</p><p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。 例如， 你可以使用一个将所有数据转换为英制单位 （如英尺和英里） 的适配器封装运行于米和千米单位制中的对象。</p><p>适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：</p><ol><li>适配器实现与其中一个现有对象兼容的接口。</li><li>现有对象可以使用该接口安全地调用适配器方法。</li><li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li></ol><p>有时你甚至可以创建一个双向适配器来实现双向转换调用。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_10-57-06.png"></p><p>回到股票市场程序。 为了解决数据格式不兼容的问题， 你可以为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器， 然后让客户端仅通过这些适配器来与函数库进行交流。 当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。</p><h3 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-01-20.png" alt="出国旅行前后的旅行箱。"></p><p>如果你是第一次从美国到欧洲旅行， 那么在给笔记本充电时可能会大吃一惊。 不同国家的电源插头和插座标准不同。 美国插头和德国插座不匹配。 同时提供美国标准插座和欧洲标准插头的电源适配器可以解决你的难题。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-04-16.png"></p><ol><li><p>客户端 （Client） 是包含当前程序业务逻辑的类。</p></li><li><p>客户端接口 （Client Inter­face） 描述了其他类与客户端代码合作时必须遵循的协议。</p></li><li><p>服务 （Ser­vice） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。</p></li><li><p>适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</p></li></ol><p>客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</p><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>这一实现使用了继承机制： 适配器同时继承两个对象的接口。 <strong>请注意， 这种方式仅能在支持多重继承的编程语言中实现， 例如 C++。Java仅支持单继承</strong>”</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-10-27.png"></p><p>类适配器不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>下面介绍一个适配器模式演示基于经典的“方钉和圆孔”问题。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_11-23-53.png" alt="让方钉适配圆孔"></p><p>适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// 假设你有两个接口相互兼容的类：圆孔（RoundHole）和圆钉（RoundPeg）。</span><br><span class="hljs-keyword">class</span> RoundHole <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">RoundHole</span><span class="hljs-params">(radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回孔的半径。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">fits</span><span class="hljs-params">(peg: RoundPeg)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">this</span>.<span class="hljs-title">getRadius</span><span class="hljs-params">()</span> &gt;= <span class="hljs-title">peg</span>.<span class="hljs-title">getRadius</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">RoundPeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">RoundPeg</span><span class="hljs-params">(radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回钉子的半径。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 但还有一个不兼容的类：方钉（SquarePeg）。</span></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SquarePeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(width)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 返回方钉的宽度。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适配器对象作为圆钉。</span></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SquarePegAdapter</span> <span class="hljs-title">extends</span> <span class="hljs-title">RoundPeg</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-comment">// 在实际情况中，适配器中会包含一个 SquarePeg 类的实例。</span></span><br><span class="hljs-function">  <span class="hljs-title">private</span> <span class="hljs-title">field</span> <span class="hljs-title">peg</span>:</span> SquarePeg<br><br>  <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(peg: SquarePeg)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">peg</span> = <span class="hljs-title">peg</span></span><br><span class="hljs-function"> </span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 适配器会假扮为一个圆钉，其半径刚好能与适配器实际封装的方钉搭配起来。</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">peg</span>.<span class="hljs-title">getWidth</span><span class="hljs-params">()</span> * <span class="hljs-title">Math</span>.<span class="hljs-title">sqrt</span><span class="hljs-params">(2)</span> / 2</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 客户端代码中的某个位置。</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span> = <span class="hljs-title">new</span> <span class="hljs-title">RoundHole</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">rpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">RoundPeg</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(rpeg)</span> <span class="hljs-comment">// true</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">small_sqpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(5)</span></span><br><span class="hljs-function"><span class="hljs-title">large_sqpeg</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePeg</span><span class="hljs-params">(10)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(small_sqpeg)</span> <span class="hljs-comment">// 此处无法编译（类型不一致）。</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">small_sqpeg_adapter</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(small_sqpeg)</span></span><br><span class="hljs-function"><span class="hljs-title">large_sqpeg_adapter</span> = <span class="hljs-title">new</span> <span class="hljs-title">SquarePegAdapter</span><span class="hljs-params">(large_sqpeg)</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(small_sqpeg_adapter)</span> <span class="hljs-comment">// true</span></span><br><span class="hljs-function"><span class="hljs-title">hole</span>.<span class="hljs-title">fits</span><span class="hljs-params">(large_sqpeg_adapter)</span> <span class="hljs-comment">// false</span></span><br></code></pre></td></tr></table></figure><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</p><p>适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</p><p>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>确保至少有两个类的接口不兼容：<ul><li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。</li><li>一个或多个将受益于使用服务类的客户端类。</li></ul></li><li>声明客户端接口，描述客户端与服务如何交互；</li><li>创建遵循客户端接口的适配器。所有方法暂时都为空；</li><li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li><li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li><li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>单一职责原则：你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li><li>开闭原则：只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li></ol><p>缺点：</p><ol><li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li></ol><h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol><li><p>桥接通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p></li><li><p>适配器可以对已有对象的接口进行修改， 装饰则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p></li><li><p>适配器能为被封装对象提供不同的接口， 代理能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p></li><li><p>外观为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p></li><li><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p></li></ol><h2 id="桥接-Bridge"><a href="#桥接-Bridge" class="headerlink" title="桥接 Bridge"></a>桥接 Bridge</h2><p>将一个大类或者一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。</p><h3 id="问题提出-1"><a href="#问题提出-1" class="headerlink" title="问题提出"></a>问题提出</h3><p>假如你有一个几何 形状Shape类， 从它能扩展出两个子类：  圆形Cir­cle和 方形Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为 红色Red和 蓝色Blue的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如 蓝色圆形Blue­Cir­cle和 红色方形Red­Square 。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_12-54-47.png" alt="所有组合类的数量将以几何倍数增长"></p><p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。 如此以往， 情况会越来越糟糕。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>问题的根本原因是我们试图在两个独立的维度——形状与颜色——上扩展形状类。 这在处理类继承时是很常见的问题。</p><p>桥接模式通过将继承改为组合的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_12-57-47.png" alt="将一个类层次转化为多个相关的类层析，避免单个类层次的失控"> </p><p>根据该方法， 我们可以将颜色相关的代码抽取到拥有 红色和 蓝色两个子类的颜色类中， 然后在 形状类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 形状和 颜色之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。</p><h3 id="抽象部分与实现部分"><a href="#抽象部分与实现部分" class="headerlink" title="抽象部分与实现部分"></a>抽象部分与实现部分</h3><p>设计模式四人组的著作 在桥接定义中提出了抽象部分和实现部分两个术语。 我觉得这些术语过于学术了， 反而让模式看上去比实际情况更加复杂。 在介绍过形状和颜色的简单例子后， 我们来看看四人组著作中让人望而生畏的词语的含义。</p><p>抽象部分 （也被称为接口） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给实现部分层（亦称 平台 ）</p><p>注意， 这里提到的内容与编程语言中的接口或抽象类无关。 它们并不是一回事。</p><p>在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。</p><p>一般来说， 你可以在两个独立方向上扩展这种应用：</p><ul><li>开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置）</li><li>支持多个不同的 API （例如， 能够在 Win­dows、 Linux 和 macOS 上运行该程序）。</li></ul><p>在最糟糕的情况下， 程序可能会是一团乱麻， 其中包含数百种条件语句， 连接着代码各处不同种类的 GUI 和各种API。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-05-16.png" alt="在庞杂的代码中， 即使是很小的改动都非常难以完成， 因为你必须要在整体上对代码有充分的理解。 而在较小且定义明确的模块中， 进行修改则要容易得多 "></p><p>你可以将特定接口-平台的组合代码抽取到独立的类中， 以在混乱中建立一些秩序。 但是， 你很快会发现这种类的数量很多。 类层次将以指数形式增长， 因为每次添加一个新的 GUI 或支持一种新的 API 都需要创建更多的类。</p><p>让我们试着用桥接模式来解决这个问题。 该模式建议将类拆分为两个类层次结构：</p><ul><li>抽象部分： 程序的 GUI 层。</li><li>实现部分： 操作系统的 API。</li></ul><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-09-29.png" alt="创建跨平台应用程序的一种方法"></p><p>抽象对象控制程序的外观， 并将真实工作委派给连入的实现对象。 不同的实现只要遵循相同的接口就可以互换， 使同一 GUI 可在 Win­dows 和 Linux 下运行。</p><p>最后的结果是： 你无需改动与 API 相关的类就可以修改 GUI 类。 此外如果想支持一个新的操作系统， 只需在实现部分层次中创建一个子类即可。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-12-17.png"></p><ol><li><p>抽象部分 （Abstrac­tion） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</p></li><li><p>实现部分 （Imple­men­ta­tion） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。</p></li><li><p>具体实现 （Con­crete Imple­men­ta­tions） 中包括特定于平台的代码。</p></li><li><p>精确抽象 （Refined Abstrac­tion） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</p></li><li><p>通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</p></li></ol><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>示例演示了桥接模式如何拆分程序中同时管理设备及其遥控器的庞杂代码。  设备Device类作为实现部分， 而 遥控器Remote类则作为抽象部分。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_13-15-02.png" alt="最初类层次结构被才分成两个部分：设备和遥控器"></p><p>遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。</p><p>你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。</p><p>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实</span><br><span class="hljs-comment">// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span><br><span class="hljs-keyword">class</span> RemoteControl is<br>  protected field device: Device<br>  constructor <span class="hljs-constructor">RemoteControl(<span class="hljs-params">device</span>: Device)</span> is<br>    this.device = device<br>  <span class="hljs-keyword">method</span> toggle<span class="hljs-constructor">Power()</span> is<br>    <span class="hljs-keyword">if</span> (device.is<span class="hljs-constructor">Enabled()</span>) <span class="hljs-keyword">then</span><br>      device.disable<span class="hljs-literal">()</span><br>    <span class="hljs-keyword">else</span><br>      device.enable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> volume<span class="hljs-constructor">Down()</span> is<br>    device.set<span class="hljs-constructor">Volume(<span class="hljs-params">device</span>.<span class="hljs-params">getVolume</span>()</span> - <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">method</span> volume<span class="hljs-constructor">Up()</span> is<br>    device.set<span class="hljs-constructor">Volume(<span class="hljs-params">device</span>.<span class="hljs-params">getVolume</span>()</span> + <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">method</span> channel<span class="hljs-constructor">Down()</span> is<br>    device.set<span class="hljs-constructor">Channel(<span class="hljs-params">device</span>.<span class="hljs-params">getChannel</span>()</span> - <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">method</span> channel<span class="hljs-constructor">Up()</span> is<br>    device.set<span class="hljs-constructor">Channel(<span class="hljs-params">device</span>.<span class="hljs-params">getChannel</span>()</span> + <span class="hljs-number">1</span>)<br><br><br><span class="hljs-comment">// 你可以独立于设备类的方式从抽象层中扩展类。</span><br><span class="hljs-keyword">class</span> AdvancedRemoteControl extends RemoteControl is<br>  <span class="hljs-keyword">method</span> mute<span class="hljs-literal">()</span> is<br>    device.set<span class="hljs-constructor">Volume(0)</span><br><br><br><span class="hljs-comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相</span><br><span class="hljs-comment">// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而</span><br><span class="hljs-comment">// 抽象接口则会基于这些操作定义较高层次的操作。</span><br>interface Device is<br>  <span class="hljs-keyword">method</span> is<span class="hljs-constructor">Enabled()</span><br>  <span class="hljs-keyword">method</span> enable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> disable<span class="hljs-literal">()</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Volume()</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Volume(<span class="hljs-params">percent</span>)</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">Channel()</span><br>  <span class="hljs-keyword">method</span> set<span class="hljs-constructor">Channel(<span class="hljs-params">channel</span>)</span><br><br><br><span class="hljs-comment">// 所有设备都遵循相同的接口。</span><br><span class="hljs-keyword">class</span> Tv implements Device is<br>  <span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> Radio implements Device is<br>  <span class="hljs-comment">// ...</span><br><br><br><span class="hljs-comment">// 客户端代码中的某个位置。</span><br>tv = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Tv()</span><br>remote = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RemoteControl(<span class="hljs-params">tv</span>)</span><br>remote.toggle<span class="hljs-constructor">Power()</span><br><br>radio = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Radio()</span><br>remote = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AdvancedRemoteControl(<span class="hljs-params">radio</span>)</span><br></code></pre></td></tr></table></figure><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p><p>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</p><p>2、如果你希望在几个独立维度上扩展一个类， 可使用该模式。</p><p>桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</p><p>3、如果你需要在运行时切换不同实现方法， 可使用桥接模式。</p><p>当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</p><p>顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。</p><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</p></li><li><p>了解客户端的业务需求， 并在抽象基类中定义它们。</p></li><li><p>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</p></li><li><p>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</p></li><li><p>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</p></li><li><p>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</p></li><li><p>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</p></li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>你可以创建与平台无关的类和程序。</li><li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li><li>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li><li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li></ol><p>缺点：</p><ol><li>对高内聚的类使用该模式可能会让代码更加复杂。</li></ol><h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol><li><p>桥接通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p></li><li><p>桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p></li><li><p>你可以将抽象工厂和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p></li><li><p>你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p></li></ol><h2 id="组合-Composite"><a href="#组合-Composite" class="headerlink" title="组合 Composite"></a>组合 Composite</h2><p>可以使用该模式将对象组合成树状结构，并且能够像使用独立对象一样使用他们。</p><h3 id="问题提出-2"><a href="#问题提出-2" class="headerlink" title="问题提出"></a>问题提出</h3><p>如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。</p><p>例如， 你有两类对象：  产品 和 盒子 。 一个盒子中可以包含多个 产品或者几个较小的 盒子 。 这些小 盒子中同样可以包含一些 产品或更小的 盒子 ， 以此类推。</p><p>假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子……以及其他盒子。 此时你会如何计算每张订单的总价格呢？</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-08-16.png"></p><p>你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后计算总价。 这在真实世界中或许可行， 但在程序中， 你并不能简单地使用循环语句来完成该工作。 你必须事先知道所有 产品和 盒子的类别， 所有盒子的嵌套层数以及其他繁杂的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>组合模式建议使用一个通用接口来与 产品和 盒子进行交互， 并且在该接口中声明一个计算总价的方法。</p><p>那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-10-43.png"></p><p>该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。</p><h3 id="真实世界类比-1"><a href="#真实世界类比-1" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-12-18.png"></p><p>大部分国家的军队都采用层次结构管理。 每支部队包括几个师， 师由旅构成， 旅由团构成， 团可以继续划分为排。 最后， 每个排由一小队实实在在的士兵组成。 军事命令由最高层下达， 通过每个层级传递， 直到每位士兵都知道自己应该服从的命令。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-14-17.png"></p><p>1、组件 （Com­po­nent） 接口描述了树中简单项目和复杂项目所共有的操作。</p><p>2、叶节点 （Leaf） 是树的基本结构， 它不包含子项目。</p><p>一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p><p>3、容器 （Con­tain­er）——又名 “组合 （Com­pos­ite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。</p><p>容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</p><p>4、客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</p><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 我们将借助组合模式帮助你在图形编辑器中实现一系列的几何图形。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-12_15-17-26.png"></p><p>组合图形Com­pound­Graph­ic是一个容器， 它可以由多个包括容器在内的子图形构成。 组合图形与简单图形拥有相同的方法。 但是， 组合图形自身并不完成具体工作， 而是将请求递归地传递给自己的子项目， 然后 “汇总” 结果。</p><p>通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 组件接口会声明组合中简单和复杂对象的通用操作。</span><br><span class="hljs-keyword">interface</span> Graphic <span class="hljs-keyword">is</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象</span><br><span class="hljs-function">// 通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Dot</span> <span class="hljs-title">implements</span> <span class="hljs-title">Graphic</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">x</span>, <span class="hljs-title">y</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">Dot</span><span class="hljs-params">(x, y)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">x</span> += <span class="hljs-title">x</span>, <span class="hljs-title">this</span>.<span class="hljs-title">y</span> += <span class="hljs-title">y</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在坐标位置<span class="hljs-params">(X,Y)</span>处绘制一个点。</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 所有组件类都可以扩展其他组件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">Circle</span> <span class="hljs-title">extends</span> <span class="hljs-title">Dot</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">radius</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">constructor</span> <span class="hljs-title">Circle</span><span class="hljs-params">(x, y, radius)</span> <span class="hljs-comment">&#123; ... &#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在坐标位置<span class="hljs-params">(X,Y)</span>处绘制一个半径为 <span class="hljs-title">R</span> 的圆。</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项</span><br><span class="hljs-function">// 目，然后“汇总”结果。 </span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">CompoundGraphic</span> <span class="hljs-title">implements</span> <span class="hljs-title">Graphic</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">children</span>:</span> <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> Graphic<br><br>  <span class="hljs-comment">// 组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。</span><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">add</span><span class="hljs-params">(child: Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 在子项目数组中添加一个子项目。</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">remove</span><span class="hljs-params">(child: Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 从子项目数组中移除一个子项目。</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">move</span><span class="hljs-params">(x, y)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">foreach</span> <span class="hljs-params">(child <span class="hljs-keyword">in</span> children)</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">      <span class="hljs-title">child</span>.<span class="hljs-title">move</span><span class="hljs-params">(x, y)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  // 组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和</span><br><span class="hljs-function">  // 汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，</span><br><span class="hljs-function">  // 最后组合将会完成整个对象树的遍历工作。</span><br><span class="hljs-function">    <span class="hljs-title">method</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    // 1. 对于每个子部件：</span><br><span class="hljs-function">    //     - 绘制该部件。</span><br><span class="hljs-function">    //     - 更新边框坐标。</span><br><span class="hljs-function">    // 2. 根据边框坐标绘制一个虚线长方形。</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">// 客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同</span><br><span class="hljs-function">// 时支持简单叶节点组件和复杂组件。</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">ImageEditor</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">  <span class="hljs-title">field</span> <span class="hljs-title">all</span>:</span> CompoundGraphic<br><br>  <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span> = <span class="hljs-title">new</span> <span class="hljs-title">CompoundGraphic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Dot(1, 2)</span>)</span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Circle(5, 3, 10)</span>)</span><br><span class="hljs-function">    // ...</span><br><span class="hljs-function"></span><br><span class="hljs-function">  // 将所需组件组合为复杂的组合组件。</span><br><span class="hljs-function">  <span class="hljs-title">method</span> <span class="hljs-title">groupSelected</span><span class="hljs-params">(components: <span class="hljs-keyword">array</span> <span class="hljs-keyword">of</span> Graphic)</span> <span class="hljs-title">is</span></span><br><span class="hljs-function">    <span class="hljs-title">group</span> = <span class="hljs-title">new</span> <span class="hljs-title">CompoundGraphic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">foreach</span> <span class="hljs-params">(component <span class="hljs-keyword">in</span> components)</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">      <span class="hljs-title">group</span>.<span class="hljs-title">add</span><span class="hljs-params">(component)</span></span><br><span class="hljs-function">      <span class="hljs-title">all</span>.<span class="hljs-title">remove</span><span class="hljs-params">(component)</span></span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">group</span>)</span></span><br><span class="hljs-function">    // 所有组件都将被绘制。</span><br><span class="hljs-function">    <span class="hljs-title">all</span>.<span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>1、如果你需要实现树状对象结构， 可以使用组合模式。</p><p> 组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。</p><p> 2、如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p><p> 组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</p><h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><p>1、确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p><p>2、声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p><p>3、创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p><p>4、创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p><p>实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p><p>5、最后， 在容器中定义添加和删除子元素的方法。</p><p>记住， 这些操作可在组件接口中声明。 这将会违反_接口隔离原则_， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><p>1、你可以利用多态和递归机制更方便地使用复杂树结构。</p><p>2、开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</p><p>缺点：</p><p>1、对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</p><h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><p>1、桥接、 状态和策略 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p><p>2、你可以在创建复杂组合树时使用生成器， 因为这可使其构造步骤以递归的方式运行。</p><p>3、责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p><p>4、你可以使用迭代器来遍历组合树。</p><p>5、你可以使用访问者对整个组合树执行操作。</p><p>6、你可以使用享元实现组合树的共享叶节点以节省内存。</p><p>7、组合和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p><p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p><p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p><p>8、大量使用组合和装饰的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p><h2 id="装饰-Decorator"><a href="#装饰-Decorator" class="headerlink" title="装饰 Decorator"></a>装饰 Decorator</h2><p>允许通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设你正在开发一个提供通知功能的库， 其他程序可使用它向用户发送关于重要事件的通知。</p><p>库的最初版本基于 通知器Noti­fi­er类， 其中只有很少的几个成员变量， 一个构造函数和一个 send发送方法。 该方法可以接收来自客户端的消息参数， 并将该消息发送给一系列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作为客户端的第三方程序仅会创建和配置通知器对象一次， 然后在有重要事件发生时对其进行调用。</p><h2 id="外观-Facade"><a href="#外观-Facade" class="headerlink" title="外观 Facade"></a>外观 Facade</h2><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-10-07_22-44-26.png"></p><p>能够为成序库、框架或者其他复杂类提供一个简单的接口。</p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。</p><p>最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却<u><strong>包含了客户端真正关心的功能</strong></u>。</p><p><strong>如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便</strong>，</p><p>例如， 上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库， 但它只需使用一个包含 encode­(filename, format)方法 （以文件名与文件格式为参数进行编码的方法） 的类即可。 在创建这个类并将其连接到视频转换库后， 你就拥有了自己的第一个外观。</p><h3 id="真实世界类比-2"><a href="#真实世界类比-2" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-10-07_22-47-56.png"></p><p>当你通过电话给商店下达订单时， 接线员就是该商店的所有服务和部门的外观。 接线员为你提供了一个同购物系统、 支付网关和各种送货服务进行互动的简单语音接口。</p><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-10-07_22-52-20.png"></p><ol><li><p><strong>外观</strong> （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p></li><li><p>创建<strong>附加外观</strong> （Addi­tion­al Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p></li><li><p><strong>复杂子系统</strong> （Com­plex Sub­sys­tem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p><p>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p></li><li><p>客户端 （Client） 使用外观代替对子系统对象的直接调用。</p></li></ol><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中， 外观模式简化了客户端与复杂视频转换框架之间的交互。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-10-07_23-01-17.png"></p><p>你可以创建一个封装所需功能并隐藏其他代码的外观类， 从而无需使全部代码直接与数十个框架类进行交互。 该结构还能将未来框架升级或更换所造成的影响最小化， 因为你只需修改程序中外观方法的实现即可。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法</span><br><span class="hljs-comment">// 对其进行简化。</span><br><br><span class="hljs-keyword">class</span> VideoFile<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> OggCompressionCodec<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> MPEG4CompressionCodec<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> CodecFactory<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> BitrateReader<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">class</span> AudioMixer<br><span class="hljs-comment">// ...</span><br><br><br><span class="hljs-comment">// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在</span><br><span class="hljs-comment">// 功能性和简洁性之间做出的权衡。</span><br><span class="hljs-keyword">class</span> VideoConverter is<br>  <span class="hljs-keyword">method</span> convert(filename, format):File is<br>    file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">VideoFile(<span class="hljs-params">filename</span>)</span><br>    sourceCodec = <span class="hljs-keyword">new</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CodecFactory</span>.</span></span>extract(file)<br>    <span class="hljs-keyword">if</span> (format<span class="hljs-operator"> == </span><span class="hljs-string">&quot;mp4&quot;</span>)<br>      destinationCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MPEG4CompressionCodec()</span><br>    <span class="hljs-keyword">else</span><br>      destinationCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OggCompressionCodec()</span><br>    buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BitrateReader</span>.</span></span>read(filename, sourceCodec)<br>    result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BitrateReader</span>.</span></span>convert(buffer, destinationCodec)<br>    result = (<span class="hljs-keyword">new</span> <span class="hljs-constructor">AudioMixer()</span>).fix(result)<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">result</span>)</span><br><br><span class="hljs-comment">// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，</span><br><span class="hljs-comment">// 那只需重写外观类即可。</span><br><span class="hljs-keyword">class</span> Application is<br>  <span class="hljs-keyword">method</span> main<span class="hljs-literal">()</span> is<br>    convertor = <span class="hljs-keyword">new</span> <span class="hljs-constructor">VideoConverter()</span><br>    mp4 = convertor.convert(<span class="hljs-string">&quot;funny-cats-video.ogg&quot;</span>, <span class="hljs-string">&quot;mp4&quot;</span>)<br>    mp4.save<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</p><blockquote><p>子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</p></blockquote></li><li><p>如果需要将子系统组织为多层结构， 可以使用外观。</p><blockquote><p>创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</p></blockquote></li></ul><p>让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与中介者模式非常相似。</p><h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p><strong>考虑能否在现有子系统的基础上提供一个更简单的接口</strong>。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。</p></li><li><p><strong>在一个新的外观类中声明并实现该接口</strong>。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化， 也没有对其后续生命周期进行管理， 那么外观必须完成此类工作。</p></li><li><p>如果要充分发挥这一模式的优势， 你必须<strong>确保所有客户端代码仅通过外观来与子系统进行交互</strong>。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。</p></li><li><p><strong>如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。</strong></p></li></ol><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：你可以让自己的代码独立于复杂子系统。</p><p>缺点：外观可能成为与程序中所有类都耦合的上帝对象。</p><h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li><p><strong>外观</strong>为现有对象定义了一个新接口， <strong>适配器</strong>则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p></li><li><p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<strong>抽象工厂</strong>来代替<strong>外观</strong>。</p></li><li><p>享元展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。</p></li><li><p><strong>外观</strong>和<strong>中介者</strong>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。</p><ul><li>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li><li>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li></ul></li><li><p><strong>外观类</strong>通常可以转换为<strong>单例类</strong>， 因为在大部分情况下一个外观对象就足够了。</p></li><li><p><strong>外观</strong>与<strong>代理</strong>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 <strong>代理</strong>与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p></li></ul><h2 id="享元-Flaweight"><a href="#享元-Flaweight" class="headerlink" title="享元 Flaweight"></a>享元 Flaweight</h2><p>摒弃了在每个对象中保存数据的方式，通过共享多个对象所共有的相同状态，让你能够在有限的内存容量中载入更多对象。</p><h2 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h2><p>让我们能够提供对象的替代品或者占位符。代理控制着对于原对象的访问，并且允许在将请求提交给对象前后进行一些处理。</p><h3 id="问题提出-3"><a href="#问题提出-3" class="headerlink" title="问题提出"></a>问题提出</h3><p>为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-05-07.png" alt="数据库查询有可能会非常缓慢。"></p><p>你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。</p><p>在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-07-45.png" alt="代理将自己伪装成数据库对象， 可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。"><br>这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。</p><h3 id="真实世界类比-3"><a href="#真实世界类比-3" class="headerlink" title="真实世界类比"></a>真实世界类比</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-09-56.png"></p><p>信用卡是银行账户的代理， 银行账户则是一大捆现金的代理。 它们都实现了同样的接口， 均可用于进行支付。 消费者会非常满意， 因为不必随身携带大量现金； 商店老板同样会十分高兴， 因为交易收入能以电子化的方式进入商店的银行账户中， 无需担心存款时出现现金丢失或被抢劫的情况。</p><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-10-53.png"></p><ol><li><strong>服务接口</strong> （Ser­vice Inter­face） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</li><li><strong>服务</strong> （Ser­vice） 类提供了一些实用的业务逻辑。</li><li><strong>代理</strong> （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。</li><li><strong>客户端</strong> （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</li></ol><h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>本例演示如何使用代理模式在第三方腾讯视频 （Ten­centVideo， 代码示例中记为 TV） 程序库中添加延迟初始化和缓存。</p><p><img src="/2021/09/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/Snipaste_2021-09-20_12-12-05.png"></p><p>程序库提供了视频下载类。 但是该类的效率非常低。 如果客户端程序多次请求同一视频， 程序库会反复下载该视频， 而不会将首次下载的文件缓存下来复用。</p><p>代理类实现和原下载器相同的接口， 并将所有工作委派给原下载器。 不过， 代理类会保存所有的文件下载记录， 如果程序多次请求同一文件， 它会返回缓存的文件。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 远程服务接口。</span><br>interface ThirdPartyTVLib is<br>  <span class="hljs-keyword">method</span> <span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span><br>  <span class="hljs-keyword">method</span> download<span class="hljs-constructor">Video(<span class="hljs-params">id</span>)</span><br><br><span class="hljs-comment">// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于</span><br><span class="hljs-comment">// 用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息</span><br><span class="hljs-comment">// 一模一样，程序的速度依然会减慢。</span><br><span class="hljs-keyword">class</span> ThirdPartyTVClass implements ThirdPartyTVLib is<br>  <span class="hljs-keyword">method</span> <span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span> is<br>    <span class="hljs-comment">// 向腾讯视频发送一个 API 请求。</span><br><br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span> is<br>    <span class="hljs-comment">// 获取某个视频的元数据。</span><br><br>  <span class="hljs-keyword">method</span> download<span class="hljs-constructor">Video(<span class="hljs-params">id</span>)</span> is<br>    <span class="hljs-comment">// 从腾讯视频下载一个视频文件。</span><br><br><span class="hljs-comment">// 为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无</span><br><span class="hljs-comment">// 法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签</span><br><span class="hljs-comment">// 名是`final（最终）`。因此我们会在一个实现了服务类接口的新代理类中放入</span><br><span class="hljs-comment">// 缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。</span><br><span class="hljs-keyword">class</span> CachedTVClass implements ThirdPartyTVLib is<br>  <span class="hljs-keyword">private</span> field service: ThirdPartyTVLib<br>  <span class="hljs-keyword">private</span> field listCache, videoCache<br>  field needReset<br><br>  constructor <span class="hljs-constructor">CachedTVClass(<span class="hljs-params">service</span>: ThirdPartyTVLib)</span> is<br>    this.service = service<br><br>  <span class="hljs-keyword">method</span> <span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span> is<br>    <span class="hljs-keyword">if</span> (listCache<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>needReset)<br>      listCache = service.<span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span><br>    return listCache<br>  <span class="hljs-keyword">method</span> get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span> is<br>    <span class="hljs-keyword">if</span> (videoCache<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>needReset)<br>      videoCache = service.get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span><br>    return videoCache<br><br>  <span class="hljs-keyword">method</span> download<span class="hljs-constructor">Video(<span class="hljs-params">id</span>)</span> is<br>    <span class="hljs-keyword">if</span> (!download<span class="hljs-constructor">Exists(<span class="hljs-params">id</span>)</span><span class="hljs-operator"> || </span>needReset)<br>      service.download<span class="hljs-constructor">Video(<span class="hljs-params">id</span>)</span><br><br><span class="hljs-comment">// 之前直接与服务对象交互的 GUI 类不需要改变，前提是它仅通过接口与服务对</span><br><span class="hljs-comment">// 象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实</span><br><span class="hljs-comment">// 现了相同的接口。</span><br><span class="hljs-keyword">class</span> TVManager is<br>  protected field service: ThirdPartyTVLib<br><br>  constructor <span class="hljs-constructor">TVManager(<span class="hljs-params">service</span>: ThirdPartyTVLib)</span> is<br>    this.service = service<br><br>  <span class="hljs-keyword">method</span> render<span class="hljs-constructor">VideoPage(<span class="hljs-params">id</span>)</span> is<br>    info = service.get<span class="hljs-constructor">VideoInfo(<span class="hljs-params">id</span>)</span><br>    <span class="hljs-comment">// 渲染视频页面。</span><br><br>  <span class="hljs-keyword">method</span> render<span class="hljs-constructor">ListPanel()</span> is<br>    <span class="hljs-built_in">list</span> = service.<span class="hljs-built_in">list</span><span class="hljs-constructor">Videos()</span><br>    <span class="hljs-comment">// 渲染视频缩略图列表。</span><br><br>  <span class="hljs-keyword">method</span> react<span class="hljs-constructor">OnUserInput()</span> is<br>    render<span class="hljs-constructor">VideoPage()</span><br>    render<span class="hljs-constructor">ListPanel()</span><br><br><span class="hljs-comment">// 程序可在运行时对代理进行配置。</span><br><span class="hljs-keyword">class</span> Application is<br>  <span class="hljs-keyword">method</span> init<span class="hljs-literal">()</span> is<br>    aTVService = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ThirdPartyTVClass()</span><br>    aTVProxy = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CachedTVClass(<span class="hljs-params">aTVService</span>)</span><br>    manager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TVManager(<span class="hljs-params">aTVProxy</span>)</span><br>    manager.react<span class="hljs-constructor">OnUserInput()</span><br></code></pre></td></tr></table></figure><h3 id="适用应用场景"><a href="#适用应用场景" class="headerlink" title="适用应用场景"></a>适用应用场景</h3><p>使用代理模式的方式多种多样， 我们来看看最常见的几种。</p><ol><li><p>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</p><p>你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p></li><li><p>访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。</p><p>代理可仅在客户端凭据满足要求时将请求传递给服务对象。</p></li><li><p>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。</p><p>在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</p></li><li><p>记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</p><p>缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。</p><p>代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</p></li><li><p>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</p><p>代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。</p></li></ol><h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。</p></li><li><p>创建代理类， 其中必须包含一个存储指向服务的引用的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。</p></li><li><p>根据需求实现代理方法。 在大部分情况下， 代理在完成一些任务后应将工作委派给服务对象。</p></li><li><p>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。</p></li><li><p>可以考虑为服务对象实现延迟初始化。</p></li></ol><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ol><li>你可以在客户端毫无察觉的情况下控制服务对象。</li><li>如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。</li><li>即使服务对象还未准备好或不存在， 代理也可以正常工作。</li><li>开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。</li></ol><p>缺点</p><ol><li>代码可能会变得复杂， 因为需要新建许多类。</li><li>服务响应可能会延迟。</li></ol><h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ol><li><p>适配器能为被封装对象提供不同的接口， 代理能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p></li><li><p>外观与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p></li><li><p>装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java后端面试-错题本</title>
    <link href="/2021/09/05/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95-%E9%94%99%E9%A2%98%E6%9C%AC/"/>
    <url>/2021/09/05/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95-%E9%94%99%E9%A2%98%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/09/05/oymrkJPgf2aMKjd.png" alt="nowcoder1"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=326198#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=326198#summary</a></p><p><img src="https://i.loli.net/2021/09/05/OIh1FLr6MwQXiNG.png" alt="nowcoder2"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=2298#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=2298#summary</a></p><p><img src="https://i.loli.net/2021/09/05/iGLthmoRBcfdgzP.png" alt="nowcoder3"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=7141#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=7141#summary</a></p><p><img src="https://i.loli.net/2021/09/05/wMYNGdLaDtRH7if.png" alt="nowcoder4"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=69583#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=69583#summary</a></p><p><img src="https://i.loli.net/2021/09/05/V57bXDUkheWy8nj.png" alt="nowcoder5"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=7671#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=7671#summary</a></p><p><img src="https://i.loli.net/2021/09/05/57AjMgfYXrh4FGK.png" alt="nowcoder6"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=304923#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=304923#summary</a></p><p><img src="https://i.loli.net/2021/09/05/Fzgw3A2TlJOYGRa.png" alt="nowcoder7"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=323184#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=323184#summary</a></p><p>对内存  常量池  常量优化机制</p><p><img src="https://i.loli.net/2021/09/05/7yGZATixeaEkrS3.png" alt="nowcoder8"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=56006#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=56006#summary</a></p><p><img src="https://i.loli.net/2021/09/05/bl13ysUfD5xBghj.png" alt="nowcoder9"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=373261#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=373261#summary</a></p><p>三元运算符类型提升（包括包装类型也会进行类型提升）</p><p><img src="https://i.loli.net/2021/09/05/GQoY1SdwFma3Os5.png" alt="nowcoder10"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=26053#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=26053#summary</a></p><p><img src="https://i.loli.net/2021/09/05/USspraFmvjVBW8g.png" alt="nowcoder11"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=313963#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=313963#summary</a></p><p><img src="https://i.loli.net/2021/09/05/djJRltU8SmBVn6v.png" alt="nowcoder12"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=112859#summary">https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=112859#summary</a></p><p><img src="https://i.loli.net/2021/09/05/X1xymFQvJfEL9eg.png" alt="nowcoder13"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=323182#summary">https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=323182#summary</a></p><p><img src="https://i.loli.net/2021/09/05/6CuYzP24wJQ7FKa.png" alt="nowcoder14"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=7688#summary">https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=7688#summary</a></p><p><img src="https://i.loli.net/2021/09/05/TSYRuFCD3ovqs1e.png" alt="nowcoder15"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=23410#summary">https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=23410#summary</a></p><p><img src="https://i.loli.net/2021/09/05/HCOyRDacNlbmFVB.png" alt="nowcoder16"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=369120#summary">https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=369120#summary</a></p><p><img src="/2021/09/05/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95-%E9%94%99%E9%A2%98%E6%9C%AC/" alt="nowcoder17"></p><p><strong>以下</strong> <strong>b</strong> <strong>的值是：</strong> <strong>byte b = (byte)129;</strong></p><h1 id="正确答案-B-你的答案-C-错误"><a href="#正确答案-B-你的答案-C-错误" class="headerlink" title="正确答案: B  你的答案: C (错误)"></a>正确答案: B  你的答案: C (错误)</h1><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-126</span><br><span class="hljs-deletion">-127</span><br><span class="hljs-deletion">-128</span><br><span class="hljs-deletion">-129</span><br></code></pre></td></tr></table></figure><p><a href="https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=57777#summary">https://www.nowcoder.com/test/question/done?tid=47463095&amp;qid=57777#summary</a></p><p><img src="https://i.loli.net/2021/09/06/mN956UYP1QzyWCt.png" alt="nowcoder20"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=85573#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=85573#summary</a></p><p><img src="https://i.loli.net/2021/09/06/GYn9Rsjq5fk3tPK.png" alt="nowcoder"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=323196#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=323196#summary</a></p><p><img src="https://i.loli.net/2021/09/06/yRZkSbjTAB8dYhq.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=370501#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=370501#summary</a></p><p><img src="https://i.loli.net/2021/09/06/IJeXTsn1AvgVQyU.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=14760#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=14760#summary</a></p><p><img src="https://i.loli.net/2021/09/06/XEzkeOJdAsZhpDB.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=323166#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=323166#summary</a></p><p><img src="https://i.loli.net/2021/09/06/lcZfdhCQtDa9X3H.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=373190#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=373190#summary</a></p><p><img src="https://i.loli.net/2021/09/07/U6nZabsO2eMdLlt.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=55999#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=55999#summary</a></p><p><img src="https://i.loli.net/2021/09/07/aOvRbwStyi9z8dr.png"></p><p><img src="https://i.loli.net/2021/09/07/UHYVSmZco7XrBuA.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=326233#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=326233#summary</a></p><p><img src="https://i.loli.net/2021/09/07/XuHLgKTCvd51nVl.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=57785#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=57785#summary</a></p><p><img src="https://i.loli.net/2021/09/07/E8H4IPkFoqnha1u.png"></p><p><img src="https://i.loli.net/2021/09/07/V2doArcGLaXzHv3.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=51840#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=51840#summary</a></p><p><img src="https://i.loli.net/2021/09/11/FH84lADPUZKgc6b.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=68441#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=68441#summary</a></p><p><img src="https://i.loli.net/2021/09/11/moneEDyUqYh8A47.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=56865#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=56865#summary</a></p><p><img src="https://i.loli.net/2021/09/11/3iVKlUfB4QW2Ggb.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=15239#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=15239#summary</a></p><p><img src="https://i.loli.net/2021/09/11/iafd2vjSOVWyzAt.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=372788#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=372788#summary</a></p><p><img src="https://i.loli.net/2021/09/11/K946TcfXUEjw8bV.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=112819#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=112819#summary</a></p><p><img src="https://i.loli.net/2021/09/11/Kc5oJNkF8YsiG9L.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=62862#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=62862#summary</a></p><p><img src="https://i.loli.net/2021/09/11/IzrwS6P24hKFbik.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=304911#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=304911#summary</a></p><p><img src="https://i.loli.net/2021/09/11/qk7d42fLlnW1PYm.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=373215#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=373215#summary</a></p><p><img src="https://i.loli.net/2021/09/11/EbIw8YzVilNAmsR.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=3255#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=3255#summary</a></p><p><img src="https://i.loli.net/2021/09/11/9eOWJ6BoM4Cck3u.png"></p><p><img src="https://i.loli.net/2021/09/11/AHdxevURPKGaz81.png"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=44595#summary">https://www.nowcoder.com/test/question/done?tid=47781777&amp;qid=44595#summary</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java后端面试-基础语法</title>
    <link href="/2021/09/05/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/09/05/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="一、基本数据结构"><a href="#一、基本数据结构" class="headerlink" title="一、基本数据结构"></a>一、基本数据结构</h2><p>Java 的基本数据类型有 8 种，包括 6 种数字类型、1 种字符类型和 1 种布尔类型。</p><h3 id="基本数据类型总览"><a href="#基本数据类型总览" class="headerlink" title="基本数据类型总览"></a>基本数据类型总览</h3><ol><li><p>数字类型：包括 4 种整数类型和 2 种浮点数类型，4 种整数类型是 byte、short、int 和 long，2 种浮点数类型是 float 和 double。</p></li><li><p>字符类型：是 char，用于表示单个字符。Java 使用统一码对字符进行编码。</p></li><li><p>布尔类型：是 boolean，包括 true 和 false 两种取值。</p></li></ol><p><img src="https://i.loli.net/2021/09/05/zHwdjChF3EN9Yot.png" alt="基本数据类型"></p><h3 id="数字类型直接量"><a href="#数字类型直接量" class="headerlink" title="数字类型直接量"></a>数字类型直接量</h3><p><strong>直接量</strong>是在程序中直接出现的常量值。</p><p>将整数类型的直接量赋值给整数类型的变量时，只要直接量没有超出变量的取值范围，即可直接赋值，如果直接量超出了变量的取值范围，则会导致编译错误。</p><p>整数类型的直接量默认是 int 类型，如果直接量超出了 int 类型的取值范围，则必须在其后面加上字母 L 或 l，将直接量显性声明为 long 类型，否则会导致编译错误。</p><p>浮点类型的直接量默认是 double 类型，如果要将直接量表示成 float 类型，则必须在其后面加上字母 F 或 f。将 double 类型的直接量赋值给 float 类型的变量是不允许的，会导致编译错误。</p><h3 id="基本数据类型之间的转换"><a href="#基本数据类型之间的转换" class="headerlink" title="基本数据类型之间的转换"></a>基本数据类型之间的转换</h3><p>有时需要把不同类型的值混合运算，因此需要对数据类型进行转换。</p><h4 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h4><p>不同的数字类型对应不同的范围，按照范围从小到大的顺序依次是：byte、short、int、long、float、double。</p><p>将小范围类型的变量转换为大范围类型称为拓宽类型，不需要显性声明类型转换。将大范围类型的变量转换为小范围类型称为缩窄类型，必须显性声明类型转换，否则会导致编译错误。</p><h4 id="字符类型与数字类型之间的转换"><a href="#字符类型与数字类型之间的转换" class="headerlink" title="字符类型与数字类型之间的转换"></a>字符类型与数字类型之间的转换</h4><p>字符类型与数字类型之间可以进行转换。</p><p>将数字类型转换成字符类型时，只使用整数的低 16 位（浮点数类型将整数部分转换成字符类型）。</p><p>将字符类型转换成数字类型时，字符的统一码转换成指定的数值类型。如果字符的统一码超出了转换成的数值类型的取值范围，则必须显性声明类型转换。</p><h4 id="布尔类型不能与其他基本数据类型进行转换"><a href="#布尔类型不能与其他基本数据类型进行转换" class="headerlink" title="布尔类型不能与其他基本数据类型进行转换"></a>布尔类型不能与其他基本数据类型进行转换</h4><p>布尔类型不能转换成其他基本数据类型，其他基本数据类型也不能转换成布尔类型。</p><p><img src="https://i.loli.net/2021/09/05/SVExNg7DQjd8mX5.png" alt="练习题1"></p><p><img src="https://i.loli.net/2021/09/05/GUnaRxkLXQO3zbI.png" alt="练习题2"></p><p><img src="https://i.loli.net/2021/09/05/96d1mNfjiyWvzbU.png" alt="nowcode1"></p><p><img src="https://i.loli.net/2021/09/05/VDhXlc9bFSONCYn.png" alt="nowcoder2"></p><p><img src="https://i.loli.net/2021/09/05/dt6xyBZ9vL8QsmE.png" alt="nowcoder3"></p><p><img src="https://i.loli.net/2021/09/05/heYwKR32FHOSXWr.png" alt="nowcoder4"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=25211#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=25211#summary</a></p><p><img src="https://i.loli.net/2021/09/05/57AjMgfYXrh4FGK.png" alt="nowcoder4"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=304923#summary">https://www.nowcoder.com/test/question/done?tid=47461352&amp;qid=304923#summary</a></p><p><img src="https://i.loli.net/2021/09/06/xsXlpVPIWJ2Hg8R.png" alt="nowcoder20"></p><p><a href="https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=4337#summary">https://www.nowcoder.com/test/question/done?tid=47513854&amp;qid=4337#summary</a></p><h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h2><p>Java 中的方法，在其他语言中也可能被称为过程或函数，是为执行一个操作而组合在一起的语句组。如果一个操作会被多次执行，则可以将该操作定义成一个方法，执行该操作的时候调用方法即可。</p><h3 id="方法的语法结构"><a href="#方法的语法结构" class="headerlink" title="方法的语法结构"></a>方法的语法结构</h3><p>方法包括方法头和方法体，方法头又可以分成修饰符、返回值类型、方法名和参数列表，因此方法包括 5 个部分。</p><ol><li><p>修饰符：修饰符是可选的，告诉编译器如何调用该方法。</p></li><li><p>返回值类型：方法可以返回一个值，此时返回值类型是方法要返回的值的数据类型。方法也可以没有返回值，此时返回值类型是 void。</p></li><li><p>方法名：方法的实际名称。</p></li><li><p>参数列表：定义在方法头中的变量称为形式参数或参数，简称形参。当调用方法时，需要给参数传递一个值，称为实际参数，简称实参。参数列表指明方法中的参数类型、次序和数量。参数是可选的，方法可以不包含参数。</p></li><li><p>方法体：方法体包含具体的语句集合。</p></li></ol><p>方法名和参数表共同构成方法签名。</p><h3 id="参数的值传递"><a href="#参数的值传递" class="headerlink" title="参数的值传递"></a>参数的值传递</h3><p>调用方法时，需要提供实参，实参必须与形参的次序相同，称为参数顺序匹配。实参必须与方法签名中的形参在次序上和数量上匹配，在类型上兼容，兼容的意思是不需要显性声明类型转换，即类型相同或者类型转换为拓宽类型。</p><p>在调用带参数的方法时，实参的值赋给形参，称为值传递。Java 中只有值传递，无论形参在方法中如何改变，实参不受影响。</p><ol><li><p>当参数类型是基本数据类型时，传递的是实参的值，因此不能对实参进行修改。</p></li><li><p>当参数类型是对象时，传递的是对象的引用，此时可以对实参引用的对象进行修改，但是不能让实参引用新的对象。</p></li></ol><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>方法的重载是指在同一个类中的多个方法有相同的名称，但是方法签名不同，编译器能够根据方法签名决定调用哪个方法。由于方法签名由方法名和参数表共同构成，因此方法的重载等同于多个方法有相同的名称和不同的参数列表。</p><p>方法的重载可以增加程序的可读性，执行相似操作的方法应该有相同的名称。</p><p>关于方法的重载，需要注意以下两点。</p><ol><li><p>方法签名只由方法名和参数列表共同构成，因此被重载的方法必须具有不同的参数列表，而不能通过不同的修饰符和返回值类型进行方法的重载。</p></li><li><p>如果一个方法调用有多个可能的匹配，则编译器会调用最合适的匹配方法，如果编译器无法判断哪个方法最匹配，则称为歧义调用，会导致编译错误。</p></li></ol><p>比较下列两段代码说明方法的重载：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 示例一</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        getSum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        getSum(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>);<br>        getSum(<span class="hljs-number">5</span>, <span class="hljs-number">5.5</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(num1 + <span class="hljs-string">&quot;+&quot;</span> + num2 + <span class="hljs-string">&quot;=&quot;</span> + (num1 + num2));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> num1, <span class="hljs-keyword">double</span> num2)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(num1 + <span class="hljs-string">&quot;+&quot;</span> + num2 + <span class="hljs-string">&quot;=&quot;</span> + (num1 + num2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        getSum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 歧义调用，编译错误</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">double</span> num2)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(num1 + <span class="hljs-string">&quot;+&quot;</span> + num2 + <span class="hljs-string">&quot;=&quot;</span> + (num1 + num2));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">double</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(num1 + <span class="hljs-string">&quot;+&quot;</span> + num2 + <span class="hljs-string">&quot;=&quot;</span> + (num1 + num2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在示例 1 中，getSum(1, 2) 调用的是参数为两个 int 型的方法，getSum(1.5, 2.5) 和 getSum(5, 5.5) 调用的是参数为两个 double 型的方法，因此运行上述代码得到的输出结果是：</p><blockquote><p>1+2=3<br>1.5+2.5=4.0<br>5.0+5.5=10.5</p></blockquote><p>在示例 2 中，getSum(1, 2) 可以同时匹配两个方法，任何一个方法都不比另一个方法更匹配，因此为歧义调用，导致编译错误。</p><p><img src="https://i.loli.net/2021/09/05/j4Iz1mPc9vGLAgX.png" alt="练习3"></p><h2 id="三、递归"><a href="#三、递归" class="headerlink" title="三、递归"></a>三、递归</h2><p>程序调用自身的编程技巧称为递归。递归方法是直接或间接调用自身的方法。</p><h3 id="递归的要点"><a href="#递归的要点" class="headerlink" title="递归的要点"></a>递归的要点</h3><p>定义递归方法时，需要定义递归的初始状态、初始状态的处理和递归调用。</p><p>初始状态也称为终止条件，即最简单的情况，此时应该直接给出如何处理初始状态。</p><p>对于非初始状态，则需要进行递归调用，对子问题进行求解，直到初始状态，然后将结果返回给调用者，直到传回原始的调用者。</p><p>递归必须定义初始状态，且保证所有的递归调用都能到达初始状态，否则会发生无限递归，导致栈溢出。</p><h3 id="递归的优点"><a href="#递归的优点" class="headerlink" title="递归的优点"></a>递归的优点</h3><p>递归的优点是代码简洁且易于理解。如果问题满足递归的特点，即可以分解成子问题且子问题与原始问题相似，则可以使用递归给出自然、直接、简单的解法。</p><h3 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h3><p>时间和空间的消耗比较大。每一次函数调用都需要在内存栈中分配空间，对栈的操作还需要时间，因此时间复杂度和空间复杂度都会比较高。</p><p>如果子问题之间存在重叠，则在不加记忆化的情况下，递归会产生重复计算，导致时间复杂度过高。</p><p>由于栈的空间有限，如果递归调用的次数太多，则可能导致调用栈溢出。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>当递归调用是方法中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。</p><p>尾递归的特点是在返回时直接传回原始的调用者，而不用经过中间的调用者，这个特点很重要，因为大多数现代的编译器会利用该特点自动生成优化的代码。</p><p>使用尾递归代替普通的递归，可以在时间和空间方面都带来显著的提升。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下代码是计算斐波那契数的普通递归和尾递归的实现。</p><p>使用普通递归，会产生大量重复计算，导致时间复杂度过高。</p><p>使用尾递归，则不会有重复计算。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fibonacci</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> fibonacci(<span class="hljs-built_in">long</span> <span class="hljs-keyword">index</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> fibonacci(<span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>) + fibonacci(<span class="hljs-keyword">index</span> - <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> fibonacciTailRecursion(<span class="hljs-built_in">long</span> <span class="hljs-keyword">index</span>) &#123;<br>        <span class="hljs-keyword">return</span> fibonacciTailRecursion(<span class="hljs-keyword">index</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> fibonacciTailRecursion(<span class="hljs-built_in">long</span> <span class="hljs-keyword">index</span>, <span class="hljs-built_in">int</span> curr, <span class="hljs-built_in">int</span> <span class="hljs-keyword">next</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> curr;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> fibonacciTailRecursion(<span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>, <span class="hljs-keyword">next</span>, curr + <span class="hljs-keyword">next</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/05/g8lGrBzkPQ32exO.png" alt="练习4"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql执行计划</title>
    <link href="/2021/06/06/MySql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <url>/2021/06/06/MySql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="MySql-执行计划"><a href="#MySql-执行计划" class="headerlink" title="MySql 执行计划"></a>MySql 执行计划</h1><p>在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t3 where id&#x3D;3952602;<br></code></pre></td></tr></table></figure><h3 id="执行结果解释"><a href="#执行结果解释" class="headerlink" title="执行结果解释"></a>执行结果解释</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-------------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">-------</span>+<br>| id | select_type | table | type  | possible_keys     | key     | key_len | ref   | rows | Extra |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">-------------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">-------</span>+<br></code></pre></td></tr></table></figure><p>EXPLAIN 出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; explain select <span class="hljs-symbol">*</span> from (select <span class="hljs-symbol">*</span> from ( select <span class="hljs-symbol">*</span> from t3 where id=3952602) a) b;<br>+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+<br>|<span class="hljs-string"> id </span>|<span class="hljs-string"> select_type </span>|<span class="hljs-string"> table      </span>|<span class="hljs-string"> type   </span>|<span class="hljs-string"> possible_keys     </span>|<span class="hljs-string"> key     </span>|<span class="hljs-string"> key_len </span>|<span class="hljs-string"> ref  </span>|<span class="hljs-string"> rows </span>|<span class="hljs-string"> Extra </span>|<br>+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+<br>|<span class="hljs-string">  1 </span>|<span class="hljs-string"> PRIMARY     </span>|<span class="hljs-string"> &lt;derived2&gt; </span>|<span class="hljs-string"> system </span>|<span class="hljs-string"> NULL              </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string">    1 </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string">  2 </span>|<span class="hljs-string"> DERIVED     </span>|<span class="hljs-string"> &lt;derived3&gt; </span>|<span class="hljs-string"> system </span>|<span class="hljs-string"> NULL              </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string">    1 </span>|<span class="hljs-string">       </span>|<br>|<span class="hljs-string">  3 </span>|<span class="hljs-string"> DERIVED     </span>|<span class="hljs-string"> t3         </span>|<span class="hljs-string"> const  </span>|<span class="hljs-string"> PRIMARY,idx_t3_id </span>|<span class="hljs-string"> PRIMARY </span>|<span class="hljs-string"> 4       </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    1 </span>|<span class="hljs-string">       </span>|<br>+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+<br></code></pre></td></tr></table></figure><p>概要描述：<br>id:选择标识符<br>select_type:表示查询的类型。<br>table:输出结果集的表<br>partitions:匹配的分区<br>type:表示表的连接类型<br>possible_keys:表示查询时，可能使用的索引<br>key:表示实际使用的索引<br>key_len:索引字段的长度<br>ref:列与索引的比较<br>rows:扫描出的行数(估算的行数)<br>filtered:按表条件过滤的行百分比<br>Extra:执行情况的描述和说明</p><p>下面对这些字段出现的可能进行解释：</p><p>一、 id</p><p>SELECT识别符。这是SELECT的查询序列号</p><p>我的理解是SQL执行的顺序的标识，SQL从大到小的执行</p><ol><li><p>id相同时，执行顺序由上至下</p></li><li><p>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p></li><li><p>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查看在研发部并且名字以Jef开头的员工，经典查询<br>explain select e.no, e.name from emp e left join dept d on e.dept_no &#x3D; d.no where e.name like &#39;Jef%&#39; and d.name &#x3D; &#39;研发部&#39;;<br></code></pre></td></tr></table></figure><p>二、select_type</p><pre><code>  示查询中每个select子句的类型</code></pre><p>(1) SIMPLE(简单SELECT，不使用UNION或子查询等)</p><p>(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p><p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p><p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p><p>(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p><p>(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p><p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p><p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p><p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p><p>三、table</p><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p><p>四、type</p><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p><p>常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</p><p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p><p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p><p>range:只检索给定范围的行，使用一个索引来选择行</p><p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p><p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p><p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p><p>五、possible_keys</p><p>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</p><p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p><p>六、Key</p><p>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</p><p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p><p>七、key_len</p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p><p>不损失精确性的情况下，长度越短越好 </p><p>八、ref</p><p>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p>九、rows</p><p> 估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p><p>十、Extra</p><p>该列包含MySQL解决查询的详细信息,有以下几种情况：</p><p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p><p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p><p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p><p>– 测试Extra的filesort<br>explain select * from emp order by name;<br>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p><p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p><p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p><p>No tables used：Query语句中使用from dual 或不含任何from子句</p><p>– explain select now() from dual;</p><p>总结：<br>• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况<br>• EXPLAIN不考虑各种Cache<br>• EXPLAIN不能显示MySQL在执行查询时所作的优化工作<br>• 部分统计信息是估算的，并非精确值<br>• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread-Concurrent</title>
    <link href="/2021/05/19/Thread-Concurrent/"/>
    <url>/2021/05/19/Thread-Concurrent/</url>
    
    <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p><p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> AddThread();<br>        <span class="hljs-keyword">var</span> dec = <span class="hljs-keyword">new</span> DecThread();<br>        add.start();<br>        dec.start();<br>        add.join();<br>        dec.join();<br>        System.out.println(Counter.count);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123; Counter.count += <span class="hljs-number">1</span>; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123; Counter.count -= <span class="hljs-number">1</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码很简单，两个线程同时对一个<code>int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p><p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p><p>例如，对于语句：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">n</span> = n + <span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>看上去是一行语句，实际上对应了3条指令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ILOAD</span><br><span class="hljs-attribute">IADD</span><br><span class="hljs-attribute">ISTORE</span><br></code></pre></td></tr></table></figure><p>我们假设<code>n</code>的值是<code>100</code>，如果两个线程同时执行<code>n = n + 1</code>，得到的结果很可能不是<code>102</code>，而是<code>101</code>，原因在于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────┐    ┌───────┐<br>│Thread1│    │Thread2│<br>└───┬───┘    └───┬───┘<br>    │            │<br>    │ILOAD (100) │<br>    │            │ILOAD (100)<br>    │            │IADD<br>    │            │ISTORE (101)<br>    │IADD        │<br>    │ISTORE (101)│<br>    ▼            ▼<br></code></pre></td></tr></table></figure><p>如果线程1在执行<code>ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行<code>ILOAD</code>后获取的值仍然是<code>100</code>，最终结果被两个线程的<code>ISTORE</code>写入后变成了<code>101</code>，而不是期待的<code>102</code>。</p><p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───────┐     ┌───────┐<br>│Thread1│     │Thread2│<br>└───┬───┘     └───┬───┘<br>    │             │<br>    │-- lock --   │<br>    │ILOAD (100)  │<br>    │IADD         │<br>    │ISTORE (101) │<br>    │-- unlock -- │<br>    │             │-- lock --<br>    │             │ILOAD (101)<br>    │             │IADD<br>    │             │ISTORE (102)<br>    │             │-- unlock --<br>    ▼             ▼<br></code></pre></td></tr></table></figure><p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</p><p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">synchronized(lock) &#123;<br>    <span class="hljs-built_in">n</span> = <span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>synchronized</code>保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用<code>synchronized</code>改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> AddThread();<br>        <span class="hljs-keyword">var</span> dec = <span class="hljs-keyword">new</span> DecThread();<br>        add.start();<br>        dec.start();<br>        add.join();<br>        dec.join();<br>        System.out.println(Counter.count);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock) &#123;<br>                Counter.count += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock) &#123;<br>                Counter.count -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(Counter.lock)</span></span> &#123; <span class="hljs-comment">// 获取锁</span><br>    ...<br>&#125; <span class="hljs-comment">// 释放锁</span><br></code></pre></td></tr></table></figure><p>它表示用<code>Counter.lock</code>实例作为锁，两个线程在执行各自的<code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁。这样一来，对<code>Counter.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p><p>使用<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为<code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p><p>我们来概括一下如何使用<code>synchronized</code>：</p><ol><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li></ol><p>在使用<code>synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();<br>        &#125;<br>        <span class="hljs-keyword">this</span>.value += m;<br>    &#125; <span class="hljs-comment">// 无论有无异常，都会在此释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看一个错误使用<code>synchronized</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> AddThread();<br>        <span class="hljs-keyword">var</span> dec = <span class="hljs-keyword">new</span> DecThread();<br>        add.start();<br>        dec.start();<br>        add.join();<br>        dec.join();<br>        System.out.println(Counter.count);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock1 = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock2 = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock1) &#123;<br>                Counter.count += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(Counter.lock2) &#123;<br>                Counter.count -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果并不是0，这是因为两个线程各自的<code>synchronized</code>锁住的<em>不是同一个对象</em>！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。</p><p>因此，使用<code>synchronized</code>的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p><p>我们再看一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    public static void main(<span class="hljs-type">String</span>[] args) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-keyword">var</span> ts = <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>[] &#123; <span class="hljs-keyword">new</span> <span class="hljs-type">AddStudentThread</span>(), <span class="hljs-keyword">new</span> <span class="hljs-type">DecStudentThread</span>(), <span class="hljs-keyword">new</span> <span class="hljs-type">AddTeacherThread</span>(), <span class="hljs-keyword">new</span> <span class="hljs-type">DecTeacherThread</span>() &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t : ts) &#123;<br>            t.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t : ts) &#123;<br>            t.join();<br>        &#125;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-type">Counter</span>.studentCount);<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-type">Counter</span>.teacherCount);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    public static <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> lock = <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>();<br>    public static int studentCount = <span class="hljs-number">0</span>;<br>    public static int teacherCount = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddStudentThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    public void run() &#123;<br>        <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            synchronized(<span class="hljs-type">Counter</span>.lock) &#123;<br>                <span class="hljs-type">Counter</span>.studentCount += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecStudentThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    public void run() &#123;<br>        <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            synchronized(<span class="hljs-type">Counter</span>.lock) &#123;<br>                <span class="hljs-type">Counter</span>.studentCount -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddTeacherThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    public void run() &#123;<br>        <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            synchronized(<span class="hljs-type">Counter</span>.lock) &#123;<br>                <span class="hljs-type">Counter</span>.teacherCount += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecTeacherThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    public void run() &#123;<br>        <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123;<br>            synchronized(<span class="hljs-type">Counter</span>.lock) &#123;<br>                <span class="hljs-type">Counter</span>.teacherCount -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是<code>Counter.lock</code>这一个对象，这就造成了原本可以并发执行的<code>Counter.studentCount += 1</code>和<code>Counter.teacherCount += 1</code>，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：<code>AddStudentThread</code>和<code>DecStudentThread</code>，<code>AddTeacherThread</code>和<code>DecTeacherThread</code>，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p><p><code>AddStudentThread</code>和<code>DecStudentThread</code>使用<code>lockStudent</code>锁：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(Counter.lockStudent)</span></span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AddTeacherThread</code>和<code>DecTeacherThread</code>使用<code>lockTeacher</code>锁：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(Counter.lockTeacher)</span></span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样才能最大化地提高执行效率。</p><h3 id="不需要synchronized的操作"><a href="#不需要synchronized的操作" class="headerlink" title="不需要synchronized的操作"></a>不需要synchronized的操作</h3><p>JVM规范定义了几种原子操作：</p><ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li><li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li></ul><p><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p><p>单条原子操作的语句不需要同步。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">int m</span>)</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">synchronized</span>(<span class="hljs-params">lock</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就不需要同步。</p><p>对引用也是类似。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.value = s;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述赋值语句并不需要同步。</p><p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> first;<br>    <span class="hljs-keyword">int</span> last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">this</span>.first = first;<br>            <span class="hljs-keyword">this</span>.last = last;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> &#123;</span><br>    <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">pair</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] ps = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; first, last &#125;;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">pair</span> = ps;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>就不再需要同步，因为<code>this.pair = ps</code>是引用赋值的原子操作。而语句：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span>[] ps = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; first, last &#125;;<br></code></pre></td></tr></table></figure><p>这里的<code>ps</code>是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过<code>synchronized</code>同步；</p><p>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</p><p>注意加锁对象必须是同一个实例；</p><p>对JVM定义的单个原子操作不需要同步。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread-Deamon</title>
    <link href="/2021/05/19/Thread-Deamon/"/>
    <url>/2021/05/19/Thread-Deamon/</url>
    
    <content type="html"><![CDATA[<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p><p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p><p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(LocalTime.now());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p><p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p><p>答案是使用守护线程（Daemon Thread）。</p><p>守护线程是指为其他线程服务的线程。<strong>在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</strong></p><p>因此，JVM退出时，不必关心守护线程是否已结束。</p><p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t = <span class="hljs-keyword">new</span> MyThread();<br>t.setDaemon(<span class="hljs-keyword">true</span>);<br>t.start();<br></code></pre></td></tr></table></figure><p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread-Interrupt</title>
    <link href="/2021/05/18/Thread-Interrupt/"/>
    <url>/2021/05/18/Thread-Interrupt/</url>
    
    <content type="html"><![CDATA[<h1 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h1><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。</p><p>我们举个栗子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p><p>我们还是看示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> MyThread();<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 暂停1毫秒</span><br>        t.interrupt(); <span class="hljs-comment">// 中断t线程</span><br>        t.join(); <span class="hljs-comment">// 等待t线程结束</span><br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (! isInterrupted()) &#123;<br>            n ++;<br>            System.out.println(n + <span class="hljs-string">&quot; hello!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仔细看上述代码，<code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测<code>isInterrupted()</code>，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p><p>如果线程处于等待状态，例如，<code>t.join()</code>会让<code>main</code>线程进入等待状态，此时，如果对<code>main</code>线程调用<code>interrupt()</code>，<code>join()</code>方法会立刻抛出<code>InterruptedException</code>，因此，目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p><p>我们来看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> MyThread();<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        t.interrupt(); <span class="hljs-comment">// 中断t线程</span><br>        t.join(); <span class="hljs-comment">// 等待t线程结束</span><br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread hello = <span class="hljs-keyword">new</span> HelloThread();<br>        hello.start(); <span class="hljs-comment">// 启动hello线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            hello.join(); <span class="hljs-comment">// 等待hello线程结束</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;interrupted!&quot;</span>);<br>        &#125;<br>        hello.interrupt();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!isInterrupted()) &#123;<br>            n++;<br>            System.out.println(n + <span class="hljs-string">&quot; hello!&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出。</p><p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        HelloThread t = <span class="hljs-keyword">new</span> HelloThread();<br>        t.start();<br>        Thread.sleep(<span class="hljs-number">1</span>);<br>        t.running = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 标志位置为false</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> running = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (running) &#123;<br>            n ++;<br>            System.out.println(n + <span class="hljs-string">&quot; hello!&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p><p>为什么要对线程间共享的变量用关键字<code>volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐<br>           Main Memory<br>│                               │<br>   ┌───────┐┌───────┐┌───────┐<br>│  │ var A ││ var B ││ var C │  │<br>   └───────┘└───────┘└───────┘<br>│     │ ▲               │ ▲     │<br> ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─<br>      │ │               │ │<br>┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐<br>      ▼ │               ▼ │<br>│  ┌───────┐  │   │  ┌───────┐  │<br>   │ var A │         │ var C │<br>│  └───────┘  │   │  └───────┘  │<br>   Thread 1          Thread 2<br>└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘<br></code></pre></td></tr></table></figure><p>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量<code>a = true</code>，线程1执行<code>a = false</code>时，它在此刻仅仅是把变量<code>a</code>的副本变成了<code>false</code>，主内存的变量<code>a</code>还是<code>true</code>，在JVM把修改后的<code>a</code>回写到主内存之前，其他线程读取到的<code>a</code>的值仍然是<code>true</code>，这就造成了多线程之间共享的变量不一致。</p><p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</li><li>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</li><li>通过标志位判断需要正确使用<code>volatile</code>关键字；</li><li><code>volatile</code>关键字解决了共享变量在线程间的可见性问题。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread-Status</title>
    <link href="/2021/05/18/Thread-Status/"/>
    <url>/2021/05/18/Thread-Status/</url>
    
    <content type="html"><![CDATA[<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li></ul><p>用一个状态转移图表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ascii">         ┌─────────────┐<br>         │     New     │<br>         └─────────────┘<br>                │<br>                ▼<br>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐<br> ┌─────────────┐ ┌─────────────┐<br>││  Runnable   │ │   Blocked   ││<br> └─────────────┘ └─────────────┘<br>│┌─────────────┐ ┌─────────────┐│<br> │   Waiting   │ │Timed Waiting│<br>│└─────────────┘ └─────────────┘│<br> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─<br>                │<br>                ▼<br>         ┌─────────────┐<br>         │ Terminated  │<br>         └─────────────┘<br></code></pre></td></tr></table></figure><p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;start&quot;</span>);<br>        t.start();<br>        t.join();<br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是<code>main</code>线程先打印<code>start</code>，<code>t</code>线程再打印<code>hello</code>，<code>main</code>线程最后再打印<code>end</code>。</p><p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Java线程对象<code>Thread</code>的状态包括：<code>New</code>、<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>、<code>Timed Waiting</code>和<code>Terminated</code>；</li><li>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束；</li><li>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</li><li>对已经运行结束的线程调用<code>join()</code>方法会立刻返回。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread-Intro</title>
    <link href="/2021/05/17/Thread-Intro/"/>
    <url>/2021/05/17/Thread-Intro/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程介绍"><a href="#多线程介绍" class="headerlink" title="多线程介绍"></a>多线程介绍</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务，例如：</p><p><img src="https://i.loli.net/2021/05/17/U2rlmZve51Woxcu.png"></p><p>CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。</p><p>例如，假设我们有语文、数学、英语3门作业要做，每个作业需要30分钟。我们把这3门作业看成是3个任务，可以做1分钟语文作业，再做1分钟数学作业，再做1分钟英语作业：</p><p><img src="https://i.loli.net/2021/05/17/e3phUVX968LQKCv.png"></p><p>这样轮流做下去，在某些人眼里看来，做作业的速度就非常快，看上去就像同时在做3门作业一样。类似的，操作系统轮流让多个任务交替执行，例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p><p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p><p><img src="https://i.loli.net/2021/05/18/o6UbqJ8gA5cntmE.png"></p><p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p><p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p><p>多进程模式（每个进程只有一个线程）：</p><p><img src="https://i.loli.net/2021/05/18/acvgpF2POqTj8C7.png"></p><p>多线程模式（一个进程有多个线程）：</p><p><img src="https://i.loli.net/2021/05/18/zu1y6biYAUOLclH.png"></p><p>多进程＋多线程模式（复杂度最高）：</p><p><img src="https://i.loli.net/2021/05/18/KGczwBvO8fue2WH.png"></p><h2 id="进程VS线程"><a href="#进程VS线程" class="headerlink" title="进程VS线程"></a>进程VS线程</h2><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p><p>具体采用哪种方式，要考虑到进程和线程的特点。</p><p>和多线程相比，多进程的缺点在于：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul><p>而多进程的优点在于：</p><p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p><h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p><p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p><p>Java多线程编程的特点又在于：</p><ul><li>多线程模型是Java程序最基本的并发模型；</li><li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li></ul><p>因此，必须掌握Java多线程编程才能继续深入学习其他内容。</p><h1 id="Java多线程-1"><a href="#Java多线程-1" class="headerlink" title="Java多线程"></a>Java多线程</h1><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行<code>main()</code>方法。在<code>main()</code>方法中，我们又可以启动其他线程。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>要创建一个新线程非常容易，我们需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread();<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：</p><ul><li>方法一：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> MyThread();<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上述代码，注意到<code>start()</code>方法会在内部自动调用实例的<code>run()</code>方法。</p><ul><li>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者用Java8引入的lambda语法进一步简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;start new thread!&quot;</span>);<br>        &#125;);<br>        t.start(); <span class="hljs-comment">// 启动新线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h2><p>有童鞋会问，使用线程执行的打印语句，和直接在<code>main()</code>方法执行有区别吗？我们看以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;main start...&quot;</span>); <span class="hljs-comment">//蓝</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-comment">//蓝</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;thread run...&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;thread end.&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t.start();<span class="hljs-comment">//蓝</span><br>        System.out.println(<span class="hljs-string">&quot;main end...&quot;</span>);<span class="hljs-comment">//蓝</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用蓝色表示主线程，也就是<code>main</code>线程，<code>main</code>线程执行的代码有4行，首先打印<code>main start</code>，然后创建<code>Thread</code>对象，紧接着调用<code>start()</code>启动新线程。当<code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量<code>t</code>来表示这个新线程对象，并开始执行。</p><p>接着，<code>main</code>线程继续执行打印<code>main end</code>语句，而<code>t</code>线程在<code>main</code>线程执行的同时会并发执行，打印<code>thread run</code>和<code>thread end</code>语句。</p><p>当<code>run()</code>方法结束时，新线程就结束了。而<code>main()</code>方法结束时，主线程也结束了。</p><p>我们再来看线程的执行顺序：</p><ol><li><code>main</code>线程肯定是先打印<code>main start</code>，再打印<code>main end</code>；</li><li><code>t</code>线程肯定是先打印<code>thread run</code>，再打印<code>thread end</code>。</li></ol><p>但是，除了可以肯定，<code>main start</code>会先打印外，<code>main end</code>打印在<code>thread run</code>之前、<code>thread end</code>之后或者之间，都无法确定。因为从<code>t</code>线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。</p><p>要模拟并发执行的效果，我们可以在线程中调用<code>Thread.sleep()</code>，强迫当前线程暂停一段时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        Thread t = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;thread run...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>                System.out.println(<span class="hljs-string">&quot;thread end.&quot;</span>);<br>            &#125;<br>        &#125;;<br>        t.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">20</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>        System.out.println(<span class="hljs-string">&quot;main end...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sleep()</code>传入的参数是毫秒。调整暂停时间的大小，我们可以看到<code>main</code>线程和<code>t</code>线程执行的先后顺序。</p><h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><p>直接调用<code>Thread</code>实例的<code>run()</code>方法是无效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> MyThread();<br>        t.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在<code>main()</code>方法内部又调用了<code>run()</code>方法，打印<code>hello</code>语句是在<code>main</code>线程中执行的，没有任何新线程被创建。</p><p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>可以对线程设定优先级，设定优先级的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.setPriority(<span class="hljs-keyword">int</span> n) <span class="hljs-comment">// 1~10, 默认值5</span><br></code></pre></td></tr></table></figure><p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来<strong>确保高优先级的线程一定会先执行（无法保证）</strong>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程；</li><li>一个线程对象只能调用一次<code>start()</code>方法；</li><li>线程的执行代码写在<code>run()</code>方法中；</li><li>线程调度由操作系统决定，程序本身无法决定调度顺序；</li><li><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread-AQS</title>
    <link href="/2021/05/17/Thread-AQS/"/>
    <url>/2021/05/17/Thread-AQS/</url>
    
    <content type="html"><![CDATA[<h1 id="AQS-知道吗？"><a href="#AQS-知道吗？" class="headerlink" title="AQS 知道吗？"></a>AQS 知道吗？</h1><p>Why - What - How。为什么会有这个东西？这个东西是什么？怎么做到的？</p><p>任何技术的产生第一件事就是思考 Why？这个 AQS 的产生是为什么，大家平常用过 synchronized，可能觉得已经有锁了，还需要 AQS 吗?</p><p>Why: synchronized 只解决了有和没有的问题，但是锁的场景和多样性方面还很欠缺，例如: 带超时时间的获取锁、获取锁非阻塞(尝试获取锁)、带等待条件的请求锁。其实这些你通过 synchronized 加手动封装也能实现，但是需要些功力而且还容易出错，所以 Doug Lea 就写了功能更加丰富的 AQS 以及一些一系列多线程组件，方便大家按需扩展。AQS 是 JDK1.5 引入的，那个时候 synchronized 还没做优化，没有偏向锁和轻量级锁，所以 AQS 的 CAS(Reentrantlock) 自旋就很有必要了，毕竟有时间竞争并不激烈。</p><p>What: AQS 是 AbstractQueuedSynchronizer 的缩写，抽象队列同步器，我们很多同步工具 ReentrantLock、Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier 都是基于 AQS 实现的。</p><p>How: AQS 实现机制是什么呢？大家可以先不往下看，如果让你来实现一个多线程控制访问共享资源的工具，你会如何写？考虑这么几个问题：</p><ul><li>当有多个线程竞争的时候，运行线程排队等待获取资源，如何做？</li><li>当某个线程使用完资源，如何通知正在排队等待的资源？</li><li>synchronized 获取锁是阻塞的，也就是线程获取锁的时候一定会进入等待，但是如果希望实现一个线程过来访问，发现已经有其他线程持有锁了，直接返回，不希望产生锁竞争，怎么实现？</li></ul><p><img src="https://i.loli.net/2021/05/17/5Vf9JMpWv4ctaUd.png"></p><p>它底层采用的是状态标志位(state 变量)+FIFO 队列的方式来记录获取锁、释放锁、竞争锁等一系列锁操作；</p><p>对于 AQS 而言,其中的 state 变量可以看做是锁，队列采用的是先进先出的双向链表，state 共享状态变量表示锁状态，内部使用 CAS 对 state 进行原子操作修改来完成锁状态变更（锁的持有和释放）。</p><p>实现一个生产者消费者模式<br>这个实现方式有很多种，通过 synchronized 的 wait、notify 可以，通过 Reentrantlock 的 Condition 也可以，当然还有别的方式，另外单独讲。</p><p>下面介绍第一种：</p><p>基本原理就是通过锁 + 等待/唤醒实现生产和消费</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective_Java_2_所有对象的通用方法</title>
    <link href="/2021/05/05/Effective-Java-2-%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2021/05/05/Effective-Java-2-%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h1><p>尽管 Object 是一个具体类，但设计它主要是为了扩展。 它所有的非 final 方法（equals 、 hashCode 、 t oString 、 clone 和 finalize ）都有 明 确的通 用 约定（ general contract), 因为它们设计成是要被覆盖（ override ）的 。 任何一个类，它在覆盖这些方法的时·候，都有 责任遵守这些通用约定；如果不能做到这一点，其他依赖于这些约定的类（例如 HashMap 和 HashSet ）就无法结合该类一起正常运作 。</p><p>本章将讲述何时以及如何覆盖这些非 final 的 Object 方法。 本章不再讨论 finalize 方法，因为第 8 条已经讨论过这个方法了 。 而 Comparable . compareTo 虽然不是 Object 方法，但是本章也将对它进行讨论，因为它具有类似的特征 。</p><h2 id="第10条-覆盖equals时请遵守通用规定"><a href="#第10条-覆盖equals时请遵守通用规定" class="headerlink" title="第10条 覆盖equals时请遵守通用规定"></a>第10条 覆盖equals时请遵守通用规定</h2><p>覆盖 equals 方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重 。 最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个 实例都只与它 自身相等 。 如果满足了以下任何一个条件，这就正是所期望的结果 ：</p><ul><li><p>类的每个实例本质上都是唯一的 。 对于代表活动实体而不是值（ value ）的类来说确 实如 此 ，例如 Thread。 Object 提供的 equals 实 现对于这些类来说正是正确的 行为 。</p></li><li><p>类没有必要提供“逻辑相等”（ logical equality ）的测试功能。 例如， j ava . util . regex . Pattern 可以覆盖 equals ，以检查两个 Patter口实例是否代表 同 一个 正则表达式，但是设计者并不认为客户需要或者期望这样的功能。 在这类情况之下，从 Object 继承得到的 equals 实现已经足够了 。</p></li><li><p>超 类 已 经覆盖 了 equals ，超类的行为对于这个 类 也是合适的 。例如，大多数的Set 实现都从 Abstract Set 继承 equals 实现， List 实现从 AbstractList 继 承 equals 实现， Map 实现从 AbstractMap 继承 equals 实现 。</p></li><li><p>类是私 有的 ， 或者是包级私有的 ， 可以确定它的 equals 方法永远不会 被调用 。 果你非常想要规避风险，可以覆盖 equals 方法，以确保它不会被意外调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();  <span class="hljs-comment">// Method is never called</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么，什么时候应该覆盖 equals 方法呢？如果类具有自己特有的“逻辑相等”（ logical equality ）概念（不同于对象等同的概念），而且超类还没有覆盖 equals 。 这通常属于“值 类”（ value class ）的情形 。 值类仅仅是一个表示值的类，例如 Integer 或者 String。 程 序员在利用 equals 方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不 是想了解它们是否指向同一个对象。 为了满足程序员的要求，不仅必须覆盖 equa ls 方法， 而且这样做也使得这个类的实例可以被用作映射表（ map ）的键（ key ），或者集合（ set ）的元 素，使映射或者集合表现出预期的行为 。</p></li></ul><p>有一种“值类”不需要覆盖 equals 方法，即用实例受控（详见第 l 条）确保“每个 值至多只存在一个对象”的类 。 枚举类型（详见第 34 条）就属于这种类 。 对于这样的类而 言，逻辑相同与对象等同是一回事，因此 Object 的 equals 方法等同于逻辑意义上的equals 方法。</p><p>在覆盖 equals 方法的时候，必须要遵守它的通用约定 。 下面是约定的内容，来自Object 的规范 。</p><p>equals 方法实现了等价关系（ equivalence relation ），其属性如下：</p><p>0 自反性（ reflexive ） ： 对于任何非 null 的引用值 x x . equals(x ）必须返回 true 。 </p><p>口 对称性（ symmetric ）：对于任何非 null 的引用值 x 和 y ，当且仅当 y.equals(x ）返 回 true 时＇， x.equals(y ）必须返回 true 。 </p><p>口 传递性（ transitive ） ： 对于任何非 null 的引用值 x 、 y 和 z ，如果 x.equals(y ）返回true ，并且 y.equals(z ）也返回 true ，那么 x.equals(z ）也必须返回 true 0 </p><p>口 一致性（ consistent ） ： 对于任何非 null 的 引用值 x 和 y ，只要 equals 的比较操作 在对象中所用的信息没有被修改，多次调用 x.equals(y ）就会一致地返回 true, 或者一致地返回 false 。 </p><p>口 对于任何非 null 的引用值 x, x.equals (null ）必须返回 false 。</p><p>除非你对数学特别感兴趣，否则这些规定看起来可能有点让人感到恐惧，但是绝对不 要忽视这些规定 ！ 如果违反了，就会发现程序将会表现得不正常，甚至崩溃，而且很难找到 失败的根源 。 用 John Donne 的话说 ，没有哪个类是孤立的 。 一个类的实例通常会被频繁地 传递给另一个类的实例 。 有许多类，包括所有的集合类（ collection class ）在内，都依赖于传递给它们的对象是否遵守了 equals 约定 。</p><p>现在你已经知道了违反 equals 约定有多么可怕，下面将更细致地讨论这些约定 。 值 得欣慰的是，这些约定虽然看起来很吓人，实际上并不十分复杂。 一旦理解了这些约定，要遵守它们并不困难。</p><p>那么什么是等价关系呢？不严格地说，它是一个操作符，将一组元素划分到其元素与 另一个元素等价的分组中 。 这些分组被称作等价类（巳qui valence class ） 。 从用户的角度来看， 对于有用的 equals 方法，每个等价类中的所有元素都必须是可交换的 。 现在我们按照顺 序逐一查看以下 5 个要求 。</p><p>!! ……</p><p>结合所有这些要求，得出了以下实现高质量 equals 方法的诀窍 ：</p><ol><li><p>使用＝＝操作符检查“参数是否为这个对象的引用” 。 如果是，则返回 true 。 这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</p></li><li><p>使用 instanceof 操作符检查 “参数是否为正确的类型” 。 如果不是，则返回 false。 一般说来，所谓“正确的类型”是指 equals 方法所在的那个类 。 某些情况下，是指该类所实现的某个接口 。 如果类实现的接口改进了 equals 约定，允许在实现了该接口的类之间进行比较，那么就使用接口 。 集合接口如 Set 、 List 、 Map 和 Map.Entry 具有这样的特性。  注意 ！！ instanceOf和getClass两种区别</p></li><li><p>把参数转换成正确的类型。 因为转换之前进行过且stanceof 测试，所以确保会成功 。</p></li><li><p>对于该类中的每个“关键”（ significant ）域，检查参数中的域是否与该对象中对应的 域相匹配。 如果这些测试全部成功， 则返回 true ；否则返回 false 。 如果第 2 步 中 的类型 是个接口，就必须通过接口方法访问参数中的域；如果该类型是个类，也许就能够直接访问 参数中的域，这要取决于它们 的可访问性 。</p></li></ol><p>！！！ 。。。。。</p><p>FBI Warning；</p><ol><li><p>覆盖 equals 时总要覆盖 hashCode （详见第 l l 条 ） 。</p></li><li><p>不要企 图让 equals 方法过于 智能 。 如果只是简单地测试域中的值是否相等，则不难做到遵守 equals 约定 。 如果想过度地去寻求各种等价关系， 则很容易陷入麻烦之中 。 把任何一种别名形式考虑到等价的范围内，往往不会是个好主意 。 例如， File类不应该试图把指向同一个文件的符号链接（ symbolic link ） 当作相等的对象来看待 。所幸 File 类没有这样做。</p></li><li><p>不要将 equa ls 声 明 中 的 Object 对象替换为其他的类型。 程序员编写出下面这样的equals 方法并不鲜见，这会使程序员花上数个小时都搞不清为什么它不能正常工作 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Broken - parameter type must be Object!</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(MyClass o)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题在于，这个方法并没有覆盖（ override ) Object. equals ，因为它 的 参数应该是 Object 类型，相反，它重载（ overload ）了 Object. equals （详见第 52 条） 。 在正常 equals 方法的基础上，再提供一个“强类型”（ strongly typed ）的 equals 方法，这是无法接受的，因为会导致子类中的 Override 注解产生错误的正值，带来错误的安全感。</p></li></ol><p>@Override 注解的用法一致，就如本条目中所示，可以防止犯这种错误（详见第 40 条） 。 这个 equal s 方法不能编译，错误消息会告诉你到底哪里出了问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Still broken - but won&#x27;t compile</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(MyClass o)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>编写和测试 equa l s （及 hashCode ）方法都是卡分烦琐的，得到的代码也很琐碎。 代 替于工编写 和测试这些方法的最佳途径，是使用 Google 开源的 AutoValue 框架 ，它会自动 替你生成这些方法，通过类 中的单个注解就能触发 。 在大多数情况下 ， AutoValue 生成的方 法本质上与你亲自编写的方法是一样 的 。</p><p>IDE 也有 工具 可以生成 e quals 和 hash Code 方法，但得 到的源代码比使用 AutoValue 的更加冗长，可读性也更差，它无法自动追踪类中 的变化，因此需要进行测试。 也就 是说 ，让 IDE 生成 equals （及 hashCode ）方法，通常优于手工实现它们，因为 IDE 不会 犯粗心的错误，但是程序员会犯错。</p><p>总而言之，不要轻易覆盖 equals 方法，除非迫不得已 。 因为在许多情况下，从 Object 处继承的实现正是你想要的 。 如果覆盖 equals ，一定要比较这个类的所有关键域，并且查看它们是否遵守 equals 合约的所有五个条款。</p><h2 id="第11条-覆盖-equals-时总要覆盖-hash-Code"><a href="#第11条-覆盖-equals-时总要覆盖-hash-Code" class="headerlink" title="第11条 覆盖 equals 时总要覆盖 hash Code"></a>第11条 覆盖 equals 时总要覆盖 hash Code</h2><p>在每个 覆盖了 equals 方法的类中，都 必须 覆盖 hashCode 方法。 如果不这样做的话，就会违反 hashCode 的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这类集合包括 HashMap 和 HashSet 。 下面是约定的内容，摘自 Object 规范：</p><ol><li><p>在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被 修改，那么对同一个对象的多次调用， hashCode 方法都必须始终返回同一个值。 在一个应用程序与另一个程序的执行过程中，执行 hashCode 方法所返回的值可以 不一致 。</p></li><li><p>如果两个对象根据 equals(Object ）方法比较是相等的，那么调用这两个对象中 的 hashCode 方法都必须产生同样的整数结果。</p></li><li><p>如果两个对象根据 equals(Object ）方法比较是不相等的，那么调用这两个对象中的 hashCode 方法，则不一定要求 hashCode 方法必须产生不同的结果 。 但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表（ hash table ）的性能。</p></li></ol><p>因没有覆盖 hashCode 而违反的关键约定是 第二条：相等的对象必须具有相等的散到码（ hash code ） 。 根据类的 equals 方法，两个截然不同的实例在逻辑上有可能是相等的， 但是根据 Object 类的 hashCode 方法，它们仅仅是两个没有任何共同之处的对象。 因此，对象的 hashCode 方法返回两个看起来是随机的整数，而不是根据第二个约定所要求的那 样，返回两个相等的整数 。</p><p>假设在 HashMap 中用第 10 条中出现过的 PhoneNur由er 类的实例作为键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;PhoneNumber, String&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>m.put(<span class="hljs-keyword">new</span> PhoneNumber(<span class="hljs-number">707</span>, <span class="hljs-number">867</span>, <span class="hljs-number">5309</span>), <span class="hljs-string">&quot;Jenny&quot;</span>);<br></code></pre></td></tr></table></figure><p>此时，你可能期望 m . get (new PhoneNumber (707, 867 , 5309 ））会返回＂ Jenny ＂，但 它实际上返回的是川口 。 注意，这里涉及两个 PhoneNumber 实例 ： 第一个被插入 HashMap 中，第二个实例与第一个相等，用于从 Map 中根据 PhoneNumber 去获取用户名字 。 由于 Phone Number 类没有覆盖 hashCode 方法，从而导致两个相等的实例具有不相等的散列 码，违反了 hashCode 的约定 。 因此， put 方法把 电话号码对象存放在一个散列桶 （ hashbucket ）中，get 方法却在另一个散列桶中查找这个电话号码。即使这两个实例正好被放到同一个散列桶中，get 方法也必定会返回 null ，因为 HashMap 有一项优化，可以将与每个项相关联的散列码缓存起来，如果散列码不匹配，也就不再去检验对象的等同性 。</p><p>修正这个问题非常简单，只需为 PhoneNumber类提供一个适当的hashCode方法即可。那么， hashCode 方法应该是什么样的呢？编写一个合法但并不好用的 hashCode 方法没有任何价值。 例如，下面这个方法总是合法的，但是它永远都不应该被正式使用 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The worst possible legal hashCode imple『『1entation - never use!</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span> <span class="hljs-params">()</span>｛</span><br><span class="hljs-function">    return 42</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个 hashCode 方法是合法的，因为它确保了相等的对象总是具有同样的散列码 。但它也极为恶劣，因为它使得每个对象都具有同样的散列码 。 因此，每个对象都被映射到同 一个散列桶中，使散列表退化为链表（ linked list ） 。 它使得本该线性时间运行的程序变成了 以平方级时间在运行 。 对于规模很大的散列表而言，这会关系到散列表能否正常工作 。</p><p>一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码” 。 这正是 hashCode 约定中第 三条 的含义 。 理想情况下，散列函数应该把集合中不相等的实例均匀 地分布到所有可能的 int 值上 。 要想完全达到这种理想的情形是非常困难的 。 幸运的是， 相对接近这种理想情形则并不太困难。 下面给出一种简单的解决办法 ：</p><ol><li><p>声明一个 int 变量并命名为 result ，将它初始化为对象中第一个关键域的散列码 c ，如步骤 2.a 中计算所示（如第 10 条所述，关键域是指影响巳quals 比较的域） 。</p></li><li><p>对象中剩下的每一个关键域 f 都完成以下步骤：</p><ol><li>为该域计算 int 类型的散列码 C:<ul><li>如果该域是基本类型，则计算 Type. hashCode ( f ），这里的 Type 是装箱基 本类型的类，与 f 的类型相对应 。</li><li>如果该域是一个对象引用，并且该类的 equals 方法通过递归地调用 equals 的方式来比较这个域，则同样为这个域递归地调用 hashCode 。 如果需要更复 杂的比较，则为这个域计算一个“范式”（ canonical representation ），然后针对这个范式调用 hashCode 。 如果这个域的值为 null ，则 返回 0 （或者其他某个常数，但通常是 0 ） 。</li><li>如果该域是一个数组，则要把每一个元素当作单独的域来处理。 也就是说，递归地应用上述规则，对每个重要的元素计算 一个散列码，然后根据步骤 2.b 中的做法把这些散列值组合起来 。 如果数组域中没有重要的元素，可以使用 一个常量，但最好不要用 0。 如果数组域中的所有元素都很重要，可以使用Arrays . hashCode 方法 。</li></ul></li><li>按照下面的公式，把步骤 2 . a 中计算得到的散列码 c 合并到 result 中 ：<br> <code> result = 31 * result + c;</code></li></ol></li><li><p>返回result</p></li></ol><p>写完了 hashCode 方法之后，问问自己“相等的实例是否都具有相等的散列码” 。 要编 写单元测 试来验证你的推断（除非利用 AutoValue 生成 equals 和 hashCode 方法，这样 你就可 以放心地省略这些测试） 。 如果相等的实例有着不相等的散列码， 则要找出原因，并 修正错误。</p><p>在散列码的计算过程中，可 以把衍生域（ derived field ）排除在外 。 换句话说，如果一 个域的值可以根据参与计算的其他域值计算出来， 则可以把这样的域排除在外 。 <strong>必须排除 equals 比较计算中没有用到的任何域，否则很有可能违反 hashCode 约定的第二条</strong>。</p><p>步骤 2.b 中的乘法部分使得散列值依赖于域的顺序，如果一个类包含多个相似 的域，这 样的乘法运算就会产生一个更好的散列函数。 例如，如果 String 散列函数省｜略了这个乘法 部分，那么只是字母顺序不同的所有字符串将都会有相同的散列码。 之所以选择 31 ，是因为 它是一个奇素数。 如果乘数是偶数，并且乘法、溢出的话，信息就会丢失，因为与 2 相乘等价 于移位运算 。 使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果 。 3 1 有个 很好的特性，即用移位和减法来代替乘法，可以得到更好的性能 ： 31 女 i = = ( i &lt; &lt; 5 ) - i 。 现代的虚拟机可以自动完成这种优化 。</p><p>现在我们要把上述解决办法用到 PhoneNumber 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Typical hashCode method </span><br><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = Short.hashCode(areaCode);<br><br>    result = <span class="hljs-number">31</span> * result + Short.hashCode(prefix);<br>    result = <span class="hljs-number">31</span> * result + Short.hashCode(lineNum);<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这个方法返回的结果是一个简单、确定的计算结果，它的输入只是 PhoneNumber 实例中的三个关键域，因此相等的 PhoneNumber 实例显然都会有相等的散列码 。 实际上， 对于 PhoneNumber 的 hashCode 实现而言，上面这个方法是非常合理的，相当于 Java 平台类库中的实现。 它的做法非常简单，也相当快捷，恰当地把不相等的电话号码分散到不同 的散列桶中 。</p><p>虽然本条目中前面给出的 hashCode 实现方法能够获得相当好的散列函数，但它们并不是最先进的 。 它们的质量堪 比 Java 平台类库的值类型中提供的散列函数，这些方法对于 绝大多数应用程序而言已经足够了 。 如果执意想让散列函数尽可能地不会造成冲突，请参阅 Guava ’ s com.google.common.hash.Hashing [Guava］ 。</p><p>Objects 类有一个静态方法，它带有任意数量的对象，并为它们返回 一个散列码。 这 个方法名为 ha sh ， 是让你只需要编写一行代码的 hashCode 方法，与根据本条目前面介绍 过的解决方案编写出 来的 相比，它的质量是 与之相当的 。 遗憾的是，运行速度更慢一些， 因为它们会引发数组的创建，以便传入数目可变的参数， 如果参数中有基本类型，还需要 装箱和拆箱 。 建议只将这类散列函数用于不太注重性能的 情况 。 下面就是用这种方法为 PhoneNumber 编写 的散列 函数 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// One-line hashCode method - mediocre performance</span><br><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Object.hash(lineNum, prefix, areaCode);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个类是不可变的，并且计算散列码的开销也比较大 ， 就应该考虑把散列码缓存在 对象内部，而不是每次请求的时候都重新计算散列码。 如果你觉得这种类型的大多数对象会 被用作散列键（ hash keys ），就应该在创建实例的时候计算散列码。 否则，可以选择“延迟初 始化”（ lazily initialize ）散列码，即一直到 hashCode 被第一次调用的时候才初始化 （见第 83 条） 。 虽然我们的 PhoneNumber 类不值得这样处理，但是可以通过它来说明这种方法该如 何实现。 注意 hashCode 域的初始值（在本例中是 O ） 一般不能成为创建的实例的散列码：</p><p>! ……</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective_Java_1_创建和销毁对象</title>
    <link href="/2021/05/05/Effective-Java-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/05/05/Effective-Java-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h1><p>何时以及如何创建对象，何时以及如何避免创建对象， 如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作 。</p><h2 id="第一条-使用静态工厂方法代替构造函数（构造器Constructor）"><a href="#第一条-使用静态工厂方法代替构造函数（构造器Constructor）" class="headerlink" title="第一条 使用静态工厂方法代替构造函数（构造器Constructor）"></a>第一条 使用静态工厂方法代替构造函数（构造器Constructor）</h2><p>Static Factory Method   VS   Constructor</p><p>对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个公有 的构造器。 还有一种方法，也应该在每个程序员的工具箱中占有一席之地 。</p><p>类可以提供一个 公有的静态 工厂 方法（ static factory method ），它只是一个返回类的实例的静态方法。</p><p>下面是 一个来自 B。 olean （基本类型 boolean 的装箱类）的简单示例 。 这个方法将 boolean 基本 类型值转换成了一个 B o olean 对象引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b ? Boolean.TUE : Boolean.FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，静态工厂方法与设计模式［ Gamma95 ］中的工厂方法（ Factory Method ） 模式不同 。</p><p>如果不通过公有的构造器 ， 或者说除了公有的构造器之外，类还可以给它的客户端提 供静态工厂方法 。 提供静态工厂方法而不是公有的构造器，这样做既有优势，也有劣势:</p><ul><li>静态工厂方法与构造器不同的第一大优势在于，它们有名称。如果构造器的参数本 身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，产生的 客户端代码也更易于阅读。 例如，构造器 Biginteger (int , int, Random ）返回的Biginteger 可能为素数，如果用名为 B 工 ginteger.probablePrime 的静态工厂方法来表示，显然更为清楚。 (Java 4 版本中增加了这个方法 。 ）    一个类只能有一个带有指定签名的构造器 。 编程人员通常知道如何避开这一限制 ： 通过 提供两个构造器，它们 的参数列表只在参数类型的顺序上有所不同 。 实际上这并不是个好主 意。面对这样的 API ， 用户永远也记不住该用哪个构造器 ， 结果常常会调用错误 的构造器 。 并且在读到使用了这些构造器的代码时，如果没有参考类的文档，往往不知所云 。     由于静态工厂方法有名称，所以它们不受上述限制 。 当一个类需要多个带有相同签名 的构造器时，就用静态工厂方法代替构造器，并且仔细地选择名称以便突出静态工厂方法之 间的区别 。</li></ul><ul><li>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。 这使得不可变类（详见第 17 条）可以使用预先构建好的 实 例，或者将 构建好的 实 例 缓存起来， 进行重复利用，从而避免创建不必要的重复对象。 Boolean. va lueOf (b oolean ）方法说明了这项技术 ： 它从来不创 建对象 。 这种方法类似于享元 (Flyweight ）模式［ Gamma95 ］ 。 如果程序经常请求创建相同的对象，并且创建对象的代价 很高，则这项技术可以极大地提升性能 。      静态工厂方法能够为重复的调用返回相同对象，这样有助于类总能严格控制在某个时· 刻哪些实例应该存在 。 这种类被称作实例受控的类（ instance-controlled ） 。 编写实例受控的 类有几个原因 。 实例受控使得类可 以确保它是一个 Singleton （详见第 3 条 ）或者是不可实例 化的（详见第 4 条） 。 它还使得不可变的值类（详见第 17 条）可 以确保不会存在两个相等的 实例， 即 当且仅当 a==b 时， a . equals(b ）才为 true 。 这是享元模式［ Gamma95 ］ 的基础 。 枚举（巳num ）类型（详见第 34 条 ）保证了这一点 。</li></ul><ul><li>静态工厂方法与构造器不同的第三大优势在子，它们可以返回原返回类型的任何子类型的对象。这样我们在选择返回对象的类时就有 了更大的灵活性 。     这种灵活性的一种应用是 ， API 可以返回对象，同时又不会使对象的类变成公有的 。 以 这种方式隐藏实现类会使 API 变得非常简洁。 这项技术适用于基于接口的框架（ interface四 based framework ) （详见第 20 条），因为在这种框架中 ，接 口 为静态工厂方法提供了自然返回 类型 。     在 Java 8 之前 ，接 口不能有静态方法，因此按照惯例，接口 Type 的静态工厂方法被放在 一个名为 Types 的不可 实例化的伴生类（详见第 4 条）中 。 例如 Java Collections Framework 的集合接口有 45 个工具实现，分别提供了不可修改的集合、 同步集合，等等。 几乎所有这 些实现都通过静态工厂方法在－个不可实例化的类（ java . ut il. Collections ） 中导出 。 所有返回对象的类都是非公有的 。   现在的 Collections Framework API 比导出 45 个独立公有类 的那种实 现方式要小得多， 每种便利实现都对应一个类。 这不仅仅是指 API 数量上 的 减少 ，也是概念意义上的减少：为了使用这个API，用户必须掌握的概念在数量和难度上都减少了 。 程序员知道，被返回的对象是由相关的接口精确指定的，所以他们不需要阅读有关的类文档 。 此外，使用这种静态 工厂方法时，甚至要求客户端通过接口来引用被返回的对象， 而不是通过它的实现类来引用 被返回的对象，这是一种良好的习惯（详见第 64 条） 。 从 Java 8 版本开始，接口中不能包含静态方法 的这一 限制成为历史，因此一般没有任何理由给接口提供一个不可实例化的伴生类 。 已经被放在这种类中的许多公有的静态成员， 应该被放到接口中去 。 但是要注意，仍然有必要将这些静态方法背后的大部分实现代码， 单独放进一个包级私有的类中 。 这是因为在 Java 8 中仍要求接口的所有静态成员都必须是 公有的 。 在 Java 9 中允许接口有私有的静态方法，但是静态域和静态成员类仍然需要是公 有的 。</li></ul><ul><li>静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取 决于静态工厂方法的参数值。 只要是已声明的返回类型的子类型，都是允许的 。 返回对象的 类也可能随着发行版本的不同而不同 。       EnumSet （详见第 36 条）没有公有的构造器，只有静态工厂方法。 在 OpenJDK 实现中， 它们返回两种子类之一的一个实例，具体则取决于底层枚举类型的大小：如果它的元素有 64 个或者更少，就像大多数枚举类型一样，静态工厂方法就会返回一个 RegalarEumSet 实例， 用单个 long 进行支持；如果枚举类型有 65 个或者更多元素，工厂就返回 JumboEnumSet 实例，用一个 long 数组进行支持。     这两个实现类的存在对于客户端来说是不可见的 。 如果 RegularEnumSet 不能再给 小的枚举类型提供性能优势，就可能从未来的发行版本中将它删除，不会造成任何负面的影 H向 。 同样地，如果事实证明对性能有好处，也可能在未来的发行版本中添加第三甚至第四个 EnumSet 实现。 客户端永远不知道也不关心它们从工厂方法中得到的对象的类，它们只关心它是 EnumSet 的某个子类 。</li></ul><ul><li>静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方 法的类时可以不存在。    这种灵活的静态工厂方法构成了服务提供者框架（ Service Provider Framework）的基础，例如 JDBC(Java 数据库连接）API 。 服务提供者框架是指这样一个系统： 多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个 实现中解稠出来 。     服务提供者框架中有三个重要的组件 ：服务接口 （ Service Interface ），这是提供者实现 的；提供者注册 API ( Provider Registration API ），这是提供者用来注册实现的；服务访问 API (Service Access API) ，这是客户端用来获取服务的实例 。 服务访问 API 是客户端用来指 定某种选择实现的条件。 如果没有这样的规定， API 就会返回默认实现的一个实例，或者允 许客户端遍历所有可用的实现。 服务访问 API 是“灵活的静态工厂”，它构成了服务提供者 框架的基础 。    服务提供者框架的第四个组件服务提供者接口（ Service Provid巳r Interface ）是可选的，它表示产生服务接口之实例的工厂对象 。 如果没有服务提供者接口，实现就通过反射方式进行实例化（详见第 65 条） 。 对于 JDBC 来说Connectio 口就是其服务接口的一部分,DriverManager . registerDriver 是提供者注册 API,DriverManager.getConnection是服务访问 API, Driver 是服务提供者接口 。       服务提供者框架模式有着无数种变体。 例如，服务访问 API 可以返回比提供者需要 的 更丰富的服务接口 。 这就是桥接（ Bridge ）模式 ［ Gamma95 ］ 。 依赖、注入框架（详见第 5 条） 可以被看作是一个强大的服务提供者 。 从 Java 6 版本开始， Java 平台就提供了 一个通用的服务提供者框架 j ava . util.ServiceLoader ，因 此你不需要（一般来说也不应该）再自 己编写了（详见第 59 条 ） 。 JDBC 不用 S erv工 ceLoader ，因为前者 出现得比后者早。</li></ul><ul><li>静态工厂方法的主要缺点在子，类如果不含公有的或者受保护的构造器，就不能被子类化 。 例如，要想将 Collections Framework 中的任何便利的实现类子类化 ， 这是不可能的 。 但是这样也许会因祸得福，因为它鼓励程序员使用复合（ composition ），而不是继承（详见 第四条），这正是不可变类型所需要的（详见第 17 条） 。</li></ul><ul><li>静态工厂方法的第二个缺点在于，程序员很难发现它们 。在 API 文档中，它们没有像 构造器那样在 API 文档中明确标识出来， 因 此 对于提供了静态工厂方法而不是构造器的 类来说，要想查明如何实例化一个类是非常困难的 。 Javadoc 工具总有一天会注意到静态工厂方法。 同时，通过在类或者接 口 注释 中关注静态工厂 ， 并遵守标准的命名 习惯，也可以弥补这一劣势。 下面是静态工厂方法 的一些惯用名称 。 这里只列 出了其中的一小部分：</li></ul><table><thead><tr><th>方法名</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>from</td><td>类型转换方法，它只有单个参数，返回该类型的一个相对应的实例</td><td>Date d = Date.from(instant);</td></tr><tr><td>of</td><td>聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来</td><td>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</td></tr><tr><td>valueOf</td><td>比 from 和 of 更烦琐的一种替代方法</td><td>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</td></tr><tr><td>instance 或 getInstance</td><td>返回的实例是通过方法的（如有）参数来 描述的，但是不能说与参数具有 同样的值</td><td>StackWalker Luke = StackWalker.getInstance(options);</td></tr><tr><td>create 或者 newInsatnce</td><td>象 instance 或者 getinstaηce 一样，但 create 或者 newInstance 能够确保每次调用都返回一个新的实例</td><td>Object newArray = Array.newIntance(classObject, arrayLen);</td></tr><tr><td>get<em>Type</em></td><td>像 get Ins taηce 一 样，但是在工厂方法处于不同的类中的时候使 用 ，Type 表示工厂方法所返回的对象类型</td><td>FileStore fs = Files.getFileStore(path);</td></tr><tr><td>new<em>Type</em></td><td>’象 newInstance 一样，但是在工厂方法处于不同的类中的时候使用。Type 表示工厂方法所返回的对象类型</td><td>BufferedReader br = Files.newBufferedReader(path);</td></tr><tr><td><em>type</em></td><td><em>getType</em> 和 <em>newType</em> 的简版</td><td>List&lt;Complaint&gt; litany = Collections.list(legancyLitany);</td></tr></tbody></table><p>简而言之，静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处。 静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器， 而不先考虑静态工厂 。</p><h2 id="第二条-遇到多个构造器参数时要考虑使用构建器"><a href="#第二条-遇到多个构造器参数时要考虑使用构建器" class="headerlink" title="第二条 遇到多个构造器参数时要考虑使用构建器"></a>第二条 遇到多个<em>构造器</em>参数时要考虑使用<em>构建器</em></h2><p>静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。 比如 用一个类表示包装食品外面显示的营养成分标签。 这些标签中有几个域是必需的：每份的含 量、每罐的含量以及每份的卡路里 。 还有超过 20 个的可选域 ： 总脂肪量、饱和脂肪量、转 化脂肪、胆固醇、纳，等等 。 大多数产品在某几个可选域中都会有非零的值。</p><p>对于这样的类，应该用哪种构造器或者静态工厂来编写呢？程序员一向习惯采用重叠 构造器（ telescoping constructor ）模式，在这种模式下，提供的第一个构造器只有必要的参 数，第二个构造器有一个可选参数，第三个构造器有两个可选参数，依此类推，最后一个构 造器包含所有可选的参数 。 下面有个示例，为了简单起见，它只显示四个可选域 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.telescopingconstructor;<br><br><span class="hljs-comment">// Telescoping constructor pattern - does not scale well! (Pages 10-11)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NutritionFacts</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servingSize;  <span class="hljs-comment">// (mL)            required</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servings;     <span class="hljs-comment">// (per container) required</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> calories;     <span class="hljs-comment">// (per serving)   optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fat;          <span class="hljs-comment">// (g/serving)     optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sodium;       <span class="hljs-comment">// (mg/serving)    optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> carbohydrate; <span class="hljs-comment">// (g/serving)     optional</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(servingSize, servings, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> calories)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(servingSize, servings, calories, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> calories, <span class="hljs-keyword">int</span> fat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(servingSize, servings, calories, fat, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> calories, <span class="hljs-keyword">int</span> fat, <span class="hljs-keyword">int</span> sodium)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(servingSize, servings, calories, fat, sodium, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> calories, <span class="hljs-keyword">int</span> fat, <span class="hljs-keyword">int</span> sodium, <span class="hljs-keyword">int</span> carbohydrate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.servingSize  = servingSize;<br>        <span class="hljs-keyword">this</span>.servings     = servings;<br>        <span class="hljs-keyword">this</span>.calories     = calories;<br>        <span class="hljs-keyword">this</span>.fat          = fat;<br>        <span class="hljs-keyword">this</span>.sodium       = sodium;<br>        <span class="hljs-keyword">this</span>.carbohydrate = carbohydrate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NutritionFacts cocaCola =<br>                <span class="hljs-keyword">new</span> NutritionFacts(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">35</span>, <span class="hljs-number">27</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>当你想要创建实例的时候，就利用参数列表最短的构造器，但该列表中包含了要设置的所有参数 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">NutritionFacts cocaCloa = <span class="hljs-keyword">new</span> NutritionFacts(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">35</span>, <span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure><p>这个构造器调用通常需要许多你本不想设置的参数，但还是不得不为它们传递值。 在 这个例子中，我们给 fat 传递了一个值为 0。 如果“仅仅”是这 6 个参数，看起来还不算太 糟糕，问题是随着参数数目的增加，它很快就失去了控制 。</p><p>简而言之，重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难缩写， 并且仍然较难以阅读。 如果读者想知道那些值是什么意思，必须很仔细地数着这些参数来探 个究竟。 一长串类型相同的参数会导致一些微妙的错误。 如果客户端不小心颠倒了其中两个 参数的顺序，编译器也不会出错，但是程序在运行时会出现错误的行为（详见第 51 条） 。</p><p>遇到许多可选的构造器参数的时候，还有第二种代替办法，即 JavaBeans 模式，在这 种模式下，先调用一个无参构造器来创建对象，然后再调用 setter 方法来设置每个必要的参 数，以及每个相关的可选参数 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.javabeans;<br><br><span class="hljs-comment">// JavaBeans Pattern - allows inconsistency, mandates mutability  (pages 11-12)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NutritionFacts</span> </span>&#123;<br>    <span class="hljs-comment">// Parameters initialized to default values (if any)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> servingSize  = -<span class="hljs-number">1</span>; <span class="hljs-comment">// Required; no default value</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> servings     = -<span class="hljs-number">1</span>; <span class="hljs-comment">// Required; no default value</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> calories     = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fat          = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sodium       = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> carbohydrate = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// Setters</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServingSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>  </span>&#123; servingSize = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServings</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>     </span>&#123; servings = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCalories</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>     </span>&#123; calories = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>          </span>&#123; fat = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSodium</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span>       </span>&#123; sodium = val; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCarbohydrate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123; carbohydrate = val; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NutritionFacts cocaCola = <span class="hljs-keyword">new</span> NutritionFacts();<br>        cocaCola.setServingSize(<span class="hljs-number">240</span>);<br>        cocaCola.setServings(<span class="hljs-number">8</span>);<br>        cocaCola.setCalories(<span class="hljs-number">100</span>);<br>        cocaCola.setSodium(<span class="hljs-number">35</span>);<br>        cocaCola.setCarbohydrate(<span class="hljs-number">27</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式弥补了重叠构造器模式的不足 。 说得明白一点，就是创建实例很容易，这样 产生的代码读起来也很容易：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">NutritionFacts cocaCola = <span class="hljs-keyword">new</span> NutritionFacts();<br>cocaCola.setServingSize(<span class="hljs-number">240</span>);<br>cocaCola.setServings(<span class="hljs-number">8</span>);<br>cocaCola.setCalories(<span class="hljs-number">100</span>);<br>cocaCola.setSodium(<span class="hljs-number">35</span>);<br>cocaCola.setCarbohydrate(<span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure><p>遗憾的是， JavaBeans 模式自身有着很严重的缺点 。 因为构造过程被分到了几个调用中， 在构造过程中 Java Bean 可能处于不一致的状态。 类无法仅仅通过检验构造器参数的有效性 来保证一致性 。 试图使用处于不一致状态的对象将会导致失败，这种失败与包含错误的代码 大相径庭，因此调试起来十分困难 。 与此相关的另一点不足在于， Java Beans 模式使得把 类做成不可变的可能性不复存在 （详见第 17 条），这就需要程序员 付出 额外 的努力来确保它 的线程安全 。<br>当对象的构造完成，并且不允许在冻结之前使用时 ，通过手工“冻结”对象可 以 弥补这 些不足，但是这种方式十分笨拙，在实践中很少使用 。 此外，它甚至会在运行时导致错误， 因为编译器无法确保程序员会在使用之前先调用对象上的 freeze 方法进行冻结。</p><p>幸运的是，还有第 三种替代方法，它既能保证像重叠构造器模式那样的安全性，也能 保证像 JavaBeans 模式那么好的可读性 。 这就是建造者（ Builder ）模式 ［ Gamma95 ］ 的一 种形式 。 它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静 态工厂），得到一个 builder 对象。 然后客户端在 builder 对象上调用类似于 setter 的方法，来设置每个相关的可选参数。 最后客户端调用无参的 build 方法来生成通常是不可变的对象。 这个 buiider 通常是它构建的类的静态成员类（详见第 24 条） 。 下面就是它的示例 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NutritionFacts</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servingSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servings;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> calories;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fat;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sodium;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> carbohydrate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>        <span class="hljs-comment">// Required parameters</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servingSize;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> servings;<br><br>        <span class="hljs-comment">// Optional parameters - initialized to default values</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> calories      = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fat           = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sodium        = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> carbohydrate  = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> servingSize, <span class="hljs-keyword">int</span> servings)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.servingSize = servingSize;<br>            <span class="hljs-keyword">this</span>.servings    = servings;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">calories</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">        </span>&#123; calories = val;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">fat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">        </span>&#123; fat = val;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">sodium</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">        </span>&#123; sodium = val;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">carbohydrate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">        </span>&#123; carbohydrate = val;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> NutritionFacts <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NutritionFacts(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">NutritionFacts</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        servingSize  = builder.servingSize;<br>        servings     = builder.servings;<br>        calories     = builder.calories;<br>        fat          = builder.fat;<br>        sodium       = builder.sodium;<br>        carbohydrate = builder.carbohydrate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NutritionFacts cocaCola = <span class="hljs-keyword">new</span> NutritionFacts.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)<br>                .calories(<span class="hljs-number">100</span>).sodium(<span class="hljs-number">35</span>).carbohydrate(<span class="hljs-number">27</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 NutritionFacts 是不可变的，所有的默认参数值都单独放在）个地方。 builder的设值方法返回 builder 本身，以便把调用链接起来，得到一个流式的 API。 下面就是其客户端代码 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">NutritionFacts cocaCola = <span class="hljs-keyword">new</span> NutritionFacts.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)<br>    .calories(<span class="hljs-number">100</span>)<br>    .sodium(<span class="hljs-number">35</span>)<br>    .carbohydrate(<span class="hljs-number">27</span>).<br>    build();<br></code></pre></td></tr></table></figure><p>这样的客户端代码很容易编写，更为重要的是易于阅读 。 选参数 ，就像 Python 和 Scala 编程语言中的一样 。</p><p>为了简洁起见，示例中省略了有效性检查。 要想尽快侦测到无效的参数， 可以在 builder 的构造器和方法中检查参数的有效性。 查看不可变量，包括 build 方法调用的构造 器中的多个参数。 为了确保这些不变量免受攻击， 从 builder 复制完参数之后，要检查对象 域 （详见 第 50 条） 。 如果检 查失败 ，就抛出 I l leg a lArgumen tExcept ion （详 见第 72条），其中的详细信息会说明哪些参数是无效的（详见第 75 条） 。</p><p>Builder 模式也适用于类层次结构 。 使用平行层次结构的 builder 时， 各自嵌套在相应的 类中 。 抽象类有抽象的 builder ，具体类有具体的 builder。 假设用类层次根部 的一个抽象类 表示各式各样的比萨：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.hierarchicalbuilder;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">// Builder pattern for class hierarchies (Page 14)</span><br><br><span class="hljs-comment">// Note that the underlying &quot;simulated self-type&quot; idiom  allows for arbitrary fluid hierarchies, not just builders</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pizza</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Topping</span> </span>&#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125;<br>    <span class="hljs-keyword">final</span> Set&lt;Topping&gt; toppings;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">addTopping</span><span class="hljs-params">(Topping topping)</span> </span>&#123;<br>            toppings.add(Objects.requireNonNull(topping));<br>            <span class="hljs-keyword">return</span> self();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">abstract</span> Pizza <span class="hljs-title">build</span><span class="hljs-params">()</span></span>;<br><br>        <span class="hljs-comment">// Subclasses must override this method to return &quot;this&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title">self</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>    <br>    Pizza(Builder&lt;?&gt; builder) &#123;<br>        toppings = builder.toppings.clone(); <span class="hljs-comment">// See Item 50</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意， Pizza . Builder 的类型是泛型（ generic type ），带有一个递归类型参数（recursive type parameter ），详见第 30 条。 它和抽象的 self 方法一样，允许在子类中适当地进行方法 链接，不需要转换类型 。 这个针对 Java 缺乏 self 类型的解决方案，被称作模拟的 self 类型（ simulated self-type ） 。</p><p>这里有两个具体的 Pizza 子类，其中一个表示经典纽约风味的比萨，另 一个表示馅料 内置的半月型（ calzone ）比萨。 前者需要一个尺寸参数，后者则要你指定酱汁应该内 置还是 外置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.hierarchicalbuilder;<br><br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-comment">// Subclass with hierarchical builder (Page 15)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NyPizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span> </span>&#123; SMALL, MEDIUM, LARGE &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Size size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span>.<span class="hljs-title">Builder</span>&lt;<span class="hljs-title">Builder</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Size size;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(Size size)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.size = Objects.requireNonNull(size);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> NyPizza <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NyPizza(<span class="hljs-keyword">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> Builder <span class="hljs-title">self</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">NyPizza</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(builder);<br>        size = builder.size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;New York Pizza with &quot;</span> + toppings;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.hierarchicalbuilder;<br><br><span class="hljs-comment">// Subclass with hierarchical builder (Page 15)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calzone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> sauceInside;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span>.<span class="hljs-title">Builder</span>&lt;<span class="hljs-title">Builder</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> sauceInside = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Default</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">sauceInside</span><span class="hljs-params">()</span> </span>&#123;<br>            sauceInside = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Calzone <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Calzone(<span class="hljs-keyword">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> Builder <span class="hljs-title">self</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Calzone</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(builder);<br>        sauceInside = builder.sauceInside;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Calzone with %s and sauce on the %s&quot;</span>,<br>                toppings, sauceInside ? <span class="hljs-string">&quot;inside&quot;</span> : <span class="hljs-string">&quot;outside&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，每个子类的构建器中的 build 方法，都声明返回正确的子类： NyPizza.Bu i lder的 build 方法返回 Ny Pizz a ，而 Cal zo ne.Builder 中的则返回 Calzo口e 。 在该 方法中，子类方法声明返回超级类中声明的返回类型的子类型，这被称作协变返回类型(covariant return type ） 。 它允许客户端无须转换类型就能使用这些构建器。</p><p>这些“层次化构建器” 的客户端代码本质上与简单的 NutritionFacts 构建器一样。 为了简洁起见，下列客户端代码示例假设是在枚举常量上静态导人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item2.hierarchicalbuilder;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> effectivejava.chapter2.item2.hierarchicalbuilder.Pizza.Topping.*;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> effectivejava.chapter2.item2.hierarchicalbuilder.NyPizza.Size.*;<br><br><span class="hljs-comment">// Using the hierarchical builder (Page 16)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NyPizza pizza = <span class="hljs-keyword">new</span> NyPizza.Builder(SMALL)<br>                .addTopping(SAUSAGE).addTopping(ONION).build();<br>        Calzone calzone = <span class="hljs-keyword">new</span> Calzone.Builder()<br>                .addTopping(HAM).sauceInside().build();<br>        <br>        System.out.println(pizza);<br>        System.out.println(calzone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与构造器相比， builder 的 微略优势在于，它可 以有 多 个可 变（ varargs ） 参数。 因为 builder 是利用单独的方法来设置每一个参数。 此外，构造器还可以将多次调用某一个方法而传人的参数集 中到一个域中，如前面的调用了两次 addToppi口q 方法的代码所示 。</p><p>Builder 模式十分灵活，可以利用单个 builder 构建多个对象 。 build町的参数可以在调用 build 方法来创建对象期间进行调整，也可以随着不同的对象而改变 。 builder 可以自动填 充某些域，例如每次创建对象时自动增加序列号 。</p><p>Builder 模式的确也有它自身的不足。 为了创建对象 ，必须先创建它 的构建器。 虽然创 建这个构建器的开销在实践中可能不那么明显 但是在某些十分注重性能 的情况下，可能就 成问题了 。 Builder 模式还 比重叠构造器模式更加冗长 ，因此它只在有很多参数的时候才使 用，比如 4 个或者更多个参数。 但是记住，将来你可能需要添加参数。 如果一开始就使用构 造器或者静态工厂，等到类需要多个参数时才添加构造器，就会无法控制，那些过时的构造 器或者静态工厂显得十分不协调 。 因 此，通常最好一开始就使用构建器。</p><p>简而言之 ， 如果类的构造器或者静态工厂中具有多个参数，设计这种类时， Builde「 模式就是一种不错的选择， 特别是当大多数参数都是可选或者类型相同的时候。 与使用 重叠构造器模式相比，使用 Builder 模式 的客户端代码将更易于 阅读和编写，构建器也比 JavaBeans 更加安全。</p><p>扩展：如何限定前面必填项填完之后，才能填接下来的参数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chamc.boot.bpm.model.process.param;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">import</span> org.apache.commons.lang3.ArrayUtils;<br><br><span class="hljs-keyword">import</span> com.chamc.boot.bpm.model.common.Variable;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<br><br><span class="hljs-meta">@AllArgsConstructor</span> <span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@Data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StartBpmParam</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StartBpmParam</span><span class="hljs-params">(String userId, String processKey, String bussinessKey, String title, String orgId, <span class="hljs-keyword">boolean</span> toNext, List&lt;Variable&gt; variables, AssignInfo assignInfo)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.userId = userId;<br><span class="hljs-keyword">this</span>.processKey = processKey;<br><span class="hljs-keyword">this</span>.bussinessKey = bussinessKey;<br><span class="hljs-keyword">this</span>.title = title;<br><span class="hljs-keyword">this</span>.orgId = orgId;<br><span class="hljs-keyword">this</span>.toNext = toNext;<br><span class="hljs-keyword">this</span>.variables = variables;<br><span class="hljs-keyword">this</span>.assignInfo = assignInfo;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StartBpmParam</span><span class="hljs-params">(String userId, String processKey, String bussinessKey, String title, String orgId)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.userId = userId;<br><span class="hljs-keyword">this</span>.processKey = processKey;<br><span class="hljs-keyword">this</span>.bussinessKey = bussinessKey;<br><span class="hljs-keyword">this</span>.title = title;<br><span class="hljs-keyword">this</span>.orgId = orgId;<br>&#125;<br><br><span class="hljs-keyword">private</span> String userId;<br><br><span class="hljs-keyword">private</span> String processKey;<br><br><span class="hljs-keyword">private</span> String bussinessKey;<br><br><span class="hljs-keyword">private</span> String title;<br><br><span class="hljs-keyword">private</span> String orgId;<br><br><span class="hljs-keyword">private</span> String comment;<br><br><span class="hljs-comment">/**鏄惁璺宠繃棣栬妭鐐�*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> toNext;<br><br><span class="hljs-keyword">private</span> List&lt;Variable&gt; variables;<br><br><span class="hljs-keyword">private</span> AssignInfo assignInfo;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Builder <span class="hljs-title">builder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Builder();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder2 <span class="hljs-title">startBy</span><span class="hljs-params">(String userAcco, String orgCode)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Builder2(userAcco, orgCode);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder2</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String userId;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String orgId;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder3 <span class="hljs-title">processKey</span><span class="hljs-params">(String processKey)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Builder3(userId, orgId, processKey);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder3</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String userId;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String orgId;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String processKey;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder4 <span class="hljs-title">bussinessKey</span><span class="hljs-params">(String bussinessKey)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Builder4(userId, orgId, processKey, bussinessKey);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder4</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String userId;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String orgId;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String processKey;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String bussinessKey;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">title</span><span class="hljs-params">(String title)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Builder5(userId, orgId, processKey, bussinessKey, title);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder5</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String userId;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String orgId;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String processKey;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String bussinessKey;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String title;<br><br><span class="hljs-keyword">private</span> String comment;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> toNext;<br><span class="hljs-keyword">private</span> List&lt;Variable&gt; variables;<br><span class="hljs-keyword">private</span> AssignInfo assignInfo;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">comment</span><span class="hljs-params">(String comment)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.comment = comment;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 璺宠繃绗竴涓妭鐐癸紝榛樿涓嶈烦杩�</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">skipFirst</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">this</span>.toNext = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 璁剧疆涓嬩竴鑺傜偣鎸囧畾鏈烘瀯</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nextOrgId</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">nextOrgId</span><span class="hljs-params">(String nextOrgId)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (Objects.isNull(<span class="hljs-keyword">this</span>.assignInfo)) &#123;<br><span class="hljs-keyword">this</span>.assignInfo = <span class="hljs-keyword">new</span> AssignInfo();<br>&#125;<br><span class="hljs-keyword">this</span>.assignInfo.setNextOrgId(nextOrgId);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 璁剧疆鎸囨淳浜哄憳</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> toUserAccos</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">assign</span><span class="hljs-params">(String... toUserAccos)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(Objects.isNull(<span class="hljs-keyword">this</span>.assignInfo)) &#123;<br><span class="hljs-keyword">this</span>.assignInfo = <span class="hljs-keyword">new</span> AssignInfo();<br>&#125;<br><span class="hljs-keyword">this</span>.assignInfo.setUserIds(toUserAccos);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 娣诲姞鎸囨淳浜哄憳</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> toUserAccos</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">assignAdditional</span><span class="hljs-params">(String... toUserAccos)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(Objects.isNull(<span class="hljs-keyword">this</span>.assignInfo)) &#123;<br><span class="hljs-keyword">this</span>.assignInfo = <span class="hljs-keyword">new</span> AssignInfo();<br>&#125;<br>String[] old = <span class="hljs-keyword">this</span>.assignInfo.getUserIds();<br><span class="hljs-keyword">if</span>(ArrayUtils.isEmpty(old)) &#123;<br><span class="hljs-keyword">this</span>.assignInfo.setUserIds(toUserAccos);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>String[] userIds = <span class="hljs-keyword">new</span> String[old.length + toUserAccos.length];<br>System.arraycopy(old, <span class="hljs-number">0</span>, userIds, <span class="hljs-number">0</span>, old.length);<br>System.arraycopy(toUserAccos, <span class="hljs-number">0</span>, userIds, old.length, toUserAccos.length);<br><span class="hljs-keyword">this</span>.assignInfo.setUserIds(userIds);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 娣诲姞琛ㄥ崟鍙橀噺</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">var</span><span class="hljs-params">(String name, String value)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(Objects.isNull(<span class="hljs-keyword">this</span>.variables)) &#123;<br><span class="hljs-keyword">this</span>.variables = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">2</span>);<br>&#125;<br>Variable <span class="hljs-keyword">var</span> = <span class="hljs-keyword">new</span> Variable(name, <span class="hljs-keyword">null</span>, value);<br><span class="hljs-keyword">this</span>.variables.add(<span class="hljs-keyword">var</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 娣诲姞琛ㄥ崟瀵硅薄鍙橀噺</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> objectValue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">var</span><span class="hljs-params">(String name, Object objectValue)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(Objects.isNull(<span class="hljs-keyword">this</span>.variables)) &#123;<br><span class="hljs-keyword">this</span>.variables = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">2</span>);<br>&#125;<br>Variable <span class="hljs-keyword">var</span> = <span class="hljs-keyword">new</span> Variable(name, objectValue);<br><span class="hljs-keyword">this</span>.variables.add(<span class="hljs-keyword">var</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 娣诲姞琛ㄥ崟鍙橀噺</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> names</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> values</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder5 <span class="hljs-title">vars</span><span class="hljs-params">(String[] names, String... values)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(Objects.isNull(<span class="hljs-keyword">this</span>.variables)) &#123;<br><span class="hljs-keyword">this</span>.variables = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(names.length);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; names.length; i++) &#123;<br>Variable <span class="hljs-keyword">var</span> = <span class="hljs-keyword">new</span> Variable(names[i], <span class="hljs-keyword">null</span>, values[i]);<br><span class="hljs-keyword">this</span>.variables.add(<span class="hljs-keyword">var</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> StartBpmParam <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>StartBpmParam param = <span class="hljs-keyword">new</span> StartBpmParam(userId, processKey, bussinessKey, title, orgId, comment, toNext, variables, assignInfo);<br><span class="hljs-keyword">return</span> param;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="第三条-用私有构造器或者枚举类型强化-Singleton-属性"><a href="#第三条-用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="第三条 用私有构造器或者枚举类型强化 Singleton 属性"></a>第三条 用私有构造器或者枚举类型强化 Singleton 属性</h2><p>Singleton 是指仅仅被实例化一次的类 ［ Gamma95 ］ 。 Singleton 通常被用来代表一个无状态的对象，如函数（详见第 24 条），或者那些本质上唯一的系统组件 。 使类成为 Singleton 会使它的害户端测试变得十分困难 ，因为不可能给 Singleton 替换模拟实现，除非实现一个 充当其类型的接口 。</p><p>实现 Singleton 有两种常见的方法 。 这两种方法都要保持构造器为私有的，并导出公有 的静态成员，以便允许客户端能够访问该类的唯一实例 。 在第一种方法中，公有静态成员是个 final 域 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item3.field;<br><br><span class="hljs-comment">// Singleton with public final field  (Page 17)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Elvis</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Elvis INSTANCE = <span class="hljs-keyword">new</span> Elvis();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Elvis</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leaveTheBuilding</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Whoa baby, I&#x27;m outta here!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// This code would normally appear outside the class!</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Elvis elvis = Elvis.INSTANCE;<br>        elvis.leaveTheBuilding();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>私有构造器仅被调用一 次，用来实例化公有的静态 final 域 Elvis.INSTANCE 。 由于缺少公有的或者受保护的构造器，所以保证了 Elvis 的全局唯一性 ： 一旦 Elvis 类被实例化，将只会存在一个 Elvis 实例 ，不多也不少。 客户端的任何行为都不会改变这一点， 但要提醒一点：享有特权的客户端可以借助 Access 工bleObject.setAccessible 方法， 通过反射机制（详见第 65 条）调用私有构造器。 如果需要抵御这种攻击，可以修改构造器， 让它在被要求创建第二个实例的时候抛出异常。</p><p>在实现 Singleton 的第二种方法中，公有的成员是个静态工厂方法 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item3.staticfactory;<br><br><span class="hljs-comment">// Singleton with static factory (Page 17)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Elvis</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Elvis INSTANCE = <span class="hljs-keyword">new</span> Elvis();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Elvis</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Elvis <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> INSTANCE; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leaveTheBuilding</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Whoa baby, I&#x27;m outta here!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// This code would normally appear outside the class!</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Elvis elvis = Elvis.getInstance();<br>        elvis.leaveTheBuilding();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于静态方法 Elvis.getInstance 的所有调用，都会返回同一个对象引用，所以， 永远不会创建其他的 Elvis 实例（上述提醒依然适用） 。</p><p>公有域方法的主要优势在于， API 很清楚地表明了这个类是一个 Singleton ： 公有的静态域是 final 的，所以该域总是包含相同的对象引用 。 第二个优势在于它更简单。</p><p>静态工厂方法的优势之一在于，它提供了灵活性 ： 在不改变其 API 的前提下 ， 我们可以改变该类是否应该为 Singleton 的想法。 工厂方法返回该类的唯一实例，但是，它很容易被修改， 比如改成为每个调用该方法的线程返回一个唯一的实例 。 第二个优势是， 如果应用程序需要，可以编写一个泛型 Singleton 工厂 （ generic singleton factory) （详见第 30 条） 。 使用静态工厂的最后一个优势是，可以通过方法引用（ method reference ）作为提供者，比如 Elvis::Instance 就是一个 Supplier&lt;Elvis&gt; , 除非满足以上任意一种优势 ， 否则还 是优先考虑公有域（ public-field ）的方法。</p><p>为了将利用上述方法实现的 Singleton 类变成是可序列化的 （ Serializable ）（详见第 12 章），仅仅在声明中加上 implements Serializable 是不够的 。 为了维护并保证 Singleton, 必须声明所有实例域都是瞬时（ transient 关键字）的， 并提供一个 readResolve 方法（详见第四条） 。 否则 ，每次反序列化一个序列化的实例时都会创建一个新的实例 ，比如， 在我们的例子中， 会导致“假冒的 Elvis”。为了防止发生这种情况， 要在 Elvis 类中加入如下 readResolve 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// readResolve method to preserve singleton property</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// return the one ture Elvis and let the garbage collector</span><br>    <span class="hljs-comment">// take care of the Elvis impersonator.</span><br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现 Singleton 的第三种方法是声明一个包含单个元素的枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item3.enumtype;<br><br><span class="hljs-comment">// Enum singleton - the preferred approach (Page 18)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Elvis</span> </span>&#123;<br>    INSTANCE;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leaveTheBuilding</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Whoa baby, I&#x27;m outta here!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// This code would normally appear outside the class!</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Elvis elvis = Elvis.INSTANCE;<br>        elvis.leaveTheBuilding();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法在功能上与公有域方法相似， 但更加简洁， 无偿地提供了序列化机制， 绝对防止多次实例化， 即使是在面对复杂的序列化或者反射攻击的时候 。 虽然这种方法还没有广泛采用， 但是单元素 的枚举类型经常成为实现 Singleton 的最佳方法。 注意， 如果 Singleton 必须扩展一个超类， 而不是扩展 Enum 的时候， 则不宜使用这个方法（虽然可以声明枚举去实现接口） 。</p><h2 id="第四条-通过私有构造器强化不可实例化的能力"><a href="#第四条-通过私有构造器强化不可实例化的能力" class="headerlink" title="第四条 通过私有构造器强化不可实例化的能力"></a>第四条 通过私有构造器强化不可实例化的能力</h2><p>有时可能需要编写只包含静态方法和静态域的类 。 这些类的名声很不好， 因为有些人在面向对象的语言中滥用这样的类来编写过程化的程序，但它们也确实有特别的用处。 我们可以利用这种类， 以 java.lang.Math 或者 java.util.Arrays 的方式， 把基本类型的值或者数组类型上的相关方法组织起来 。 我们也可以通过 java.util.Collections的方式， 把实现特定接口的对象上的静态方法， 包括工厂方法（详见第1条）组织起来 。 （从 Java 8 开始， 也可以把这些方法放进接口中， 假定这是你自己编写的接口可以进行修改 。 ） 最后， 还可以利用这种类把 final 类上的方法组织起来， 因为不能把它们放在子类中 。</p><p>这样的 工具 类（ utility class ）不希望被实例化， 因为实例化对它没有任何意义。 然而 ， 在缺少显式构造器的情况下， 编译器会自动提供一个公有的 、 无参的缺省构造器（ default constructor ） 。 对于用户而言， 这个构造器与其他的构造器没有任何区别 。 在已发行的 API 中常常可以看到一些被无意识地实例化的类 。</p><p>企图通过将类做成抽 象类 来强制该类不可被实例化是行不通的。 该类可以被子类化 ，并且该子类也可以被实例化。 这样做甚至会误导用户，以为这种类是专门为了继承而设计的 （详见第 19 条） 。 然而，有一些简单的习惯用法可以确保类不可被实例化。 由于只有当类不 包含显式的构造器时－，编译器才会生成缺省的构造器，因此只要让这个类包含一个私有构造器，它就不能被实例化 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item4;<br><br><span class="hljs-comment">// Noninstantiable utility class (Page 19)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UtilityClass</span> </span>&#123;<br>    <span class="hljs-comment">// Suppress default constructor for noninstantiability</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">UtilityClass</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();<br>    &#125;<br><br>    <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于显式的构造器是私有的，所以不可以在该类的外部访问它 。 AssertionError 不是必需的，但是它可以避免不小心在类的 内部调用构造器。 它保证该类在任何情况下都不会被实例化。 这种习惯用法有点违背直觉，好像构造器就是专门设计成不能被调用一样 。 因此，明智的做法就是在代码中增加一条注释，如上所示 。</p><p>这种习惯用法也有副作用，它使得一个类不能被子类化。 所有的构造器都必须显式或 隐式地调用超类（ superclass ）构造器，在这种情形下，子类就没有可访问的超类构造器可调用了 。</p><h2 id="第五条-优先考虑依赖注人来引用资源"><a href="#第五条-优先考虑依赖注人来引用资源" class="headerlink" title="第五条 优先考虑依赖注人来引用资源"></a>第五条 优先考虑依赖注人来引用资源</h2><p>!!! 理解一下，资源是什么东西？  一个类中的字段分类  属性  和  资源，暂时这样理解吧！</p><p>有许多类会依赖一个或多个底层的资源 。 例如，拼写检查器需要依赖词典。 下面这样把类实现为静态工具类的做法并不少见（详见第 4 条）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpellChecker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Lexicon directionary = ...;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SpellChecker</span><span class="hljs-params">(...)</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String word)</span> </span>&#123;...&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">suggestions</span><span class="hljs-params">(String typo)</span> </span>&#123;...&#125;;  <br>&#125;<br></code></pre></td></tr></table></figure><p>同样地，将这些类实现为 Singleton 的做法也并不少见（详见第 3 条）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpellChecker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Lexicon directionary = ...;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SpellChecker</span><span class="hljs-params">(...)</span> </span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> INSTABCE = <span class="hljs-keyword">new</span> SpellChecker(...);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String word)</span> </span>&#123;...&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">suggestions</span><span class="hljs-params">(String typo)</span> </span>&#123;...&#125;;  <br>&#125;<br></code></pre></td></tr></table></figure><p>以上两种方法都不理想，因为它们都是假定只有一本词典可用 。 实际上，每一种语言都有自己的词典， 特殊词汇还要使用特殊的词典。 此外， 可能还需要用特殊的词典进行测试。 因此假定用一本词典， 就能满足所有需求， 这简直是痴心妄想。</p><p>建议尝民用 SpellChecker 来支持多词典， 即在现有的拼写检查器中， 设 dictionary 域为 non final ，并 添加1一个方法用它来修改词典， 但是这样的设置会显得很笨拙、容易出 错，并且无法并行工作 。 静态工具类和 S ingleto n 类不适合于需要引用底层资源的类 。</p><p>这里需要的是能够支持类的多个实例（在本例中是指SpellChecker ），每一个实例都使用客户端指定的资源（在本例中是指同典） 。 满足该需求的最简单的模式是， 当创 建一个 新的实例时 ， 就将该资源传到构造器中 。 这是依赖注入（ dependency injection ）的一种形式： 词典（ dictionary ）是拼写检查器的一个依赖（ dependency ），在创建拼写检查器时就将词典注 入（ injected ）其中 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Dependency injection provides flexiblity and testability</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpellChecker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lexicon directionary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SpellChecker</span><span class="hljs-params">(Lexicon dictionary)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.directionary = directionary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String word)</span> </span>&#123;...&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">suggestions</span><span class="hljs-params">(String typo)</span> </span>&#123;...&#125;;  <br>&#125;<br></code></pre></td></tr></table></figure><p>依赖注入模式就是这么简单， 因此许多程序员使用多年， 却不知道它还有名字呢。 虽然这个拼写检查器的范例中只有一个资源（词典）， 但是依赖注入却适用于任意数量的资源， 以及任意的依赖形式。 依赖注入的对象资源具有不可变性（详见第 17 条）， 因此多个客户端 可以共享依赖对象（假设客户端们想要的是同一个底层资惊 ）。依赖注入也同样适用于构造器、静态工厂（详见第1条）和构建器（详见第 2 条） 。</p><p>这个程序模式的另一种有用的变体是， 将资源工厂（ factory ）传给构造器。 工厂是可以被重复调用来创建类型实例的一个对象。 这类工厂具体表现为工厂方法（ Factory Method) 模式［ Gamma95 J 。 在 Java 8 中增加的接口 Supplier＜T&gt;， 最适合用于表示工厂 。 带有 Supplier&lt;T&gt;的方法， 通常应该限制输入工厂的类型参数使用有限制的通配符类 型 ( bounded wildcard type ），详见第 31 条，以便客户端能自多传入一个工厂， 来创建指定类型的任意子类型。马赛克：例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Mosaic <span class="hljs-title">create</span><span class="hljs-params">(Supplier＜? extends Tile&gt;)</span> </span>&#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>虽然依赖注人极大地提升了灵活性和可测试性， 但它会导致大型项目凌乱不堪， 因为它 通常包含上千个依赖。 不过这种凌乱用一个依赖、注入框架（ dependency injection framework ) 便可以终结， 如 Dagger [Dagger］ 、 Guice [Guice］或者 Spring [Spring］ 。 这些框架的用法超 出 了本书的讨论范畴， 但是， 请注意：设计成手动依赖注入的 A凹， 一般都适用于这些框架 。</p><p>总而言之，不要用 Singleton 和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为 ；也不要直接用这个类来创建这些资源 。 而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类。 这个实践就被称 作依赖注入，它极大地提升了类的灵活性 、 可重用性和可测试性 。</p><h2 id="第六条-避免创建不必要的对象"><a href="#第六条-避免创建不必要的对象" class="headerlink" title="第六条 避免创建不必要的对象"></a>第六条 避免创建不必要的对象</h2><p>一般来说，最好能重用单个对象，而不是在每次需要 的时候就创建一个相同功能的新对象。 重用方式既快速，又流行。 如果对象是不可变的（immutable) （详见第 17 条），它就始终可以被重用。</p><p>作为一个极端的反面例子，看看下面的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;bikini&quot;</span>);   <span class="hljs-comment">//DON&#x27;T DO THIS!</span><br></code></pre></td></tr></table></figure><p>该语句每次被执行的时候都创建一个新的 String 实例，但是这些创建对象的动作全都是不必要的 。 传递给 String 构造器的参数（”bikini”）本身就是一个 String 实例， 功能方面等同于构造器创建的所有对象。 如果这种用法是在一个循环中，或者是在一个被频繁调用的方法中，就会创建出成千上万不必要的 String 实例 。</p><p>改进后的版本如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;bikini&quot;</span>;<br></code></pre></td></tr></table></figure><p>这个版本只用了 一个 String 实例，而不是每次执行的 时候都创建一个新的实例 。 而 且，它可以保证，对于所有在同一台虚拟机中运行的代码，只要它们包含相同的字符串 字面 常量，该对象就会被重用［ JLS , 3 .10. 5 ］。</p><p>对于同时提供了静态 工厂方法 （ static factory method) （详见第 l 条）和构造器的不可变 类，通常优先使用静态工厂方法而不是构造器，以避免创建不必要的对象。 例如，静态工厂 方法 Boolean. valueOf (String ）几乎总是优先于构造器 Boolean(String ），注意 构造器 Boolean(String ）在 Java 9 中已经被废弃了 。 构造器在每次被调用的时候都会创 建一个新的对象，而静态工厂方法则从来不要求这样做，实际上也不会这样做。 除了重用不 可变的对象之外，也可以重用那些已知不会被修改的可变对象。</p><p>有些对象创建的成本比其他对象要高得多 。 如果重复地需要这类“昂贵的对象”，建议将它缓存下来重用 。 遗憾的是，在创建这种对象的时候，并非总是那么显而易见 。 假设想要编写一个方法，用它确定一个字符串是否为一个有效的罗马数字。 下面介绍一种最容易的方 法，使用一个正则表达式 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item6;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">// Reusing expensive object for improved performance (Pages 22 and 23)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RomanNumerals</span> </span>&#123;<br>    <span class="hljs-comment">// Performance can be greatly improved! (Page 22)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRomanNumeralSlow</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.matches(<span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>                + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Reusing expensive object for improved performance (Page 23)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Pattern ROMAN = Pattern.compile(<br>            <span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>                    + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRomanNumeralFast</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ROMAN.matcher(s).matches();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> numSets = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> numReps = Integer.parseInt(args[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numSets; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numReps; j++) &#123;<br>                b ^= isRomanNumeralSlow(<span class="hljs-string">&quot;MCMLXXVI&quot;</span>);  <span class="hljs-comment">// Change Slow to Fast to see performance difference</span><br>            &#125;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println(((end - start) / (<span class="hljs-number">1_000.</span> * numReps)) + <span class="hljs-string">&quot; μs.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Prevents VM from optimizing away everything.</span><br>        <span class="hljs-keyword">if</span> (!b)<br>            System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个实现的问题在于它依赖 String . matches 方法。虽然 String.matches 方法最易于查看一个字符串是否与正则表达式相匹配 ， 但并不适合在注重性能的情形中重复使用 。 问 题在于 ， 它在 内部为正则表达式创建了一个 Pattern 实例，却只用了一次，之后就可以进 行垃圾回收了 。 创建 Pattern 实例的成本很高 ，因为需要将正则表达式编译成一个有限状 态机（ finite state machine ） 。</p><p>为了提升性能，应该显式地将正则表达式编译成一个 Pattern 实例（不可变），让它成 为类初始化的一部分，并将它缓存起来，每当调用 isRomanNumeral 方法的时候就重用同 一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item6;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">// Reusing expensive object for improved performance (Pages 22 and 23)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RomanNumerals</span> </span>&#123;<br>    <span class="hljs-comment">// Performance can be greatly improved! (Page 22)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRomanNumeralSlow</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.matches(<span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>                + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Reusing expensive object for improved performance (Page 23)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Pattern ROMAN = Pattern.compile(<br>            <span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>                    + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRomanNumeralFast</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ROMAN.matcher(s).matches();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> numSets = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> numReps = Integer.parseInt(args[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numSets; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numReps; j++) &#123;<br>                b ^= isRomanNumeralSlow(<span class="hljs-string">&quot;MCMLXXVI&quot;</span>);  <span class="hljs-comment">// Change Slow to Fast to see performance difference</span><br>            &#125;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println(((end - start) / (<span class="hljs-number">1_000.</span> * numReps)) + <span class="hljs-string">&quot; μs.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Prevents VM from optimizing away everything.</span><br>        <span class="hljs-keyword">if</span> (!b)<br>            System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进后的 isRomanNumeral 方法如果被频繁地调用，会显示出明显的性能优势。 在我的机器上，原来的版本在一个 8 字符 的输入字符串上花了 1.1 川，而改进后的版本只花了 0.17 µs ，速度快了 6.5 倍。 除了提高性能之外，可以说代码也更清晰了 。 将不可见的 Pattern 实例做成 final 静态域时，可以给它起个名字，这样会比正则表达式本身更有可读性。</p><p>如果包含改进后的工 sRomanNumeral 方法的类被初始化了，但是该方法没有被调用，那就没必要初始化 ROMAN 域。通过在 isRomanNumeral 方法第一次被调用的时候延迟初始化（ lazily initializing) （ 详见第 83 条）这个域，有可能消除这个不必要 的初始化工作，但 是不 建议这样做。 正如延迟初始化中常见的情况一样，这样做会使方法的实现更加复杂，从 而无法将性能显著提高到超过已 经达到的水平（详见第 67 条） 。</p><p>如果一个对象是不变的，那么它显然能够被安全地重用，但其他有些情形则并不总是 这么明显 。 考虑适配器（ adapter ）的情形［ Gamma95 ］ ，有时也叫作视图（ view ） 。 适配器是 指这样一个对象 ： 它把功能委托给一个后备对象（ backing object ），从而为后备对象提供一 个可以替代的接口 。 由于适配器除了后备对象之外， 没有其他的状态信息，所以针对某个给 定对象的特定适配器而言，它不需要创建多个适配器实例 。</p><p>例如 ，Map 接口 的 keySet 方法返回该 Map 对象的 Set 视图，其 中包含该 Map 中所有的键（ key ） 。 乍看之下 ，好像每次调用 keySet 都应该创建一个新 的 Set 实例，但是， 对于一个给定的 Map 对象，实际上每次调用 keySe t 都返回同样的 Set 实例 。 虽然被返回 的 Set 实例一般是可改变的，但是所有返回的对象在功能上是等同的 ： 当其中一个返回对 象发生变化的时候，所有其他的返回对象也要发生变化，因为它们是由 同一个 Map 实例支 撑的 。 虽然创建 key Set 视图对象的多个实例并无害处， 却是没有必要，也没有好处的。</p><p>另一种创建多余对象的方法，称作自动装箱（ autoboxing ），它允许程序员将基本类型和 装箱基本类型（ Boxed Primitive Type ）混用，按需要自动装箱和拆箱 。 自动装箱使得基本类 型和装箱基本类型之间的差别变得模糊起来， 但是并没有完全消除 。 它们在语义上还有着微妙的差别，在性能上也有着比较明显的差别（详见第 61 条） 。 请看下面的程序，它计算所有 int 正整数值的总和 。 为此，程序必须使用 long 算法，因为 int 不够大，无法容纳所有 int 正整数值的总和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item6;<br><br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-comment">// Hideously slow program! Can you spot the object creation? (Page 24)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>&#123;<br>        Long sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt;= Integer.MAX_VALUE; i++)<br>            sum += i;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> numSets = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">long</span> x = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numSets; i++) &#123;<br>            <span class="hljs-keyword">long</span> start = System.nanoTime();<br>            x += sum();<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println((end - start) / <span class="hljs-number">1_000_000.</span> + <span class="hljs-string">&quot; ms.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Prevents VM from optimizing away everything.</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">42</span>)<br>            System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序算出的答案是正确的，但是比实际情况要更慢一些，只因为打错了一个字 符 。 变量 sum 被声明成 Long 而不是 long ，意味着程序构造了大约 231 个多余的 Long 实 例（大约每次往 Long sum 中增加 long 时构造一个实例） 。 将 sum 的声明从 Long 改成 long ，在我的机器上使运行时间从 6.3 秒减少到了 0 . 59 秒。 结论很明显 ： 要优先使用 基本 类型而不是装箱基本类型，要当心无意识的自动装箱。</p><p>不要错误地认为本条目所介绍的内容暗示着“创建对象的代价非常昂贵，我们应该要 尽可能地避免创建对象” 。 相反，由于小对象的构造器只做很少量的显式工作，所以小对象 的创建和回收动作是非常廉价的，特别是在现代的 JVM 实现上更是如此。 通过创建附加的 对象，提升程序的清晰性、简洁性和功能性，这通常是件好事 。</p><p>反之，通过维护自己的对象池（ object pool ）来避免创建对象并不是一种好的做法，除 非池中的对象是非常重量级的 。 正确使用对象池的典型对象示例就是数据库连接池。 建立数 据库连接的代价是非常昂贵的，因此重用这些对象非常有意义 。 而且，数据库的许可可能限制你只能使用一定数量的连接 。 但是，一般而言，维护自己的对象池必定会把代码弄得很乱，同时增加内存占用（ footprint ），并且还会损害性能 。 现代的 JVM 实现具有高度优化的垃圾回收器，其性能很容易就会超过轻量级对象池的性能 。</p><p>与本条目对应的是第 50 条中有关“保护性拷贝”（ defensive copying ）的内容 。 本条目 提及“当你应该重用现有对象的时候，请不要创建新的对象”,而第50条则说“当你应该创建新对象的时候，请不要重用现有的对象” 。 注意，在提倡使用保护性拷贝的时候，因重用 对象而付出的代价要远远大于因创建重复对象而付出的代价 。 必要时如果没能实施保护性拷贝，将会导致潜在的 Bug 和安全漏洞；而不必要地创建对象则只会影响程序的风格和性能。</p><h2 id="第七条-消除过期对象的引用"><a href="#第七条-消除过期对象的引用" class="headerlink" title="第七条 消除过期对象的引用"></a>第七条 消除过期对象的引用</h2><p>当你从手工管理内存的语言（比如 C 或 C＋＋）转换到具有垃圾回收功能的比如 Java 语言时，程序员的工作会变得更加容易，因为当你用完了对象之后，它们会被自动回收。 当你 第一次经历对象回收功能的时候，会觉得这简直有点不可思议。 它很容易给你留下这样的印 象， 认为自己不再需要考虑内存管理的事情了，其实不然。</p><p>请看下面这个简单的战实现的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item7;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">// Can you spot the &quot;memory leak&quot;?  (Pages 26-27)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] elements;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stack</span><span class="hljs-params">()</span> </span>&#123;<br>        elements = <span class="hljs-keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Object e)</span> </span>&#123;<br>        ensureCapacity();<br>        elements[size++] = e;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();<br>        <span class="hljs-keyword">return</span> elements[--size];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Ensure space for at least one more element, roughly</span><br><span class="hljs-comment">     * doubling the capacity each time the array needs to grow.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (elements.length == size)<br>            elements = Arrays.copyOf(elements, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-comment">//    // Corrected version of pop method (Page 27)</span><br><span class="hljs-comment">//    public Object pop() &#123;</span><br><span class="hljs-comment">//        if (size == 0)</span><br><span class="hljs-comment">//            throw new EmptyStackException();</span><br><span class="hljs-comment">//        Object result = elements[--size];</span><br><span class="hljs-comment">//        elements[size] = null; // Eliminate obsolete reference</span><br><span class="hljs-comment">//        return result;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stack stack = <span class="hljs-keyword">new</span> Stack();<br>        <span class="hljs-keyword">for</span> (String arg : args)<br>            stack.push(arg);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)<br>            System.err.println(stack.pop());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序（它的泛型版本请见第 29 条）中并没有很 明显的错误。 无论如何测试，它都 会成功地通过每一项测试，但是这个程序中隐藏着一个问题。 不严格地讲，这段程序有一个 “内存泄漏”，随着垃圾回收器活动的增加，或者由于内存占用的不断增加，程序性能的降低 会逐渐表现出来 。 在极端的情况下，这种内存泄漏会导致磁盘交换（ Disk Paging ），甚至导 致程序失败（ OutOfMemoryError 错误），但是这种失败情形相对比较少见。</p><p>那么，程序中哪里发生了内存泄漏呢？ 如果一个战先是增长 ，然后再收缩 ， 那么，从 校中弹出来的对象将不会被当作垃圾回收，即使使用校的程序不再引用这些对象，它们也 不会被回收。 这是因为校内部维护着对这些对象的过期引用 （ obsolete reference ） 。 所谓的过 期引用，是指永远也不会再被解除的引用 。 在本例中，凡是在 elements 数组的“活动部分” (active portion ）之外的任何引用都是过期的 。 活动部分是指 elements 中下标小于 size 的那 些元素 。</p><p>在支持垃圾回收的语言中，内存泄漏是很隐蔽的（称这类内存泄漏为“无意识的对象保持”（ unintentional object retention ）更为恰当） 。 如果一个对象引用被无意识地保留起来了， 那么垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对 象 。 即使只有少量的几个对象引用被无意识地保留下来，也会有许许多多的对象被排除在垃 圾回收机制之外，从而对性能造成潜在的重大影响 。</p><p>这类问题的修复方法很简单 ： 一旦对象引用已经过期，只需清空这些引用即可 。 对于 上述例子中的 Stack 类而言，只要一个单元被弹出拢，指向它的引用就过期了 。 pop 方法 的修订版本如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//    // Corrected version of pop method (Page 27)</span><br><span class="hljs-comment">//    public Object pop() &#123;</span><br><span class="hljs-comment">//        if (size == 0)</span><br><span class="hljs-comment">//            throw new EmptyStackException();</span><br><span class="hljs-comment">//        Object result = elements[--size];</span><br><span class="hljs-comment">//        elements[size] = null; // Eliminate obsolete reference</span><br><span class="hljs-comment">//        return result;</span><br><span class="hljs-comment">//    &#125;</span><br></code></pre></td></tr></table></figure><p>清空过期引用的另一个好处是，如果它们以后又被错误地解除引用，程序就会立即抛出 Null Po 工nterException 异常，而不是悄悄地错误运行下去 。 尽快地检测出程序中的错误总是有益的 。</p><p>当程序员第一次被类似这样的问题困扰的时候，他们往往会过分小心 ： 对于每一个对象 引用，一旦程序不再用到它，就把它清空 。 其实这样做既没必要，也不是我们所期望的，因 为这样做会把程序代码弄得很乱。 清空对象引用应该是一种例外 ， 而不是一种规范行为 。 消 除过期引用最好的方法是让包含该引用的变量结束其生命周期 。 如果你是在最紧凑的作用域 范围内定义每一个变量（详见第 57 条），这种情形就会自然而然地发生 。</p><p>那么，何时应该清空引用呢？ Stack 类的哪方面特性使它易于遭受 内存泄漏的影响呢？ 简而言之，问题在于， Stack 类自己管理内存。 存储池（ storage pool ）包含了 elements 数 组（对象引用单元，而不是对象本身）的元素 。 数组活动区域（同前面的定义）中的元素是 己分配的（ allocated ），而数组其余部分的元素则是自由的（ free ） 。 但是垃圾回收器并不知道 这一点；对于垃圾回收器而言， elements 数组中的所有对象引用都同等有效 。 只有程序员知 道数组的非活动部分是不重要的 。 程序员可以把这个情况告知垃圾回收器，做法很简单：一 旦数组元素变成了非活动部分的一部分，程序员就手工清空这些数组元素 。</p><p>一般来说 ， 只要类是自己管理内存，程序员就应该警惕内存泄漏问题。 一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空。</p><p>内存泄漏的另一个常见来源是缓存。 一旦你把对象引用放到缓存中，它就很容易被遗忘掉，从而使得它不再有用之后很长一段时间内仍然留在缓存中 。 对于这个问题，有几种可能的解决方案 。 如果你正好要实现这样的缓存：只要在缓存之外存在对某个项的键的引用， 该项就有意义，那么就可以用 WeakHashMap 代表缓存；当缓存中的项过期之后，它们就会自动被删除。 记住只有当所要的缓存项的生命周期是由该键的外部引用而不是由值决定时，WeakHashMap 才有用处。</p><p>更为常见的情形则是，“缓存项的生命周期是否有意义”并不是很容易确定，随着时间 的推移，其中的项会变得越来越没有价值。 在这种情况下，缓存应该时不时地清除掉没用的 项 。 这项清除工作可以由一个后台线程 （ 可能是 ScheduledThreadPoolExecutor ）来 完成，或者也可以在给缓存添加新条目的时候顺便进行清理。 LinkedHashMap 类利用它 的 removeEldestEntry 方法可以很容易地实现后一种方案 。 对于更加复杂的缓存，必须直接使用 java.lang.ref。</p><p>内存泄漏的第三个常见来源是监昕器和其他回调 。 如果你实现了一个 API，客户端在 这个 API 中注册回调，却没有显式地取消注册，那么除非你采取某些动作，否则它们就会 不断地堆积起来 。 确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用 （ weak reference ） ，例如，只将它们保存成 WeakHashMap 中的键。</p><p>由于内存泄漏通常不会表现成明显的失败，所以它们可以在一个系统中存在很多年。 往往只有通过仔细检查代码，或者借助于 Heap 剖析工具（ Heap Profiler ）才能发现内存泄漏问题。 因此，如果能够在内存泄漏发生之前就知道如何预测此类问题，并阻止它们发生，那是最好不过的了 。</p><h2 id="第八条-避免使用终结方法和清除方法"><a href="#第八条-避免使用终结方法和清除方法" class="headerlink" title="第八条 避免使用终结方法和清除方法"></a>第八条 避免使用终结方法和清除方法</h2><p>终结方法（ finalize「）通常是不可预测的，也是很危险的，一般情况下是不必要的 。 使 用终结方法会导致行为不稳定 、 性能降低，以及可移植性问题。 当然，终结方法也有其可用 之处，我们将在本条目的最后再做介绍；但是根据经验，应该避免使用终结方法 。 在 Java 9 中用清除方法（ cleaner ）代替了终结方法。 清除方法没有终结方法那么危险，但仍然是不可 预测、运行缓慢，一般情况下也是不必要的 。</p><p>C＋＋的程序员被告知“不要把终结方法当作是 C＋＋中析构器（ destructors ）的对应物” 。 在 C＋＋中，析构器是回收一个对象所占用资源的常规方法，是构造器所必需的对应物 。 在 Java 中，当一个对象变得不可到达的时候，垃圾回收器会回收与该对象相关联的存储空间， 并不需要程序员做专 门 的工作 。 C＋＋的析构器也可以被用来回收其他的非内存资源。 而在 Java 中，一般用 try-fi口ally 块来完成类似的工作（详见第 9 条） 。</p><p>终结方法和清除方法的缺点在于不能保证会被及时执行 ［ JLS . 12.6 ］。 从一个对象变得 不可到达开始，到它的终结方法被执行，所花费的这段时间是任意长的 。 这意味着， 注重时间（ time-critical ）的任务不应该由终结方法或者清除方法来完成。 例如，用终结方法或者清除方法来关闭已经打开的文件，就是一个严重的错误，因为打开文件的描述符是一种很有限的资源 。 如果系统元法及时运行终结方法或者清除方法就会导致大量的文件仍然保留在打开状态，于是当一个程序再也不能打开文件的时候，它可能会运行失败。</p><p>及时地执行终结方法和清除方法正是垃圾回收算法的一个主要功能，这种算法在不同 的 JVM 实现中会大相径庭。 如果程序依赖于终结方法或者清除方法被执行的时间点，那么这个程序的行为在不同的 JVM 中运行的表现可能就会截然不同 。 一个程序在你测试用的 JVM 平台上运行得非常好，而在你最重要顾客的 JVM 平台上却根本无法运行，这是完全有可能的 。</p><p>延迟终结过程并不只是一个理论问题。 在很少见的情况下，为类提供终结方法，可能会随意地延迟其实例的回收过程。 一位同事最近在调试一个长期运行的 GUI 应用程序的时候，该应用程序莫名其妙地出现 OutOfMemoryError 错误而死掉 。 分析表明，该应用程序死掉的时候，其终结方法队列中有数千个图形对象正在等待被终结和回收 。 遗憾的是，终结方法线程的优先级比该应用程序的其他线程的优先级要低得多，所以，图形对象的终结速度达不到它们进入队列的速度 。 Java语言规范并不保证哪个线程将会执行终结方法，所以， 除了不使用终结方法之外，并没有很轻便的办法能够避免这样的问题。 在这方面，清除方法比终结方法稍好一些，因为类的设计者可以控制自己的清除线程， 但清除方法仍然在后台运行，处于垃圾回收器的控制之下，因此不能确保及时清除。</p><p>Java 语言规范不仅不保证终结方法或者清除方法会被及时地执行，而且根本就不保证 它们会被执行 。 当一个程序终止的时候，某些已经无法访问的对象上的终结方法却根本没有 被执行，这是完全有可能的 。 结论是： 永远不应该依赖终结方法或者清除方法来更新重要的 持久状态。 例如，依赖终结方法或者清除方法来释放共享资源（比如数据库）上的永久锁， 这很容易让整个分布式系统垮掉。</p><p>不要被 System . gc 和 System.runFinalization 这两个方法所诱惑，它们确实增加了终结方法或者清除方法被执行的机会，但是它们并不保证终结方法或者清除方法一定会被执行。 唯一声称保证它们会被执行的两个方法是 System . runFinal 工 zersOnExit, 及其臭名昭著的孪生兄弟 Runtime . runFinalizersOnExit 。 这两个方法都有致命的缺 陷，井且已经被废弃很久了［ ThreadStop ］ 。</p><p>使用终结方法的另一个问题是：如果忽略在终结过程中被抛出来的未被捕获的异常，该 对象的终结过程也会终止 ［ JLS, 12 . 6 ］ 。 未被捕获的异常会使对象处于破坏的状态（ corrupt state ），如果另 一个线程企图使用这种被破坏的对象，则可能发生任何不确定的行为 。 正常 情况下，未被捕获的异常将会使线程终止，并打印出战轨迹（ Stack Trace ），但是，如果异常 发生在终结方法之中，则不会如此，甚至连警告都不会打印出来 。 清除方法没有这个问题， 因为使用清除方法的一个类库在控制它的线程 。</p><p>使用终结方法和清除方法有一个非常严重的性能损失 。 在我的机器上，创建一个简单 的 AutoCloseable 对象，用 try-with-resources 将它关闭，再让垃圾回收器将它回 收，完成这些工作花费的时间大约为 12ns 。 增加一个终结方法使时间增加到了 550ns。 换句 话说，用终结方法创建和销毁对象慢了大约 50 倍。 这主要是因为终结方法阻止了有效的垃 圾回收 。 如果用清除方法来清除类的所有实例 ，它的速度 比终结方法会稍微快一些（在我的 机器上大约是每个实例花 500ns ），但如果只是把清除方法作为一道安全网（ safety net ），下面将会介绍，那么清除方法的速度还会更快一些 。 在这种情况下，创建、清除和销毁对象，在我的机器上花了大约 66ns ，这意味着，如果没有使用它，为了确保安全网多花了 5 倍（而 不是 50 倍）的代价 。</p><p>终结方法有一个严重的安全问题： 它们为终结方法攻击（ finalizer attack ） 打开了类的大 门。 终结方法攻击背后的思想很简单：如果从构造器或者它的序列化对等体（ readObject 和 readResolve 方法，详见第 12 章）抛出异常，恶意子类的终结方法就可以在构造了 一 部分的应该已经半途夭折的对象上运行 。 这个终结方法会将对该对象的引用记录在一个静态 域中，阻止它被垃圾回收 。 一旦记录到异常的对象，就可以轻松地在这个对象上调用任何原 本永远不允许在这里出现的方法 。 从构造器抛出的异常，应该足以防止对象继续存在；有了 终结方法的存在，这一点就做不到了 。 这种攻击可能造成致命的后果 。 final 类不会受到终 结方法攻击，因为没有人能够编写出 final 类的恶意子类 。 为了防止非 final 类受到终结方法 攻击 ， 要编写一个空的 final 的 finalize 方法。</p><p>那么，如果类的对象中封装的资源（例如文件或者线程）确实需要终止，应该怎么做 才能不用编写终结方法或者清除方法呢？只需 让类实现 AutoCloseable，并要求其客户端 在每个实例不再需要的时候调用 close 方法，一般是利用 try - with - resources 确保 终止，即使遇到异常也是如此（详见第 9 条） 。 值得提及的一个细节是，该实例必须记录 下自己是否已经被关闭了： close 方法必须在一个私有域中记录下“该对象已经不再有效” 。 如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域，并抛出IllegalStateException 异常 。</p><p>那么终结方法和清除方法有什么好处呢？它们有两种合法用途。 第一种用途是，当资源的所有者忘记调用它的 close 方法时，终结方法或者清除方法可以充当“安全网”。虽然这样做井不能保证终结方法或者清除方法会被及时地运行，但是在客户端无法正常结束操作的情况下，迟一点释放资源总比永远不释放要好。 如果考虑编写这样的安全网终结方法，就要认真考虑清楚，这种保护是否值得付出这样的代价。 有些 Java 类（如 FileinputStream 、FileOutputStream 、ThreadPoolExecutor 和 java.sql.Connection ）都具有能充当安全网的终结方法 。</p><p>清除方法的第二种合理用途与对象的本地对等体（ native peer ）有关。 本地对等体是一 个本地（非 Java 的）对象（ native object ），普通对象通过本地方法（ native method ）委托给 一个本地对象。 因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的 Java 对等体被回收的时候，它不会被回收。 如果本地对等体没有关键资源，并且性能也可以接受的话，那么清除方法或者终结方法正是执行这项任务最合适的工具。 如果本地对等体拥有必须被及时终止的资源，或者性能无法接受，那么该类就应该具有一个 close 方法， 如前所述。</p><p>清除方法的使用有一定的技巧 。 下面以一个简单的 Room 类为例 。 假设房间在收回之前 必须进行清除。 Room 类实现了 AutoCloseable ；它利用清除方法自动清除安全网的过程 只不过是一个实现细节 。 与终结方法不同的是，清除方法不会污染类的公有 API:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item8;<br><br><span class="hljs-keyword">import</span> java.lang.ref.Cleaner;<br><br><span class="hljs-comment">// An autocloseable class using a cleaner as a safety net (Page 32)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AutoCloseable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Cleaner cleaner = Cleaner.create();<br><br>    <span class="hljs-comment">// Resource that requires cleaning. Must not refer to Room!</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> numJunkPiles; <span class="hljs-comment">// Number of junk piles in this room</span><br><br>        State(<span class="hljs-keyword">int</span> numJunkPiles) &#123;<br>            <span class="hljs-keyword">this</span>.numJunkPiles = numJunkPiles;<br>        &#125;<br><br>        <span class="hljs-comment">// Invoked by close method or cleaner</span><br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Cleaning room&quot;</span>);<br>            numJunkPiles = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// The state of this room, shared with our cleanable</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> State state;<br><br>    <span class="hljs-comment">// Our cleanable. Cleans the room when it’s eligible for gc</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Cleaner.Cleanable cleanable;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Room</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numJunkPiles)</span> </span>&#123;<br>        state = <span class="hljs-keyword">new</span> State(numJunkPiles);<br>        cleanable = cleaner.register(<span class="hljs-keyword">this</span>, state);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        cleanable.clean();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内嵌的静态类 State 保存清除方法清除房 间所需的资源 。 在这个例子中，就是 num-JunkPiles 域，表示房间的杂乱度 。 更现实 地说，它可以 是 final 的 long， 包含一个指 向本地对等体的指针。 State 实现了 Runnable 接口，它的 run 方法最多被 Cleanable 调用一次 ，后者是我们在 Room 构造器中用清除器注册 State 实例时获得的 。 以下两种情 况之一会触发 run 方法的调用：通常是通过调用 Room 的 close 方法触发的，后者又调用 了 Cleanable 的清除方法 。 如 果到了 Room 实例应该被垃圾 回收时，客户端还没有调用 close 方法，清除方法就会（希望如此 ）调用 State 的 run 方法。</p><p>关键是 State 实例没有引用它的 Room 实例 。 如果它引用了，会造成循环，阻止 Room实例被垃圾回收 （以及防止被自动清除） 。 因 此 State 必须是一个静态的嵌套类，因为非 静态的嵌套类包含了对其外围实例的引用（详见第 24 条） 。 同样地，也不建议使用 lambda, 因为它们很容易捕捉到对外围对象的引用 。</p><p>如前所述， Room 的清除方法只用作安全网 。 如果客户端将所有的 Room 实例化都包在町with-resource 块中 ，将永远不会请求到自动清除。 用下面这个表现良好的客户端代码示范一下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item8;<br><br><span class="hljs-comment">// Well-behaved client of resource with cleaner safety-net (Page 33)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adult</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (Room myRoom = <span class="hljs-keyword">new</span> Room(<span class="hljs-number">7</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Goodbye&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正如所期待的一样，运行 Adult 程序会打印出 Goodbye ，接着是 Cleaning room。但是下面这个表现糟糕的程序又如何呢？ 哪一个将永远不会清除它 的房间？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item8;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">// Ill-behaved client of resource with cleaner safety-net (Page 33)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teenager</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Room(<span class="hljs-number">99</span>);<br>        System.out.println(<span class="hljs-string">&quot;Peace out&quot;</span>);<br><br>        <span class="hljs-comment">// Uncomment next line and retest behavior, but note that you MUST NOT depend on this behavior!</span><br><span class="hljs-comment">//      System.gc();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能期望打印出 Peac e out ，然后是 Cleaning room ，但是在我 的机器 上，它 没有打印出 Cleaning room ，就退出程序了 。 这就是我们之前提到过的不可预见性 。 Cleaner 规范指出：“清除方法在 System.exit 期间的行为是与实现相关的 。 不确保清 除动作是否会被调用 。 ”虽然规范没有指明，其实对于正常的程序退出也是如此。 在我的机 器上，只要在 Teenager 的 main 方法上添加代码行 System . gc （），就足以让它在退出之前打印出 Cleaning room ，但是不能保证在你的机器上也能看到相同的行为 。</p><p>总而言之，除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用 清除方法，对于在 Java 9 之前的发行版本，则尽量不要使用终结方法。 若使用了终结方法 或者清除方法，则要注意它的不确定性和性能后果。</p><h2 id="第九条-try-with-resources-优先于-try-finally"><a href="#第九条-try-with-resources-优先于-try-finally" class="headerlink" title="第九条 try-with-resources 优先于 try-finally"></a>第九条 try-with-resources 优先于 try-finally</h2><p>Java 类库中包括许多必须通过调用 close 方法来手工关闭的资源。 例如 InputStream 、OutputStream 和 java.sql.Connection 。 客户端经常会忽略资源的关闭 ，造成严重的性能后果也就可想而知了。 虽然这其中的许多资源都是用终结方法作为安全网，但是效果并不理想（详见第 8 条） 。</p><p>根据经验， try -finally 语句是确保资源会被适时关闭的最佳方法，就算发生异常或 者返回也一样 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-finally - No longer the best way to close resources!</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">firstLineOfFile</span><span class="hljs-params">(String path)</span> throw IOException </span>&#123;<br>    Bufferedeader br = <span class="hljs-keyword">new</span> Bufferedeader(<span class="hljs-keyword">new</span> Fileeader(path));<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> br.readerLine().<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这看起来好像也不算太坏，但是如果再添加第二个资源，就会一团糟了 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-finally is ugly when used with more than one resource! (Page 34)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        InputStream in = <span class="hljs-keyword">new</span> FileInputStream(src);<br>        <span class="hljs-keyword">try</span> &#123;<br>            OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(dst);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[BUFFER_SIZE];<br>                <span class="hljs-keyword">int</span> n;<br>                <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>)<br>                    out.write(buf, <span class="hljs-number">0</span>, n);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                out.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            in.close();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这可能令人有点难以置信，不过就算优秀的程序员也会经常犯这样的错误 。 起先，我 曾经在《 Java Puzzlers &gt; [ Bloch05 ］ 第 88 页犯过这个错误，时隔多年竟然没有人发现。 事实上，在 2007 年，close 方法在 Java 类库中有 2/3 都用错了 。</p><p>即使用 try-finally 语句正确地关闭了资源，如前两段代码范例所示，它也存在着些许不足。因为在 try 块和 finally 块中的代码，都会抛出异常。例如在 firstLineOfFile方法中，如果底层的物理设备异常，那么调用 readLine 就会抛出异常，基于同样的原因， 调用 close 也会出现异常 。 在这种情况下，第二个异常完全抹除了第一个异常。 在异常堆 枝轨迹中，完全没有关于第一个异常的记录，这在现实的系统中会导致调试变得非常复杂， 因为通常需要看到第一个异常才能诊断出问题何在 。 虽然可以通过编写代码来禁止第二个异 常，保留第一个异常，但事实上没有人会这么做，因为实现起来太烦琐了 。</p><p>当 Java 7 引人 try-with刊sources 语句时［ JLS, 14.20.3 ］，所有这些问题一下子就全部 解决了 。 要使用这个构造的资源，必须先实现 AutoCloseable 接口，其中包含了单个返 回 void 的 close 方法 。 Java 类库与第三方类库中的许多类和接口，现在都实现或扩展了 AutoCloseable 接口 。 如果编写了 一个类，它代表的是必须被关闭的资源，那么这个类也应该实现 AutoCloseable 。</p><p>以下就是使用 try-with-resources 的第一个范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item9.trywithresources;<br><br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopLine</span> </span>&#123;<br>    <span class="hljs-comment">// try-with-resources - the the best way to close resources!  (Page 35)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">firstLineOfFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<br>                <span class="hljs-keyword">new</span> FileReader(path))) &#123;<br>            <span class="hljs-keyword">return</span> br.readLine();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String path = args[<span class="hljs-number">0</span>];<br>        System.out.println(firstLineOfFile(path));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是使用 try-with-resources 的第二个范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item9.trywithresources;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Copy</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BUFFER_SIZE = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// try-with-resources on multiple resources - short and sweet (Page 35)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">try</span> (InputStream   in = <span class="hljs-keyword">new</span> FileInputStream(src);<br>             OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(dst)) &#123;<br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[BUFFER_SIZE];<br>            <span class="hljs-keyword">int</span> n;<br>            <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>)<br>                out.write(buf, <span class="hljs-number">0</span>, n);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String src = args[<span class="hljs-number">0</span>];<br>        String dst = args[<span class="hljs-number">1</span>];<br>        copy(src, dst);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 try-with-resources 不仅使代码 变得更简洁易懂， 也更容易进行诊断。 以 first LineOfFile 方法为例，如果调用 readLine 和（不可见的） close 方法都抛出异常，后 一个异常就会被禁止，以保留第一个异常。 事实上，为了保留你想要看到的那个异常，即便 多个异常都可以被禁止。 这些被禁止的异常并不是简单地被抛弃了，而是会被打印在堆枝轨 迹中，并注明它们是被禁止的异常 。 通过编程调用 getSuppressed 方法还可以访问到它 们， getsuppres sed 方法也已经添加在 Java 7 的 Throwable 中了 。</p><p>在 try-with-resources 语句中还可以使用 catch 子句，就像在平时的 try -finally 语句中 一样。 这样既可以处理异常，又不需要再套用一层代码 。 下面举一个稍费了点心思的范例，这个 firstLineOfFile 方法没有抛出异常读取，就会返回一个默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> effectivejava.chapter2.item9.trywithresources;<br><br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopLineWithDefault</span> </span>&#123;<br>    <span class="hljs-comment">// try-with-resources with a catch clause  (Page 36)</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">firstLineOfFile</span><span class="hljs-params">(String path, String defaultVal)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<br>                <span class="hljs-keyword">new</span> FileReader(path))) &#123;<br>            <span class="hljs-keyword">return</span> br.readLine();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">return</span> defaultVal;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String path = args[<span class="hljs-number">0</span>];<br>        System.out.println(firstLineOfFile(path, <span class="hljs-string">&quot;Toppy McTopFace&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论很明显 ： 在处理必须关闭的资源时，始终要优先考虑用 try-with-resources ，而不是 用 try-finally 。 这样得到的代码将更加简洁、清晰，产生的异常也更有价值。 有了 try-with-resources 语句，在使用必须关闭的资源时，就能更轻松地正确编写代码了 。 实践证明，这个用 try-finally 是不可能做到的 。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective_Java_5_范型</title>
    <link href="/2021/05/04/Effective-Java-5-%E8%8C%83%E5%9E%8B/"/>
    <url>/2021/05/04/Effective-Java-5-%E8%8C%83%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="28：列表优先于数组"><a href="#28：列表优先于数组" class="headerlink" title="28：列表优先于数组"></a>28：列表优先于数组</h1><p>数组与泛型相比，有两个重要的不同点（奇怪为什么数组要与范型对比，两者在同一层次吗？个人理解应该是<strong>数组的类型</strong>和<strong>范型</strong>比较）：</p><h2 id="第一大区别：数组是协变的"><a href="#第一大区别：数组是协变的" class="headerlink" title="第一大区别：数组是协变的"></a>第一大区别：数组是协变的</h2><p>数组是协变（covariant）的：如果A是B的子类，A[]就是B[]的子类；</p><p>相反</p><p>范型是可变的（incovariant）的：：对于任意两个不同的类型 Type1 和 Type2, List&lt;Type1＞既不是 List&lt;Type2＞ 的子类型，也不是 List&lt;Type2＞的超 类型［JLS, 4.10; Naftalin07, 2.5 J。</p><p>你可能认为，这意味着泛型是有缺陷的，但实际上可以说数组才是有缺陷的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Fails at runtime!</span><br>Object[] objectArray = <span class="hljs-keyword">new</span> Long[<span class="hljs-number">1</span>];<br>objectArray[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;I don&#x27;t fit in&quot;</span>; <span class="hljs-comment">// Throws ArrayStoreException</span><br></code></pre></td></tr></table></figure><p>下面是不合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Won&#x27;t compile!</span><br>List&lt;Object&gt; ol = <span class="hljs-keyword">new</span> ArrayList&lt;Long&gt;(); <span class="hljs-comment">// Incompatible types</span><br>ol.add(<span class="hljs-string">&quot;I don&#x27;t fit in&quot;</span>); <br></code></pre></td></tr></table></figure><p>这其中无论哪一种方法，都不能将 String 放进 Long 容器中，但是利用数组在运行时才能够发现所犯的错误，而利用列表则可以在编译时就发现错误。 </p><h2 id="第二大区别：数组是具体化的"><a href="#第二大区别：数组是具体化的" class="headerlink" title="第二大区别：数组是具体化的"></a>第二大区别：数组是具体化的</h2><p>数组是具体化的（reified)[JLS , 4.7]，因此数组会在运行时知道和强化它们的元素类型。如上所述，如果企图将 String 保存到 Long 数组中，就会得到一个 ArrayStoreException 异常。</p><p>相比之下</p><p>泛型则是通过擦除 (erasure) [ JLS, 4.6 ］来实现的。这意味着，泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用（详见第 26 条），以确保在 Java 5 中平滑过渡到泛型。</p><p>由 于上述这些根本 的 区别 ，因此数组和 泛型不能很好地棍合使用 。 例如，创建泛型、 参数化类型或者类型参数的数组是非法的 3 这些数组创建表达式没有一个是合法 的： new</p><p>List<E>[]、new List<String>[]和 new E[]。 这些在编译时都会导致一个泛型数组创建（ generic array creation ）错误。为什么创建泛型数组是非法的，因为它不是类型安全的。要是它合法，编译器在其他正确的程序中发生的转换就会在运行时失败，并出现一个ClassCastException异常。 这就违背了泛型系统提供的基本保证。</String></E></p><h2 id="第29条-优先考虑范型"><a href="#第29条-优先考虑范型" class="headerlink" title="第29条 优先考虑范型"></a>第29条 优先考虑范型</h2><p>一般来说 ，将集合声明参数化，以及使用 JDK 所提供的泛型方法，这些都不太困难 。编写自己的泛型会比较困难一些，但是值得花些时间去学习如何编写 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><p>这个类应该先被参数化，但是它没有，我们可以在后面将它泛型化（ generify ） 。 换句话说，可以将它参数化，而又不破坏原来非参数化版本的客户端代码。 </p><p>也就是说，客户端必须转换从堆楼里弹出的对象，以及可能在运行时失败的那些转换。 </p><p>将类泛型化的第一步是在它的声明中添加一个或者多个类型参数。 在这个例子中有一个类型参数，它表示堆桔的元素类型，这个参数的名称通常为 E （详见第 68 条） 。</p><p>下一步是用相应的类型参数替换所有的 Object 类型，然后试着编译最终的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><p>通常，你将至少得到 一个错误提示或警告，这个类也不例外 。 幸运的是，这个类只产 生一个错误，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><p>如第 28 条中所述，你不能创建不可具体化的（ non-reifiable ）类型的数组，如 E 。 每当编写用数组支持的泛型时，都会出现这个问题。 解决这个问题有两种方法 。 </p><ul><li>第一种，直接绕 过创建泛型数组的禁令 ： 创建一个 Object 的数组，并将它转换成泛型数组类型 。 现在错误是消除了，但是编译器会产生一条警告。 这种用法是合法的，但（整体上而言）不是类型 安全的：  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```<br>编译器不可能证明你的程序是类型安全的，但是你可以 。 你自己必须确保未受检的转换不会危及程序的类型安全性。 相关的数组（即 elements 变量）保存在一个私有的域中， 永远不会被返回到客户端，或者传给任何其他方法。 这个数组中保存的唯一元素，是传给 push 方法的那些元素，它们的类型为 E ，因此未受检的转换不会有任何危害 。<br><br>一旦你证明了未受检的转换是安全的，就要在尽可能小的 范围中禁止警告（详见第 <span class="hljs-number">27</span> 条） 。 在这种情况下，构造器只包含未受检的数组创建，因此可以在整个构造器中禁止这条警 告。 通过增加一条注解＠ SuppressWarnings 来完成禁止， Stack 能够正确无误地进行编译，你就可以使用它了，无须显式的转换，也无须担心会出现 ClassCastException 异常：<br><br></code></pre></td></tr></table></figure>  <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">-</span> 消除 <span class="hljs-built_in">Stack</span> 中泛型数组创建错误的第二种方法是，将 <span class="hljs-variable">elements</span> 域的类型从 <span class="hljs-built_in">E</span> ［］改 为 <span class="hljs-variable">Object</span> ［］ 。 这么做会得到一条不同的错误：<br></code></pre></td></tr></table></figure>  <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">通过把从数组中获取到的元素由 <span class="hljs-built_in">Object</span> 转换成 E ，可以将这条错误变成一条警告：<br></code></pre></td></tr></table></figure><pre><code>由于 E 是一个不可具体化的 （ non-reifiable ）类型，编译器无法在运行时检验转换。 你还 是可以自己证实未受检的转换是安全的，因此可以禁止该警告。 根据第 27 条的建议，我们只 要在包含未受检转换的任务上禁止警告，而不是在整个 pop 方法上禁止就可以了，方法如下：</code></pre></li></ul><p>这两种消除泛型数组创建的方法，各有所长 。 </p><ul><li><p>第一种方法的可读性更强 ： 数组被声明 为 E ［］类型清楚地表明它只包含 E 实例 。 它也更加简洁 ： 在一个典型的泛型类 中，可以 在 代码中的多个地方读取到该数组；第一种方法只需要转换一次（创建数组的时候），而</p></li><li><p>第二 种方法则是每次读取一个数组元素时都需要转换一次。 因此，第一种方法优先，在实践中也更常用 。 但是，它会导致堆污染（ heap pollution ），详见第 32 条 ： 数组的运行时类型与它的编译时类型不匹配（除非 E 正好是 Object ）。 这使得有些程序员会觉得很不舒服，因而选择第二种方案，虽然堆污染在这种情况下并没有什么危害。</p></li></ul><p>打卡 第29条 优先使用范型</p><ol><li>将代码逻辑拆分为两部分：通用的逻辑和与类型相关的逻辑；<br> 通用逻辑是一些跟参数类型无关的逻辑；<br> 类型相关逻辑，是需要确定类型后才能编写的逻辑。</li><li>如果没有类型相关的逻辑，那么直接完善通用代码即可；</li><li>如果有与类型相关的逻辑，那么就需要考虑这些逻辑是否已有共同的接口实现，如果已有共同的接口实现，可以使用边界限定通配符；</li><li>如果还没有共同的接口，那么需要考虑是否可以抽象出一个通用的接口实现；</li><li>如果无法抽象出通用接口，便不要使用泛型了。</li></ol><p>如果一个类在设计之初没有考虑使用范型，我们可以在后面将它泛型化（generify），并不会破坏原来非参数化版本的代码。 </p><p>编写用数组支持的泛型时：不能创建不可具体化的（ non-reifiable ）类型的数组，如 E[]，解决：</p><ul><li>第一种 绕过创建泛型数组的禁令：创建一个 Object 的数组，并将它转换成泛型数组类型；</li><li>第二种 将E[] 改为 Object[] ，从数组中获取到的元素时，将其由 Object 转换成 E。</li></ul><p>质数生成器流</p><p>暴露即是承诺</p><p>public</p><p>protected 就是告诉别人来继承覆盖他的意思</p><p>Java为什么不能多继承，而能够多实现？</p><p>如果继承两个类里面有相同的方法签名，会导致混乱（调用或者覆盖这个方法的时候调用和覆盖的是哪个类的）。</p><p>接口</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ使用手册</title>
    <link href="/2021/02/28/RabbitMQ%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2021/02/28/RabbitMQ%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ使用手册"><a href="#RabbitMQ使用手册" class="headerlink" title="RabbitMQ使用手册"></a>RabbitMQ使用手册</h1><h2 id="1-六种工作模式"><a href="#1-六种工作模式" class="headerlink" title="1. 六种工作模式"></a>1. 六种工作模式</h2><p>RabbitMQ提供了6种模式：简单模式、工作队列模式、发布与订阅模式、Routing路由模式、Topics主题模式、RPC远程调用模式（远程调用暂不作介绍）；</p><p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p><p><img src="https://i.loli.net/2021/02/28/nRUWEuvYMqOdawZ.png"></p><p><img src="https://i.loli.net/2021/02/28/ZUmrfBKt4d1pHRY.png"></p><h3 id="1-1-Hello-World"><a href="#1-1-Hello-World" class="headerlink" title="1.1. Hello World"></a>1.1. Hello World</h3><h4 id="1-1-1-实例代码"><a href="#1-1-1-实例代码" class="headerlink" title="1.1.1. 实例代码"></a>1.1.1. 实例代码</h4><h5 id="1-1-1-1-生产者代码"><a href="#1-1-1-1-生产者代码" class="headerlink" title="1.1.1.1. 生产者代码"></a>1.1.1.1. 生产者代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;simple_queue&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <br>        <span class="hljs-comment">// 创建连接工厂</span><br>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        <br>        <span class="hljs-comment">// 配置链接参数：</span><br>        <span class="hljs-comment">// 主机地址;默认为 localhost</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        <span class="hljs-comment">// 连接端口;默认为 5672</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">// 虚拟主机名称;默认为 /</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/itcast&quot;</span>);<br>        <span class="hljs-comment">// 连接用户名；默认为guest</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        <span class="hljs-comment">// 连接密码；默认为guest</span><br>        connectionFactory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-comment">// 创建连接</span><br>        Connection connection = connectionFactory.newConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 要发送的信息</span><br>        String message = <span class="hljs-string">&quot;Hello World！&quot;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">         * 参数3：消息其它属性</span><br><span class="hljs-comment">         * 参数4：消息内容</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-1-1-2-消费者代码"><a href="#1-1-1-2-消费者代码" class="headerlink" title="1.1.1.2. 消费者代码"></a>1.1.1.2. 消费者代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionUtil</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        <span class="hljs-comment">//主机地址;默认为 localhost</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        <span class="hljs-comment">//连接端口;默认为 5672</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//虚拟主机名称;默认为 /</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/itcast&quot;</span>);<br>        <span class="hljs-comment">//连接用户名；默认为guest</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;heima&quot;</span>);<br>        <span class="hljs-comment">//连接密码；默认为guest</span><br>        connectionFactory.setPassword(<span class="hljs-string">&quot;heima&quot;</span>);<br><br>        <span class="hljs-comment">//创建连接</span><br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);<br><br>        <span class="hljs-comment">//不关闭资源，应该一直监听消息</span><br>        <span class="hljs-comment">//channel.close();</span><br>        <span class="hljs-comment">//connection.close();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-2-小结"><a href="#1-1-2-小结" class="headerlink" title="1.1.2 小结"></a>1.1.2 小结</h4><p>上述的入门案例中中其实使用的是如下的简单模式：</p><p><img src="https://i.loli.net/2021/02/28/d87OojlgsEFAckW.png"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li></ul><p>在这个入门案例中：</p><ul><li>生产者发送消息<ol><li>生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；</li><li>声明队列并设置属性；如是否排它，是否持久化，是否自动删除；</li><li>将路由键（空字符串）与队列绑定起来；</li><li>发送消息至RabbitMQ Broker；</li><li>关闭信道；</li><li>关闭连接；</li></ol></li><li>消费者接收消息<ol><li>消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker</li><li>向Broker 请求消费相应队列中的消息，设置相应的回调函数；</li><li>等待Broker回应闭关投递响应队列中的消息，消费者接收消息；</li><li>确认（ack，自动确认）接收到的消息；</li><li>RabbitMQ从队列中删除相应已经被确认的消息；</li><li>关闭信道；</li><li>关闭连接；</li></ol></li></ul><p><img src="https://i.loli.net/2021/02/28/TmWPJrKYeE4ifMk.png"></p><h4 id="1-1-3-生产者流转过程"><a href="#1-1-3-生产者流转过程" class="headerlink" title="1.1.3. 生产者流转过程"></a>1.1.3. 生产者流转过程</h4><ol><li>客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。</li><li>客户端调用connection.createChannel方法。此方法开启信道，其包装的channel.open命令发送给Broker,等待channel.basicPublish方法，对应的AMQP命令为Basic.Publish,这个命令包含了content Header 和content Body()。content Header 包含了消息体的属性，例如:投递模式，优先级等，content Body 包含了消息体本身。</li><li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li></ol><p><img src="https://i.loli.net/2021/02/28/WwflMRv6saX9j3J.png"></p><h4 id="1-1-4-消费者流转过程"><a href="#1-1-4-消费者流转过程" class="headerlink" title="1.1.4. 消费者流转过程"></a>1.1.4. 消费者流转过程</h4><ol><li>消费者客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。</li><li>消费者客户端调用connection.createChannel方法。和生产者客户端一样，协议涉及Channel . Open/Open-Ok命令。</li><li>在真正消费之前，消费者客户端需要向Broker 发送Basic.Consume 命令(即调用channel.basicConsume 方法〉将Channel 置为接收模式，之后Broker 回执Basic . Consume - Ok 以告诉消费者客户端准备好消费消息。</li><li>Broker 向消费者客户端推送(Push) 消息，即Basic.Deliver 命令，这个命令和Basic.Publish 命令一样会携带Content Header 和Content Body。</li><li>消费者接收到消息并正确消费之后，向Broker 发送确认，即Basic.Ack 命令。</li><li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li></ol><p><img src="https://i.loli.net/2021/02/28/WtoVAShp6uOZDQ3.png"></p><h3 id="1-2-Work-Queues"><a href="#1-2-Work-Queues" class="headerlink" title="1.2. Work Queues"></a>1.2. Work Queues</h3><h4 id="1-2-1-模式说明"><a href="#1-2-1-模式说明" class="headerlink" title="1.2.1. 模式说明"></a>1.2.1. 模式说明</h4><p><img src="https://i.loli.net/2021/02/28/NbocqvWi4HFf1R3.png" alt="工作队列模式"></p><p><code>Work Queues</code>与入门程序的<code>简单模式</code>相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。</p><p><strong>应用场景</strong>：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。【两个消费者处理相同类型的任务】</p><h4 id="1-2-2-实例代码"><a href="#1-2-2-实例代码" class="headerlink" title="1.2.2. 实例代码"></a>1.2.2. 实例代码</h4><h5 id="1-2-2-1-生产者代码"><a href="#1-2-2-1-生产者代码" class="headerlink" title="1.2.2.1. 生产者代码"></a>1.2.2.1. 生产者代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.example.rabbitmq.util.ConnectionUtil;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;work_queue&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-comment">// 发送信息</span><br>            String message = <span class="hljs-string">&quot;你好；小兔子！work模式--&quot;</span> + i;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">             * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">             * 参数3：消息其它属性</span><br><span class="hljs-comment">             * 参数4：消息内容</span><br><span class="hljs-comment">             */</span><br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-2-2-消费者1代码"><a href="#1-2-2-2-消费者1代码" class="headerlink" title="1.2.2.2. 消费者1代码"></a>1.2.2.2. 消费者1代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.itheima.rabbitmq.util.ConnectionUtil;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//一次只能接收并处理一个消息</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//路由key</span><br>                    System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                    <span class="hljs-comment">//交换机</span><br>                    System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                    <span class="hljs-comment">//消息id</span><br>                    System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                    <span class="hljs-comment">//收到的消息</span><br>                    System.out.println(<span class="hljs-string">&quot;消费者1-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                    <span class="hljs-comment">//确认消息</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.QUEUE_NAME, <span class="hljs-keyword">false</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-2-3-消费者2代码"><a href="#1-2-2-3-消费者2代码" class="headerlink" title="1.2.2.3. 消费者2代码"></a>1.2.2.3. 消费者2代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.itheima.rabbitmq.util.ConnectionUtil;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//一次只能接收并处理一个消息</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//路由key</span><br>                    System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                    <span class="hljs-comment">//交换机</span><br>                    System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                    <span class="hljs-comment">//消息id</span><br>                    System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                    <span class="hljs-comment">//收到的消息</span><br>                    System.out.println(<span class="hljs-string">&quot;消费者2-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                    <span class="hljs-comment">//确认消息</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.QUEUE_NAME, <span class="hljs-keyword">false</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-测试"><a href="#1-2-3-测试" class="headerlink" title="1.2.3. 测试"></a>1.2.3. 测试</h4><p>启动两个消费者，然后再启动生产者发送消息；到IDEA的两个消费者对应的控制台查看是否竞争性的接收到消息。</p><p><img src="https://i.loli.net/2021/02/28/Dvr9hctSOTpi7Nz.png" alt="消费者-1"></p><p><img src="https://i.loli.net/2021/02/28/eTMopACFykIBbwa.png" alt="消费者-2"></p><h4 id="1-2-4-小结"><a href="#1-2-4-小结" class="headerlink" title="1.2.4. 小结"></a>1.2.4. 小结</h4><p>在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是<strong>竞争</strong>的关系。</p><h3 id="1-3-Publish-Subscribe"><a href="#1-3-Publish-Subscribe" class="headerlink" title="1.3. Publish/Subscribe"></a>1.3. Publish/Subscribe</h3><h4 id="1-3-1-模式说明"><a href="#1-3-1-模式说明" class="headerlink" title="1.3.1. 模式说明"></a>1.3.1. 模式说明</h4><p>订阅模式示例图：</p><p><img src="https://i.loli.net/2021/02/28/D5NB8woGhk4cW7J.png" alt="发布订阅模式"></p><p>前面2个案例中，只有3个角色：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分</li></ul><p>而在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>C：消费者，消息的接受者，会一直等待消息到来。</li><li>Queue：消息队列，接收消息、缓存消息。</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>发布订阅模式：<br>1、每个消费者监听自己的队列。<br>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收<br>到消息</p><h4 id="1-3-2-实例代码"><a href="#1-3-2-实例代码" class="headerlink" title="1.3.2. 实例代码"></a>1.3.2. 实例代码</h4><h5 id="1-3-2-1-生产者代码"><a href="#1-3-2-1-生产者代码" class="headerlink" title="1.3.2.1. 生产者代码"></a>1.3.2.1. 生产者代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.itheima.rabbitmq.util.ConnectionUtil;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发布与订阅使用的交换机类型为：fanout</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUT_EXCHAGE = <span class="hljs-string">&quot;fanout_exchange&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUT_QUEUE_1 = <span class="hljs-string">&quot;fanout_queue_1&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUT_QUEUE_2 = <span class="hljs-string">&quot;fanout_queue_2&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明交换机</span><br><span class="hljs-comment">         * 参数1：交换机名称</span><br><span class="hljs-comment">         * 参数2：交换机类型，fanout、topic、direct、headers</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(FANOUT_QUEUE_1, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        channel.queueDeclare(FANOUT_QUEUE_2, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(FANOUT_QUEUE_1, FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>);<br>        channel.queueBind(FANOUT_QUEUE_2, FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">// 发送信息</span><br>            String message = <span class="hljs-string">&quot;你好；小兔子！发布订阅模式--&quot;</span> + i;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">             * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">             * 参数3：消息其它属性</span><br><span class="hljs-comment">             * 参数4：消息内容</span><br><span class="hljs-comment">             */</span><br>            channel.basicPublish(FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-3-2-2-消费者1代码"><a href="#1-3-2-2-消费者1代码" class="headerlink" title="1.3.2.2. 消费者1代码"></a>1.3.2.2. 消费者1代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.itheima.rabbitmq.util.ConnectionUtil;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.FANOUT_QUEUE_1, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.FANOUT_QUEUE_1, Producer.FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者1-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.FANOUT_QUEUE_1, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-3-2-3-消费者2代码"><a href="#1-3-2-3-消费者2代码" class="headerlink" title="1.3.2.3. 消费者2代码"></a>1.3.2.3. 消费者2代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.itheima.rabbitmq.util.ConnectionUtil;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.FANOUT_QUEUE_2, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.FANOUT_QUEUE_2, Producer.FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者2-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.FANOUT_QUEUE_2, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-测试"><a href="#1-3-3-测试" class="headerlink" title="1.3.3. 测试"></a>1.3.3. 测试</h4><p>启动所有消费者，然后使用生产者发送消息；在每个消费者对应的控制台可以查看到生产者发送的所有消息；到达<strong>广播</strong>的效果。</p><p>在执行完测试代码后，其实到RabbitMQ的管理后台找到<code>Exchanges</code>选项卡，点击 <code>fanout_exchange</code> 的交换机，可以查看到如下的绑定：</p><h4 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4. 小结"></a>1.3.4. 小结</h4><p>交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。</p><p><strong>发布订阅模式与工作队列模式的区别</strong></p><p>1、工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。 </p><p>2、发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。</p><p>3、发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机 。</p><h3 id="1-4-Routing"><a href="#1-4-Routing" class="headerlink" title="1.4. Routing"></a>1.4. Routing</h3><h4 id="1-4-1-模式说明"><a href="#1-4-1-模式说明" class="headerlink" title="1.4.1. 模式说明"></a>1.4.1. 模式说明</h4><p>路由模式特点：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><img src="https://i.loli.net/2021/03/01/nQlxGeMLmNTO5KV.png" alt="Routing模式"></p><p>图解：</p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li></ul><h4 id="1-4-2-实例代码"><a href="#1-4-2-实例代码" class="headerlink" title="1.4.2. 实例代码"></a>1.4.2. 实例代码</h4><h5 id="1-4-2-1-生产者代码"><a href="#1-4-2-1-生产者代码" class="headerlink" title="1.4.2.1. 生产者代码"></a>1.4.2.1. 生产者代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 路由模式的交换机类型为：direct</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIRECT_EXCHAGE = <span class="hljs-string">&quot;direct_exchange&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIRECT_QUEUE_INSERT = <span class="hljs-string">&quot;direct_queue_insert&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIRECT_QUEUE_UPDATE = <span class="hljs-string">&quot;direct_queue_update&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明交换机</span><br><span class="hljs-comment">         * 参数1：交换机名称</span><br><span class="hljs-comment">         * 参数2：交换机类型，fanout、topic、direct、headers</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(DIRECT_QUEUE_INSERT, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        channel.queueDeclare(DIRECT_QUEUE_UPDATE, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(DIRECT_QUEUE_INSERT, DIRECT_EXCHAGE, <span class="hljs-string">&quot;insert&quot;</span>);<br>        channel.queueBind(DIRECT_QUEUE_UPDATE, DIRECT_EXCHAGE, <span class="hljs-string">&quot;update&quot;</span>);<br><br>        <span class="hljs-comment">// 发送信息</span><br>        String message = <span class="hljs-string">&quot;新增了商品。路由模式；routing key 为 insert &quot;</span> ;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">         * 参数3：消息其它属性</span><br><span class="hljs-comment">         * 参数4：消息内容</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(DIRECT_EXCHAGE, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 发送信息</span><br>        message = <span class="hljs-string">&quot;修改了商品。路由模式；routing key 为 update&quot;</span> ;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">         * 参数3：消息其它属性</span><br><span class="hljs-comment">         * 参数4：消息内容</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(DIRECT_EXCHAGE, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-4-2-2-消费者1代码"><a href="#1-4-2-2-消费者1代码" class="headerlink" title="1.4.2.2. 消费者1代码"></a>1.4.2.2. 消费者1代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.DIRECT_QUEUE_INSERT, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.DIRECT_QUEUE_INSERT, Producer.DIRECT_EXCHAGE, <span class="hljs-string">&quot;insert&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者1-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.DIRECT_QUEUE_INSERT, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-4-2-3-消费者2代码"><a href="#1-4-2-3-消费者2代码" class="headerlink" title="1.4.2.3. 消费者2代码"></a>1.4.2.3. 消费者2代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.DIRECT_QUEUE_UPDATE, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.DIRECT_QUEUE_UPDATE, Producer.DIRECT_EXCHAGE, <span class="hljs-string">&quot;update&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者2-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.DIRECT_QUEUE_UPDATE, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-3-测试"><a href="#1-4-3-测试" class="headerlink" title="1.4.3. 测试"></a>1.4.3. 测试</h4><p>启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达<strong>按照需要接收</strong>的效果。</p><p>在执行完测试代码后，其实到RabbitMQ的管理后台找到<code>Exchanges</code>选项卡，点击 <code>direct_exchange</code> 的交换机，可以查看到如下的绑定：</p><h4 id="1-4-4-小结"><a href="#1-4-4-小结" class="headerlink" title="1.4.4. 小结"></a>1.4.4. 小结</h4><p>Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。</p><h3 id="1-5-Topics"><a href="#1-5-Topics" class="headerlink" title="1.5. Topics"></a>1.5. Topics</h3><h4 id="1-5-1-模式说明"><a href="#1-5-1-模式说明" class="headerlink" title="1.5.1. 模式说明"></a>1.5.1. 模式说明</h4><p><code>Topic</code>类型与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候<strong>使用通配符</strong>！</p><p>消费者创建队列</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.insert.abc</code> 或者 <code>item.insert</code></p><p><code>item.*</code>：只能匹配<code>item.insert</code></p><p><img src="https://i.loli.net/2021/03/01/AhQovcqJLw1SpP3.png" alt="Topics模式"></p><p><img src="https://i.loli.net/2021/03/01/wi9HnbIEaxlN3hy.png" alt="Topic Exchange"></p><p>图解：</p><ul><li>红色Queue：绑定的是<code>usa.#</code> ，因此凡是以 <code>usa.</code>开头的<code>routing key</code> 都会被匹配到</li><li>黄色Queue：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配</li></ul><h4 id="1-5-2-实例代码"><a href="#1-5-2-实例代码" class="headerlink" title="1.5.2. 实例代码"></a>1.5.2. 实例代码</h4><h5 id="1-5-2-1-生产者代码"><a href="#1-5-2-1-生产者代码" class="headerlink" title="1.5.2.1. 生产者代码"></a>1.5.2.1. 生产者代码</h5><p>使用topic类型的Exchange，发送消息的routing key有3种： <code>item.insert</code>、<code>item.update</code>、<code>item.delete</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通配符Topic的交换机类型为：topic</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_EXCHAGE = <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_QUEUE_1 = <span class="hljs-string">&quot;topic_queue_1&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_QUEUE_2 = <span class="hljs-string">&quot;topic_queue_2&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明交换机</span><br><span class="hljs-comment">         * 参数1：交换机名称</span><br><span class="hljs-comment">         * 参数2：交换机类型，fanout、topic、topic、headers</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);<br><br><br>        <span class="hljs-comment">// 发送信息</span><br>        String message = <span class="hljs-string">&quot;新增了商品。Topic模式；routing key 为 item.insert &quot;</span> ;<br>        channel.basicPublish(TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.insert&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 发送信息</span><br>        message = <span class="hljs-string">&quot;修改了商品。Topic模式；routing key 为 item.update&quot;</span> ;<br>        channel.basicPublish(TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.update&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 发送信息</span><br>        message = <span class="hljs-string">&quot;删除了商品。Topic模式；routing key 为 item.delete&quot;</span> ;<br>        channel.basicPublish(TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.delete&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-5-2-2-消费者1代码"><a href="#1-5-2-2-消费者1代码" class="headerlink" title="1.5.2.2. 消费者1代码"></a>1.5.2.2. 消费者1代码</h5><p>接收两种类型的消息：更新商品和删除商品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.TOPIC_QUEUE_1, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.update&quot;</span>);<br>        channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.delete&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者1-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.TOPIC_QUEUE_1, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-5-2-3-消费者2代码"><a href="#1-5-2-3-消费者2代码" class="headerlink" title="1.5.2.3. 消费者2代码"></a>1.5.2.3. 消费者2代码</h5><p>接收所有类型的消息：新增商品，更新商品和删除商品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.TOPIC_QUEUE_2, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.TOPIC_QUEUE_2, Producer.TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.*&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者2-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.TOPIC_QUEUE_2, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-3-测试"><a href="#1-5-3-测试" class="headerlink" title="1.5.3. 测试"></a>1.5.3. 测试</h4><p>启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达<strong>按照需要接收</strong>的效果；并且这些routing key可以使用通配符。</p><p>在执行完测试代码后，其实到RabbitMQ的管理后台找到<code>Exchanges</code>选项卡，点击 <code>topic_exchange</code> 的交换机，可以查看到如下的绑定：</p><h4 id="1-5-4-小结"><a href="#1-5-4-小结" class="headerlink" title="1.5.4. 小结"></a>1.5.4. 小结</h4><p>Topic主题模式可以实现 <code>Publish/Subscribe发布与订阅模式</code> 和 <code> Routing路由模式</code> 的功能；只是Topic在配置routing key 的时候可以使用通配符，显得更加灵活。</p><h2 id="2-模式总结"><a href="#2-模式总结" class="headerlink" title="2. 模式总结"></a>2. 模式总结</h2><p>RabbitMQ工作模式：<br><strong>1、简单模式 HelloWorld</strong><br>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p><p><strong>2、工作队列模式 Work Queue</strong><br>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p><p><strong>3、发布订阅模式 Publish/subscribe</strong><br>需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列</p><p><strong>4、路由模式 Routing</strong><br>需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p><p><strong>5、通配符模式 Topic</strong><br>需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p><h2 id="可信发布"><a href="#可信发布" class="headerlink" title="可信发布"></a>可信发布</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java开启定时任务</title>
    <link href="/2021/02/27/Java%E5%BC%80%E5%90%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2021/02/27/Java%E5%BC%80%E5%90%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Java开启定时任务"><a href="#Java开启定时任务" class="headerlink" title="Java开启定时任务"></a>Java开启定时任务</h1><p>Java开启定时任务的方式主要有3种：</p><h2 id="使用-ScheduledExcecutorService-实现"><a href="#使用-ScheduledExcecutorService-实现" class="headerlink" title="使用 ScheduledExcecutorService 实现"></a>使用 ScheduledExcecutorService 实现</h2><p>ScheduledExecutorService 是java.util.concurrent种的额一个累, 用于实现定时任务</p><p>它可以: </p><ul><li>通过线程池的方式执行任务</li><li>设定第一次的延迟事件</li><li>提供良好的约定, 设定时间间隔</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Runnable runnable = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span> &#123;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Hello !!&quot;</span>);  <br>        &#125;  <br>    &#125;;  <br>    ScheduledExecutorService service = Executors  <br>            .newSingleThreadScheduledExecutor();  <br>    <span class="hljs-comment">// 第二个参数为首次执行的延时时间，第三个参数为定时执行的间隔时间  </span><br>    service.scheduleAtFixedRate(runnable, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);  <br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="使用Spring的-Scheduled-实现"><a href="#使用Spring的-Scheduled-实现" class="headerlink" title="使用Spring的 @Scheduled 实现"></a>使用Spring的 @Scheduled 实现</h2><h2 id="使用-第三方插件-Quartz实现"><a href="#使用-第三方插件-Quartz实现" class="headerlink" title="使用 第三方插件 Quartz实现"></a>使用 第三方插件 Quartz实现</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Schedule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AMQP协议与RabbitMQ</title>
    <link href="/2021/02/27/AMQP%E5%8D%8F%E8%AE%AE%E4%B8%8ERabbitMQ/"/>
    <url>/2021/02/27/AMQP%E5%8D%8F%E8%AE%AE%E4%B8%8ERabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列的历史"><a href="#消息队列的历史" class="headerlink" title="消息队列的历史"></a>消息队列的历史</h1><p>了解一件事情的来龙去脉，将不会对它感到神秘。让我们来看看消息队列（Message Queue）这项技术的发展历史。</p><p>Message Queue的需求由来已久，80年代最早在金融交易中，高盛等公司采用Teknekron公司的产品，当时的Message queuing软件叫做：the information bus（TIB）。 TIB被电信和通讯公司采用，路透社收购了Teknekron公司。之后，IBM开发了MQSeries，微软开发了Microsoft Message Queue（MSMQ）。这些商业MQ供应商的问题是厂商锁定，价格高昂。2001年，Java Message queuing试图解决锁定和交互性的问题，但对应用来说反而更加麻烦了。</p><p>于是2004年，摩根大通和iMatrix开始着手Advanced Message Queuing Protocol （AMQP）开放标准的开发。2006年，AMQP规范发布。2007年，Rabbit技术公司基于AMQP标准开发的RabbitMQ 1.0 发布。</p><p>目前RabbitMQ的最新版本为3.5.7，基于AMQP 0-9-1。<br>RabbitMQ采用Erlang语言开发。Erlang语言由Ericson设计，专门为开发concurrent和distribution系统的一种语言，在电信领域使用广泛。OTP（Open Telecom Platform）作为Erlang语言的一部分，包含了很多基于Erlang开发的中间件／库／工具，如mnesia／SASL，极大方便了Erlang应用的开发。OTP就类似于Python语言中众多的module，用户借助这些module可以很方便的开发应用。</p><h1 id="AMQP-Messaging的基本概念"><a href="#AMQP-Messaging的基本概念" class="headerlink" title="AMQP Messaging的基本概念"></a>AMQP Messaging的基本概念</h1><ul><li>Broker: 接收和分发消息的应用，RabbitMQ Server就是Message Broker。</li><li>Virtual host: 出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange／queue等。</li><li>Connection: publisher／consumer和broker之间的TCP连接。断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或broker服务出现问题。</li><li>Channel: 如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。</li><li>Exchange: message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</li><li>Queue: 消息最终被送到这里等待consumer取走。一个message可以被同时拷贝到多个queue中。</li><li>Binding: exchange和queue之间的虚拟连接，binding中可以包含routing key。Binding信息被保存到exchange中的查询表中，用于message的分发依据。</li></ul><p><img src="https://i.loli.net/2021/02/27/5kDv8dhiJYEszeI.png" alt="结构图-1"><br><img src="https://i.loli.net/2021/02/27/ny7kZ84qMEs2HeK.png" alt="结构图-2"><br><img src="https://i.loli.net/2021/02/27/VxuLacWmdiYwJZC.png" alt="结构图-3"></p><h1 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者/消费者模型"></a>生产者/消费者模型</h1><p>生产者发送消息到broker server（RabbitMQ）。在Broker内部，用户创建Exchange／Queue，通过Binding规则将两者联系在一起。Exchange分发消息，根据类型／binding的不同分发策略有区别。消息最后来到Queue中，等待消费者取走。</p><h1 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h1><p>Exchange有多种类型，最常用的是Direct／Fanout／Topic三种类型。</p><ul><li><p>Direct （point 2 point 点对点模式）<br>Message中的“routing key”如果和Binding中的“binding key”一致， Direct exchange则将message发到对应的queue中。</p></li><li><p>Fanout （多播模式）<br>每个发到Fanout类型Exchange的message都会分到所有绑定的queue上去。</p></li><li><p>Topic （发布-订阅模式）<br>根据routing key，及通配规则，Topic exchange将分发到目标queue中。</p></li></ul><p>Routing key中可以包含两种通配符，类似于正则表达式：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">“<span class="hljs-comment">#”通配任何零个或多个word</span><br>“*”通配任何单个<span class="hljs-built_in">word</span><br></code></pre></td></tr></table></figure><p>这里也推荐给想要了解RabbitMQ的同学一个网站，<a href="http://tryrabbitmq.com/">http://tryrabbitmq.com</a> ，它提供在线RabbitMQ 模拟器，可以帮助理解Exchange／queue／binding概念。</p><p>至此，我们对于消息队列的发展，RabbitMQ的产生，以及AMQP协议中的重要概念做了一个完整的介绍。</p><p>内容来自友情链接：<a href="https://www.cnblogs.com/frankyou/p/5283539.html">FrankYou</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>AMQP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s入门</title>
    <link href="/2021/02/17/k8s%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/17/k8s%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes概述"><a href="#Kubernetes概述" class="headerlink" title="Kubernetes概述"></a>Kubernetes概述</h1><p>请参考新文档介绍：<a href="http://docs.kubernetes.org.cn/227.html">http://docs.kubernetes.org.cn/227.html</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着（比如用户想让apache一直运行，用户不需要关心怎么去做，Kubernetes会自动去监控，然后去重启，新建，总之，让apache一直提供服务），管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用（就像canary deployments）。</p><p>现在Kubernetes着重于不间断的服务状态（比如web服务器或者缓存服务器）和原生云平台应用（Nosql）,在不久的将来会支持各种生产云平台中的各种服务，例如，分批，工作流，以及传统数据库。</p><p>在Kubenetes中，<strong>所有的容器均在Pod中运行,一个Pod可以承载一个或者多个相关的容器</strong>，在后边的案例中，<strong>同一个Pod中的容器会部署在同一个物理机器上并且能够共享资源</strong>。一个Pod也可以包含O个或者多个磁盘卷组（volumes）,这些卷组将会以目录的形式提供给一个容器，或者被所有Pod中的容器共享，对于用户创建的每个Pod,系统会自动选择那个健康并且有足够容量的机器，然后创建类似容器的容器,当容器创建失败的时候，容器会被node agent自动的重启,这个node agent叫kubelet,但是，如果是Pod失败或者机器，它不会自动的转移并且启动，除非用户定义了 replication controller。</p><p>用户可以自己创建并管理Pod,Kubernetes将这些操作简化为两个操作：基于相同的Pod配置文件部署多个Pod复制品；创建可替代的Pod当一个Pod挂了或者机器挂了的时候。而Kubernetes API中负责来重新启动，迁移等行为的部分叫做“replication controller”，它根据一个模板生成了一个Pod,然后系统就根据用户的需求创建了许多冗余，这些冗余的Pod组成了一个整个应用，或者服务，或者服务中的一层。一旦一个Pod被创建，系统就会不停的监控Pod的健康情况以及Pod所在主机的健康情况，如果这个Pod因为软件原因挂掉了或者所在的机器挂掉了，replication controller 会自动在一个健康的机器上创建一个一摸一样的Pod,来维持原来的Pod冗余状态不变，一个应用的多个Pod可以共享一个机器。</p><p>我们经常需要选中一组Pod，例如，我们要限制一组Pod的某些操作，或者查询某组Pod的状态，作为Kubernetes的基本机制，用户可以给Kubernetes Api中的任何对象贴上一组 key:value的标签，然后，我们就可以通过标签来选择一组相关的Kubernetes Api 对象，然后去执行一些特定的操作，每个资源额外拥有一组（很多） keys 和 values,然后外部的工具可以使用这些keys和vlues值进行对象的检索，这些Map叫做annotations（注释）。</p><p>Kubernetes支持一种特殊的网络模型，Kubernetes创建了一个地址空间，并且不动态的分配端口，它可以允许用户选择任何想使用的端口，为了实现这个功能，它为每个Pod分配IP地址。</p><p>现代互联网应用一般都会包含多层服务构成，比如web前台空间与用来存储键值对的内存服务器以及对应的存储服务，为了更好的服务于这样的架构，Kubernetes提供了服务的抽象，并提供了固定的IP地址和DNS名称，而这些与一系列Pod进行动态关联，这些都通过之前提到的标签进行关联，所以我们可以关联任何我们想关联的Pod，当一个Pod中的容器访问这个地址的时候，这个请求会被转发到本地代理（kube proxy）,每台机器上均有一个本地代理，然后被转发到相应的后端容器。Kubernetes通过一种轮训机制选择相应的后端容器，这些动态的Pod被替换的时候,Kube proxy时刻追踪着，所以，服务的 IP地址（dns名称），从来不变。</p><p>所有Kubernetes中的资源，比如Pod,都通过一个叫URI的东西来区分，这个URI有一个UID,URI的重要组成部分是：对象的类型（比如pod），对象的名字，对象的命名空间，对于特殊的对象类型，在同一个命名空间内，所有的名字都是不同的，在对象只提供名称，不提供命名空间的情况下，这种情况是假定是默认的命名空间。UID是时间和空间上的唯一。</p>]]></content>
    
    
    <categories>
      
      <category>k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2021/02/17/Docker/"/>
    <url>/2021/02/17/Docker/</url>
    
    <content type="html"><![CDATA[<p>Docker</p><p>容器就是将软件打包成标准化单元，以用于开发、交 付和部署。</p><ul><li>Docker是目前最具人气且应用最为广泛的容器管理系统,致力于容器标准化RunC; </li><li>Rocket 没有 Docker 那些为企业用户提供集群系统,他仅仅是一个容器引擎，兼容 Docker 镜像，Rocket 想做的，是 一个更纯粹的业界标准。</li></ul><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p>Linux基金会于2015年6月成立OCI（Open Container Initiative）组 织，旨在围绕 容器格式和运行时制定一个开放的工业化标准。组织一成立便得到了包括谷歌、微软、 亚马逊等厂家支持。 </p><p>runC就是 Docker贡献出来的，按照该开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。</p><blockquote><blockquote><p>在过去两年中随着互联网和容器技术的发展，几乎主要的所有的IT供应商和云服务提 供商都开始采用以容器技术为基础的解决方案，与容器相关的组织也如雨后春笋般增 长。<strong>于是为了确保容器的可迁移性，容器格式和运行时标准的建立就显得尤为重要。</strong> </p></blockquote><blockquote><p>对于用户来说，他们不知道采用什么样的标准来选择适合他们的容器技术。不同厂商依赖不同的系统或云平台，导致用户也被迫过度依赖某厂商的云服务。用户想在云平台上进行迁移，会比较困难。 </p></blockquote><blockquote><p>容器标准化，实际上就是为了解决上述问题。容器标准化的目标，就是规范容器技 术，引导不同厂商向同一方向发展，同时引导用户选择对自己有利的技术，或提供评价的标准。</p></blockquote></blockquote><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>Docker 支持 64 位 CentOS7 以上版本。</p><h3 id="使用官方脚本自动安装"><a href="#使用官方脚本自动安装" class="headerlink" title="使用官方脚本自动安装"></a>使用官方脚本自动安装</h3><p>安装命令如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">curl -fsSL <span class="hljs-keyword">https</span>://<span class="hljs-built_in">get</span>.docker.com | bash -s docker <span class="hljs-comment">--mirror Aliyun</span><br></code></pre></td></tr></table></figure><p>也可以使用国内 daocloud 一键安装命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">curl -sSL http<span class="hljs-variable">s:</span>//<span class="hljs-built_in">get</span>.daocloud.io/docker | <span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/failure01.png" alt="image-20200923112255340"></p><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum remove docker \<br>         docker-client \<br>         docker-client-latest \<br>         docker-common \<br>         docker-latest \<br>         docker-latest-logrotate \<br>         docker-logrotate \<br>         docker-engine<br></code></pre></td></tr></table></figure><h4 id="安装-Docker-Engine-Community"><a href="#安装-Docker-Engine-Community" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h4><h5 id="使用-Docker-仓库进行安装"><a href="#使用-Docker-仓库进行安装" class="headerlink" title="使用 Docker 仓库进行安装"></a>使用 Docker 仓库进行安装</h5><p>在新主机上首次安装 Docker Engine-Community 之前，<strong>需要设置 Docker 仓库</strong>。之后，您可以从仓库安装和更新 Docker。</p><h5 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h5><p>安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum install -y yum-utils \<br> device-mapper-persistent-data \<br> lvm2Docker<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923112733400.png" alt="image-20200923112733400"></p><p>使用以下命令来设置稳定的仓库。</p><h5 id="使用官方源地址（比较慢）"><a href="#使用官方源地址（比较慢）" class="headerlink" title="使用官方源地址（比较慢）"></a>使用官方源地址（比较慢）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum-config-manager \<br>  --add-repo \<br>  https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>可以选择国内的一些源地址：</p><h5 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo yum-config-manager \<br>  --add-repo \<br>  http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo<br></code></pre></td></tr></table></figure><h5 id="清华大学源"><a href="#清华大学源" class="headerlink" title="清华大学源"></a>清华大学源</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo yum-config-manager \<br>  --add-repo \<br>  https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo<br></code></pre></td></tr></table></figure><h5 id="安装-Docker-Engine-Community-1"><a href="#安装-Docker-Engine-Community-1" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h5><p>安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ sudo yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923112842548.png" alt="image-20200923112842548"></p><p><img src="/2021/02/17/Docker/image-20200923113823055.png" alt="image-20200923113823055"></p><p><img src="/2021/02/17/Docker/image-20200923113907279.png" alt="image-20200923113907279"></p><p><img src="/2021/02/17/Docker/image-20200923131322904.png" alt="image-20200923131322904"></p><p><img src="/2021/02/17/Docker/image-20200923131406665.png" alt="image-20200923131406665"></p><p><img src="/2021/02/17/Docker/image-20200923131444071.png" alt="image-20200923131444071"></p><p><img src="/2021/02/17/Docker/image-20200923131523184.png" alt="image-20200923131523184"></p><p>如果提示您接受 GPG 密钥，请选是。</p><blockquote><p><strong>有多个 Docker 仓库吗？</strong></p><p>如果启用了多个 Docker 仓库，则在未在 yum install 或 yum update 命令中指定版本的情况下，进行的安装或更新将始终安装最高版本，这可能不适合您的稳定性需求。</p></blockquote><p>Docker 安装完默认未启动。并且已经创建好 docker 用户组，但该用户组下没有用户。</p><p><strong>要安装特定版本的 Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：</strong></p><p>1、列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。</p><p>$ <strong>yum list</strong> docker-ce –showduplicates <strong>|</strong> <strong>sort</strong> -r</p><p>docker-ce.x86_64  3:18.09.1-3.el7           docker-ce-stable<br>docker-ce.x86_64  3:18.09.0-3.el7           docker-ce-stable<br>docker-ce.x86_64  18.06.1.ce-3.el7           docker-ce-stable<br>docker-ce.x86_64  18.06.0.ce-3.el7           docker-ce-stable</p><p>2、通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ sudo yum install docker-<span class="hljs-keyword">ce</span>-<span class="hljs-symbol">&lt;VERSION_STRING&gt;</span> docker-<span class="hljs-keyword">ce</span>-cli-<span class="hljs-symbol">&lt;VERSION_STRING&gt;</span> containerd.io<br></code></pre></td></tr></table></figure><p>启动 Docker。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo systemctl <span class="hljs-built_in">start</span> docker<br></code></pre></td></tr></table></figure><p>通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo docker <span class="hljs-builtin-name">run</span> hello-world<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923131152241.png" alt="image-20200923131152241"></p><h2 id="Docker的使用"><a href="#Docker的使用" class="headerlink" title="Docker的使用"></a>Docker的使用</h2><h3 id="Docker-Hello-World"><a href="#Docker-Hello-World" class="headerlink" title="Docker Hello World"></a>Docker Hello World</h3><p>Docker 允许你在容器内运行应用程序， 使用 <strong>docker run</strong> 命令来在容器内运行一个应用程序。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run ubuntu:<span class="hljs-number">15</span>.<span class="hljs-number">10</span> /bin/echo <span class="hljs-string">&quot;Hello world&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923133610990.png" alt="image-20200923133610990"></p><p>各个参数解析：</p><ul><li><strong>docker:</strong> Docker 的二进制执行文件。</li><li><strong>run:</strong> 与前面的 docker 组合来运行一个容器。</li><li><strong>ubuntu:15.10</strong> 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li><li><strong>/bin/echo “Hello world”:</strong> 在启动的容器里执行的命令</li></ul><p>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</p><h4 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h4><p>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现**”对话”**的能力：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker run -i -t ubuntu:15.10 /bin/bash</span><br>root<span class="hljs-variable">@a54fb2a26823</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># ll</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923134043254.png" alt="image-20200923134043254"></p><p>各个参数解析：</p><ul><li><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</li><li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</li></ul><p>注意第二行 **root@a54fb2a2682:/#**，此时我们已进入一个 ubuntu15.10 系统的容器</p><p>我们尝试在容器中运行命令 <strong>cat /proc/version</strong>和<strong>ls</strong>分别查看当前系统的版本信息和当前目录下的文件列表</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@a<span class="hljs-number">54</span>fb<span class="hljs-number">2</span>a<span class="hljs-number">2682</span>:/#  cat /proc/version<br><span class="hljs-attribute">Linux</span> version <span class="hljs-number">4</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>-<span class="hljs-number">151</span>-generic (buildd@lgw<span class="hljs-number">01</span>-amd<span class="hljs-number">64</span>-<span class="hljs-number">043</span>) (gcc version <span class="hljs-number">5</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span> <span class="hljs-number">20160609</span> (Ubuntu <span class="hljs-number">5</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>-<span class="hljs-number">6</span>ubuntu<span class="hljs-number">1</span>~<span class="hljs-number">16</span>.<span class="hljs-number">04</span>.<span class="hljs-number">10</span>) ) #<span class="hljs-number">178</span>-Ubuntu SMP Tue Jun <span class="hljs-number">11</span> <span class="hljs-number">08</span>:<span class="hljs-number">30</span>:<span class="hljs-number">22</span> UTC <span class="hljs-number">2019</span><br><span class="hljs-attribute">root</span>@a<span class="hljs-number">54</span>fb<span class="hljs-number">2</span>a<span class="hljs-number">2682</span>:/# ls<br><span class="hljs-attribute">bin</span>  boot  dev  etc  home  lib  lib<span class="hljs-number">64</span>  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br><span class="hljs-attribute">root</span>@a<span class="hljs-number">54</span>fb<span class="hljs-number">2</span>a<span class="hljs-number">2682</span>:/# <br></code></pre></td></tr></table></figure><p>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">root@<span class="hljs-number">0123</span>ce188bd8:/<span class="hljs-comment">#  exit</span><br><span class="hljs-keyword">exit</span><br>[root@bogon ~]<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p>注意第三行中 <strong>root@bogon:~#</strong> 表明我们已经退出了当期的容器，返回到当前的主机中。</p><hr><h4 id="启动容器（后台模式）"><a href="#启动容器（后台模式）" class="headerlink" title="启动容器（后台模式）"></a>启动容器（后台模式）</h4><p>使用以下命令创建一个以进程方式运行的容器</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[root<span class="hljs-title">@bogon</span> ~]# docker run -d ubuntu:<span class="hljs-number">15.10</span> /bin/sh -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="hljs-number">2</span>b<span class="hljs-number">1</span>b<span class="hljs-number">7</span>a<span class="hljs-number">428627</span><span class="hljs-keyword">c</span><span class="hljs-number">51</span>ab<span class="hljs-number">8810</span>d<span class="hljs-number">541</span>d<span class="hljs-number">759</span>f<span class="hljs-number">072</span>b<span class="hljs-number">4</span>fc<span class="hljs-number">75487</span>eed<span class="hljs-number">05812646</span>b<span class="hljs-number">8534</span>a<span class="hljs-number">2</span>fe<span class="hljs-number">63</span><br></code></pre></td></tr></table></figure><p>在输出中，我们没有看到期望的 “hello world”，而是一串长字符</p><p><strong>2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</strong></p><p>这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</p><p>首先，我们需要确认容器有在运行，可以通过 <strong>docker ps</strong> 来查看：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[root<span class="hljs-title">@bogon</span> ~]# docker run -d ubuntu:<span class="hljs-number">15.10</span> /bin/sh -<span class="hljs-keyword">c</span> <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="hljs-number">9021</span><span class="hljs-keyword">c</span><span class="hljs-number">013e892307</span>e<span class="hljs-number">5</span>d<span class="hljs-number">307133471859</span>ee<span class="hljs-number">32</span>d<span class="hljs-number">2621</span>be<span class="hljs-number">02</span>ebf<span class="hljs-number">50</span>fea<span class="hljs-number">11</span>fc<span class="hljs-number">47</span>ba<span class="hljs-number">328</span>bf<br>[root<span class="hljs-title">@bogon</span> ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br><span class="hljs-number">9021</span><span class="hljs-keyword">c</span><span class="hljs-number">013e892</span>        ubuntu:<span class="hljs-number">15.10</span>        <span class="hljs-string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   <span class="hljs-number">14</span> seconds ago      Up <span class="hljs-number">13</span> seconds                           reverent_mclean<br></code></pre></td></tr></table></figure><p>输出详情介绍：</p><p><strong>CONTAINER ID:</strong> 容器 ID。</p><p><strong>IMAGE:</strong> 使用的镜像。</p><p><strong>COMMAND:</strong> 启动容器时运行的命令。</p><p><strong>CREATED:</strong> 容器的创建时间。</p><p><strong>STATUS:</strong> 容器状态。</p><p>状态有7种：</p><ul><li>created（已创建）</li><li>restarting（重启中）</li><li>running（运行中）</li><li>removing（迁移中）</li><li>paused（暂停）</li><li>exited（停止）</li><li>dead（死亡）</li></ul><p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p><p><strong>NAMES:</strong> 自动分配的容器名称。</p><p>在宿主主机内使用 <strong>docker logs</strong> 命令，查看容器内的<strong>标准输出</strong>：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">[root@<span class="hljs-keyword">bogon </span>~]<span class="hljs-comment"># docker logs 9021c013e892</span><br><span class="hljs-keyword">or</span><br><span class="hljs-keyword">[root@bogon </span>~]<span class="hljs-comment"># docker logs reverent_mclean</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923134543278.png" alt="image-20200923134543278"></p><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><p>我们使用 <strong>docker stop</strong> 命令来停止容器：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">[root@<span class="hljs-keyword">bogon </span>~]<span class="hljs-comment"># docker stop 9021c013e892</span><br><span class="hljs-keyword">or</span><br><span class="hljs-keyword">[root@bogon </span>~]<span class="hljs-comment"># docker stop reverent_mclean</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923135322807.png" alt="image-20200923135322807"></p><p>通过 <strong>docker ps</strong> 查看，容器已经停止工作：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker ps</span><br></code></pre></td></tr></table></figure><p>可以看到容器已经不在了。</p><h3 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h3><p>docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923143638273.png" alt="image-20200923143638273"></p><p>可以通过命令 <strong>docker command –help</strong> 更深入的了解指定的 Docker 命令使用方法。</p><p>例如我们要查看 <strong>docker stats</strong> 指令的具体使用方法：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># docker stats --help</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923143738872.png" alt="image-20200923143738872"></p><hr><h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>docker pull ubuntu<br></code></pre></td></tr></table></figure><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923160317710.png" alt="image-20200923160317710"></p><p>参数说明：</p><ul><li><strong>-i</strong>: 交互式操作。</li><li><strong>-t</strong>: 终端。</li><li><strong>ubuntu</strong>: ubuntu 镜像。</li><li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li></ul><p>要退出终端，直接输入 <strong>exit</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@ed<span class="hljs-number">09</span>e<span class="hljs-number">4490</span>c<span class="hljs-number">57</span>:/# exit<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923160444832.png" alt="image-20200923160444832"></p><h4 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h4><p>查看所有的容器命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br></code></pre></td></tr></table></figure><p>点击图片查看大图：</p><p><img src="/2021/02/17/Docker/image-20200923160629468.png" alt="image-20200923160629468"></p><p>使用 docker start 启动一个已停止的容器：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker <span class="hljs-built_in">start</span> cranky_wu<br>or<br><span class="hljs-variable">$</span> docker <span class="hljs-built_in">start</span> <span class="hljs-number">9543463</span>e9df3<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923160941003.png" alt="image-20200923160941003"></p><h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">run</span> -itd <span class="hljs-comment">--name ubuntu-test ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure><p>点击图片查看大图：</p><p><img src="/2021/02/17/Docker/image-20200923161214603.png" alt="image-20200923161214603"></p><p><strong>注：</strong>加了 <strong>-d</strong> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong>（下面会介绍到）。</p><h4 id="停止-重启一个容器"><a href="#停止-重启一个容器" class="headerlink" title="停止/重启一个容器"></a>停止/重启一个容器</h4><p>停止容器的命令如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ docker <span class="hljs-built_in">stop</span> &lt;容器 ID&gt;<br></code></pre></td></tr></table></figure><p>停止的容器可以通过 docker restart 重启：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">$ docker restart <span class="hljs-attribute">&lt;容器 ID&gt;</span><br></code></pre></td></tr></table></figure><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p><ul><li><strong>docker attach</strong></li><li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</li></ul><p><strong>attach 命令</strong></p><p>下面演示了使用 docker attach 命令。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ docker <span class="hljs-built_in">attach</span> d9688f79f608<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923161936136.png" alt="image-20200923161936136"></p><p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p><p><strong>exec 命令</strong></p><p>下面演示了使用 docker exec 命令。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> exec -it d<span class="hljs-number">9688</span>f<span class="hljs-number">79</span>f<span class="hljs-number">608</span> /bin/bash<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923162202160.png" alt="image-20200923162202160"></p><p><strong>注意：</strong> 如果从这个容器退出，不会导致容器的停止，这就是为什么推荐大家使用 <strong>docker exec</strong> 的原因。</p><p>更多参数说明请使用 <strong>docker exec –help</strong> 命令查看。</p><h4 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h4><p><strong>导出容器</strong></p><p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ docker <span class="hljs-keyword">export</span> d9688f79f608 &gt; ubuntu-<span class="hljs-keyword">export</span>-<span class="hljs-keyword">test</span>.tar<br></code></pre></td></tr></table></figure><p>导出容器 d9688f79f608快照到本地文件 ubuntu-export-test.tar。</p><p><img src="/2021/02/17/Docker/image-20200923162709222.png" alt="image-20200923162709222"></p><p>这样将导出容器快照到本地文件。</p><p><strong>导入容器快照</strong></p><p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ cat ubuntu-<span class="hljs-keyword">export</span>-<span class="hljs-keyword">test</span>.tar | docker import - <span class="hljs-keyword">test</span>/ubuntu:v1<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923163032681.png" alt="image-20200923163032681"></p><p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ docker import http:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/exampleimage.tgz example/im</span>agerepo<br></code></pre></td></tr></table></figure><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>删除容器使用 <strong>docker rm</strong> 命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> d9688f79f608<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923163304774.png" alt="image-20200923163304774"></p><p>下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ docker <span class="hljs-built_in">container</span> prune<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200923163412553.png" alt="image-20200923163412553"></p><hr><h3 id="运行一个-web-应用"><a href="#运行一个-web-应用" class="headerlink" title="运行一个 web 应用"></a>运行一个 web 应用</h3><p>前面我们运行的容器并没有一些什么特别的用处。</p><p>接下来让我们尝试使用 docker 构建一个 web 应用程序。</p><p>我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker pull training/webapp  # 载入镜像</span><br>[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker run -d -P training/webapp python app.py</span><br></code></pre></td></tr></table></figure><p>参数说明:</p><ul><li>**-d:**让容器在后台运行。</li><li>**-P:**将容器内部使用的网络端口随机映射到我们使用的主机上。</li></ul><hr><h4 id="查看-WEB-应用容器"><a href="#查看-WEB-应用容器" class="headerlink" title="查看 WEB 应用容器"></a>查看 WEB 应用容器</h4><p>使用 docker ps 来查看我们正在运行的容器：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment">#  docker ps</span><br>CONTAINER ID        IMAGE               COMMAND             ...        PORTS                 <br>d3d5e39ed9d3        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>     ...        0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">32769</span>-&gt;<span class="hljs-number">5000</span>/tcp<br></code></pre></td></tr></table></figure><p>这里多了端口信息。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">PORTS<br><span class="hljs-number">0.0.0.0:32769</span>-&gt;<span class="hljs-number">5000</span>/tcp<br></code></pre></td></tr></table></figure><p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</p><p>这时我们可以通过浏览器访问WEB应用</p><p><img src="https://www.runoob.com/wp-content/uploads/2016/05/docker31.png" alt="img"></p><p>我们也可以通过 -p 参数来设置不一样的端口：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker run -d -p 5000:5000 training/webapp python app.py</span><br></code></pre></td></tr></table></figure><p><strong>docker ps</strong>查看正在运行的容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@bogon ~]<span class="hljs-comment">#  docker ps</span><br>CONTAINER ID        IMAGE                             PORTS                     NAMES<br>bf08b7f2cd89        training<span class="hljs-regexp">/webapp     ...        0.0.0.0:5000-&gt;5000/</span>tcp    wizardly_chandrasekhar<br>d3d5e39ed9d3        training<span class="hljs-regexp">/webapp     ...        0.0.0.0:32769-&gt;5000/</span>tcp   xenodochial_hoov<br></code></pre></td></tr></table></figure><p>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</p><hr><h4 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h4><p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射，<strong>docker</strong> 还提供了另一个快捷方式 <strong>docker port</strong>，使用 <strong>docker port</strong> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p><p>上面我们创建的 web 应用容器 ID 为 <strong>bf08b7f2cd89</strong> 名字为 <strong>wizardly_chandrasekhar</strong>。</p><p>我可以使用 <strong>docker port bf08b7f2cd89</strong> 或 <strong>docker port wizardly_chandrasekhar</strong> 来查看容器端口的映射情况。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker port bf08b7f2cd89</span><br><span class="hljs-number">5000</span>/tcp -&gt; 0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">5000</span><br>[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker port wizardly_chandrasekhar</span><br><span class="hljs-number">5000</span>/tcp -&gt; 0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><hr><h4 id="查看-WEB-应用程序日志"><a href="#查看-WEB-应用程序日志" class="headerlink" title="查看 WEB 应用程序日志"></a>查看 WEB 应用程序日志</h4><p>docker logs [ID或者名字] 可以查看容器内部的标准输出。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[root@bogon ~]</span># docker logs -f bf08b7f2cd89<br> * Running on http://<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">5000</span>/ (Press CTRL+C to quit)<br><span class="hljs-number">192.168.239.1</span> - - <span class="hljs-string">[09/May/2016 16:30:37]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> / HTTP/1.1&quot;</span> <span class="hljs-number">200</span> -<br><span class="hljs-number">192.168.239.1</span> - - <span class="hljs-string">[09/May/2016 16:30:37]</span> <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span> /favicon.ico HTTP/1.1&quot;</span> <span class="hljs-number">404</span> -<br></code></pre></td></tr></table></figure><p><strong>-f:</strong> 让 <strong>docker logs</strong> 像使用 <strong>tail -f</strong> 一样来输出容器内部的标准输出。</p><p>从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。</p><hr><h4 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h4><p>我们还可以使用 docker top 来查看容器内部运行的进程</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">[root@bogon ~]# docker top wizardly_chandrasekhar<br><span class="hljs-function"><span class="hljs-title">UID</span></span>     PID         PPID          ...       TIME                CMD<br><span class="hljs-function"><span class="hljs-title">root</span></span>    <span class="hljs-number">23245</span>       <span class="hljs-number">23228</span>         ...       <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>            python app.py<br></code></pre></td></tr></table></figure><hr><h4 id="检查-WEB-应用程序"><a href="#检查-WEB-应用程序" class="headerlink" title="检查 WEB 应用程序"></a>检查 WEB 应用程序</h4><p>使用 <strong>docker inspect</strong> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@bogon ~</span>]<span class="hljs-meta"># docker inspect wizardly_chandrasekhar</span><br>[<span class="hljs-meta"></span><br><span class="hljs-meta">    &#123;</span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Id&quot;</span>: <span class="hljs-meta-string">&quot;bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85&quot;</span>,</span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Created&quot;</span>: <span class="hljs-meta-string">&quot;2018-09-17T01:41:26.174228707Z&quot;</span>,</span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Path&quot;</span>: <span class="hljs-meta-string">&quot;python&quot;</span>,</span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;Args&quot;</span>: [</span><br><span class="hljs-meta">            <span class="hljs-meta-string">&quot;app.py&quot;</span></span><br><span class="hljs-meta">        </span>],<br>        <span class="hljs-string">&quot;State&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Status&quot;</span>: <span class="hljs-string">&quot;running&quot;</span>,<br>            <span class="hljs-string">&quot;Running&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;Paused&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;Restarting&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;OOMKilled&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;Dead&quot;</span>: <span class="hljs-literal">false</span>,<br>            <span class="hljs-string">&quot;Pid&quot;</span>: <span class="hljs-number">23245</span>,<br>            <span class="hljs-string">&quot;ExitCode&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&quot;Error&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;StartedAt&quot;</span>: <span class="hljs-string">&quot;2018-09-17T01:41:26.494185806Z&quot;</span>,<br>            <span class="hljs-string">&quot;FinishedAt&quot;</span>: <span class="hljs-string">&quot;0001-01-01T00:00:00Z&quot;</span><br>        &#125;,<br>......<br></code></pre></td></tr></table></figure><hr><h4 id="停止-WEB-应用容器"><a href="#停止-WEB-应用容器" class="headerlink" title="停止 WEB 应用容器"></a>停止 WEB 应用容器</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker stop wizardly_chandrasekhar   </span><br>wizardly_chandrasekhar<br></code></pre></td></tr></table></figure><hr><h4 id="重启WEB应用容器"><a href="#重启WEB应用容器" class="headerlink" title="重启WEB应用容器"></a>重启WEB应用容器</h4><p>已经停止的容器，我们可以使用命令 docker start 来启动。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker start wizardly_chandrasekhar</span><br>wizardly_chandrasekhar<br></code></pre></td></tr></table></figure><p>docker ps -l 查询最后一次创建的容器：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#  docker ps -l </span><br><span class="hljs-attribute">CONTAINER</span> ID        IMAGE                             PORTS                     NAMES<br><span class="hljs-attribute">bf08b7f2cd89</span>        training/webapp     ...        <span class="hljs-number">0.0.0.0:5000</span>-&gt;<span class="hljs-number">5000</span>/tcp    wizardly_chandrasekhar<br></code></pre></td></tr></table></figure><p>正在运行的容器，我们可以使用 <strong>docker restart</strong> 命令来重启。</p><hr><h4 id="移除WEB应用容器"><a href="#移除WEB应用容器" class="headerlink" title="移除WEB应用容器"></a>移除WEB应用容器</h4><p>我们可以使用 docker rm 命令来删除不需要的容器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker rm wizardly_chandrasekhar  </span><br>wizardly_chandrasekhar<br></code></pre></td></tr></table></figure><p>删除容器时，容器必须是停止状态，否则会报如下错误</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[root@bogon ~]# docker rm wizardly_chandrasekhar<br><span class="hljs-keyword">Error </span>response from daemon: You cannot remove a running container bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85. Stop the container before attempting removal or force remove<br></code></pre></td></tr></table></figure><h2 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h2><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p><p>下面我们来学习：</p><ul><li>1、管理和使用本地 Docker 主机镜像</li><li>2、创建镜像</li></ul><hr><h3 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h3><p>我们可以使用 <strong>docker images</strong> 来列出<u>本地主机</u>上的镜像。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@bogon ~]<span class="hljs-comment"># docker images           </span><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>ubuntu              14.04               90d5884b1ee0       <span class="hljs-number"> 5 </span>days ago         <span class="hljs-number"> 188 </span>MB<br>php                 5.6                 f40e9e0f10c8       <span class="hljs-number"> 9 </span>days ago          444.8 MB<br>nginx               latest              6f8d099c3adc       <span class="hljs-number"> 12 </span>days ago         182.7 MB<br>mysql               5.6                 f2e8d6c772c0       <span class="hljs-number"> 3 </span>weeks ago         324.6 MB<br>httpd               latest              02ef73cf1bc0       <span class="hljs-number"> 3 </span>weeks ago         194.4 MB<br>ubuntu              15.10               4e3b13c8a266       <span class="hljs-number"> 4 </span>weeks ago         136.3 MB<br>hello-world         latest              690ed74de00f       <span class="hljs-number"> 6 </span>months ago       <span class="hljs-number"> 960 </span>B<br>training/webapp     latest              6fae60ef3446       <span class="hljs-number"> 11 </span>months ago       348.8 MB<br></code></pre></td></tr></table></figure><p>各个选项说明:</p><ul><li><strong>REPOSITORY：</strong>表示镜像的仓库源</li><li><strong>TAG：</strong>镜像的标签</li><li><strong>IMAGE ID：</strong>镜像ID</li><li><strong>CREATED：</strong>镜像创建时间</li><li><strong>SIZE：</strong>镜像大小</li></ul><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p><p>所以，我们如果要使用指定版本为15.10的ubuntu系统镜像来运行容器时，命令如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker run -t -i ubuntu:15.10 /bin/bash </span><br>root<span class="hljs-variable">@d77ccb2e5cca</span><span class="hljs-symbol">:/</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>-i</strong>: 交互式操作。</li><li><strong>-t</strong>: 终端。</li><li><strong>ubuntu:15.10</strong>: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</li><li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li></ul><p>如果要使用版本为 14.04 的 ubuntu 系统镜像来运行容器时，命令如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker run -t -i ubuntu:14.04 /bin/bash </span><br>root<span class="hljs-variable">@39e968165990</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p><hr><h3 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h3><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ldif">[root@bogon ~]<span class="hljs-comment"># docker pull ubuntu:13.10</span><br><span class="hljs-attribute">13.10</span>: Pulling from library/ubuntu<br><span class="hljs-attribute">6599cadaf950</span>: Pull complete <br><span class="hljs-attribute">23eda618d451</span>: Pull complete <br><span class="hljs-attribute">f0be3084efe9</span>: Pull complete <br><span class="hljs-attribute">52de432f084b</span>: Pull complete <br><span class="hljs-attribute">a3ed95caeb02</span>: Pull complete <br><span class="hljs-attribute">Digest</span>: sha256:15b79a6654811c8d992ebacdfbd5152fcf3d165e374e264076aa435214a947a3<br><span class="hljs-attribute">Status</span>: Downloaded newer image for ubuntu:13.10<br></code></pre></td></tr></table></figure><p>下载完成后，我们可以直接使用这个镜像来运行容器。</p><hr><h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <strong><a href="https://hub.docker.com/">https://hub.docker.com/</a></strong></p><p>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta">#  docker search httpd</span><br></code></pre></td></tr></table></figure><p>点击图片查看大图：</p><p><img src="/2021/02/17/Docker/image-20200924234925800.png" alt="image-20200924234925800"></p><p><strong>NAME:</strong> 镜像仓库源的名称</p><p><strong>DESCRIPTION:</strong> 镜像的描述</p><p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p><p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p><p><strong>AUTOMATED:</strong> 自动构建。</p><hr><h3 id="拖取镜像"><a href="#拖取镜像" class="headerlink" title="拖取镜像"></a>拖取镜像</h3><p>我们决定使用上图中的 httpd 官方版本的镜像，使用命令 docker pull 来下载镜像。</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ldif">[root@bogon ~]<span class="hljs-comment"># docker pull httpd</span><br><span class="hljs-attribute">Using default tag</span>: latest<br><span class="hljs-attribute">latest</span>: Pulling from library/httpd<br><span class="hljs-attribute">8b87079b7a06</span>: Pulling fs layer <br><span class="hljs-attribute">a3ed95caeb02</span>: Download complete <br><span class="hljs-attribute">0d62ec9c6a76</span>: Download complete <br><span class="hljs-attribute">a329d50397b9</span>: Download complete <br><span class="hljs-attribute">ea7c1f032b5c</span>: Waiting <br><span class="hljs-attribute">be44112b72c7</span>: Waiting<br></code></pre></td></tr></table></figure><p>下载完成后，我们就可以使用这个镜像了。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker run httpd</span><br></code></pre></td></tr></table></figure><hr><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>镜像删除使用 <strong>docker rmi</strong> 命令，比如我们删除 hello-world 镜像：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>docker rmi hello-world<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200924235639918.png" alt="image-20200924235639918"></p><hr><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p><ul><li>1、从已经创建的容器中更新镜像，并且提交这个镜像</li><li>2、使用 Dockerfile 指令来创建一个新的镜像</li></ul><h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><p>更新镜像之前，我们需要使用镜像来创建一个容器。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker run -t -i ubuntu:15.10 /bin/bash</span><br>root<span class="hljs-variable">@e218edb10161</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p><u>在运行的容器内使用 <strong>apt-get update</strong> 命令进行更新。</u></p><blockquote><p>执行apt-get update 失败，暂时的解决手段：docker run -it <strong>–net=host</strong> ubuntu /bin/bash  通过–net=host 改变容器网络模式解决。</p></blockquote><p>在完成操作之后，输入 exit 命令来退出这个容器。</p><p>此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[root<span class="hljs-title">@bogon</span> ~]# docker commit -m<span class="hljs-operator">=</span><span class="hljs-string">&quot;has update&quot;</span> -a<span class="hljs-operator">=</span><span class="hljs-string">&quot;bogon&quot;</span> e<span class="hljs-number">218</span>edb<span class="hljs-number">10161</span> bogon/ubuntu:v<span class="hljs-number">2</span><br>sha<span class="hljs-number">256</span>:<span class="hljs-number">70</span>bf<span class="hljs-number">1840</span>fd<span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span>d<span class="hljs-number">2</span>d<span class="hljs-number">8</span>ef<span class="hljs-number">0</span>a<span class="hljs-number">42</span>a<span class="hljs-number">817</span>eb<span class="hljs-number">29</span>f<span class="hljs-number">854</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span>af<span class="hljs-number">8</span>f<span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">59</span>fc<span class="hljs-number">03</span>ac<span class="hljs-number">7</span>bdee<span class="hljs-number">9545</span>aff<span class="hljs-number">8</span><br>[root<span class="hljs-title">@bogon</span> ~]# docker commit -m<span class="hljs-operator">=</span><span class="hljs-string">&quot;has update&quot;</span> -a<span class="hljs-operator">=</span><span class="hljs-string">&quot;bogon&quot;</span> e<span class="hljs-number">218</span>edb<span class="hljs-number">10161</span> ubuntu:latest  // 将自己的容器提交更新为Ubuntu最新latest镜像<br></code></pre></td></tr></table></figure><p>各个参数说明：</p><ul><li><strong>-m:</strong> 提交的描述信息</li><li><strong>-a:</strong> 指定镜像作者</li><li><strong>e218edb10161：</strong>容器 ID</li><li><strong>bogon/ubuntu:v2:</strong> 指定要创建的目标镜像名</li></ul><p>我们可以使用 <strong>docker images</strong> 命令来查看我们的新镜像 <strong>bogon/ubuntu:v2</strong>：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@bogon ~]<span class="hljs-comment"># docker images</span><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>bogon/ubuntu       v2                  70bf1840fd7c       <span class="hljs-number"> 15 </span>seconds ago      158.5 MB<br>ubuntu              14.04               90d5884b1ee0       <span class="hljs-number"> 5 </span>days ago         <span class="hljs-number"> 188 </span>MB<br>php                 5.6                 f40e9e0f10c8       <span class="hljs-number"> 9 </span>days ago          444.8 MB<br>nginx               latest              6f8d099c3adc       <span class="hljs-number"> 12 </span>days ago         182.7 MB<br>mysql               5.6                 f2e8d6c772c0       <span class="hljs-number"> 3 </span>weeks ago         324.6 MB<br>httpd               latest              02ef73cf1bc0       <span class="hljs-number"> 3 </span>weeks ago         194.4 MB<br>ubuntu              15.10               4e3b13c8a266       <span class="hljs-number"> 4 </span>weeks ago         136.3 MB<br>hello-world         latest              690ed74de00f       <span class="hljs-number"> 6 </span>months ago       <span class="hljs-number"> 960 </span>B<br>training/webapp     latest              6fae60ef3446       <span class="hljs-number"> 12 </span>months ago       348.8 MB<br></code></pre></td></tr></table></figure><p>使用我们的新镜像 <strong>bogon/ubuntu</strong> 来启动一个容器</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker run -t -i bogon/ubuntu:v2 /bin/bash</span><br>root<span class="hljs-variable">@1a9fbdeb5da3</span><span class="hljs-symbol">:/</span><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>我们使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">[root@bogon ~]<span class="hljs-comment"># cat Dockerfile </span><br><span class="hljs-keyword">FROM</span>    centos:<span class="hljs-number">6.7</span><br><span class="hljs-keyword">MAINTAINER</span>      Fisher <span class="hljs-string">&quot;fisher@sudops.com&quot;</span><br><br><span class="hljs-keyword">RUN</span><span class="bash">     /bin/<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="hljs-keyword">RUN</span><span class="bash">     useradd bogon</span><br><span class="hljs-keyword">RUN</span><span class="bash">     /bin/<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;bogon:123456&#x27;</span> |chpasswd</span><br><span class="hljs-keyword">RUN</span><span class="bash">     /bin/<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="hljs-built_in">local</span></span><br><span class="hljs-keyword">EXPOSE</span>  <span class="hljs-number">22</span><br><span class="hljs-keyword">EXPOSE</span>  <span class="hljs-number">80</span><br><span class="hljs-keyword">CMD</span><span class="bash">     /usr/sbin/sshd -D</span><br></code></pre></td></tr></table></figure><p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p><p>第一条FROM，指定使用哪个镜像源</p><p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</p><p>然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[root@bogon ~]# docker build -t bogon/centos:6.7 .<br>Sending build context <span class="hljs-keyword">to</span> Docker daemon 17.92 kB<br><span class="hljs-keyword">Step</span> 1 : <span class="hljs-keyword">FROM</span> centos:6.7<br> ---&amp;gt; d95b5ca17cc3<br><span class="hljs-keyword">Step</span> 2 : MAINTAINER Fisher <span class="hljs-string">&quot;fisher@sudops.com&quot;</span><br> ---&amp;gt; Using cache<br> ---&amp;gt; 0c92299c6f03<br><span class="hljs-keyword">Step</span> 3 : <span class="hljs-builtin-name">RUN</span> /bin/echo <span class="hljs-string">&#x27;root:123456&#x27;</span> |chpasswd<br> ---&amp;gt; Using cache<br> ---&amp;gt; 0397ce2fbd0a<br><span class="hljs-keyword">Step</span> 4 : <span class="hljs-builtin-name">RUN</span> useradd bogon<br><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>-t</strong> ：指定要创建的目标镜像名</li><li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li></ul><p>使用docker images 查看创建的镜像已经在列表中存在,镜像ID为860c279d2fec</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@bogon ~]<span class="hljs-comment"># docker images </span><br>REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE<br>bogon/centos       6.7                 860c279d2fec        About a minute ago   190.6 MB<br>bogon/ubuntu       v2                  70bf1840fd7c       <span class="hljs-number"> 17 </span>hours ago         158.5 MB<br>ubuntu              14.04               90d5884b1ee0       <span class="hljs-number"> 6 </span>days ago          <span class="hljs-number"> 188 </span>MB<br>php                 5.6                 f40e9e0f10c8       <span class="hljs-number"> 10 </span>days ago          444.8 MB<br>nginx               latest              6f8d099c3adc       <span class="hljs-number"> 12 </span>days ago          182.7 MB<br>mysql               5.6                 f2e8d6c772c0       <span class="hljs-number"> 3 </span>weeks ago          324.6 MB<br>httpd               latest              02ef73cf1bc0       <span class="hljs-number"> 3 </span>weeks ago          194.4 MB<br>ubuntu              15.10               4e3b13c8a266       <span class="hljs-number"> 5 </span>weeks ago          136.3 MB<br>hello-world         latest              690ed74de00f       <span class="hljs-number"> 6 </span>months ago        <span class="hljs-number"> 960 </span>B<br>centos              6.7                 d95b5ca17cc3       <span class="hljs-number"> 6 </span>months ago         190.6 MB<br>training/webapp     latest              6fae60ef3446       <span class="hljs-number"> 12 </span>months ago        348.8 MB<br></code></pre></td></tr></table></figure><p>我们可以使用新的镜像来创建容器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[root@bogon ~]# docker <span class="hljs-builtin-name">run</span> -t -i bogon/centos:6.7  /bin/bash<br>[root@41c28d18b5fb /]# id bogon<br><span class="hljs-attribute">uid</span>=500(bogon) <span class="hljs-attribute">gid</span>=500(bogon) <span class="hljs-attribute">groups</span>=500(bogon)<br></code></pre></td></tr></table></figure><p>从上面看到新镜像已经包含我们创建的用户 bogon。</p><h3 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h3><p>我们可以使用 docker tag 命令，为镜像添加一个新的标签。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker tag 860c279d2fec runoob/centos:dev</span><br></code></pre></td></tr></table></figure><p>docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。</p><p>使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runoob</span>@runoob:~$ docker images<br><span class="hljs-attribute">REPOSITORY</span>          TAG                 IMAGE ID            CREATED             SIZE<br><span class="hljs-attribute">runoob</span>/centos       <span class="hljs-number">6</span>.<span class="hljs-number">7</span>                 <span class="hljs-number">860</span>c<span class="hljs-number">279</span>d<span class="hljs-number">2</span>fec        <span class="hljs-number">5</span> hours ago         <span class="hljs-number">190</span>.<span class="hljs-number">6</span> MB<br><span class="hljs-attribute">runoob</span>/centos       dev                 <span class="hljs-number">860</span>c<span class="hljs-number">279</span>d<span class="hljs-number">2</span>fec        <span class="hljs-number">5</span> hours ago         <span class="hljs-number">190</span>.<span class="hljs-number">6</span> MB<br><span class="hljs-attribute">runoob</span>/ubuntu       v<span class="hljs-number">2</span>                  <span class="hljs-number">70</span>bf<span class="hljs-number">1840</span>fd<span class="hljs-number">7</span>c        <span class="hljs-number">22</span> hours ago        <span class="hljs-number">158</span>.<span class="hljs-number">5</span> MB<br><span class="hljs-attribute">ubuntu</span>              <span class="hljs-number">14</span>.<span class="hljs-number">04</span>               <span class="hljs-number">90</span>d<span class="hljs-number">5884</span>b<span class="hljs-number">1</span>ee<span class="hljs-number">0</span>        <span class="hljs-number">6</span> days ago          <span class="hljs-number">188</span> MB<br><span class="hljs-attribute">php</span>                 <span class="hljs-number">5</span>.<span class="hljs-number">6</span>                 f<span class="hljs-number">40</span>e<span class="hljs-number">9</span>e<span class="hljs-number">0</span>f<span class="hljs-number">10</span>c<span class="hljs-number">8</span>        <span class="hljs-number">10</span> days ago         <span class="hljs-number">444</span>.<span class="hljs-number">8</span> MB<br><span class="hljs-attribute">nginx</span>               latest              <span class="hljs-number">6</span>f<span class="hljs-number">8</span>d<span class="hljs-number">099</span>c<span class="hljs-number">3</span>adc        <span class="hljs-number">13</span> days ago         <span class="hljs-number">182</span>.<span class="hljs-number">7</span> MB<br><span class="hljs-attribute">mysql</span>               <span class="hljs-number">5</span>.<span class="hljs-number">6</span>                 f<span class="hljs-number">2</span>e<span class="hljs-number">8</span>d<span class="hljs-number">6</span>c<span class="hljs-number">772</span>c<span class="hljs-number">0</span>        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">324</span>.<span class="hljs-number">6</span> MB<br><span class="hljs-attribute">httpd</span>               latest              <span class="hljs-number">02</span>ef<span class="hljs-number">73</span>cf<span class="hljs-number">1</span>bc<span class="hljs-number">0</span>        <span class="hljs-number">3</span> weeks ago         <span class="hljs-number">194</span>.<span class="hljs-number">4</span> MB<br><span class="hljs-attribute">ubuntu</span>              <span class="hljs-number">15</span>.<span class="hljs-number">10</span>               <span class="hljs-number">4</span>e<span class="hljs-number">3</span>b<span class="hljs-number">13</span>c<span class="hljs-number">8</span>a<span class="hljs-number">266</span>        <span class="hljs-number">5</span> weeks ago         <span class="hljs-number">136</span>.<span class="hljs-number">3</span> MB<br><span class="hljs-attribute">hello</span>-world         latest              <span class="hljs-number">690</span>ed<span class="hljs-number">74</span>de<span class="hljs-number">00</span>f        <span class="hljs-number">6</span> months ago        <span class="hljs-number">960</span> B<br><span class="hljs-attribute">centos</span>              <span class="hljs-number">6</span>.<span class="hljs-number">7</span>                 d<span class="hljs-number">95</span>b<span class="hljs-number">5</span>ca<span class="hljs-number">17</span>cc<span class="hljs-number">3</span>        <span class="hljs-number">6</span> months ago        <span class="hljs-number">190</span>.<span class="hljs-number">6</span> MB<br><span class="hljs-attribute">training</span>/webapp     latest              <span class="hljs-number">6</span>fae<span class="hljs-number">60</span>ef<span class="hljs-number">3446</span>        <span class="hljs-number">12</span> months ago       <span class="hljs-number">348</span>.<span class="hljs-number">8</span> MB<br></code></pre></td></tr></table></figure><h2 id="Docker-容器连接"><a href="#Docker-容器连接" class="headerlink" title="Docker 容器连接"></a>Docker 容器连接</h2><p>前面我们实现了通过网络端口来访问运行在 docker 容器内的服务。</p><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <strong>-P</strong> 或 <strong>-p</strong> 参数来指定端口映射。</p><p>下面我们来实现通过端口连接到一个 docker 容器。</p><hr><h3 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h3><p>我们创建了一个 python 应用的容器。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[root<span class="hljs-title">@bogon</span> ~]# docker run -d -P httpd<br><span class="hljs-number">0</span>d<span class="hljs-number">5522</span>b<span class="hljs-number">2e0</span>bcd<span class="hljs-number">8</span>f<span class="hljs-number">18</span><span class="hljs-keyword">c</span><span class="hljs-number">078</span>dda<span class="hljs-number">3</span>bde<span class="hljs-number">1</span>d<span class="hljs-number">2</span><span class="hljs-keyword">c</span><span class="hljs-number">6</span>b<span class="hljs-number">53</span><span class="hljs-keyword">c</span><span class="hljs-number">0</span>d<span class="hljs-number">0</span>b<span class="hljs-number">7e6</span>e<span class="hljs-number">366</span>a<span class="hljs-number">7876</span>f<span class="hljs-number">3</span>a<span class="hljs-number">76139925</span><br></code></pre></td></tr></table></figure><p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p><p>我们使用 <strong>-P</strong> 参数创建一个容器，使用 <strong>docker ps</strong> 可以看到<u>容器端口 5000 绑定主机端口 32768</u>。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker ps</span><br>CONTAINER ID        IMAGE               COMMAND                STATUS              PORTS                   NAMES<br>0d5522b2e0bc        httpd               <span class="hljs-string">&quot;httpd-foreground&quot;</span>   Up <span class="hljs-number">5</span> seconds        0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">32768</span>-&gt;<span class="hljs-number">80</span>/tcp   brave_johnson<br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200925001023038.png" alt="image-20200925001023038"></p><p><img src="/2021/02/17/Docker/image-20200925001104501.png" alt="image-20200925001104501"></p><p>我们也可以使用 <strong>-p</strong> 标识来指定容器端口绑定到主机端口。</p><p>两种方式的区别是:</p><ul><li><strong>-P :**是容器内部端口</strong>随机**映射到主机的高端口。</li><li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="hljs-number">33</span>e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0<br>runoob<span class="hljs-variable">@runoob</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>docker ps<br>CONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES<br><span class="hljs-number">33</span>e4523d30aa        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...   0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">5000</span>-&gt;<span class="hljs-number">5000</span>/tcp    berserk_bartik<br>fce072cc88ce        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...   0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">32768</span>-&gt;<span class="hljs-number">5000</span>/tcp   grave_hopper<br></code></pre></td></tr></table></figure><p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="hljs-number">95</span>c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c<br>[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker ps</span><br>CONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES<br><span class="hljs-number">95</span>c6ceef88ca        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...  <span class="hljs-number">5000</span>/tcp, <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-number">5001</span>-&gt;<span class="hljs-number">5000</span>/tcp   adoring_stonebraker<br><span class="hljs-number">33</span>e4523d30aa        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...  0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">5000</span>-&gt;<span class="hljs-number">5000</span>/tcp               berserk_bartik<br>fce072cc88ce        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...    0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">32768</span>-&gt;<span class="hljs-number">5000</span>/tcp              grave_hopper<br></code></pre></td></tr></table></figure><p>这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口。</p><p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <strong>/udp</strong>。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br><span class="hljs-number">6779686</span>f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a<br>[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker ps</span><br>CONTAINER ID        IMAGE               COMMAND           ...   PORTS                                NAMES<br><span class="hljs-number">6779686</span>f06f6        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...   <span class="hljs-number">5000</span>/tcp, <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-number">5000</span>-&gt;<span class="hljs-number">5000</span>/udp   drunk_visvesvaraya<br><span class="hljs-number">95</span>c6ceef88ca        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...    <span class="hljs-number">5000</span>/tcp, <span class="hljs-number">127.0</span>.0.<span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-number">5001</span>-&gt;<span class="hljs-number">5000</span>/tcp   adoring_stonebraker<br><span class="hljs-number">33</span>e4523d30aa        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...     0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">5000</span>-&gt;<span class="hljs-number">5000</span>/tcp               berserk_bartik<br>fce072cc88ce        training/webapp     <span class="hljs-string">&quot;python app.py&quot;</span>   ...    0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">32768</span>-&gt;<span class="hljs-number">5000</span>/tcp              grave_hopper<br></code></pre></td></tr></table></figure><p><strong>docker port</strong> 命令可以让我们快捷地查看端口的绑定情况。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[root@bogon ~]</span># docker port adoring_stonebraker <span class="hljs-number">5000</span><br><span class="hljs-number">127.0.0.1:5001</span><br></code></pre></td></tr></table></figure><hr><h3 id="Docker-容器互联"><a href="#Docker-容器互联" class="headerlink" title="Docker 容器互联"></a>Docker 容器互联</h3><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。</p><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p><p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p><hr><h4 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h4><p>当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 <strong>–name</strong> 标识来命名容器，例如：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> ~]<span class="hljs-meta"># docker run -d -P --name bogon training/webapp python app.py</span><br><span class="hljs-number">43780</span>a6eabaaf14e590b6e849235c75f3012995403f97749775e38436db9a441<br></code></pre></td></tr></table></figure><p>我们可以使用 <strong>docker ps</strong> 命令来查看容器名称。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@bogon</span> ~]<span class="hljs-comment"># docker ps -l</span><br>CONTAINER ID     IMAGE            COMMAND           ...    PORTS                     NAMES<br><span class="hljs-number">43780</span>a6eabaa     training/webapp   <span class="hljs-string">&quot;python app.py&quot;</span>  ...     0.0.0.0<span class="hljs-symbol">:</span><span class="hljs-number">32769</span>-&gt;<span class="hljs-number">5000</span>/tcp   bogon<br></code></pre></td></tr></table></figure><h4 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h4><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker network create <span class="hljs-literal">-d</span> bridge <span class="hljs-built_in">test-net</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/17/Docker/image-20200926215018989.png" alt="image-20200926215018989"></p><p>参数说明：</p><p><strong>-d</strong>：参数指定 Docker 网络类型，有 bridge、overlay。</p><p>其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p><h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>运行一个容器并连接到新建的 test-net 网络:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ docker run -itd <span class="hljs-params">--name</span> test1 <span class="hljs-params">--network</span> test-net ubuntu <span class="hljs-string">/bin/bash</span><br></code></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ docker run -itd <span class="hljs-params">--name</span> test2 <span class="hljs-params">--network</span> test-net ubuntu <span class="hljs-string">/bin/bash</span><br></code></pre></td></tr></table></figure><p>点击图片查看大图：</p><p><img src="/2021/02/17/Docker/image-20200926215317172.png" alt="image-20200926215317172"></p><p>下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。</p><p>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br>apt install iputils-ping<br></code></pre></td></tr></table></figure><blockquote><p>问题：</p><p><img src="/2021/02/17/Docker/image-20200926222424190.png" alt="image-20200926222424190"></p><p>解决手段：</p><ol><li>docker run -it <strong>–net=host</strong> ubuntu /bin/bash  通过–net=host 改变容器网络模式解决。<strong>问题来了容器网络模式是啥？？</strong></li><li>其它的修改 容器DNS的，IP的，先不管怎么搞了</li></ol></blockquote><p>在 test1 容器输入以下命令：</p><p>点击图片查看大图：</p><p><img src="/2021/02/17/Docker/image-20200926225435616.png" alt="image-20200926225435616"></p><p>同理在 test2 容器也会成功连接到:</p><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-net4.png"><img src="https://www.runoob.com/wp-content/uploads/2016/05/docker-net4.png" alt="img"></a></p><p>这样，test1 容器和 test2 容器建立了互联关系。</p><p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose，后面会介绍。</p><hr><h3 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h3><p>我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;dns&quot;</span> : [<br>    <span class="hljs-string">&quot;114.114.114.114&quot;</span>,<br>    <span class="hljs-string">&quot;8.8.8.8&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</p><p>配置完，需要重启 docker 才能生效。</p><p>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ docker <span class="hljs-keyword">run</span> -it --<span class="hljs-keyword">rm</span>  ubuntu  <span class="hljs-keyword">cat</span> etc/resolv.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-net5.png"><img src="https://www.runoob.com/wp-content/uploads/2016/05/docker-net5.png" alt="img"></a></p><p><strong>手动指定容器的配置</strong></p><p>如果只想在指定的容器设置 DNS，则可以使用以下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-builtin-name">run</span> -it --rm -h host_ubuntu  <span class="hljs-attribute">--dns</span>=114.114.114.114 <span class="hljs-attribute">--dns-search</span>=test.com ubuntu<br></code></pre></td></tr></table></figure><p>参数说明：</p><p><strong>–rm</strong>：容器退出时自动清理容器内部的文件系统。</p><p><strong>-h HOSTNAME 或者 –hostname=HOSTNAME</strong>： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</p><p><strong>–dns=IP_ADDRESS</strong>： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p><p><strong>–dns-search=DOMAIN</strong>： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p><p>点击图片查看大图：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/05/docker-net6.png"><img src="https://www.runoob.com/wp-content/uploads/2016/05/docker-net6.png" alt="img"></a></p><p>如果在容器启动时没有指定 <strong>–dns</strong> 和 <strong>–dns-search</strong>，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</p><h2 id="Docker-仓库管理"><a href="#Docker-仓库管理" class="headerlink" title="Docker 仓库管理"></a>Docker 仓库管理</h2><p>仓库（Repository）是集中存放镜像的地方。以下介绍一下 <a href="https://hub.docker.com/">Docker Hub</a>。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>。</p><p>大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>在 <a href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p><h3 id="登录和退出"><a href="#登录和退出" class="headerlink" title="登录和退出"></a>登录和退出</h3><p>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>docker login<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/10/5974B2AE-945F-4DD0-A7C8-9D9B01BDAF62.jpg"><img src="https://www.runoob.com/wp-content/uploads/2019/10/5974B2AE-945F-4DD0-A7C8-9D9B01BDAF62.jpg" alt="img"></a></p><p><strong>退出</strong></p><p>退出 docker hub 可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">logout</span></span><br></code></pre></td></tr></table></figure><p>拉取镜像</p><p>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</p><p>以 ubuntu 为关键词进行搜索：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>docker search ubuntu<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/10/docker-search22.png"><img src="https://www.runoob.com/wp-content/uploads/2019/10/docker-search22.png" alt="img"></a></p><p>使用 docker pull 将官方 ubuntu 镜像下载到本地：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>docker pull ubuntu <br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/10/docker-pull22.png"><img src="https://www.runoob.com/wp-content/uploads/2019/10/docker-pull22.png" alt="img"></a></p><h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 username 请替换为你的 Docker 账号用户名。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ docker <span class="hljs-keyword">tag</span> <span class="hljs-title">ubuntu</span>:<span class="hljs-number">18.04</span> username/ubuntu:<span class="hljs-number">18.04</span><br>$ docker image ls<br><br>REPOSITORY      <span class="hljs-keyword">TAG</span>        <span class="hljs-title">IMAGE</span> ID            CREATED           ...  <br>ubuntu          <span class="hljs-number">18.04</span>      <span class="hljs-number">275</span>d79972a86        <span class="hljs-number">6</span> days ago        ...  <br>username/ubuntu <span class="hljs-number">18.04</span>      <span class="hljs-number">275</span>d79972a86        <span class="hljs-number">6</span> days ago        ...  <br>$ docker push username/ubuntu:<span class="hljs-number">18.04</span><br>$ docker search username/ubuntu<br><br>NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED<br>username/ubuntu<br></code></pre></td></tr></table></figure><h2 id="Docker-Dockerfile"><a href="#Docker-Dockerfile" class="headerlink" title="Docker Dockerfile"></a>Docker Dockerfile</h2><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><h3 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h3><p>这里仅讲解如何运行 Dockerfile 文件来定制一个镜像，具体 Dockerfile 文件内指令详解，将在下一节中介绍，这里你只要知道构建的流程即可。</p><p><strong>1、下面以定制一个 nginx 镜像（构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件）</strong></p><p>在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> nginx<br>RUN echo <span class="hljs-string">&#x27;这是一个本地构建的nginx镜像&#x27;</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html<br></code></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/dockerfile1.png" alt="img"></p><p><strong>2、FROM 和 RUN 指令的作用</strong></p><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p><p>shell 格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">RUN &lt;命令行命令&gt;<br><span class="hljs-comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></code></pre></td></tr></table></figure><p>exec 格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">RUN [<span class="hljs-string">&quot;可执行文件&quot;</span>, <span class="hljs-string">&quot;参数1&quot;</span>, <span class="hljs-string">&quot;参数2&quot;</span>]<br><span class="hljs-comment"># 例如：</span><br><span class="hljs-comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM centos<br>RUN yum install wget<br>RUN wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br>RUN tar -xvf redis.tar.gz<br></code></pre></td></tr></table></figure><p>以上执行会创建 3 层镜像。可简化为以下格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM centos<br>RUN yum install wget \<br>  &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \<br>  &amp;&amp; tar -xvf redis.tar.gz<br></code></pre></td></tr></table></figure><p>如上，以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1 层镜像。</p><h3 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h3><p>在 Dockerfile 文件的存放目录下，执行构建动作。</p><p>以下示例，通过目录下的 Dockerfile 构建一个 nginx:test（镜像名称:镜像标签）。</p><p><strong>注</strong>：最后的 <strong>.</strong> 代表本次执行的上下文路径，下一节会介绍。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker build -t nginx:<span class="hljs-built_in">test</span> .</span><br></code></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2019/11/dockerfile2.png" alt="img"></p><p>以上显示，说明已经构建成功。</p><h3 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h3><p>上一节中，有提到指令最后一个 <strong>.</strong> 是上下文路径，那么什么是上下文路径呢？</p><p>$ docker build -t nginx:test.</p><p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p><p><strong>解析</strong>：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p><p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p><p><strong>注意</strong>：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p><hr><h2 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h2><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bnf">COPY [--chown=<span class="hljs-attribute">&lt;user&gt;</span>:<span class="hljs-attribute">&lt;group&gt;</span>] <span class="hljs-attribute">&lt;源路径1&gt;</span>...  <span class="hljs-attribute">&lt;目标路径&gt;</span><br>COPY [--chown=<span class="hljs-attribute">&lt;user&gt;</span>:<span class="hljs-attribute">&lt;group&gt;</span>] [&quot;<span class="hljs-attribute">&lt;源路径1&gt;</span>&quot;,...  &quot;<span class="hljs-attribute">&lt;目标路径&gt;</span>&quot;]<br></code></pre></td></tr></table></figure><p>**[–chown=<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。</group></user></p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> hom* <span class="hljs-regexp">/mydir/</span><br><span class="hljs-keyword">COPY</span> hom?.txt <span class="hljs-regexp">/mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><ul><li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker <span class="hljs-keyword">run</span><span class="bash">  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nginx -c <span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ docker run  nginx:test -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">nginx -c <span class="hljs-regexp">/etc/</span>nginx/<span class="hljs-keyword">new</span>.conf<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">ENV <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>ENV <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value1</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">value2</span>&gt;</span>...<br></code></pre></td></tr></table></figure><p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> NODE_VERSION <span class="hljs-number">7.2</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/node-v<span class="hljs-variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="bash">  &amp;&amp; curl -SLO <span class="hljs-string">&quot;https://nodejs.org/dist/v<span class="hljs-variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ARG <span class="hljs-attribute">&lt;参数名&gt;</span>[=<span class="hljs-attribute">&lt;默认值&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>仅仅只是声明端口。</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt;<span class="hljs-meta"> [&lt;端口2&gt;...]</span><br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">WORKDIR <span class="hljs-attribute">&lt;工作目录路径&gt;</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">USER <span class="hljs-attribute">&lt;用户名&gt;</span>[:<span class="hljs-attribute">&lt;用户组&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dos">HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt;：设置检查容器健康状况的命令<br>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><br>HEALTHCHECK [选项] <span class="hljs-built_in">CMD</span> &lt;命令&gt; : 这边 <span class="hljs-built_in">CMD</span> 后面跟随的命令使用，可以参考 <span class="hljs-built_in">CMD</span> 的用法。<br></code></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><p>格式：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ONBUILD <span class="hljs-attribute">&lt;其它指令&gt;</span><br></code></pre></td></tr></table></figure><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h3 id="Compose-简介"><a href="#Compose-简介" class="headerlink" title="Compose 简介"></a>Compose 简介</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><p>如果你还不了解 YML 文件配置，可以先阅读 <a href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程</a>。</p><p>Compose 使用的三个步骤：</p><ul><li>使用 Dockerfile 定义应用程序的环境。</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li></ul><p>docker-compose.yml 的配置案例如下（配置参数参考下文）：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p># yaml 配置实例<br>version**:** ‘3’<br>services:<br> web:<br>  build**:** .<br>  ports**:<br>**  - “5000:5000”<br>  volumes**:<br>**  - .:/code<br>  - logvolume01:/var/log<br>  links**:<br>**  - redis<br> redis:<br>  image**:** redis<br>volumes:<br> logvolume01**:** {}</p><hr><h2 id="Compose-安装"><a href="#Compose-安装" class="headerlink" title="Compose 安装"></a>Compose 安装</h2><p>Linux</p><p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：<a href="https://github.com/docker/compose/releases%E3%80%82">https://github.com/docker/compose/releases。</a></p><p>运行以下命令以下载 Docker Compose 的当前稳定版本：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot;</span> -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose<br></code></pre></td></tr></table></figure><p>要安装其他版本的 Compose，请替换 1.24.1。</p><p>将可执行权限应用于二进制文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose<br></code></pre></td></tr></table></figure><p>创建软链：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose <span class="hljs-regexp">/usr/</span>bin/docker-compose<br></code></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker-compose <span class="hljs-comment">--version</span><br>cker-compose <span class="hljs-built_in">version</span> <span class="hljs-number">1.24</span><span class="hljs-number">.1</span>, build <span class="hljs-number">4667896</span>b<br></code></pre></td></tr></table></figure><p><strong>注意</strong>： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。</p><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>Mac 的 Docker 桌面版和 Docker Toolbox 已经包括 Compose 和其他 Docker 应用程序，因此 Mac 用户不需要单独安装 Compose。Docker 安装说明可以参阅 <a href="https://www.runoob.com/docker/macos-docker-install.html">MacOS Docker 安装</a>。</p><h3 id="windows-PC"><a href="#windows-PC" class="headerlink" title="windows PC"></a>windows PC</h3><p>Windows 的 Docker 桌面版和 Docker Toolbox 已经包括 Compose 和其他 Docker 应用程序，因此 Windows 用户不需要单独安装 Compose。Docker 安装说明可以参阅<a href="https://www.runoob.com/docker/windows-docker-install.html"> Windows Docker 安装</a>。</p><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h3><p>创建一个测试目录：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> mkdir composetest<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> composetest<br></code></pre></td></tr></table></figure><p>在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容：</p><h2 id="composetest-app-py-文件代码"><a href="#composetest-app-py-文件代码" class="headerlink" title="composetest/app.py 文件代码"></a>composetest/app.py 文件代码</h2><p><strong>import</strong> time</p><p><strong>import</strong> redis<br><strong>from</strong> flask <strong>import</strong> Flask</p><p>app = Flask(<strong>name</strong>)<br>cache = redis.Redis(host=’redis’, port=6379)</p><p><strong>def</strong> get_hit_count():<br>  retries = 5<br>  <strong>while</strong> True:<br>    <strong>try</strong>:<br>      <strong>return</strong> cache.incr(‘hits’)<br>    <strong>except</strong> redis.exceptions.ConnectionError <strong>as</strong> exc:<br>      <strong>if</strong> retries == 0:<br>        <strong>raise</strong> exc<br>      retries -= 1<br>      time.sleep(0.5)</p><p>@app.route(‘/‘)<br><strong>def</strong> hello():<br>  count = get_hit_count()<br>  <strong>return</strong> ‘Hello World! I have been seen {} times.<strong>\n</strong>‘.format(count)</p><p>在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。</p><p>在 composetest 目录中创建另一个名为 requirements.txt 的文件，内容如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flask</span><br><span class="hljs-attribute">redis</span><br></code></pre></td></tr></table></figure><h3 id="2、创建-Dockerfile-文件"><a href="#2、创建-Dockerfile-文件" class="headerlink" title="2、创建 Dockerfile 文件"></a>2、创建 Dockerfile 文件</h3><p>在 composetest 目录中，创建一个名为的文件 Dockerfile，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine<br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /code</span><br><span class="hljs-keyword">ENV</span> FLASK_APP app.py<br><span class="hljs-keyword">ENV</span> FLASK_RUN_HOST <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><span class="hljs-keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span><br><span class="hljs-keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span><br><span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">COPY</span><span class="bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>Dockerfile 内容解释：</strong></p><ul><li><p><strong>FROM python:3.7-alpine</strong>: 从 Python 3.7 映像开始构建镜像。</p></li><li><p><strong>WORKDIR /code</strong>: 将工作目录设置为 /code。</p></li><li><pre><code>ENV FLASK_APP app.pyENV FLASK_RUN_HOST 0.0.0.0<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>  设置 flask 命令使用的环境变量。<br><br>- **<span class="hljs-builtin-name">RUN</span> apk <span class="hljs-builtin-name">add</span> --no-cache gcc musl-dev linux-headers**: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。<br><br>- ```<br>  COPY requirements.txt requirements.txt<br>  <span class="hljs-builtin-name">RUN</span> pip install -r requirements.txt<br></code></pre></td></tr></table></figure>复制 requirements.txt 并安装 Python 依赖项。</code></pre></li><li><p><strong>COPY . .</strong>: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</p></li><li><p><strong>CMD [“flask”, “run”]</strong>: 容器提供默认的执行命令为：flask run。</p></li></ul><h3 id="3、创建-docker-compose-yml"><a href="#3、创建-docker-compose-yml" class="headerlink" title="3、创建 docker-compose.yml"></a>3、创建 docker-compose.yml</h3><p>在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：</p><h2 id="docker-compose-yml-配置文件"><a href="#docker-compose-yml-配置文件" class="headerlink" title="docker-compose.yml 配置文件"></a>docker-compose.yml 配置文件</h2><p># yaml 配置<br>version**:** ‘3’<br>services:<br> web:<br>  build**:** .<br>  ports**:<br>**   - “5000:5000”<br> redis:<br>  image**:** “redis:alpine”</p><p>该 Compose 文件定义了两个服务：web 和 redis。</p><ul><li><strong>web</strong>：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</li><li><strong>redis</strong>：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</li></ul><h3 id="4、使用-Compose-命令构建和运行您的应用"><a href="#4、使用-Compose-命令构建和运行您的应用" class="headerlink" title="4、使用 Compose 命令构建和运行您的应用"></a>4、使用 Compose 命令构建和运行您的应用</h3><p>在测试目录中，执行以下命令来启动应用程序：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up</span><br></code></pre></td></tr></table></figure><p>如果你想在后台执行该服务可以加上 <strong>-d</strong> 参数：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span><br></code></pre></td></tr></table></figure><hr><h2 id="yml-配置指令参考"><a href="#yml-配置指令参考" class="headerlink" title="yml 配置指令参考"></a>yml 配置指令参考</h2><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>指定本 yml 依从的 compose 哪个版本制定的。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>指定为构建镜像上下文路径：</p><p>例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  webapp:</span><br><span class="hljs-symbol">    build:</span> ./dir<br></code></pre></td></tr></table></figure><p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  webapp:</span><br><span class="hljs-symbol">    build:</span><br><span class="hljs-symbol">      context:</span> ./dir<br><span class="hljs-symbol">      dockerfile:</span> Dockerfile-alternate<br><span class="hljs-symbol">      args:</span><br><span class="hljs-symbol">        buildno:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">      labels:</span><br>        - <span class="hljs-string">&quot;com.example.description=Accounting webapp&quot;</span><br>        - <span class="hljs-string">&quot;com.example.department=Finance&quot;</span><br>        - <span class="hljs-string">&quot;com.example.label-with-empty-value&quot;</span><br><span class="hljs-symbol">      target:</span> prod<br></code></pre></td></tr></table></figure><ul><li>context：上下文路径。</li><li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li><li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li><li>labels：设置构建镜像的标签。</li><li>target：多层构建，可以指定构建哪一层。</li></ul><h3 id="cap-add，cap-drop"><a href="#cap-add，cap-drop" class="headerlink" title="cap_add，cap_drop"></a>cap_add，cap_drop</h3><p>添加或删除容器拥有的宿主机的内核功能。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">cap_add:</span><br>  - ALL <span class="hljs-meta"># 开启全部权限</span><br><br><span class="hljs-symbol">cap_drop:</span><br>  - SYS_PTRACE <span class="hljs-meta"># 关闭 ptrace权限</span><br></code></pre></td></tr></table></figure><h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h3><p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">cgroup_parent:</span> m-executor-abcd<br></code></pre></td></tr></table></figure><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动的默认命令。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">command:</span> [<span class="hljs-string">&quot;bundle&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;thin&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;3000&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>指定自定义容器名称，而不是生成的默认名称。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">container_name: <span class="hljs-keyword">my</span>-web-container<br></code></pre></td></tr></table></figure><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>设置依赖关系。</p><ul><li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li><li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li><li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  web:</span><br><span class="hljs-symbol">    build:</span> .<br><span class="hljs-symbol">    depends_on:</span><br>      - db<br>      - redis<br><span class="hljs-symbol">  redis:</span><br><span class="hljs-symbol">    image:</span> redis<br><span class="hljs-symbol">  db:</span><br><span class="hljs-symbol">    image:</span> postgres<br></code></pre></td></tr></table></figure><p>注意：web 服务不会等待 redis db 完全启动 之后才启动。</p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">version</span>: <span class="hljs-string">&quot;3.7&quot;</span><br>service<span class="hljs-variable">s:</span><br>  <span class="hljs-keyword">redi</span><span class="hljs-variable">s:</span><br>    image: <span class="hljs-keyword">redi</span><span class="hljs-variable">s:alpine</span><br>    deploy:<br>      <span class="hljs-keyword">mode</span>：replicated<br>      replica<span class="hljs-variable">s:</span> <span class="hljs-number">6</span><br>      endpoint_mode: dnsrr<br>      label<span class="hljs-variable">s:</span> <br>        description: <span class="hljs-string">&quot;This redis service label&quot;</span><br>      resource<span class="hljs-variable">s:</span><br>        limit<span class="hljs-variable">s:</span><br>          cpu<span class="hljs-variable">s:</span> <span class="hljs-string">&#x27;0.50&#x27;</span><br>          memory: <span class="hljs-number">50</span>M<br>        reservation<span class="hljs-variable">s:</span><br>          cpu<span class="hljs-variable">s:</span> <span class="hljs-string">&#x27;0.25&#x27;</span><br>          memory: <span class="hljs-number">20</span>M<br>      restart_policy:<br>        condition: <span class="hljs-keyword">on</span>-failure<br>        delay: <span class="hljs-number">5</span>s<br>        max_attempt<span class="hljs-variable">s:</span> <span class="hljs-number">3</span><br>        <span class="hljs-keyword">windo</span><span class="hljs-variable">w:</span> <span class="hljs-number">120</span>s<br></code></pre></td></tr></table></figure><p>可以选参数：</p><p><strong>endpoint_mode</strong>：访问集群服务的方式。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">endpoint_mode:</span> vip <br><span class="hljs-meta"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span><br><span class="hljs-symbol">endpoint_mode:</span> dnsrr<br><span class="hljs-meta"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span><br></code></pre></td></tr></table></figure><p><strong>labels</strong>：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p><p><strong>mode</strong>：指定服务提供的模式。</p><ul><li><p><strong>replicated</strong>：复制服务，复制指定服务到集群的机器上。</p></li><li><p><strong>global</strong>：全局服务，服务将部署至集群的每个节点。</p></li><li><p>图解：下图中黄色的方块是 replicated 模式的运行情况，灰色方块是 global 模式的运行情况。</p><p><img src="/2021/02/17/Docker/docker-composex.png" alt="img"></p></li></ul><p><strong>replicas：mode</strong> 为 replicated 时，需要使用此参数配置具体运行的节点数量。</p><p><strong>resources</strong>：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</p><p><strong>restart_policy</strong>：配置如何在退出容器时重新启动容器。</p><ul><li>condition：可选 none，on-failure 或者 any（默认值：any）。</li><li>delay：设置多久之后重启（默认值：0）。</li><li>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。</li><li>window：设置容器重启超时时间（默认值：0）。</li></ul><p><strong>rollback_config</strong>：配置在更新失败的情况下应如何回滚服务。</p><ul><li>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</li><li>delay：每个容器组回滚之间等待的时间（默认为0s）。</li><li>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。</li><li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li><li>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</li><li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。</li></ul><p><strong>update_config</strong>：配置应如何更新服务，对于配置滚动更新很有用。</p><ul><li>parallelism：一次更新的容器数。</li><li>delay：在更新一组容器之间等待的时间。</li><li>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。</li><li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li><li>max_failure_ratio：在更新过程中可以容忍的故障率。</li><li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。</li></ul><p><strong>注</strong>：仅支持 V3.4 及更高版本。</p><h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>指定设备映射列表。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">devices:</span><br>  - <span class="hljs-string">&quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;</span><br></code></pre></td></tr></table></figure><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>自定义 DNS 服务器，可以是单个值或列表的多个值。</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">dns</span>: 8.8.8.8<br><br><span class="hljs-attribute">dns:</span><br><span class="hljs-attribute">  - 8.8.8.8</span><br><span class="hljs-attribute">  - 9.9.9.9</span><br></code></pre></td></tr></table></figure><h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h3><p>自定义 DNS 搜索域。可以是单个值或列表。</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">dns_search</span>: example.com<br><br><span class="hljs-attribute">dns_search:</span><br><span class="hljs-attribute">  - dc1.example.com</span><br><span class="hljs-attribute">  - dc2.example.com</span><br></code></pre></td></tr></table></figure><h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>覆盖容器默认的 entrypoint。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">entrypoint: <span class="hljs-regexp">/code/</span>entrypoint.sh<br></code></pre></td></tr></table></figure><p>也可以是以下格式：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml">entrypoint:<br>    -<span class="ruby"> php</span><br><span class="ruby">    - -d</span><br><span class="ruby">    - zend_extension=<span class="hljs-regexp">/usr/local</span><span class="hljs-regexp">/lib/php</span><span class="hljs-regexp">/extensions/no</span>-debug-non-zts-<span class="hljs-number">20100525</span>/xdebug.so</span><br><span class="ruby">    - -d</span><br><span class="ruby">    - memory_limit=-<span class="hljs-number">1</span></span><br><span class="ruby">    - vendor/bin/phpunit</span><br></code></pre></td></tr></table></figure><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>从文件添加环境变量。可以是单个值或列表的多个值。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">env_file:</span> .env<br></code></pre></td></tr></table></figure><p>也可以是列表格式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">env_file:<br>  - ./common.env<br>  - .<span class="hljs-regexp">/apps/</span>web.env<br>  - <span class="hljs-regexp">/opt/</span>secrets.env<br></code></pre></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">environment</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">RACK_ENV</span>: <span class="hljs-string">development</span><br>  <span class="hljs-attr">SHOW</span>: <span class="hljs-string">&#x27;true&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haml">expose:<br> -<span class="ruby"> <span class="hljs-string">&quot;3000&quot;</span></span><br><span class="ruby"> - <span class="hljs-string">&quot;8000&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h3><p>添加主机名映射。类似 docker client –add-host。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haml">extra_hosts:<br> -<span class="ruby"> <span class="hljs-string">&quot;somehost:162.242.195.82&quot;</span></span><br><span class="ruby"> - <span class="hljs-string">&quot;otherhost:50.31.209.229&quot;</span></span><br></code></pre></td></tr></table></figure><p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">162.242.195.82</span>  somehost<br><span class="hljs-number">50.31.209.229</span>   otherhost<br></code></pre></td></tr></table></figure><h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h3><p>用于检测 docker 服务是否健康运行。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">healthcheck:</span><br><span class="hljs-symbol">  test:</span> [<span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;http://localhost&quot;</span>] <span class="hljs-meta"># 设置检测程序</span><br><span class="hljs-symbol">  interval:</span> <span class="hljs-number">1</span>m30s <span class="hljs-meta"># 设置检测间隔</span><br><span class="hljs-symbol">  timeout:</span> <span class="hljs-number">10</span>s <span class="hljs-meta"># 设置检测超时时间</span><br><span class="hljs-symbol">  retries:</span> <span class="hljs-number">3</span> <span class="hljs-meta"># 设置重试次数</span><br><span class="hljs-symbol">  start_period:</span> <span class="hljs-number">40</span>s <span class="hljs-meta"># 启动后，多少秒开始启动检测程序</span><br></code></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定容器运行的镜像。以下格式都可以：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">image:</span> redis<br><span class="hljs-symbol">image:</span> ubuntu:<span class="hljs-number">14.04</span><br><span class="hljs-symbol">image:</span> tutum/influxdb<br><span class="hljs-symbol">image:</span> example-registry.com:<span class="hljs-number">4000</span>/postgresql<br><span class="hljs-symbol">image:</span> a4bc65fd <span class="hljs-meta"># 镜像id</span><br></code></pre></td></tr></table></figure><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>服务的日志记录配置。</p><p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">driver:</span> <span class="hljs-string">&quot;json-file&quot;</span><br><span class="hljs-symbol">driver:</span> <span class="hljs-string">&quot;syslog&quot;</span><br><span class="hljs-symbol">driver:</span> <span class="hljs-string">&quot;none&quot;</span><br></code></pre></td></tr></table></figure><p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">logging:<br>  driver: json-<span class="hljs-built_in">file</span><br>  options:<br>    <span class="hljs-built_in">max</span>-size: <span class="hljs-string">&quot;200k&quot;</span> <span class="hljs-comment"># 单个文件大小为200k</span><br>    <span class="hljs-built_in">max</span>-<span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-comment"># 最多10个文件</span><br></code></pre></td></tr></table></figure><p>当达到文件限制上限，会自动删除旧得文件。</p><p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">logging:</span><br><span class="hljs-symbol">  driver:</span> syslog<br><span class="hljs-symbol">  options:</span><br>    syslog-address: <span class="hljs-string">&quot;tcp://192.168.0.42:123&quot;</span><br></code></pre></td></tr></table></figure><h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h3><p>设置网络模式。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">network_mode:</span> <span class="hljs-string">&quot;bridge&quot;</span><br><span class="hljs-symbol">network_mode:</span> <span class="hljs-string">&quot;host&quot;</span><br><span class="hljs-symbol">network_mode:</span> <span class="hljs-string">&quot;none&quot;</span><br><span class="hljs-symbol">network_mode:</span> <span class="hljs-string">&quot;service:[service name]&quot;</span><br><span class="hljs-symbol">network_mode:</span> <span class="hljs-string">&quot;container:[container name/id]&quot;</span><br></code></pre></td></tr></table></figure><p>networks</p><p>配置容器连接的网络，引用顶级 networks 下的条目 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">some-service:</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-attr">some-network:</span><br>        <span class="hljs-attr">aliases:</span><br>         <span class="hljs-bullet">-</span> <span class="hljs-string">alias1</span><br>      <span class="hljs-attr">other-network:</span><br>        <span class="hljs-attr">aliases:</span><br>         <span class="hljs-bullet">-</span> <span class="hljs-string">alias2</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">some-network:</span><br>    <span class="hljs-comment"># Use a custom driver</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">custom-driver-1</span><br>  <span class="hljs-attr">other-network:</span><br>    <span class="hljs-comment"># Use a custom driver which takes special options</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">custom-driver-2</span><br></code></pre></td></tr></table></figure><p><strong>aliases</strong> ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</p><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><ul><li>no：是默认的重启策略，在任何情况下都不会重启容器。</li><li>always：容器总是重新启动。</li><li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li><li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">restart</span>: &quot;no&quot;<br><span class="hljs-keyword">restart</span>: <span class="hljs-keyword">always</span><br><span class="hljs-keyword">restart</span>: <span class="hljs-keyword">on</span>-failure<br><span class="hljs-keyword">restart</span>: unless-stopped<br></code></pre></td></tr></table></figure><p>注：swarm 集群模式，请改用 restart_policy。</p><h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h3><p>存储敏感数据，例如密码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&quot;3.1&quot;</span><br><span class="hljs-symbol">services:</span><br><br><span class="hljs-symbol">mysql:</span><br><span class="hljs-symbol">  image:</span> mysql<br><span class="hljs-symbol">  environment:</span><br><span class="hljs-symbol">    MYSQL_ROOT_PASSWORD_FILE:</span> <span class="hljs-meta-keyword">/run/</span>secrets/my_secret<br><span class="hljs-symbol">  secrets:</span><br>    - my_secret<br><br><span class="hljs-symbol">secrets:</span><br><span class="hljs-symbol">  my_secret:</span><br><span class="hljs-symbol">    file:</span> ./my_secret.txt<br></code></pre></td></tr></table></figure><h3 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h3><p>修改容器默认的 schema 标签。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">security-opt：<br>  - label:user:<span class="hljs-keyword">USER</span>   <span class="hljs-title"># 设置容器的用户标签</span><br><span class="hljs-title">  - label</span>:role:<span class="hljs-keyword">ROLE</span>   <span class="hljs-title"># 设置容器的角色标签</span><br><span class="hljs-title">  - label</span>:<span class="hljs-keyword">type</span>:<span class="hljs-keyword">TYPE</span>   <span class="hljs-comment"># 设置容器的安全策略标签</span><br>  - label:level:LEVEL  <span class="hljs-comment"># 设置容器的安全等级标签</span><br></code></pre></td></tr></table></figure><h3 id="stop-grace-period"><a href="#stop-grace-period" class="headerlink" title="stop_grace_period"></a>stop_grace_period</h3><p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">stop_grace_period</span>: <span class="hljs-number">1</span>s # 等待 <span class="hljs-number">1</span> 秒<br><span class="hljs-attribute">stop_grace_period</span>: <span class="hljs-number">1</span>m<span class="hljs-number">30</span>s # 等待 <span class="hljs-number">1</span> 分 <span class="hljs-number">30</span> 秒 <br></code></pre></td></tr></table></figure><p>默认的等待时间是 10 秒。</p><h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h3><p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p><p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">stop_signal</span>: SIGUSR<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>设置容器中的内核参数，可以使用数组或字典格式。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sysctls:<br>  net<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.somaxconn</span>: <span class="hljs-number">1024</span><br>  net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_syncookies</span>: <span class="hljs-number">0</span><br><br>sysctls:<br>  - net<span class="hljs-selector-class">.core</span>.somaxconn=<span class="hljs-number">1024</span><br>  - net<span class="hljs-selector-class">.ipv4</span>.tcp_syncookies=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">tmpfs: /run<br><br>tmpfs:<br>  - /run<br>  - /tmp<br></code></pre></td></tr></table></figure><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>覆盖容器默认的 ulimit。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">ulimits:</span><br><span class="hljs-symbol">  nproc:</span> <span class="hljs-number">65535</span><br><span class="hljs-symbol">  nofile:</span><br><span class="hljs-symbol">    soft:</span> <span class="hljs-number">20000</span><br><span class="hljs-symbol">    hard:</span> <span class="hljs-number">40000</span><br></code></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>将主机的数据卷或着文件挂载到容器里。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-symbol">services:</span><br><span class="hljs-symbol">  db:</span><br><span class="hljs-symbol">    image:</span> postgres:latest<br><span class="hljs-symbol">    volumes:</span><br>      - <span class="hljs-string">&quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br>      - <span class="hljs-string">&quot;/localhost/data:/var/lib/postgresql/data&quot;</span><br></code></pre></td></tr></table></figure><h1 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</p><p>Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</p><p><img src="/2021/02/17/Docker/68747470733a2f2f646f63732e646f636b65722e636f6d2f6d616368696e652f696d672f6c6f676f2e706e67.png" alt="img"></p><p>Docker Machine 管理的虚拟主机可以是机上的，也可以是云供应商，如阿里云，腾讯云，AWS，或 DigitalOcean。</p><p>使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。</p><p><img src="/2021/02/17/Docker/machine.png" alt="img"></p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 Docker Machine 之前你需要先安装 Docker。</p><p>Docker Mechine 可以在多种平台上安装使用，包括 Linux 、MacOS 以及 windows。</p><h3 id="Linux-安装命令"><a href="#Linux-安装命令" class="headerlink" title="Linux 安装命令"></a>Linux 安装命令</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ base=https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/m</span>achine<span class="hljs-regexp">/releases/</span>download/v0.<span class="hljs-number">16.0</span> &amp;&amp;<br>  curl -L <span class="hljs-variable">$base</span><span class="hljs-regexp">/docker-machine-$(uname -s)-$(uname -m) &gt;/</span>tmp/docker-machine &amp;&amp;<br>  sudo mv <span class="hljs-regexp">/tmp/</span>docker-machine <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-machine &amp;&amp;<br>  chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-machine<br></code></pre></td></tr></table></figure><h3 id="macOS-安装命令"><a href="#macOS-安装命令" class="headerlink" title="macOS 安装命令"></a>macOS 安装命令</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ base=https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/m</span>achine<span class="hljs-regexp">/releases/</span>download/v0.<span class="hljs-number">16.0</span> &amp;&amp;<br>  curl -L <span class="hljs-variable">$base</span><span class="hljs-regexp">/docker-machine-$(uname -s)-$(uname -m) &gt;/u</span>sr<span class="hljs-regexp">/local/</span>bin/docker-machine &amp;&amp;<br>  chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-machine<br></code></pre></td></tr></table></figure><h3 id="Windows-安装命令"><a href="#Windows-安装命令" class="headerlink" title="Windows 安装命令"></a>Windows 安装命令</h3><p>如果你是 Windows 平台，可以使用 <a href="https://git-for-windows.github.io/">Git BASH</a>，并输入以下命令：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">$ base=https:<span class="hljs-regexp">//gi</span>thub.com/docker/machine/releases/download/v<span class="hljs-number">0</span>.<span class="hljs-number">16.0</span> &amp;&amp;<br>  <span class="hljs-keyword">mkdir</span> -p <span class="hljs-string">&quot;$HOME/bin&quot;</span> &amp;&amp;<br>  curl -L $base/docker-machine-Windows-x86_64.exe &gt; <span class="hljs-string">&quot;$HOME/bin/docker-machine.exe&quot;</span> &amp;&amp;<br>  <span class="hljs-keyword">chmod</span> +<span class="hljs-keyword">x</span> <span class="hljs-string">&quot;$HOME/bin/docker-machine.exe&quot;</span><br></code></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker-machine <span class="hljs-built_in">version</span><br>docker-machine <span class="hljs-built_in">version</span> <span class="hljs-number">0.16</span><span class="hljs-number">.0</span>, build <span class="hljs-number">9371605</span><br></code></pre></td></tr></table></figure><hr><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>本章通过 virtualbox 来介绍 docker-machine 的使用方法。其他云服务商操作与此基本一致。具体可以参考每家服务商的指导文档。</p><h3 id="1、列出可用的机器"><a href="#1、列出可用的机器" class="headerlink" title="1、列出可用的机器"></a>1、列出可用的机器</h3><p>可以看到目前只有这里默认的 default 虚拟机。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker<span class="hljs-literal">-machine</span> <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine1.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine1.png" alt="img"></a></p><h3 id="2、创建机器"><a href="#2、创建机器" class="headerlink" title="2、创建机器"></a>2、创建机器</h3><p>创建一台名为 test 的机器。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ docker-machine <span class="hljs-built_in">create</span> <span class="hljs-comment">--driver virtualbox test</span><br></code></pre></td></tr></table></figure><ul><li><strong>–driver</strong>：指定用来创建机器的驱动类型，这里是 virtualbox。</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine2.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine2.png" alt="img"></a></p><h3 id="3、查看机器的-ip"><a href="#3、查看机器的-ip" class="headerlink" title="3、查看机器的 ip"></a>3、查看机器的 ip</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker-machine ip <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine3.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine3.png" alt="img"></a></p><h3 id="4、停止机器"><a href="#4、停止机器" class="headerlink" title="4、停止机器"></a>4、停止机器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker-machine stop <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine4.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine4.png" alt="img"></a></p><h3 id="5、启动机器"><a href="#5、启动机器" class="headerlink" title="5、启动机器"></a>5、启动机器</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> docker<span class="hljs-literal">-machine</span> <span class="hljs-built_in">start</span> test<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine5.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine5.png" alt="img"></a></p><h3 id="6、进入机器"><a href="#6、进入机器" class="headerlink" title="6、进入机器"></a>6、进入机器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker-machine ssh <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine6.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/docker-machine6.png" alt="img"></a></p><h3 id="docker-machine-命令参数说明"><a href="#docker-machine-命令参数说明" class="headerlink" title="docker-machine 命令参数说明"></a>docker-machine 命令参数说明</h3><ul><li><p><strong>docker-machine active</strong>：查看当前激活状态的 Docker 主机。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ docker-machine ls<br><br>NAME      ACTIVE   DRIVER         STATE     URL<br>dev       -        virtualbox     Running   tcp:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">99.103</span>:<span class="hljs-number">2376</span><br>staging   *        digitalocean   Running   tcp:<span class="hljs-regexp">//</span><span class="hljs-number">203.0</span>.<span class="hljs-number">113.81</span>:<span class="hljs-number">2376</span><br><br>$ echo <span class="hljs-variable">$DOCKER_HOST</span><br>tcp:<span class="hljs-regexp">//</span><span class="hljs-number">203.0</span>.<span class="hljs-number">113.81</span>:<span class="hljs-number">2376</span><br><br>$ docker-machine active<br>staging<br></code></pre></td></tr></table></figure></li><li><p><strong>config</strong>：查看当前激活状态 Docker 主机的连接信息。</p></li><li><p><strong>creat</strong>：创建 Docker 主机</p></li><li><p><strong>env</strong>：显示连接到某个主机需要的环境变量</p></li><li><p><strong>inspect</strong>： 以 json 格式输出指定Docker的详细信息</p></li><li><p><strong>ip</strong>： 获取指定 Docker 主机的地址</p></li><li><p><strong>kill</strong>： 直接杀死指定的 Docker 主机</p></li><li><p><strong>ls</strong>： 列出所有的管理主机</p></li><li><p><strong>provision</strong>： 重新配置指定主机</p></li><li><p><strong>regenerate-certs</strong>： 为某个主机重新生成 TLS 信息</p></li><li><p><strong>restart</strong>： 重启指定的主机</p></li><li><p><strong>rm</strong>： 删除某台 Docker 主机，对应的虚拟机也会被删除</p></li><li><p><strong>ssh</strong>： 通过 SSH 连接到主机上，执行命令</p></li><li><p><strong>scp</strong>： 在 Docker 主机之间以及 Docker 主机和本地主机之间通过 scp 远程复制数据</p></li><li><p><strong>mount</strong>： 使用 SSHFS 从计算机装载或卸载目录</p></li><li><p><strong>start</strong>： 启动一个指定的 Docker 主机，如果对象是个虚拟机，该虚拟机将被启动</p></li><li><p><strong>status</strong>： 获取指定 Docker 主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等</p></li><li><p><strong>stop</strong>： 停止一个指定的 Docker 主机</p></li><li><p><strong>upgrade</strong>： 将一个指定主机的 Docker 版本更新为最新</p></li><li><p><strong>url</strong>： 获取指定 Docker 主机的监听 URL</p></li><li><p><strong>version</strong>： 显示 Docker Machine 的版本或者主机 Docker 版本</p></li><li><p><strong>help</strong>： 显示帮助信息</p></li></ul><h1 id="Swarm-集群管理"><a href="#Swarm-集群管理" class="headerlink" title="Swarm 集群管理"></a>Swarm 集群管理</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。</p><p>支持的工具包括但不限于以下各项：</p><ul><li>Dokku</li><li>Docker Compose</li><li>Docker Machine</li><li>Jenkins</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如下图所示，swarm 集群由管理节点（manager）和工作节点（work node）构成。</p><ul><li><strong>swarm mananger</strong>：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</li><li><strong>work node</strong>：即图中的 available node，主要负责运行相应的服务来执行任务（task）。</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/services-diagram.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/services-diagram.png" alt="img"></a></p><hr><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>以下示例，均以 Docker Machine 和 virtualbox 进行介绍，确保你的主机已安装 virtualbox。</p><h3 id="1、创建-swarm-集群管理节点（manager）"><a href="#1、创建-swarm-集群管理节点（manager）" class="headerlink" title="1、创建 swarm 集群管理节点（manager）"></a>1、创建 swarm 集群管理节点（manager）</h3><p>创建 docker 机器：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>docker-machine create -d virtualbox swarm-manager<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm1.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm1.png" alt="img"></a></p><p>初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ docker-machine ssh <span class="hljs-keyword">swarm-manager</span><br><span class="hljs-keyword">$ </span>docker <span class="hljs-keyword">swarm </span>init --advertise-<span class="hljs-keyword">addr </span><span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">99</span>.<span class="hljs-number">107</span> <span class="hljs-comment">#这里的 IP 为创建机器时分配的 ip。</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm2.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm2.png" alt="img"></a></p><p>以上输出，证明已经初始化成功。需要把以下这行复制出来，在增加工作节点时会用到：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> swarm join --token SWMTKN-<span class="hljs-number">1</span>-<span class="hljs-number">4</span>oogo<span class="hljs-number">9</span>qziq<span class="hljs-number">768</span>dma<span class="hljs-number">0</span>uh<span class="hljs-number">3</span>j<span class="hljs-number">0</span>z<span class="hljs-number">0</span>m<span class="hljs-number">5</span>twlm<span class="hljs-number">10</span>iynvz<span class="hljs-number">7</span>ixza<span class="hljs-number">96</span>k<span class="hljs-number">6</span>jh<span class="hljs-number">9</span>p-ajkb<span class="hljs-number">6</span>w<span class="hljs-number">7</span>qd<span class="hljs-number">06</span>y<span class="hljs-number">1</span>e<span class="hljs-number">33</span>yrgko<span class="hljs-number">64</span>sk <span class="hljs-number">192.168.99.107:2377</span><br></code></pre></td></tr></table></figure><h3 id="2、创建-swarm-集群工作节点（worker）"><a href="#2、创建-swarm-集群工作节点（worker）" class="headerlink" title="2、创建 swarm 集群工作节点（worker）"></a>2、创建 swarm 集群工作节点（worker）</h3><p>这里直接创建好俩台机器，swarm-worker1 和 swarm-worker2 。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm3.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm3.png" alt="img"></a></p><p>分别进入两个机器里，指定添加至上一步中创建的集群，这里会用到上一步复制的内容。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm4.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm4.png" alt="img"></a></p><p>以上数据输出说明已经添加成功。</p><p>上图中，由于上一步复制的内容比较长，会被自动截断，实际上在图运行的命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span>@swarm-worker<span class="hljs-number">1</span>:~$ docker swarm join --token SWMTKN-<span class="hljs-number">1</span>-<span class="hljs-number">4</span>oogo<span class="hljs-number">9</span>qziq<span class="hljs-number">768</span>dma<span class="hljs-number">0</span>uh<span class="hljs-number">3</span>j<span class="hljs-number">0</span>z<span class="hljs-number">0</span>m<span class="hljs-number">5</span>twlm<span class="hljs-number">10</span>iynvz<span class="hljs-number">7</span>ixza<span class="hljs-number">96</span>k<span class="hljs-number">6</span>jh<span class="hljs-number">9</span>p-ajkb<span class="hljs-number">6</span>w<span class="hljs-number">7</span>qd<span class="hljs-number">06</span>y<span class="hljs-number">1</span>e<span class="hljs-number">33</span>yrgko<span class="hljs-number">64</span>sk <span class="hljs-number">192.168.99.107:2377</span><br></code></pre></td></tr></table></figure><h3 id="3、查看集群信息"><a href="#3、查看集群信息" class="headerlink" title="3、查看集群信息"></a>3、查看集群信息</h3><p>进入管理节点，执行：docker info 可以查看当前集群的信息。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ docker <span class="hljs-meta">info</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm5.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm5.png" alt="img"></a></p><p>通过画红圈的地方，可以知道当前运行的集群中，有三个节点，其中有一个是管理节点。</p><h3 id="4、部署服务到集群中"><a href="#4、部署服务到集群中" class="headerlink" title="4、部署服务到集群中"></a>4、部署服务到集群中</h3><p><strong>注意</strong>：跟集群管理有关的任何操作，都是在管理节点上操作的。</p><p>以下例子，在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">docker<span class="hljs-variable">@swarm</span><span class="hljs-operator">-</span>manager:<span class="hljs-operator">~</span>$ docker service <span class="hljs-keyword">create</span> <span class="hljs-comment">--replicas 1 --name helloworld alpine ping docker.com</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm6.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm6.png" alt="img"></a></p><h3 id="5、查看服务部署情况"><a href="#5、查看服务部署情况" class="headerlink" title="5、查看服务部署情况"></a>5、查看服务部署情况</h3><p>查看 helloworld 服务运行在哪个节点上，可以看到目前是在 swarm-worker1 节点：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker<span class="hljs-variable">@swarm</span>-<span class="hljs-symbol">manager:</span>~<span class="hljs-variable">$ </span>docker service ps helloworld<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm7.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm7.png" alt="img"></a></p><p>查看 helloworld 部署的具体信息：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">docker@swarm-<span class="hljs-name">manager</span>:~$ docker service inspect <span class="hljs-comment">--pretty helloworld</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm8.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm8.png" alt="img"></a></p><h3 id="6、扩展集群服务"><a href="#6、扩展集群服务" class="headerlink" title="6、扩展集群服务"></a>6、扩展集群服务</h3><p>我们将上述的 helloworld 服务扩展到俩个节点。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker@swarm-manager:~$ docker<span class="hljs-built_in"> service </span>scale <span class="hljs-attribute">helloworld</span>=2<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm9.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm9.png" alt="img"></a></p><p>可以看到已经从一个节点，扩展到两个节点。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm10.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm10.png" alt="img"></a></p><h3 id="7、删除服务"><a href="#7、删除服务" class="headerlink" title="7、删除服务"></a>7、删除服务</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker<span class="hljs-variable">@swarm</span>-<span class="hljs-symbol">manager:</span>~<span class="hljs-variable">$ </span>docker service rm helloworld<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm11.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm11.png" alt="img"></a></p><p>查看是否已删除：</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm12.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm12.png" alt="img"></a></p><h3 id="8、滚动升级服务"><a href="#8、滚动升级服务" class="headerlink" title="8、滚动升级服务"></a>8、滚动升级服务</h3><p>以下实例，我们将介绍 redis 版本如何滚动升级至更高版本。</p><p>创建一个 3.0.6 版本的 redis。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span>@swarm-manager:~$ docker service create --replicas <span class="hljs-number">1</span> --name redis --update-delay <span class="hljs-number">10</span>s redis:<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm13.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm13.png" alt="img"></a></p><p>滚动升级 redis 。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span>@swarm-manager:~$ docker service update --image redis:<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">7</span> redis<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm14.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm14.png" alt="img"></a></p><p>看图可以知道 redis 的版本已经从 3.0.6 升级到了 3.0.7，说明服务已经升级成功。</p><h3 id="9、停止某个节点接收新的任务"><a href="#9、停止某个节点接收新的任务" class="headerlink" title="9、停止某个节点接收新的任务"></a>9、停止某个节点接收新的任务</h3><p>查看所有的节点：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker@swarm-manager:~$ docker <span class="hljs-keyword">node</span> <span class="hljs-title">ls</span><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm16.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm16.png" alt="img"></a></p><p>可以看到目前所有的节点都是 Active, 可以接收新的任务分配。</p><p>停止节点 swarm-worker1：</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm17.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm17.png" alt="img"></a></p><p><strong>注意</strong>：swarm-worker1 状态变为 Drain。不会影响到集群的服务，只是 swarm-worker1 节点不再接收新的任务，集群的负载能力有所下降。</p><p>可以通过以下命令重新激活节点：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker@swarm-manager:~$  docker <span class="hljs-keyword">node</span> <span class="hljs-title">update</span> --availability active swarm-worker1<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2019/11/swarm19.png"><img src="https://www.runoob.com/wp-content/uploads/2019/11/swarm19.png" alt="img"></a></p><h1 id="Docker-命令大全"><a href="#Docker-命令大全" class="headerlink" title="Docker 命令大全"></a>Docker 命令大全</h1><hr><h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><ul><li><a href="https://www.runoob.com/docker/docker-run-command.html">run</a></li><li><a href="https://www.runoob.com/docker/docker-start-stop-restart-command.html">start/stop/restart</a></li><li><a href="https://www.runoob.com/docker/docker-kill-command.html">kill</a></li><li><a href="https://www.runoob.com/docker/docker-rm-command.html">rm</a></li><li><a href="https://www.runoob.com/docker/docker-pause-unpause-command.html">pause/unpause</a></li><li><a href="https://www.runoob.com/docker/docker-create-command.html">create</a></li><li><a href="https://www.runoob.com/docker/docker-exec-command.html">exec</a></li></ul><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><ul><li><a href="https://www.runoob.com/docker/docker-ps-command.html">ps</a></li><li><a href="https://www.runoob.com/docker/docker-inspect-command.html">inspect</a></li><li><a href="https://www.runoob.com/docker/docker-top-command.html">top</a></li><li><a href="https://www.runoob.com/docker/docker-attach-command.html">attach</a></li><li><a href="https://www.runoob.com/docker/docker-events-command.html">events</a></li><li><a href="https://www.runoob.com/docker/docker-logs-command.html">logs</a></li><li><a href="https://www.runoob.com/docker/docker-wait-command.html">wait</a></li><li><a href="https://www.runoob.com/docker/docker-export-command.html">export</a></li><li><a href="https://www.runoob.com/docker/docker-port-command.html">port</a></li></ul><h3 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h3><ul><li><a href="https://www.runoob.com/docker/docker-commit-command.html">commit</a></li><li><a href="https://www.runoob.com/docker/docker-cp-command.html">cp</a></li><li><a href="https://www.runoob.com/docker/docker-diff-command.html">diff</a></li></ul><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><ul><li><a href="https://www.runoob.com/docker/docker-login-command.html">login</a></li><li><a href="https://www.runoob.com/docker/docker-pull-command.html">pull</a></li><li><a href="https://www.runoob.com/docker/docker-push-command.html">push</a></li><li><a href="https://www.runoob.com/docker/docker-search-command.html">search</a></li></ul><h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><ul><li><a href="https://www.runoob.com/docker/docker-images-command.html">images</a></li><li><a href="https://www.runoob.com/docker/docker-rmi-command.html">rmi</a></li><li><a href="https://www.runoob.com/docker/docker-tag-command.html">tag</a></li><li><a href="https://www.runoob.com/docker/docker-build-command.html">build</a></li><li><a href="https://www.runoob.com/docker/docker-history-command.html">history</a></li><li><a href="https://www.runoob.com/docker/docker-save-command.html">save</a></li><li><a href="https://www.runoob.com/docker/docker-load-command.html">load</a></li><li><a href="https://www.runoob.com/docker/docker-import-command.html">import</a></li></ul><h3 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h3><ul><li><a href="https://www.runoob.com/docker/docker-info-command.html">info</a></li><li><a href="https://www.runoob.com/docker/docker-version-command.html">version</a></li></ul><h1 id="Docker-资源汇总"><a href="#Docker-资源汇总" class="headerlink" title="Docker 资源汇总"></a>Docker 资源汇总</h1><hr><h3 id="Docker-资源"><a href="#Docker-资源" class="headerlink" title="Docker 资源"></a>Docker 资源</h3><ul><li>Docker 官方主页: <a href="https://www.docker.com/">https://www.docker.com</a></li><li>Docker 官方博客: <a href="https://blog.docker.com/">https://blog.docker.com/</a></li><li>Docker 官方文档: <a href="https://docs.docker.com/">https://docs.docker.com/</a></li><li>Docker Store: <a href="https://store.docker.com/">https://store.docker.com</a></li><li>Docker Cloud: <a href="https://cloud.docker.com/">https://cloud.docker.com</a></li><li>Docker Hub: <a href="https://hub.docker.com/">https://hub.docker.com</a></li><li>Docker 的源代码仓库: <a href="https://github.com/moby/moby">https://github.com/moby/moby</a></li><li>Docker 发布版本历史: <a href="https://docs.docker.com/release-notes/">https://docs.docker.com/release-notes/</a></li><li>Docker 常见问题: <a href="https://docs.docker.com/engine/faq/">https://docs.docker.com/engine/faq/</a></li><li>Docker 远端应用 API: <a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a></li></ul><h3 id="Docker-国内镜像"><a href="#Docker-国内镜像" class="headerlink" title="Docker 国内镜像"></a>Docker 国内镜像</h3><p>阿里云的加速器：<a href="https://help.aliyun.com/document_detail/60750.html">https://help.aliyun.com/document_detail/60750.html</a></p><p>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></p><p>官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></p><p>ustc 的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></p><p>daocloud：<a href="https://www.daocloud.io/mirror#accelerator-doc%EF%BC%88%E6%B3%A8%E5%86%8C%E5%90%8E%E4%BD%BF%E7%94%A8%EF%BC%89">https://www.daocloud.io/mirror#accelerator-doc（注册后使用）</a></p><p>如果有更好的资源，欢迎通过下面的笔记来分享。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s的Yaml编写</title>
    <link href="/2021/02/17/k8s%E7%9A%84Yaml%E7%BC%96%E5%86%99/"/>
    <url>/2021/02/17/k8s%E7%9A%84Yaml%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="k8s的yaml编写指引"><a href="#k8s的yaml编写指引" class="headerlink" title="k8s的yaml编写指引"></a>k8s的yaml编写指引</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>             <span class="hljs-comment">#指定api版本，此值必须在kubectl apiversion中  </span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>                  <span class="hljs-comment">#指定创建资源的角色/类型  </span><br><span class="hljs-attr">metadata:</span>                  <span class="hljs-comment">#资源的元数据/属性  </span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">django-pod</span>         <span class="hljs-comment">#pod资源的名字，在同一个namespace中必须唯一  </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">name-space</span> <span class="hljs-comment">#pod所属命名空间，默认default</span><br>  <span class="hljs-attr">labels:</span>                  <span class="hljs-comment">#设定资源的标签列表，使这个标签在service网络中备案，以便被获知</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">django</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span>  <br>    <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span>  <br>  <span class="hljs-attr">annotations:</span>             <span class="hljs-comment">#设置自定义注解列表  </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">String</span>         <span class="hljs-comment">#设置自定义注解名字  </span><br><span class="hljs-attr">spec:</span>                      <span class="hljs-comment">#设置该资源的内容，Pod中容器详细定义  </span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span>    <span class="hljs-comment">#表示自动重启，一直都会有这个容器运行</span><br>  <span class="hljs-attr">nodeSelector:</span>            <span class="hljs-comment">#选择node节点14     zone: node1  </span><br>  <span class="hljs-attr">containers:</span>   <span class="hljs-comment">#Pod中容器列表</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">django-pod</span>       <span class="hljs-comment">#容器的名字  </span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">django:v1.1</span>     <span class="hljs-comment">#容器使用的镜像地址  </span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span> <span class="hljs-comment">#三个选择Always、Never、IfNotPresent，每次启动时检查和更新（从registery）images的策略，</span><br>                           <span class="hljs-comment"># Always，每次都检查</span><br>                           <span class="hljs-comment"># Never，每次都不检查（不管本地是否有）</span><br>                           <span class="hljs-comment"># IfNotPresent，如果本地有就不检查，如果没有就拉取</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>]        <span class="hljs-comment">#启动容器的运行命令，将覆盖容器中的Entrypoint,对应Dockefile中的ENTRYPOINT  </span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;$(str)&quot;</span>]       <span class="hljs-comment">#启动容器的命令参数，对应Dockerfile中CMD参数  </span><br>    <span class="hljs-attr">env:</span>                   <span class="hljs-comment">#设置容器运行前的环境变量列表 </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">str</span>            <span class="hljs-comment">#变量的名字  </span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;/etc/run.sh&quot;</span> <span class="hljs-comment">#变量的值  </span><br>    <span class="hljs-attr">resources:</span>             <span class="hljs-comment">#资源限制和资源请求的设置</span><br>      <span class="hljs-attr">requests:</span>            <span class="hljs-comment">#容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行  </span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.1</span>           <span class="hljs-comment">#CPU资源（核数），两种方式，浮点数或者是整数+m，0.1=100m，最少值为0.001核（1m）</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">32Mi</span>       <span class="hljs-comment">#内存使用量</span><br>      <span class="hljs-attr">limits:</span>              <span class="hljs-comment">#资源限制  </span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-number">0.5</span>           <span class="hljs-comment">#用于docker run --cpu-shares参数</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">32Mi</span>       <span class="hljs-comment">#用于docker run --memmory参数</span><br>    <span class="hljs-attr">ports:</span>     <span class="hljs-comment">#容器要暴露的端口列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>  <span class="hljs-comment">#容器开发对外的端口，即容器监听的端口号</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">uwsgi</span>          <span class="hljs-comment">#名称</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>   <span class="hljs-comment">#默认TCP</span><br>      <span class="hljs-attr">hostport:</span> <span class="hljs-number">8080</span> <span class="hljs-comment">#容器所在宿主机需要监听的端口号，默认与containerPort相同。设置hostport时同一台宿主机将无法启动该容器的第二份副本</span><br>    <span class="hljs-attr">livenessProbe:</span>         <span class="hljs-comment">#pod内容器健康检查的设置</span><br>      <span class="hljs-attr">httpGet:</span>             <span class="hljs-comment">#通过httpget检查健康，返回200-399之间，则认为容器正常  </span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span>            <span class="hljs-comment">#URI地址  </span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>  <br>        <span class="hljs-comment">#host: 127.0.0.1   #主机地址     </span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span>  <br>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">180</span> <span class="hljs-comment">#表明第一次检测在容器启动后多长时间后开始  </span><br>      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span>    <span class="hljs-comment">#检测的超时时间  </span><br>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">15</span>    <span class="hljs-comment">#检查间隔时间  </span><br>      <span class="hljs-comment">#也可以用这种方法  </span><br>      <span class="hljs-comment">#exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常  </span><br>      <span class="hljs-comment">#  command:  </span><br>      <span class="hljs-comment">#    - cat  </span><br>      <span class="hljs-comment">#    - /tmp/health  </span><br>      <span class="hljs-comment">#也可以用这种方法  </span><br>      <span class="hljs-comment">#tcpSocket: //通过tcpSocket检查健康   </span><br>      <span class="hljs-comment">#  port: number   </span><br>    <span class="hljs-attr">lifecycle:</span>             <span class="hljs-comment">#生命周期管理(钩子)  </span><br>      <span class="hljs-attr">postStart:</span>           <span class="hljs-comment">#容器运行之前运行的任务  </span><br>        <span class="hljs-attr">exec:</span>  <br>          <span class="hljs-attr">command:</span>  <br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;sh&#x27;</span>  <br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;yum upgrade -y&#x27;</span>  <br>      <span class="hljs-attr">preStop:</span>             <span class="hljs-comment">#容器关闭之前运行的任务  </span><br>        <span class="hljs-attr">exec:</span>  <br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;service httpd stop&#x27;</span>]  <br>    <span class="hljs-attr">volumeMounts:</span>          <span class="hljs-comment">#挂载容器内部存储卷的设置</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume</span>         <span class="hljs-comment">#挂载设备的名字，与volumes[*].name 需要对应    </span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span>     <span class="hljs-comment">#挂载到容器的某个路径下  </span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">True</span>   <span class="hljs-comment">#默认false</span><br>  <span class="hljs-attr">volumes:</span>                 <span class="hljs-comment">#定义一组挂载设备  </span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume</span>           <span class="hljs-comment">#定义一个挂载设备的名字  </span><br>    <span class="hljs-comment">#meptyDir: &#123;&#125;  </span><br>    <span class="hljs-attr">hostPath:</span>  <br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/opt</span>           <span class="hljs-comment">#挂载设备类型为hostPath，路径为宿主机下的/opt</span><br>  <span class="hljs-attr">hostAliases:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">hostnames:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">www.baidu.com</span><br>      <span class="hljs-attr">ip:</span> <span class="hljs-number">49.232</span><span class="hljs-number">.1</span><span class="hljs-number">.206</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">hostnames:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">www.baidu1.com</span><br>      <span class="hljs-attr">ip:</span> <span class="hljs-number">49.5</span><span class="hljs-number">.7</span><span class="hljs-number">.139</span><br>  <br></code></pre></td></tr></table></figure><p>=============</p>]]></content>
    
    
    <categories>
      
      <category>kubernates</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS软件安装使用的一系列问题</title>
    <link href="/2021/02/17/MacOS%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/2021/02/17/MacOS%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="MacOS软件安装使用的一系列问题"><a href="#MacOS软件安装使用的一系列问题" class="headerlink" title="MacOS软件安装使用的一系列问题"></a>MacOS软件安装使用的一系列问题</h2><h3 id="Mac打开软件提示”已损坏，无法打开。-您应该将它移到废纸篓”"><a href="#Mac打开软件提示”已损坏，无法打开。-您应该将它移到废纸篓”" class="headerlink" title="Mac打开软件提示”已损坏，无法打开。 您应该将它移到废纸篓”"></a>Mac打开软件提示”已损坏，无法打开。 您应该将它移到废纸篓”</h3><p>1、打开任何来源设置<br>打开系统偏好设置 -&gt; 安全性与隐私 -&gt; 通用 -&gt; 任何来源。在终端执行如下命令，打开后如图所示</p><p><code>sudo spctl --master-disable</code></p><p>2、更改应用程序拓展属性<br>如果您仍然坚持软件没有问题，在终端执行如下命令</p><p><code>sudo xattr -r -d com.apple.quarantine （注意最后有一个空格）</code></p><p>先不要按回车,打开 “访达”（Finder）进入 “应用程序” 目录，找到该软件图标，将图标拖到刚才的终端窗口里面，会得到如下组合</p><p><code>sudo xattr -r -d com.apple.quarantine xxx</code></p><p>回车输入密码即可</p><p>3、考虑app本身问题<br>如果上诉办法仍然没有解决问题，90%可能性就不是mac系统了，建议上Stack Overflow搜索下解决办法。<br>比如Shimo报错macOS cannot connect to OpenVPN using Shimo - Kext error，最终发现是软件缺少了配置文件，打开科学上网软件下载一个配置文件安装即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环不变式</title>
    <link href="/2021/02/16/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F/"/>
    <url>/2021/02/16/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h1><p>熟练掌握数学归纳法的思路对于程序员来说是相当重要的。例如，要在程序中编写循环处理(loop) 时数学归纳法是非常有用的。</p><p>在编写循环时，找到让每次循环都成立的逻辑表达式很重要。这种逻辑表达式称为<strong>循环不变式</strong>（loop invariant）。循环不变式相当于用数学归纳法证明的“断言”。</p><p>循环不变式用于证明程序的正确性。在编写循环时，思考一下“这个循环的循环不变式是什么”就能减少错误。</p><h2 id="数学归纳分析"><a href="#数学归纳分析" class="headerlink" title="数学归纳分析"></a>数学归纳分析</h2><p>对于有一些简单的算法（比如简单的线性查找算法），我们能够很容易的看到每个算法均能生成正确的结果。但是有时候对于一些复杂的算法，我们对其输出的结果是否正确很难给出准确判断——可能涉及一系列技术。</p><p>循环是重复多次实现的，要证明循环的结果是正确的，就要仿照<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/5155524">数学归纳法</a>的方法，即如这次满足某一性质那么下次也满足，则循环完毕性质也成立（证明循环的每次迭代之前循环不变式为真）——循环不变式证明 。</p><p>代码清单1-1是用C 语言写的sum 函数，功能是求出数组元素之和。参数array[] 是要求和的对象数组，<em>size</em> 是这个数组的元素数。调用sum 函数，会获得array[0] 至array[<em>size</em>-1] 的<em>size</em> 个元素之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (k &lt; size) &#123;<br>    s = s + <span class="hljs-built_in">array</span>[k];<br>    k = k + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>在sum 函数中使用了简单的while 循环语句。从数学归纳法的角度来看这个循环，得出下述断言M(n)，这个断言就是循环不变式：</p><blockquote><p><strong>断言M (n )</strong> ：数组array 的前n 个元素之和，等于变量s 的值。</p></blockquote><p>在程序中成立的断言上标注注释，形成清单1-2 所示代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* M(0) */</span><br>  <span class="hljs-keyword">while</span> (k &lt; size) &#123;<br>    <span class="hljs-comment">/* M(k) */</span><br>    s = s + <span class="hljs-built_in">array</span>[k];<br>    <span class="hljs-comment">/* M(k+1) */</span><br>    k = k + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/* M(k) */</span><br>  &#125;<br>  <span class="hljs-comment">/* M(size) */</span><br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码清单1-2的第4 行，s 初始化为0。由此，第5 行的M(0) 成立。M(0) 即为“数组array 的前0 个元素之和等于变量s 的值”。这相当于数学归纳法的步骤一。</p><h3 id="数学归纳法的步骤一（M-0-成立）"><a href="#数学归纳法的步骤一（M-0-成立）" class="headerlink" title="数学归纳法的步骤一（M(0)成立）"></a>数学归纳法的步骤一（M(0)成立）</h3><p><img src="/2021/02/16/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F/step-1.png" alt="step-1"></p><p>第7 行中，循环的第一次迭代k=0，所以M(k) 成立。然后进行第8 行的处理， 将数组array[k] 的值加入s，因此M(k+1) 成立。这相当于数学归纳法的步骤二。</p><h3 id="数学归纳法的步骤二（M-k-M-k-1-成立）"><a href="#数学归纳法的步骤二（M-k-M-k-1-成立）" class="headerlink" title="数学归纳法的步骤二（M(k) M(k+1)成立）"></a>数学归纳法的步骤二（M(k) M(k+1)成立）</h3><p><img src="/2021/02/16/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F/step-2.png"></p><p>请一定要理解第8 行，s=s+array[k]，意为“在M(k) 成立的前提下，M(k+1) 成立”。第10 行中k 递增1，所以第11 行的M(k) 成立。这里是为了下一步处理而设定变量k的值。</p><p>最后，第13 行的M(size) 成立。因为 while 语句中的 k 递增了1，而这时一直满足M(k)，走到第13 行时 k 和 size 的值相等。M(size) 成立说明sum 函数是没有问题的。因此，第14 行return 返回结果。</p><p><img src="/2021/02/16/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F/step-3.png" alt="step-3"></p><p>综上所述，这个循环在k 从0 增加到size 的过程中一直保持循环不变式M(k) 成立。编写循环时，有两个注意点。一个是“达到目的”，还有一个是“适时结束循环”。循环不变式M(k) 就是为了确保“ 达到目的”。而 k 从0 到size 递增确保了“适时结束循环”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>循环不变式能够帮助我们证明正确性，关于循环不变式，必须证明：</p><ul><li><strong>初始化</strong>：循环的第一次迭代之前，该循环不变式（数学归纳法的“断言”）为真；</li><li><strong>保持</strong>：如果循环的每次迭代之前为真，那么下次迭代之前它仍然为真；</li><li><strong>终止</strong>：循环终止时，当它确实终止时，伴随循环终止的原因，循环不变式为我们提供了一个有用的性质。</li></ul><blockquote><p>证明的最后一条有点晦涩，下次再说</p></blockquote><hr><p>《算法基础》一书中以线性查找算法为例作推理，这一系列的推理其实就是为了说明一个简单循环。但是实际编程中，在写一个简单的循环时，脑海里能够很清楚的浮现出它的循环不变式。</p><p>大多数人认为循环不变式对于理解线性查找这样的简单循环没有必要，但是我们想要理解复杂的循环能够正确的操作时使用循环不变式会很方便。</p><p>《算法基础–打开算法之门》作者Thomas H. Corman；</p><p>百度百科：<a href="https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F/10593291?fr=aladdin%EF%BC%9B">https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F/10593291?fr=aladdin；</a></p><p>图灵社区：<a href="https://www.ituring.com.cn/book/miniarticle/20305%EF%BC%9B">https://www.ituring.com.cn/book/miniarticle/20305；</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>程序设计方法</tag>
      
      <tag>软件系统调试原理技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac安装Wine-6.0</title>
    <link href="/2021/02/16/Mac%E5%AE%89%E8%A3%85Wine-6-0/"/>
    <url>/2021/02/16/Mac%E5%AE%89%E8%A3%85Wine-6-0/</url>
    
    <content type="html"><![CDATA[<h2 id="Mac安装Wine-6-0"><a href="#Mac安装Wine-6-0" class="headerlink" title="Mac安装Wine-6.0"></a>Mac安装Wine-6.0</h2><p>官方网站为MacOS用户提供了二进制安装版本Wine-5.x：<a href="https://www.winehq.org/">https://www.winehq.org/</a></p><p><img src="/2021/02/16/Mac%E5%AE%89%E8%A3%85Wine-6-0/BinaryPackages.png" alt="Wine二进制二进制安装包"></p><p>这个二进制安装包仅适用于仍支持32位应用的MacOS10.8-10.14，高版本MacOS不再为32应用提供支持不必尝试。<a href="https://support.apple.com/en-ca/HT208436">https://support.apple.com/en-ca/HT208436</a></p><h2 id="下载源码解压"><a href="#下载源码解压" class="headerlink" title="下载源码解压"></a>下载源码解压</h2><p><a href="https://dl.winehq.org/wine/source/6.0/wine-6.0.tar.xz">https://dl.winehq.org/wine/source/6.0/wine-6.0.tar.xz</a><br>cd到wine-6.0目录下</p><p><img src="/2021/02/16/Mac%E5%AE%89%E8%A3%85Wine-6-0/wine_dir.png" alt="wine_source_dir"></p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>打开README文件，按照指引安装</p><p><img src="/2021/02/16/Mac%E5%AE%89%E8%A3%85Wine-6-0/README.png" alt="安装指引"></p><p>编译，默认编译为32，目前基本都是64位系统，需要指定64编译</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--enable-win64</span><br></code></pre></td></tr></table></figure><h3 id="解决环境问题"><a href="#解决环境问题" class="headerlink" title="解决环境问题"></a>解决环境问题</h3><p>编译出错，需要升级bison版本，查看原有版本，bison位2.3版本，通过brew安装</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">liaogangwei@<span class="hljs-keyword">bogon </span>wine<span class="hljs-number">-6</span>.<span class="hljs-number">0</span> %<span class="hljs-keyword">bison </span> --version<br><span class="hljs-keyword">bison </span>(GNU <span class="hljs-keyword">Bison) </span><span class="hljs-number">2</span>.<span class="hljs-number">3</span><br><span class="hljs-symbol">configure:</span> error: Your <span class="hljs-keyword">bison </span>version is too old. Please <span class="hljs-keyword">install </span><span class="hljs-keyword">bison </span>version <span class="hljs-number">3</span>.<span class="hljs-number">0</span> <span class="hljs-keyword">or </span>newer.<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">liaogangwei@<span class="hljs-keyword">bogon </span>wine<span class="hljs-number">-6</span>.<span class="hljs-number">0</span> %<span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span><span class="hljs-keyword">bison</span><br><span class="hljs-keyword">...</span><br></code></pre></td></tr></table></figure><p>安装完成后，还是提示同样的错误，没有生效，需要手动替换bison</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">liaogangwei@bogon wine-<span class="hljs-number">6.0</span> %brew list bison<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.7.5/</span>bin/bison<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.7.5/</span>bin/yacc<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.7.5/</span>lib/liby.a<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.7.5/</span>share<span class="hljs-regexp">/aclocal/</span>bison-i18n.m4<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.7.5/</span>share<span class="hljs-regexp">/bison/</span> (<span class="hljs-number">29</span> files)<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.7.5/</span>share<span class="hljs-regexp">/doc/</span> (<span class="hljs-number">50</span> files)<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.7.5/</span>share<span class="hljs-regexp">/info/</span>bison.info<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.7.5/</span>share<span class="hljs-regexp">/man/</span> (<span class="hljs-number">2</span> files)<br></code></pre></td></tr></table></figure><p>安装到/usr/local/Cellar/bison/目录，系统实际运行在/Library/Developer/CommandLineTools/usr/bin目前，备份旧文件，复制新文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">liaogangwei@bogon wine-<span class="hljs-number">6.0</span> %cd <span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/CommandLineTools/u</span>sr/bin<br>liaogangwei@bogon wine-<span class="hljs-number">6.0</span> %ls -l bison<br>-rwxr-xr-x  <span class="hljs-number">1</span> root  wheel  <span class="hljs-number">221200</span> <span class="hljs-number">12</span> <span class="hljs-number">19</span> <span class="hljs-number">15</span>:<span class="hljs-number">44</span> bison<br>liaogangwei@bogon wine-<span class="hljs-number">6.0</span> %mv bison bison_bak<br>mv: rename bison to bison_bak: Permission denied<br>liaogangwei@bogon wine-<span class="hljs-number">6.0</span> %sudo mv bison bison_bak<br>liaogangwei@bogon wine-<span class="hljs-number">6.0</span> %sudo cp <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/Cellar/</span>bison<span class="hljs-regexp">/3.5.3/</span>bin<span class="hljs-regexp">/bison ./</span>bison<br></code></pre></td></tr></table></figure><p>版本更新成功</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">liaogangwei@<span class="hljs-keyword">bogon </span>wine<span class="hljs-number">-6</span>.<span class="hljs-number">0</span> %<span class="hljs-keyword">bison </span>--version<br><span class="hljs-keyword">bison </span>(GNU <span class="hljs-keyword">Bison) </span><span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">5</span><br>Written <span class="hljs-keyword">by </span>Robert Corbett <span class="hljs-keyword">and </span>Richard Stallman.<br></code></pre></td></tr></table></figure><h3 id="正式尝试安装"><a href="#正式尝试安装" class="headerlink" title="正式尝试安装"></a>正式尝试安装</h3><p>重新进行configure：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">liaogangwei<span class="hljs-symbol">@bogon</span> wine<span class="hljs-number">-6.0</span> %./configure --enable-win64<br>...<br>configure: Finished.  <span class="hljs-keyword">Do</span> <span class="hljs-string">&#x27;make&#x27;</span> <span class="hljs-keyword">to</span> compile Wine.<br></code></pre></td></tr></table></figure><p>开始编译安装：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">liaogangwei</span>@bogon wine-<span class="hljs-number">6</span>.<span class="hljs-number">0</span> %make install<br><span class="hljs-attribute">mkdir</span>: /usr/local/lib<span class="hljs-number">64</span>/wine: Permission denied<br><span class="hljs-attribute">mkdir</span>: /usr/local/lib<span class="hljs-number">64</span>/wine: Permission denied<br><span class="hljs-attribute">liaogangwei</span>@bogon wine-<span class="hljs-number">6</span>.<span class="hljs-number">0</span> %<br><span class="hljs-attribute">liaogangwei</span>@bogon wine-<span class="hljs-number">6</span>.<span class="hljs-number">0</span> %<br><span class="hljs-attribute">liaogangwei</span>@bogon wine-<span class="hljs-number">6</span>.<span class="hljs-number">0</span> %sudo make install<br></code></pre></td></tr></table></figure><p>编译时间稍长，需耐心等待。</p><h2 id="安装完成-amp-失败"><a href="#安装完成-amp-失败" class="headerlink" title="安装完成&amp;失败"></a>安装完成&amp;失败</h2><p>尝试</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">liaogangwei</span>@bogon wine-<span class="hljs-number">6</span>.<span class="hljs-number">0</span> %wine<span class="hljs-number">64</span> notepad<br><span class="hljs-attribute">error</span>...<br></code></pre></td></tr></table></figure><p>还有其他一堆问题</p><p><a href="https://www.cnblogs.com/chendeqiang/p/14309515.html">https://www.cnblogs.com/chendeqiang/p/14309515.html</a></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
      <tag>环境搭建</tag>
      
      <tag>软件安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年2月11日我在北京过大年</title>
    <link href="/2021/02/15/2021%E5%B9%B42%E6%9C%8811%E6%97%A5%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC%E8%BF%87%E5%A4%A7%E5%B9%B4/"/>
    <url>/2021/02/15/2021%E5%B9%B42%E6%9C%8811%E6%97%A5%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC%E8%BF%87%E5%A4%A7%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="北京过大年20210211"><a href="#北京过大年20210211" class="headerlink" title="北京过大年20210211"></a>北京过大年20210211</h1><p>今年是我毕业来到北京参加工作的第一年，因为全国新冠疫情的反弹没能回到老家过年。疫情反弹，单位响应号召，全体软开中心人员原则上需留京过年，无特殊情况不允许离京。</p><h2 id="年货大扫荡"><a href="#年货大扫荡" class="headerlink" title="年货大扫荡"></a>年货大扫荡</h2><p>还好我们三十前夕来超市大扫荡，不然这个年估计不太好过！</p><p><img src="/2021/02/15/2021%E5%B9%B42%E6%9C%8811%E6%97%A5%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC%E8%BF%87%E5%A4%A7%E5%B9%B4/IMG_20210210_170305.jpg" alt="年货大扫荡"></p><h2 id="除夕啦，吃年夜饭"><a href="#除夕啦，吃年夜饭" class="headerlink" title="除夕啦，吃年夜饭"></a>除夕啦，吃年夜饭</h2><p>御用大厨们在做饭 😋，我们这儿第一次在北京过年，和老家不一样的是我们把年夜饭准备的很丰盛，老家的话三十晚饭就是一顿饺子汤圆。</p><p><img src="/2021/02/15/2021%E5%B9%B42%E6%9C%8811%E6%97%A5%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC%E8%BF%87%E5%A4%A7%E5%B9%B4/IMG_20210211_190140.jpg" alt="贾总康总准备年夜饭"></p><h2 id="边吃饭，边看春节联欢晚会"><a href="#边吃饭，边看春节联欢晚会" class="headerlink" title="边吃饭，边看春节联欢晚会"></a>边吃饭，边看春节联欢晚会</h2><p>上饭啦！同事家里接视频说我们是不是在地上吃😅。有图有真相，我们真的没有在地上吃，我们在阳台上吃🤣。</p><p><img src="/2021/02/15/2021%E5%B9%B42%E6%9C%8811%E6%97%A5%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC%E8%BF%87%E5%A4%A7%E5%B9%B4/IMG_20210211_185302.jpg" alt="上饭"></p><h2 id="公司年夜饭也不错"><a href="#公司年夜饭也不错" class="headerlink" title="公司年夜饭也不错"></a>公司年夜饭也不错</h2><p>因为疫情不让离京，单位也组织了食堂给我们外地不能回家的员工准备了年夜饭，看着还不错😗</p><p><img src="/2021/02/15/2021%E5%B9%B42%E6%9C%8811%E6%97%A5%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC%E8%BF%87%E5%A4%A7%E5%B9%B4/mmexport1613396939031.jpg" alt="公司年夜饭"></p><p><strong>祝：新年快乐，心想事成！</strong></p>]]></content>
    
    
    <categories>
      
      <category>生活琐事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心得体会</tag>
      
      <tag>趣事</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/Spring%20Security/"/>
    <url>/2021/02/15/Spring%20Security/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p>Spring Security 是 Spring 社区的一个顶级项目，也是 Spring Boot 官方推荐使用的安全框架。除了常规的认证（Authentication）和授权（Authorization）之外，Spring Security还提供了诸如ACLs，LDAP，JAAS，CAS等高级特性以满足复杂场景下的安全需求。</p><p>Spring Security 应用级别的安全主要包含两个主要部分，即<code>登录认证（Authentication）</code>和<code>访问授权（Authorization）</code>，首先用户登录的时候传入【登录信息】，【登录验证器】完成登录认证并将登录认证好的信息存储到【请求上下文】，然后在进行其他操作，如接口访问、方法调用时，权限认证器从上下文中获取登录认证信息，然后根据认证信息获取权限信息，通过权限信息和特定的授权策略决定是否授权。</p><p>接下来，将分别对登录认证和访问授权的执行流程进行剖析，并在最后给出完整的案例实现，结合案例理解登录认证和访问授权的执行原理。</p><h2 id="登录认证（Authentication）"><a href="#登录认证（Authentication）" class="headerlink" title="登录认证（Authentication）"></a>登录认证（Authentication）</h2><h3 id="登录认证过滤器"><a href="#登录认证过滤器" class="headerlink" title="登录认证过滤器"></a>登录认证过滤器</h3><p>如果在继承 WebSecurityConfigurerAdapter 的配置类中的 configure(HttpSecurity http) 方法中有配置 HttpSecurity 的 formLogin，则会返回一个 FormLoginConfigurer 对象。</p><p>如下是一个 Spring Security 的配置样例， formLogin().x.x 就是配置使用<code>内置的登录验证过滤器</code>，默认实现为 <code>UsernamePasswordAuthenticationFilter</code>。</p><p>WebSecurityConfig.java</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableWebSecurity</span><br><span class="hljs-variable">@EnableGlobalMethodSecurity</span>(prePostEnabled = true)<br>public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private UserDetailsService userDetailsService;<br>    <br>    <span class="hljs-variable">@Override</span><br>    public void configure(AuthenticationManagerBuilder auth) throws Exception &#123;<br>        <span class="hljs-comment">// 使用自定义身份验证组件</span><br>        <span class="hljs-selector-tag">auth</span><span class="hljs-selector-class">.authenticationProvider</span>(new JwtAuthenticationProvider(userDetailsService));<br>    &#125;<br>    <br>    @<span class="hljs-selector-tag">Override</span><br>    <span class="hljs-selector-tag">protected</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">configure</span>(HttpSecurity http) <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">Exception</span> &#123;<br>        <span class="hljs-selector-tag">http</span><span class="hljs-selector-class">.cors</span>()<span class="hljs-selector-class">.and</span>()<span class="hljs-selector-class">.csrf</span>()<span class="hljs-selector-class">.disable</span>()<br>            <span class="hljs-selector-class">.authorizeRequests</span>()<br>        <span class="hljs-comment">// 首页和登录页面</span><br>        <span class="hljs-selector-class">.antMatchers</span>(<span class="hljs-string">&quot;/&quot;</span>)<span class="hljs-selector-class">.permitAll</span>()<br>        <span class="hljs-comment">// 其他所有请求需要身份认证</span><br>        <span class="hljs-selector-class">.anyRequest</span>()<span class="hljs-selector-class">.authenticated</span>()<br>        <span class="hljs-comment">// 配置登录认证</span><br>        <span class="hljs-selector-class">.and</span>()<span class="hljs-selector-class">.formLogin</span>()<span class="hljs-selector-class">.loginProcessingUrl</span>(<span class="hljs-string">&quot;/login&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看 HttpSecurity源代码的 formLogion 方法返回一个 <code>FormLoginConfigurer</code> 对象。</p><p>org.springframework.security.config.annotation.web.builders.HttpSecurity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> FormLoginConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">formLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> FormLoginConfigurer&lt;&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>而 FormLoginConfigurer 的构造函数内绑定了一个 <code>UsernamePasswordAuthenticationFilter</code> 过滤器。</p><p>org.springframework.security.config.annotation.web.configurers.FormLoginConfigurer.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">FormLoginConfigurer</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationFilter(), <span class="hljs-literal">null</span>);<br>usernameParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>passwordParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再看 UsernamePasswordAuthenticationFilter 过滤器的构造函数内绑定了 POST 类型的 /login 请求，也就是说，如果配置了 formLogin 的相关信息，那么在使用 POST 类型的 /login URL进行登录的时候就会被这个过滤器拦截，并进行登录验证，登录验证过程我们下面继续分析。</p><p>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">UsernamePasswordAuthenticationFilter</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>查看 UsernamePasswordAuthenticationFilter，发现它继承了 AbstractAuthenticationProcessingFilter</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>AbstractAuthenticationProcessingFilter 中的 doFilter 包含了触发登录认证执行流程的相关逻辑。</p><p>org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void <span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(ServletRequest <span class="hljs-params">req</span>, ServletResponse <span class="hljs-params">res</span>, FilterChain <span class="hljs-params">chain</span>)</span> throws IOException, ServletException &#123;<br>        HttpServletRequest request = (HttpServletRequest)req;<br>        HttpServletResponse response = (HttpServletResponse)res;<br>        <span class="hljs-keyword">if</span> (!this.requires<span class="hljs-constructor">Authentication(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>) &#123;<br>            chain.<span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (this.logger.is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>                this.logger.debug(<span class="hljs-string">&quot;Request is to process authentication&quot;</span>);<br>            &#125;<br><br>            Authentication authResult;<br>            <span class="hljs-keyword">try</span> &#123;<br>                authResult = this.attempt<span class="hljs-constructor">Authentication(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;<br>                <span class="hljs-keyword">if</span> (authResult<span class="hljs-operator"> == </span>null) &#123;<br>                    return;<br>                &#125;<br><br>                this.sessionStrategy.on<span class="hljs-constructor">Authentication(<span class="hljs-params">authResult</span>, <span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;<br>            &#125; catch (InternalAuthenticationServiceException var8) &#123;<br>                this.logger.error(<span class="hljs-string">&quot;An internal error occurred while trying to authenticate the user.&quot;</span>, var8);<br>                this.unsuccessful<span class="hljs-constructor">Authentication(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>, <span class="hljs-params">var8</span>)</span>;<br>                return;<br>            &#125; catch (AuthenticationException var9) &#123;<br>                this.unsuccessful<span class="hljs-constructor">Authentication(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>, <span class="hljs-params">var9</span>)</span>;<br>                return;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (this.continueChainBeforeSuccessfulAuthentication) &#123;<br>                chain.<span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;<br>            &#125;<br><br>            this.successful<span class="hljs-constructor">Authentication(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>, <span class="hljs-params">chain</span>, <span class="hljs-params">authResult</span>)</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面的登录逻辑主要步骤有两个：</p><ol><li><p>attemptAuthentication(request, response)</p><p>这是 AbstractAuthenticationProcessingFilter 中的一个抽象方法，包含登录主逻辑，由其子类实现具体的登录验证，如 UsernamePasswordAuthenticationFilter 是使用表单方式登录的具体实现。如果是非表单登录的方式，如JNDI等其他方式登录的可以通过<code>继承 AbstractAuthenticationProcessingFilter</code> 自定义登录实现。UsernamePasswordAuthenticationFilter 的登录实现逻辑如下。</p></li></ol><p>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Authentication attempt<span class="hljs-constructor">Authentication(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span> throws AuthenticationException &#123;<br>        <span class="hljs-keyword">if</span> (postOnly<span class="hljs-operator"> &amp;&amp; </span>!request.get<span class="hljs-constructor">Method()</span>.equals(<span class="hljs-string">&quot;POST&quot;</span>)) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">AuthenticationServiceException(<span class="hljs-string">&quot;Authentication method not supported: &quot;</span> + <span class="hljs-params">request</span>.<span class="hljs-params">getMethod</span>()</span>);<br>        &#125;<br>　　　　　<span class="hljs-comment">// 获取用户名和密码</span><br>        String username = obtain<span class="hljs-constructor">Username(<span class="hljs-params">request</span>)</span>;<br>        String password = obtain<span class="hljs-constructor">Password(<span class="hljs-params">request</span>)</span>;<br><br>        <span class="hljs-keyword">if</span> (username<span class="hljs-operator"> == </span>null) &#123;<br>            username = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (password<span class="hljs-operator"> == </span>null) &#123;<br>            password = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        username = username.trim<span class="hljs-literal">()</span>;<br><br>        UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UsernamePasswordAuthenticationToken(<span class="hljs-params">username</span>, <span class="hljs-params">password</span>)</span>;<br><br>        <span class="hljs-comment">// Allow subclasses to set the &quot;details&quot; property</span><br>        set<span class="hljs-constructor">Details(<span class="hljs-params">request</span>, <span class="hljs-params">authRequest</span>)</span>;<br><br>        return this.get<span class="hljs-constructor">AuthenticationManager()</span>.authenticate(authRequest);<br>    &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</p><p>登录成功之后，将认证后的 Authentication 对象存储到请求线程上下文，这样在授权阶段就可以获取到 Authentication 认证信息，并利用 Authentication 内的权限信息进行访问控制判断。</p></li></ol><p>org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.java</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">protected</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">successfulAuthentication</span>(HttpServletRequest request,<br>        HttpServletResponse response, FilterChain chain, Authentication authResult)<br>        <span class="hljs-selector-tag">throws</span> <span class="hljs-selector-tag">IOException</span>, <span class="hljs-selector-tag">ServletException</span> &#123;<br><br>    <span class="hljs-selector-tag">if</span> (logger.isDebugEnabled()) &#123;<br>        <span class="hljs-selector-tag">logger</span><span class="hljs-selector-class">.debug</span>(<span class="hljs-string">&quot;Authentication success. Updating SecurityContextHolder to contain: &quot;</span> + authResult);<br>    &#125;<br>　　　　　<span class="hljs-comment">// 登录成功之后，把认证后的 Authentication 对象存储到请求线程上下文，这样在授权阶段就可以获取到此认证信息进行访问控制判断</span><br>    <span class="hljs-selector-tag">SecurityContextHolder</span><span class="hljs-selector-class">.getContext</span>()<span class="hljs-selector-class">.setAuthentication</span>(authResult);<br><br>    <span class="hljs-selector-tag">rememberMeServices</span><span class="hljs-selector-class">.loginSuccess</span>(request, response, authResult);<br><br>    <span class="hljs-comment">// Fire event</span><br>    <span class="hljs-selector-tag">if</span> (this.eventPublisher != null) &#123;<br>        <span class="hljs-selector-tag">eventPublisher</span><span class="hljs-selector-class">.publishEvent</span>(new InteractiveAuthenticationSuccessEvent(<br>                authResult, this.getClass()));<br>    &#125;<br><br>    <span class="hljs-selector-tag">successHandler</span><span class="hljs-selector-class">.onAuthenticationSuccess</span>(request, response, authResult);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的登录逻辑我们可以看到，Spring Security的登录认证过程是委托给 AuthenticationManager 完成的，它先是解析出用户名和密码，然后把用户名和密码封装到一个UsernamePasswordAuthenticationToken 中，传递给 AuthenticationManager，交由 AuthenticationManager 完成实际的登录认证过程。</p><p>package org.springframework.security.authentication.AuthenticationManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.security.authentication;<br><br><span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<br><span class="hljs-keyword">import</span> org.springframework.security.core.AuthenticationException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> \* Processes an &#123;<span class="hljs-doctag">@link</span> Authentication&#125; request.</span><br><span class="hljs-comment"> \* <span class="hljs-doctag">@author</span> Ben Alex</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationManager</span> </span>&#123;<br><br><span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>AuthenticationManager 提供了一个默认的 实现 ProviderManager，而 ProviderManager 又将验证委托给了 AuthenticationProvider。</p><p>ProviderManager.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> Authentication authenticate(Authentication authentication)<br>        <span class="hljs-keyword">throws</span> AuthenticationException &#123;<br>　　　　　...　　 <span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;<br>        <span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-keyword">try</span> &#123;<br>            result = provider.authenticate(authentication);<br>            <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>                copyDetails(authentication, result);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;　　　　 ...<br>&#125;<br></code></pre></td></tr></table></figure><p>根据验证方式的多样化，AuthenticationProvider 衍生出多种类型的实现，AbstractUserDetailsAuthenticationProvider 是 AuthenticationProvider 的抽象实现，定义了较为统一的验证逻辑，各种验证方式可以选择直接继承 AbstractUserDetailsAuthenticationProvider 完成登录认证，如 DaoAuthenticationProvider 就是继承了此抽象类，完成了从DAO方式获取验证需要的用户信息的。</p><p>AbstractUserDetailsAuthenticationProvider.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;<span class="hljs-comment">// Determine username</span><br>        String username = (authentication.get<span class="hljs-constructor">Principal()</span><span class="hljs-operator"> == </span>null) ? <span class="hljs-string">&quot;NONE_PROVIDED&quot;</span> : authentication.get<span class="hljs-constructor">Name()</span>;<br>        boolean cacheWasUsed = <span class="hljs-literal">true</span>;<br>        UserDetails user = this.userCache.get<span class="hljs-constructor">UserFromCache(<span class="hljs-params">username</span>)</span>;<br>        <span class="hljs-keyword">if</span> (user<span class="hljs-operator"> == </span>null) &#123;<br>            cacheWasUsed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;　　　　　　　　　 <span class="hljs-comment">// 子类根据自身情况从指定的地方加载认证需要的用户信息</span><br>                user = retrieve<span class="hljs-constructor">User(<span class="hljs-params">username</span>, (UsernamePasswordAuthenticationToken)</span> authentication);<br>            &#125;<br>            ...<span class="hljs-keyword">try</span> &#123;　　　　　　　<span class="hljs-comment">// 前置检查，一般是检查账号状态，如是否锁定之类</span><br>            preAuthenticationChecks.check(user);　　　　　　　<span class="hljs-comment">// 进行一般逻辑认证，如 DaoAuthenticationProvider 实现中的密码验证就是在这里完成的</span><br>            additional<span class="hljs-constructor">AuthenticationChecks(<span class="hljs-params">user</span>, (UsernamePasswordAuthenticationToken)</span> authentication);<br>        &#125;<br>        ...<br>　　　　 <span class="hljs-comment">//　后置检查，如可以检查密码是否过期之类</span><br>        postAuthenticationChecks.check(user);<br><br><span class="hljs-operator">　　　　 ...　　　　　</span><span class="hljs-comment">// 验证成功之后返回包含完整认证信息的 Authentication 对象</span><br>        return create<span class="hljs-constructor">SuccessAuthentication(<span class="hljs-params">principalToReturn</span>, <span class="hljs-params">authentication</span>, <span class="hljs-params">user</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如上面所述， AuthenticationProvider 通过 retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) 获取验证信息，对于我们一般所用的 DaoAuthenticationProvider 是由 UserDetailsService 专门负责获取验证信息的。</p><p>DaoAuthenticationProvider.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-function">UserDetails <span class="hljs-title">retrieveUser</span><span class="hljs-params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        UserDetails loadedUser = <span class="hljs-keyword">this</span>.getUserDetailsService().loadUserByUsername(username);<br>        <span class="hljs-keyword">if</span> (loadedUser == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalAuthenticationServiceException(<span class="hljs-string">&quot;UserDetailsService returned null, which is an interface contract violation&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> loadedUser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>UserDetailsService 接口只有一个方法，loadUserByUsername(String username)，一般需要我们实现此接口方法，根据用户名加载登录认证和访问授权所需要的信息，并返回一个 UserDetails的实现类，后面登录认证和访问授权都需要用到此中的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Locates the user based on the username. In the actual implementation, the search</span><br><span class="hljs-comment">     * may possibly be case sensitive, or case insensitive depending on how the</span><br><span class="hljs-comment">     * implementation instance is configured. In this case, the &lt;code&gt;UserDetails&lt;/code&gt;</span><br><span class="hljs-comment">     * object that comes back may have a username that is of a different case than what</span><br><span class="hljs-comment">     * was actually requested..</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username the username identifying the user whose data is required.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a fully populated user record (never &lt;code&gt;null&lt;/code&gt;)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> UsernameNotFoundException if the user could not be found or the user has no</span><br><span class="hljs-comment">     * GrantedAuthority</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>UserDetails 提供了一个默认实现 User，主要包含用户名（username）、密码(password)、权限（authorities）和一些账号或密码状态的标识。</p><p>如果默认实现满足不了你的需求，可以根据需求定制自己的 UserDetails，然后在 UserDetailsService 的 loadUserByUsername 中返回即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span>, <span class="hljs-title">CredentialsContainer</span> </span>&#123;<span class="hljs-comment">// ~ Instance fields</span><br>    <span class="hljs-comment">// ================================================================================================</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;GrantedAuthority&gt; authorities;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accountNonExpired;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accountNonLocked;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> credentialsNonExpired;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> enabled;<br><br>    <span class="hljs-comment">// ~ Constructors</span><br>    <span class="hljs-comment">// ===================================================================================================</span><br>    <span class="hljs-keyword">public</span> User(<span class="hljs-keyword">String</span> username, <span class="hljs-keyword">String</span> password,<br>            Collection<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> GrantedAuthority&gt; authorities) &#123;<br>        this(username, password, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, authorities);<br>    &#125;　　 ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><p>Spring Security 提供了一个默认的登出过滤器 LogoutFilter，默认拦截路径是 /logout，当访问 /logout 路径的时候，LogoutFilter 会进行退出处理。</p><p>LogoutFilter.java</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> org.springframework.security.web.authentication.logout;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogoutFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;<br><br>    <span class="hljs-comment">// ~ Instance fields</span><br>    <span class="hljs-comment">// ================================================================================================</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">RequestMatcher</span> logoutRequestMatcher;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LogoutHandler</span> handler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LogoutSuccessHandler</span> logoutSuccessHandler;<br><br>    <span class="hljs-comment">// ~ Constructors</span><br>    <span class="hljs-comment">// ===================================================================================================</span><br>    public <span class="hljs-type">LogoutFilter</span>(<span class="hljs-type">LogoutSuccessHandler</span> logoutSuccessHandler,<br>            <span class="hljs-type">LogoutHandler</span>... handlers) &#123;<br>        <span class="hljs-keyword">this</span>.handler = <span class="hljs-keyword">new</span> <span class="hljs-type">CompositeLogoutHandler</span>(handlers);<br>        <span class="hljs-type">Assert</span>.notNull(logoutSuccessHandler, <span class="hljs-string">&quot;logoutSuccessHandler cannot be null&quot;</span>);<br>        <span class="hljs-keyword">this</span>.logoutSuccessHandler = logoutSuccessHandler;<br>        setFilterProcessesUrl(<span class="hljs-string">&quot;/logout&quot;</span>);　　<span class="hljs-comment">// 绑定 /logout</span><br>    &#125;<span class="hljs-comment">// ~ Methods</span><br>    <span class="hljs-comment">// ========================================================================================================</span><br>    public void doFilter(<span class="hljs-type">ServletRequest</span> req, <span class="hljs-type">ServletResponse</span> res, <span class="hljs-type">FilterChain</span> chain)<br>            <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span>, <span class="hljs-type">ServletException</span> &#123;<br>        <span class="hljs-type">HttpServletRequest</span> request = (<span class="hljs-type">HttpServletRequest</span>) req;<br>        <span class="hljs-type">HttpServletResponse</span> response = (<span class="hljs-type">HttpServletResponse</span>) res;<br><br>        <span class="hljs-keyword">if</span> (requiresLogout(request, response)) &#123;<br>            <span class="hljs-type">Authentication</span> auth = <span class="hljs-type">SecurityContextHolder</span>.getContext().getAuthentication();<span class="hljs-keyword">this</span>.handler.logout(request, response, auth);　　<span class="hljs-comment">// 登出处理，可能包含session、cookie、认证信息的清理工作</span><br><br>            logoutSuccessHandler.onLogoutSuccess(request, response, auth);　　<span class="hljs-comment">// 退出后的操作，可能是跳转、返回成功状态等</span><br><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        chain.doFilter(request, response);<br>    &#125;<br><br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如下是 SecurityContextLogoutHandler 中的登出处理实现。</p><p>SecurityContextLogoutHandler.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void logout(HttpServletRequest request, HttpServletResponse response,<br>        Authentication authentication) &#123;<br>    <span class="hljs-comment">// 让 session 失效　if (invalidateHttpSession) &#123;</span><br>        HttpSession session = request.get<span class="hljs-constructor">Session(<span class="hljs-params">false</span>)</span>;<br>        <span class="hljs-keyword">if</span> (session != null) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Invalidating session: &quot;</span> + session.get<span class="hljs-constructor">Id()</span>);<br>            session.invalidate<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>　　　　　<span class="hljs-comment">// 清理 Security 上下文，其中包含登录认证信息</span><br>    <span class="hljs-keyword">if</span> (clearAuthentication) &#123;<br>        SecurityContext context = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityContextHolder</span>.</span></span>get<span class="hljs-constructor">Context()</span>;<br>        context.set<span class="hljs-constructor">Authentication(<span class="hljs-params">null</span>)</span>;<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityContextHolder</span>.</span></span>clear<span class="hljs-constructor">Context()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="访问授权（Authorization）"><a href="#访问授权（Authorization）" class="headerlink" title="访问授权（Authorization）"></a>访问授权（Authorization）</h2><p>访问授权主要分为两种：通过URL方式的接口访问控制和方法调用的权限控制。</p><h3 id="接口访问授权"><a href="#接口访问授权" class="headerlink" title="接口访问授权"></a>接口访问授权</h3><p>在通过比如浏览器使用URL访问后台接口时，是否允许访问此URL，就是接口访问权限。</p><p>在进行接口访问时，会由 FilterSecurityInterceptor 进行拦截并进行授权。</p><p>FilterSecurityInterceptor 继承了 AbstractSecurityInterceptor 并实现了 javax.servlet.Filter 接口， 所以在URL访问的时候都会被过滤器拦截，doFilter 实现如下。</p><p>FilterSecurityInterceptor.java</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">public</span> void <span class="hljs-keyword">do</span><span class="hljs-built_in">Filter</span>(ServletRequest <span class="hljs-built_in">request</span>, ServletResponse <span class="hljs-built_in">response</span>,<br>        FilterChain chain) throws IOException, ServletException &#123;<br>    FilterInvocation fi = <span class="hljs-keyword">new</span> FilterInvocation(<span class="hljs-built_in">request</span>, <span class="hljs-built_in">response</span>, chain);<br>    invoke(fi);<br>&#125;<br></code></pre></td></tr></table></figure><p>doFilter 方法又调用了自身的 invoke 方法， invoke 方法又调用了父类 AbstractSecurityInterceptor 的 beforeInvocation 方法。</p><p>FilterSecurityInterceptor.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void invoke(FilterInvocation fi) throws IOException, ServletException &#123;<br>    <span class="hljs-keyword">if</span> ((fi.get<span class="hljs-constructor">Request()</span> != null)<br><span class="hljs-operator">            &amp;&amp; </span>(fi.get<span class="hljs-constructor">Request()</span>.get<span class="hljs-constructor">Attribute(FILTER_APPLIED)</span> != null)<br><span class="hljs-operator">            &amp;&amp; </span>observeOncePerRequest) &#123;<br>        <span class="hljs-comment">// filter already applied to this request and user wants us to observe</span><br>        <span class="hljs-comment">// once-per-request handling, so don&#x27;t re-do security checking</span><br>        fi.get<span class="hljs-constructor">Chain()</span>.<span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(<span class="hljs-params">fi</span>.<span class="hljs-params">getRequest</span>()</span>, fi.get<span class="hljs-constructor">Response()</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// first time this request being called, so perform security checking</span><br>        <span class="hljs-keyword">if</span> (fi.get<span class="hljs-constructor">Request()</span> != null<span class="hljs-operator"> &amp;&amp; </span>observeOncePerRequest) &#123;<br>            fi.get<span class="hljs-constructor">Request()</span>.set<span class="hljs-constructor">Attribute(FILTER_APPLIED, Boolean.TRUE)</span>;<br>        &#125;<br><br>        InterceptorStatusToken token = super.before<span class="hljs-constructor">Invocation(<span class="hljs-params">fi</span>)</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            fi.get<span class="hljs-constructor">Chain()</span>.<span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(<span class="hljs-params">fi</span>.<span class="hljs-params">getRequest</span>()</span>, fi.get<span class="hljs-constructor">Response()</span>);<br>        &#125;<br>        finally &#123;<br>            super.finally<span class="hljs-constructor">Invocation(<span class="hljs-params">token</span>)</span>;<br>        &#125;<br><br>        super.after<span class="hljs-constructor">Invocation(<span class="hljs-params">token</span>, <span class="hljs-params">null</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法调用授权"><a href="#方法调用授权" class="headerlink" title="方法调用授权"></a>方法调用授权</h3><p>在进行后台方法调用时，是否允许该方法调用，就是方法调用权限。比如在方法上添加了此类注解 @PreAuthorize(“hasRole(‘ROLE_ADMIN’)”) ，Security 方法注解的支持需要在任何配置类中（如 WebSecurityConfigurerAdapter ）添加 @EnableGlobalMethodSecurity(prePostEnabled = true) 开启，才能够使用。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableWebSecurity</span><br><span class="hljs-variable">@EnableGlobalMethodSecurity</span>(prePostEnabled = true)<br>public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在进行方法调用时，会由 MethodSecurityInterceptor 进行拦截并进行授权。</p><p>MethodSecurityInterceptor 继承了 AbstractSecurityInterceptor 并实现了AOP 的 org.aopalliance.intercept.MethodInterceptor 接口， 所以可以在方法调用时进行拦截。</p><p>MethodSecurityInterceptor .java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    InterceptorStatusToken token = <span class="hljs-keyword">super</span>.beforeInvocation(mi);<br><br>    Object result;<br>    <span class="hljs-keyword">try</span> &#123;<br>        result = mi.<span class="hljs-keyword">proceed</span>();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">super</span>.finallyInvocation(token);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">afterInvocation</span><span class="hljs-params">(token, result)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到，MethodSecurityInterceptor 跟 FilterSecurityInterceptor 一样， 都是通过调用父类 AbstractSecurityInterceptor 的相关方法完成授权，其中 beforeInvocation 是完成权限认证的关键。</p><p>AbstractSecurityInterceptor.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> InterceptorStatusToken <span class="hljs-function"><span class="hljs-title">beforeInvocation</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> <span class="hljs-built_in">object</span></span>)</span> &#123;<br>        ...<br>　　　　　<span class="hljs-comment">// 通过 SecurityMetadataSource 获取权限配置信息，可以定制实现自己的权限信息获取逻辑</span><br>        Collection&lt;ConfigAttribute&gt; attributes = <span class="hljs-built_in">this</span>.obtainSecurityMetadataSource().getAttributes(<span class="hljs-built_in">object</span>);<br><br>　　　　　...　　　　　<span class="hljs-comment">// 确认是否经过登录认证　　　　　</span><br>        Authentication authenticated = authenticateIfRequired();<br><br>        <span class="hljs-comment">// Attempt authorization</span><br>        <span class="hljs-keyword">try</span> &#123;　　　　　　  <span class="hljs-comment">// 通过 AccessDecisionManager 完成授权认证，默认实现是 AffirmativeBased</span><br>            <span class="hljs-built_in">this</span>.accessDecisionManager.decide(authenticated, <span class="hljs-built_in">object</span>, attributes);<br>        &#125;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面代码显示 AbstractSecurityInterceptor 又是委托授权认证器 AccessDecisionManager 完成授权认证，默认实现是 AffirmativeBased， decide 方法实现如下。</p><p>AffirmativeBased.java</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decide</span>(<span class="hljs-params">Authentication authentication, Object <span class="hljs-built_in">object</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">            Collection&lt;ConfigAttribute&gt; configAttributes</span>) throws AccessDeniedException</span> &#123;<br>        <span class="hljs-built_in">int</span> deny = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;　　　　　　　　　 <span class="hljs-comment">// 通过各种投票策略，最终决定是否授权　</span><br>            <span class="hljs-built_in">int</span> result = voter.vote(authentication, <span class="hljs-built_in">object</span>, configAttributes);<br><span class="hljs-keyword">switch</span> (result) &#123;<br>            <span class="hljs-keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:<br>                deny++;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-literal">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>　　　　...<br>    &#125;<br></code></pre></td></tr></table></figure><p>而 AccessDecisionManager 决定授权又是通过一个授权策略集合（AccessDecisionVoter ）决定的，授权决定的原则是：</p><ol><li><p>遍历所有授权策略， 如果有其中一个返回 ACCESS_GRANTED，则同意授权。</p></li><li><p>否则，等待遍历结束，统计 ACCESS_DENIED 个数，只要拒绝数大于1，则不同意授权。</p><p>对于接口访问授权，也就是 FilterSecurityInterceptor 管理的URL授权，默认对应的授权策略只有一个，就是 WebExpressionVoter，它的授权策略主要是根据 WebSecurityConfigurerAdapter 内配置的路径访问策略进行匹配，然后决定是否授权。</p></li></ol><p>WebExpressionVoter.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Voter which handles web authorisation decisions.</span><br><span class="hljs-comment"> * @author Luke Taylor</span><br><span class="hljs-comment"> * @since 3.0</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> WebExpressionVoter implements AccessDecisionVoter&lt;FilterInvocation&gt; &#123;<br>    <span class="hljs-keyword">private</span> SecurityExpressionHandler&lt;FilterInvocation&gt; expressionHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultWebSecurityExpressionHandler()</span>;<br><br>    public <span class="hljs-built_in">int</span> vote(Authentication authentication, FilterInvocation fi,<br>            Collection&lt;ConfigAttribute&gt; attributes) &#123;<br>        <span class="hljs-keyword">assert</span> authentication != null;<br>        <span class="hljs-keyword">assert</span> fi != null;<br>        <span class="hljs-keyword">assert</span> attributes != null;<br><br>        WebExpressionConfigAttribute weca = find<span class="hljs-constructor">ConfigAttribute(<span class="hljs-params">attributes</span>)</span>;<br><br>        <span class="hljs-keyword">if</span> (weca<span class="hljs-operator"> == </span>null) &#123;<br>            return ACCESS_ABSTAIN;<br>        &#125;<br><br>        EvaluationContext ctx = expressionHandler.create<span class="hljs-constructor">EvaluationContext(<span class="hljs-params">authentication</span>, <span class="hljs-params">fi</span>)</span>;<br>        ctx = weca.post<span class="hljs-constructor">Process(<span class="hljs-params">ctx</span>, <span class="hljs-params">fi</span>)</span>;<br><br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExpressionUtils</span>.</span></span>evaluate<span class="hljs-constructor">AsBoolean(<span class="hljs-params">weca</span>.<span class="hljs-params">getAuthorizeExpression</span>()</span>, ctx) ? ACCESS_GRANTED : ACCESS_DENIED;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>对于方法调用授权，在全局方法安全配置类里，可以看到给 MethodSecurityInterceptor 默认配置的有 RoleVoter、AuthenticatedVoter、Jsr250Voter、和 PreInvocationAuthorizationAdviceVoter，其中 Jsr250Voter、PreInvocationAuthorizationAdviceVoter 都需要打开指定的开关，才会添加支持。</p><p>GlobalMethodSecurityConfiguration.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Configuration<br>public <span class="hljs-keyword">class</span> GlobalMethodSecurityConfiguration implements ImportAware, SmartInitializingSingleton &#123;<br>    ...<span class="hljs-keyword">private</span> MethodSecurityInterceptor methodSecurityInterceptor;<br>        　　@Bean<br>    public MethodInterceptor <span class="hljs-keyword">method</span><span class="hljs-constructor">SecurityInterceptor()</span> throws Exception &#123;<br>        this.methodSecurityInterceptor = is<span class="hljs-constructor">AspectJ()</span><br>                ? <span class="hljs-keyword">new</span> <span class="hljs-constructor">AspectJMethodSecurityInterceptor()</span><br>                : <span class="hljs-keyword">new</span> <span class="hljs-constructor">MethodSecurityInterceptor()</span>;<br>        methodSecurityInterceptor.set<span class="hljs-constructor">AccessDecisionManager(<span class="hljs-params">accessDecisionManager</span>()</span>);<br>        methodSecurityInterceptor.set<span class="hljs-constructor">AfterInvocationManager(<span class="hljs-params">afterInvocationManager</span>()</span>);<br>        methodSecurityInterceptor<br>                .set<span class="hljs-constructor">SecurityMetadataSource(<span class="hljs-params">methodSecurityMetadataSource</span>()</span>);<br>        RunAsManager runAsManager = run<span class="hljs-constructor">AsManager()</span>;<br>        <span class="hljs-keyword">if</span> (runAsManager != null) &#123;<br>            methodSecurityInterceptor.set<span class="hljs-constructor">RunAsManager(<span class="hljs-params">runAsManager</span>)</span>;<br>        &#125;<br><br>        return this.methodSecurityInterceptor;<br>    &#125;<br>    <br>    protected AccessDecisionManager access<span class="hljs-constructor">DecisionManager()</span> &#123;<br>        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters = <span class="hljs-keyword">new</span> ArrayList&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt;<span class="hljs-literal">()</span>;<br>        ExpressionBasedPreInvocationAdvice expressionAdvice = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ExpressionBasedPreInvocationAdvice()</span>;<br>        expressionAdvice.set<span class="hljs-constructor">ExpressionHandler(<span class="hljs-params">getExpressionHandler</span>()</span>);<br>        <span class="hljs-keyword">if</span> (pre<span class="hljs-constructor">PostEnabled()</span>) &#123;<br>            decisionVoters<br>                    .add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">PreInvocationAuthorizationAdviceVoter(<span class="hljs-params">expressionAdvice</span>)</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (jsr250<span class="hljs-constructor">Enabled()</span>) &#123;<br>            decisionVoters.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Jsr250Voter()</span>);<br>        &#125;<br>        decisionVoters.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">RoleVoter()</span>);<br>        decisionVoters.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">AuthenticatedVoter()</span>);<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">AffirmativeBased(<span class="hljs-params">decisionVoters</span>)</span>;<br>    &#125;　　...&#125;<br></code></pre></td></tr></table></figure><p>RoleVoter 是根据角色进行匹配授权的策略。</p><p>RoleVoter.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleVoter</span> <span class="hljs-title">implements</span> <span class="hljs-title">AccessDecisionVoter</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<br>　　 <span class="hljs-comment">// RoleVoter  默认角色名以 &quot;ROLE_&quot; 为前缀。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> rolePrefix = <span class="hljs-string">&quot;ROLE_&quot;</span>;<span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">supports</span>(<span class="hljs-params">ConfigAttribute attribute</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> ((attribute.getAttribute() != <span class="hljs-literal">null</span>)<br>                &amp;&amp; attribute.getAttribute().startsWith(getRolePrefix())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">public</span> int vote(Authentication authentication, <span class="hljs-built_in">Object</span> <span class="hljs-built_in">object</span>,<br>            Collection&lt;ConfigAttribute&gt; attributes) &#123;<br>        <span class="hljs-keyword">if</span>(authentication == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ACCESS_DENIED;<br>        &#125;<br>        int result = ACCESS_ABSTAIN;<br>        Collection&lt;? <span class="hljs-keyword">extends</span> GrantedAuthority&gt; authorities = extractAuthorities(authentication);<br>　　　　　<span class="hljs-comment">// 逐个角色进行匹配，入股有一个匹配得上，则进行授权</span><br>        <span class="hljs-keyword">for</span> (ConfigAttribute attribute : attributes) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.supports(attribute)) &#123;<br>                result = ACCESS_DENIED;<br>                <span class="hljs-comment">// Attempt to find a matching granted authority</span><br>                <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;<br>                    <span class="hljs-keyword">if</span> (attribute.getAttribute().equals(authority.getAuthority())) &#123;<br>                        <span class="hljs-keyword">return</span> ACCESS_GRANTED;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    Collection&lt;? <span class="hljs-keyword">extends</span> GrantedAuthority&gt; <span class="hljs-function"><span class="hljs-title">extractAuthorities</span>(<span class="hljs-params">Authentication authentication</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> authentication.getAuthorities();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AuthenticatedVoter 主要是针对有配置以下几个属性来决定授权的策略。</p><p>IS_AUTHENTICATED_REMEMBERED：记住我登录状态</p><p>IS_AUTHENTICATED_ANONYMOUSLY：匿名认证状态</p><p>IS_AUTHENTICATED_FULLY： 完全登录状态，即非上面两种类型</p><p>AuthenticatedVoter.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span> vote(Authentication authentication, Object <span class="hljs-keyword">object</span>,<br>            Collection&lt;ConfigAttribute&gt; attributes) &#123;<br>        <span class="hljs-built_in">int</span> result = ACCESS_ABSTAIN;<br><br>        <span class="hljs-keyword">for</span> (ConfigAttribute attribute : attributes) &#123;<br>            <span class="hljs-keyword">if</span> (this.supports(attribute)) &#123;<br>                result = ACCESS_DENIED;<br>　　　　　　　　　　<span class="hljs-comment">// 完全登录状态</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IS_AUTHENTICATED_FULLY</span>.</span></span>equals(attribute.get<span class="hljs-constructor">Attribute()</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">FullyAuthenticated(<span class="hljs-params">authentication</span>)</span>) &#123;<br>                        return ACCESS_GRANTED;<br>                    &#125;<br>                &#125;<br>　　　　　　　　　 <span class="hljs-comment">// 记住我登录状态</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IS_AUTHENTICATED_REMEMBERED</span>.</span></span>equals(attribute.get<span class="hljs-constructor">Attribute()</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (authenticationTrustResolver.is<span class="hljs-constructor">RememberMe(<span class="hljs-params">authentication</span>)</span><br><span class="hljs-operator">                            || </span>is<span class="hljs-constructor">FullyAuthenticated(<span class="hljs-params">authentication</span>)</span>) &#123;<br>                        return ACCESS_GRANTED;<br>                    &#125;<br>                &#125;<br>　　　　　　　　　 <span class="hljs-comment">// 匿名登录状态</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IS_AUTHENTICATED_ANONYMOUSLY</span>.</span></span>equals(attribute.get<span class="hljs-constructor">Attribute()</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (authenticationTrustResolver.is<span class="hljs-constructor">Anonymous(<span class="hljs-params">authentication</span>)</span><br><span class="hljs-operator">                            || </span>is<span class="hljs-constructor">FullyAuthenticated(<span class="hljs-params">authentication</span>)</span><br><span class="hljs-operator">                            || </span>authenticationTrustResolver.is<span class="hljs-constructor">RememberMe(<span class="hljs-params">authentication</span>)</span>) &#123;<br>                        return ACCESS_GRANTED;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>PreInvocationAuthorizationAdviceVoter 是针对类似 @PreAuthorize(“hasRole(‘ROLE_ADMIN’)”) 注解解析并进行授权的策略。</p><p>PreInvocationAuthorizationAdviceVoter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreInvocationAuthorizationAdviceVoter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionVoter</span>&lt;<span class="hljs-title">MethodInvocation</span>&gt; </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PreInvocationAuthorizationAdvice preAdvice;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vote</span><span class="hljs-params">(Authentication authentication, MethodInvocation method,</span></span><br><span class="hljs-function"><span class="hljs-params">            Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;<br><br>        PreInvocationAttribute preAttr = findPreInvocationAttribute(attributes);<br><br>        <span class="hljs-keyword">if</span> (preAttr == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// No expression based metadata, so abstain</span><br>            <span class="hljs-keyword">return</span> ACCESS_ABSTAIN;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span> allowed = preAdvice.before(authentication, method, preAttr);<br><br>        <span class="hljs-keyword">return</span> allowed ? ACCESS_GRANTED : ACCESS_DENIED;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> PreInvocationAttribute <span class="hljs-title">findPreInvocationAttribute</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            Collection&lt;ConfigAttribute&gt; config)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (ConfigAttribute attribute : config) &#123;<br>            <span class="hljs-keyword">if</span> (attribute <span class="hljs-keyword">instanceof</span> PreInvocationAttribute) &#123;<br>                <span class="hljs-keyword">return</span> (PreInvocationAttribute) attribute;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PreInvocationAuthorizationAdviceVoter 解析出注解属性配置， 然后通过调用 PreInvocationAuthorizationAdvice 的前置通知方法进行授权认证，默认实现类似 ExpressionBasedPreInvocationAdvice，通知内主要进行了内容的过滤和权限表达式的匹配。</p><p>ExpressionBasedPreInvocationAdvice.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ExpressionBasedPreInvocationAdvice implements PreInvocationAuthorizationAdvice &#123;<br>    <span class="hljs-keyword">private</span> MethodSecurityExpressionHandler expressionHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultMethodSecurityExpressionHandler()</span>;<br><br>    public boolean before(Authentication authentication, MethodInvocation mi, PreInvocationAttribute attr) &#123;<br>        PreInvocationExpressionAttribute preAttr = (PreInvocationExpressionAttribute) attr;<br>        EvaluationContext ctx = expressionHandler.create<span class="hljs-constructor">EvaluationContext(<span class="hljs-params">authentication</span>, <span class="hljs-params">mi</span>)</span>;<br>        Expression preFilter = preAttr.get<span class="hljs-constructor">FilterExpression()</span>;<br>        Expression preAuthorize = preAttr.get<span class="hljs-constructor">AuthorizeExpression()</span>;<br><br>        <span class="hljs-keyword">if</span> (preFilter != null) &#123;<br>            Object filterTarget = find<span class="hljs-constructor">FilterTarget(<span class="hljs-params">preAttr</span>.<span class="hljs-params">getFilterTarget</span>()</span>, ctx, mi);<br>            expressionHandler.filter(filterTarget, preFilter, ctx);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (preAuthorize<span class="hljs-operator"> == </span>null) &#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExpressionUtils</span>.</span></span>evaluate<span class="hljs-constructor">AsBoolean(<span class="hljs-params">preAuthorize</span>, <span class="hljs-params">ctx</span>)</span>;<br>    &#125;<br><br>　　...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h2><p>接下来，我们以一个实现案例来进行说明讲解。</p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>新建一个 Spring Boot 项目 springboot-spring-security。</p><p>![img](Spring Security/1-20181128154034209-1921752671.png)</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>添加项目依赖，主要是 Spring Security 和 JWT，另外添加 Swagger 和 fastjson 作为辅助工具。</p><p>pom.xml</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="xml">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>top.ivan.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-spring-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot-spring-security<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.spring.version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.spring.version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">swagger.version</span>&gt;</span>2.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">swagger.version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">jwt.version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">jwt.version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">fastjson.version</span>&gt;</span>1.2.48<span class="hljs-tag">&lt;/<span class="hljs-name">fastjson.version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="xml">           <span class="hljs-comment">&lt;!-- spring boot --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- swagger --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;swagger.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;swagger.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- spring security --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- jwt --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;jwt.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- fastjson --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;fastjson.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>启动类没什么，主要开启以下包扫描。</p><p>SpringSecurityApplication.java</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">package</span> com.citibank.springboot.spring.security;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">@SpringBootApplication</span><br><span class="hljs-keyword">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;com.louis.springboot&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SpringSecurityApplication &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        SpringApplication.run(SpringSecurityApplication.<span class="hljs-keyword">class</span>, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="跨域配置类"><a href="#跨域配置类" class="headerlink" title="跨域配置类"></a>跨域配置类</h3><p>跨域配置类，不多说，都懂得。</p><p>CorsConfig.java</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">package com.citibank.springboot.spring.security.config;<br><br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.web.servlet.config.annotation.CorsRegistry;<br>import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br>/**<br> * 跨域配置<br> */<br>@Configuration<br>public class CorsConfig implements WebMvcConfigurer &#123;<br><br>    @Override<br>    public void addCorsMappings(CorsRegistry registry) &#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)    // 允许跨域访问的路径<br>        .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)    // 允许跨域访问的源<br>        .allowedMethods(<span class="hljs-string">&quot;<span class="hljs-keyword">POST</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">PUT</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">OPTIONS</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">DELETE</span>&quot;</span>)    // 允许请求方法<br>        .maxAge(<span class="hljs-number">168000</span>)    // 预检间隔时间<br>        .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)  // 允许头部设置<br>        .allowCredentials(true);    // 是否发送cookie<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Swagger配置类"><a href="#Swagger配置类" class="headerlink" title="Swagger配置类"></a>Swagger配置类</h3><p>Swagger配置类，除了常规配置外，加了一个令牌属性，可以在接口调用的时候传递令牌。</p><p>SwaggerConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.citibank.springboot.spring.security.config;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.ParameterBuilder;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.PathSelectors;<br><span class="hljs-keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;<br><span class="hljs-keyword">import</span> springfox.documentation.schema.ModelRef;<br><span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<br><span class="hljs-keyword">import</span> springfox.documentation.service.Parameter;<br><span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<br><span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Swagger配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 添加请求参数，我们这里把token作为请求头部参数传入后端</span><br>        ParameterBuilder parameterBuilder = <span class="hljs-keyword">new</span> ParameterBuilder();<br>        List&lt;Parameter&gt; parameters = <span class="hljs-keyword">new</span> ArrayList&lt;Parameter&gt;();<br>        parameterBuilder.name(<span class="hljs-string">&quot;Authorization&quot;</span>).description(<span class="hljs-string">&quot;令牌&quot;</span>).modelRef(<span class="hljs-keyword">new</span> ModelRef(<span class="hljs-string">&quot;string&quot;</span>)).parameterType(<span class="hljs-string">&quot;header&quot;</span>)<br>                .required(<span class="hljs-keyword">false</span>).build();<br>        parameters.add(parameterBuilder.build());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select().apis(RequestHandlerSelectors.any())<br>                .paths(PathSelectors.any()).build().globalOperationParameters(parameters);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder().build();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>加了令牌属性后的 Swagger 接口调用界面。</p><p>![img](Spring Security/2-20181128155349854-989402738.png)</p><h3 id="安全配置类"><a href="#安全配置类" class="headerlink" title="安全配置类"></a>安全配置类</h3><p>下面这个配置类是Spring Security的关键配置。</p><p>在这个配置类中，我们主要做了以下几个配置：</p><ol><li><p>访问路径URL的授权策略，如登录、Swagger访问免登录认证等</p></li><li><p>指定了登录认证流程过滤器 JwtLoginFilter，由它来触发登录认证</p></li><li><p>指定了自定义身份认证组件 JwtAuthenticationProvider，并注入 UserDetailsService</p></li><li><p>指定了访问控制过滤器 JwtAuthenticationFilter，在授权时解析令牌和设置登录状态</p></li><li><p>指定了退出登录处理器，因为是前后端分离，防止内置的登录处理器在后台进行跳转</p></li></ol><p>WebSecurityConfig.java</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.citibank.springboot.spring.security.config;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.<span class="hljs-type">Autowired</span>;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.<span class="hljs-type">Bean</span>;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.<span class="hljs-type">Configuration</span>;<br><span class="hljs-keyword">import</span> org.springframework.http.<span class="hljs-type">HttpMethod</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.authentication.<span class="hljs-type">AuthenticationManager</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.authentication.builders.<span class="hljs-type">AuthenticationManagerBuilder</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.method.configuration.<span class="hljs-type">EnableGlobalMethodSecurity</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.<span class="hljs-type">HttpSecurity</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.<span class="hljs-type">EnableWebSecurity</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.<span class="hljs-type">WebSecurityConfigurerAdapter</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.<span class="hljs-type">UserDetailsService</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.web.authentication.<span class="hljs-type">UsernamePasswordAuthenticationFilter</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.web.authentication.logout.<span class="hljs-type">HttpStatusReturningLogoutSuccessHandler</span>;<br><br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.security.<span class="hljs-type">JwtAuthenticationFilter</span>;<br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.security.<span class="hljs-type">JwtAuthenticationProvider</span>;<br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.security.<span class="hljs-type">JwtLoginFilter</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Security Config</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-literal">true</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">UserDetailsService</span> userDetailsService;<br>    <br>    <span class="hljs-meta">@Override</span><br>    public void configure(<span class="hljs-type">AuthenticationManagerBuilder</span> auth) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-comment">// 使用自定义登录身份认证组件</span><br>        auth.authenticationProvider(<span class="hljs-keyword">new</span> <span class="hljs-type">JwtAuthenticationProvider</span>(userDetailsService));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">HttpSecurity</span> http) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-comment">// 禁用 csrf, 由于使用的是JWT，我们这里不需要csrf</span><br>        http.cors().and().csrf().disable()<br>            .authorizeRequests()<br>            <span class="hljs-comment">// 跨域预检请求</span><br>            .antMatchers(<span class="hljs-type">HttpMethod</span>.<span class="hljs-type">OPTIONS</span>, <span class="hljs-string">&quot;/**&quot;</span>).permitAll()<br>            <span class="hljs-comment">// 登录URL</span><br>            .antMatchers(<span class="hljs-string">&quot;/login&quot;</span>).permitAll()<br>            <span class="hljs-comment">// swagger</span><br>            .antMatchers(<span class="hljs-string">&quot;/swagger-ui.html&quot;</span>).permitAll()<br>            .antMatchers(<span class="hljs-string">&quot;/swagger-resources&quot;</span>).permitAll()<br>            .antMatchers(<span class="hljs-string">&quot;/v2/api-docs&quot;</span>).permitAll()<br>            .antMatchers(<span class="hljs-string">&quot;/webjars/springfox-swagger-ui/**&quot;</span>).permitAll()<br>            <span class="hljs-comment">// 其他所有请求需要身份认证</span><br>            .anyRequest().authenticated();<br>        <span class="hljs-comment">// 退出登录处理器</span><br>        http.logout().logoutSuccessHandler(<span class="hljs-keyword">new</span> <span class="hljs-type">HttpStatusReturningLogoutSuccessHandler</span>());<br>        <span class="hljs-comment">// 开启登录认证流程过滤器</span><br>        http.addFilterBefore(<span class="hljs-keyword">new</span> <span class="hljs-type">JwtLoginFilter</span>(authenticationManager()), <span class="hljs-type">UsernamePasswordAuthenticationFilter</span>.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-comment">// 访问控制时登录状态检查过滤器</span><br>        http.addFilterBefore(<span class="hljs-keyword">new</span> <span class="hljs-type">JwtAuthenticationFilter</span>(authenticationManager()), <span class="hljs-type">UsernamePasswordAuthenticationFilter</span>.<span class="hljs-keyword">class</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">AuthenticationManager</span> authenticationManager() <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManager();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登录认证触发过滤器"><a href="#登录认证触发过滤器" class="headerlink" title="登录认证触发过滤器"></a>登录认证触发过滤器</h3><p>JwtLoginFilter 是在通过访问 /login 的POST请求是被首先被触发的过滤器，默认实现是 UsernamePasswordAuthenticationFilter，它继承了 AbstractAuthenticationProcessingFilter，抽象父类的 doFilter 定义了登录认证的大致操作流程，这里我们的 JwtLoginFilter 继承了 UsernamePasswordAuthenticationFilter，并进行了两个主要内容的定制。</p><ol><li><p>覆写认证方法，修改用户名、密码的获取方式，具体原因看代码注释</p></li><li><p>覆写认证成功后的操作，移除后台跳转，添加生成令牌并返回给客户端</p></li></ol><p>JwtLoginFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.citibank.springboot.spring.security.security;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.nio.charset.Charset;<br><br><span class="hljs-keyword">import</span> javax.servlet.FilterChain;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.ServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.ServletResponse;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> org.springframework.security.authentication.AuthenticationManager;<br><span class="hljs-keyword">import</span> org.springframework.security.authentication.event.InteractiveAuthenticationSuccessEvent;<br><span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<br><span class="hljs-keyword">import</span> org.springframework.security.core.AuthenticationException;<br><span class="hljs-keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.utils.HttpUtils;<br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.utils.JwtTokenUtils;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动登录认证流程过滤器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtLoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JwtLoginFilter</span><span class="hljs-params">(AuthenticationManager authManager)</span> </span>&#123;<br>        setAuthenticationManager(authManager);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        <span class="hljs-comment">// POST 请求 /login 登录时拦截， 由此方法触发执行登录认证流程，可以在此覆写整个登录认证逻辑</span><br>        <span class="hljs-keyword">super</span>.doFilter(req, res, chain); <br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        <span class="hljs-comment">// 可以在此覆写尝试进行登录认证的逻辑，登录成功之后等操作不再此方法内</span><br>        <span class="hljs-comment">// 如果使用此过滤器来触发登录认证流程，注意登录请求数据格式的问题</span><br>        <span class="hljs-comment">// 此过滤器的用户名密码默认从request.getParameter()获取，但是这种</span><br>        <span class="hljs-comment">// 读取方式不能读取到如 application/json 等 post 请求数据，需要把</span><br>        <span class="hljs-comment">// 用户名密码的读取逻辑修改为到流中读取request.getInputStream()</span><br><br>        String body = getBody(request);<br>        JSONObject jsonObject = JSON.parseObject(body);<br>        String username = jsonObject.getString(<span class="hljs-string">&quot;username&quot;</span>);<br>        String password = jsonObject.getString(<span class="hljs-string">&quot;password&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;<br>            username = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;<br>            password = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        username = username.trim();<br><br>        JwtAuthenticatioToken authRequest = <span class="hljs-keyword">new</span> JwtAuthenticatioToken(username, password);<br><br>        <span class="hljs-comment">// Allow subclasses to set the &quot;details&quot; property</span><br>        setDetails(request, authRequest);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);<br>    <br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain,</span></span><br><span class="hljs-function"><span class="hljs-params">            Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        <span class="hljs-comment">// 存储登录认证信息到上下文</span><br>        SecurityContextHolder.getContext().setAuthentication(authResult);<br>        <span class="hljs-comment">// 记住我服务</span><br>        getRememberMeServices().loginSuccess(request, response, authResult);<br>        <span class="hljs-comment">// 触发事件监听器</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;<br>            eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(authResult, <span class="hljs-keyword">this</span>.getClass()));<br>        &#125;<br>        <span class="hljs-comment">// 生成并返回token给客户端，后续访问携带此token</span><br>        JwtAuthenticatioToken token = <span class="hljs-keyword">new</span> JwtAuthenticatioToken(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, JwtTokenUtils.generateToken(authResult));<br>        HttpUtils.write(response, token);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * 获取请求Body</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBody</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        InputStream inputStream = <span class="hljs-keyword">null</span>;<br>        BufferedReader reader = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = request.getInputStream();<br>            reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream, Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>)));<br>            String line = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                sb.append(line);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    inputStream.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    reader.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登录控制器"><a href="#登录控制器" class="headerlink" title="登录控制器"></a>登录控制器</h3><p>除了使用上面的登录认证过滤器拦截 /login Post请求之外，我们也可以不使用上面的过滤器，通过自定义登录接口实现，只要在登录接口手动触发登录流程并生产令牌即可。</p><p>其实 Spring Security 的登录认证过程只需 调用 AuthenticationManager 的 authenticate(Authentication authentication) 方法，最终返回认证成功的 Authentication 实现类并存储到SpringContexHolder 上下文即可，这样后面授权的时候就可以从 SpringContexHolder 中获取登录认证信息，并根据其中的用户信息和权限信息决定是否进行授权。</p><p>LoginController.java</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.citibank.springboot.spring.security.controller;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.security.authentication.AuthenticationManager;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.security.JwtAuthenticatioToken;<br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.utils.SecurityUtils;<br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.vo.HttpResult;<br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.vo.LoginBean;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录控制器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(value = <span class="hljs-meta-string">&quot;/login&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> HttpResult login(<span class="hljs-meta">@RequestBody</span> LoginBean loginBean, HttpServletRequest request) throws IOException &#123;<br>        String username = loginBean.getUsername();<br>        String password = loginBean.getPassword();<br>        <br>        <span class="hljs-comment">// 系统登录认证</span><br>        JwtAuthenticatioToken token = SecurityUtils.login(request, username, password, authenticationManager);<br>                <br>        <span class="hljs-keyword">return</span> HttpResult.ok(token);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：如果使用此登录控制器触发登录认证，需要禁用登录认证过滤器，即将 WebSecurityConfig 中的以下配置项注释即可，否则访问登录接口会被过滤拦截，执行不会再进入此登录接口，大家根据使用习惯二选一即可。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 开启登录认证流程过滤器，如果使用LoginController的login接口, 需要注释掉此过滤器，根据使用习惯二选一即可</span><br>http.add<span class="hljs-constructor">FilterBefore(<span class="hljs-params">new</span> JwtLoginFilter(<span class="hljs-params">authenticationManager</span>()</span>), <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UsernamePasswordAuthenticationFilter</span>.</span></span><span class="hljs-keyword">class</span>);<br></code></pre></td></tr></table></figure><p>如下是登录认证的逻辑， 可以看到部分逻辑跟上面的登录认证过滤器差不多。</p><ol><li><p>执行登录认证过程，通过调用 AuthenticationManager 的 authenticate(token) 方法实现</p></li><li><p>将认证成功的认证信息存储到上下文，供后续访问授权的时候获取使用</p></li><li><p>通过JWT生成令牌并返回给客户端，后续访问和操作都需要携带此令牌</p></li></ol><p>SecurityUtils.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Security相关操作</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> SecurityUtils &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 系统登录认证</span><br><span class="hljs-comment">     * @param request</span><br><span class="hljs-comment">     * @param username</span><br><span class="hljs-comment">     * @param password</span><br><span class="hljs-comment">     * @param authenticationManager</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    public static JwtAuthenticatioToken login(HttpServletRequest request, String username, String password, AuthenticationManager authenticationManager) &#123;<br>        JwtAuthenticatioToken token = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JwtAuthenticatioToken(<span class="hljs-params">username</span>, <span class="hljs-params">password</span>)</span>;<br>        token.set<span class="hljs-constructor">Details(<span class="hljs-params">new</span> WebAuthenticationDetailsSource()</span>.build<span class="hljs-constructor">Details(<span class="hljs-params">request</span>)</span>);<br>        <span class="hljs-comment">// 执行登录认证过程</span><br>        Authentication authentication = authenticationManager.authenticate(token);<br>        <span class="hljs-comment">// 认证成功存储认证信息到上下文</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityContextHolder</span>.</span></span>get<span class="hljs-constructor">Context()</span>.set<span class="hljs-constructor">Authentication(<span class="hljs-params">authentication</span>)</span>;<br>        <span class="hljs-comment">// 生成令牌并返回给客户端</span><br>        token.set<span class="hljs-constructor">Token(JwtTokenUtils.<span class="hljs-params">generateToken</span>(<span class="hljs-params">authentication</span>)</span>);<br>        return token;<br>    &#125;　　　　...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="令牌生成器"><a href="#令牌生成器" class="headerlink" title="令牌生成器"></a>令牌生成器</h3><p>我们令牌是使用JWT生成的，下面是令牌生成的简要逻辑，详细参见源码。</p><p>JwtTokenUtils.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JWT工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtTokenUtils</span> <span class="hljs-title">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    ...<span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成令牌</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>userDetails 用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return </span>令牌</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">generateToken</span>(<span class="hljs-params">Authentication authentication</span>)</span> &#123;<br>        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; claims = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">3</span>);<br>        claims.put(USERNAME, SecurityUtils.getUsername(authentication));<br>        claims.put(CREATED, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());<br>        claims.put(AUTHORITIES, authentication.getAuthorities());<br>        <span class="hljs-keyword">return</span> generateToken(claims);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从数据声明生成令牌</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param </span>claims 数据声明</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return </span>令牌</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">generateToken</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; claims</span>)</span> &#123;<br>        <span class="hljs-built_in">Date</span> expirationDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(System.currentTimeMillis() + EXPIRE_TIME);<br>        <span class="hljs-keyword">return</span> Jwts.builder().setClaims(claims).setExpiration(expirationDate).signWith(SignatureAlgorithm.HS512, SECRET).compact();<br>    &#125;<br><br>　　...<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登录身份认证组件"><a href="#登录身份认证组件" class="headerlink" title="登录身份认证组件"></a>登录身份认证组件</h3><p>上面说到登录认证是通过调用 AuthenticationManager 的 authenticate(token) 方法实现的，而 AuthenticationManager 又是通过调用 AuthenticationProvider 的 authenticate(Authentication authentication) 来完成认证的，所以通过定制 AuthenticationProvider 也可以完成各种自定义的需求，我们这里只是简单的继承 DaoAuthenticationProvider 展示如何自定义，具体的大家可以根据各自的需求按需定制。</p><p>JwtAuthenticationProvider.java</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.citibank.springboot.spring.security.security;<br><br><span class="hljs-keyword">import</span> org.springframework.security.authentication.<span class="hljs-type">UsernamePasswordAuthenticationToken</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.authentication.dao.<span class="hljs-type">DaoAuthenticationProvider</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.core.<span class="hljs-type">Authentication</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.core.<span class="hljs-type">AuthenticationException</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.<span class="hljs-type">UserDetails</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.<span class="hljs-type">UserDetailsService</span>;<br><span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.<span class="hljs-type">BCryptPasswordEncoder</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 身份验证提供者</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DaoAuthenticationProvider</span> </span>&#123;<br><br>    public <span class="hljs-type">JwtAuthenticationProvider</span>(<span class="hljs-type">UserDetailsService</span> userDetailsService) &#123;<br>        setUserDetailsService(userDetailsService);<br>        setPasswordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-type">BCryptPasswordEncoder</span>());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">Authentication</span> authenticate(<span class="hljs-type">Authentication</span> authentication) <span class="hljs-keyword">throws</span> <span class="hljs-type">AuthenticationException</span> &#123;<br>        <span class="hljs-comment">// 可以在此处覆写整个登录认证逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticate(authentication);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void additionalAuthenticationChecks(<span class="hljs-type">UserDetails</span> userDetails, <span class="hljs-type">UsernamePasswordAuthenticationToken</span> authentication)<br>            <span class="hljs-keyword">throws</span> <span class="hljs-type">AuthenticationException</span> &#123;<br>        <span class="hljs-comment">// 可以在此处覆写密码验证逻辑</span><br>        <span class="hljs-keyword">super</span>.additionalAuthenticationChecks(userDetails, authentication);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="认证信息获取服务"><a href="#认证信息获取服务" class="headerlink" title="认证信息获取服务"></a>认证信息获取服务</h3><p>通过跟踪代码运行，我们发现像默认使用的 DaoAuthenticationProvider，在认证的使用都是通过一个叫 UserDetailsService 的来获取用户认证所需信息的。</p><p>AbstractUserDetailsAuthenticationProvider 定义了在 authenticate 方法中通过 retrieveUser 方法获取用户信息，子类 DaoAuthenticationProvider 通过 UserDetailsService 来进行获取， 一般情况，这个 UserDetailsService 需要我们自定义，实现从用户服务获取用户和权限信息封装到 UserDetails 的实现类。</p><p>AbstractUserDetailsAuthenticationProvider.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        <br>　　　　　...<span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;<br>            cacheWasUsed = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);<br>            &#125;<br>     <br>        ...<span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">createSuccessAuthentication</span><span class="hljs-params">(principalToReturn, authentication, user)</span></span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>DaoAuthenticationProvider.java</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> UserDetails <span class="hljs-title">retrieveUser</span><span class="hljs-params">(<span class="hljs-keyword">String</span> username, UsernamePasswordAuthenticationToken authentication)</span></span><br><span class="hljs-function">        throws AuthenticationException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        UserDetails loadedUser = <span class="hljs-keyword">this</span>.getUserDetailsService().loadUserByUsername(username);<br>   <span class="hljs-keyword">return</span> loadedUser;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们自定义的 UserDetailsService，从我们的用户服务 UserService 中获取用户和权限信息。</p><p>UserDetailsServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.citibank.springboot.spring.security.security;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.model.User;<br><span class="hljs-keyword">import</span> com.citibank.springboot.spring.security.service.UserService;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户登录认证信息查询</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;<br>        User user = userService.findByUsername(username);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">&quot;该用户不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 用户权限列表，根据用户拥有的权限标识与如 @PreAuthorize(&quot;hasAuthority(&#x27;sys:menu:view&#x27;)&quot;) 标注的接口对比，决定是否可以调用接口</span><br>        Set&lt;String&gt; permissions = userService.findPermissions(username);<br>        List&lt;GrantedAuthority&gt; grantedAuthorities = permissions.stream().map(GrantedAuthorityImpl::<span class="hljs-keyword">new</span>).collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtUserDetails(username, user.getPassword(), grantedAuthorities);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般而言，定制 UserDetailsService 就可以满足大部分需求了，在 UserDetailsService 满足不了我们的需求的时候考虑定制 AuthenticationProvider。</p><p>如果直接定制UserDetailsService ，而不自定义 AuthenticationProvider，可以直接在配置文件 WebSecurityConfig 中这样配置。</p><p>WebSecurityConfig.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 指定自定义的获取信息获取服务</span><br>    auth.userDetailsService(userDetailsService)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户认证信息"><a href="#用户认证信息" class="headerlink" title="用户认证信息"></a>用户认证信息</h3><p>上面 UserDetailsService 加载好用户认证信息后会封装认证信息到一个 UserDetails 的实现类。</p><p>默认实现是 User 类，我们这里没有特殊需要，简单继承即可，复杂需求可以在此基础上进行拓展。</p><p>JwtUserDetails.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.citibank.springboot.spring.security.security;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.User;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安全用户模型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtUserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long serialVersionUID = 1L;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">JwtUserDetails</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username, <span class="hljs-built_in">String</span> password, Collection&lt;? <span class="hljs-keyword">extends</span> GrantedAuthority&gt; authorities</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>(username, password, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, authorities);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> JwtUserDetails(<span class="hljs-built_in">String</span> username, <span class="hljs-built_in">String</span> password, <span class="hljs-built_in">boolean</span> enabled, <span class="hljs-built_in">boolean</span> accountNonExpired,<br>            <span class="hljs-built_in">boolean</span> credentialsNonExpired, <span class="hljs-built_in">boolean</span> accountNonLocked, Collection&lt;? <span class="hljs-keyword">extends</span> GrantedAuthority&gt; authorities) &#123;<br>        <span class="hljs-built_in">super</span>(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户操作代码"><a href="#用户操作代码" class="headerlink" title="用户操作代码"></a>用户操作代码</h3><p>简单的用户模型，包含用户名密码。</p><p>User.java</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.louis.springboot.spring.security.model;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户模型</span><br><span class="hljs-comment"> * @author Louis</span><br><span class="hljs-comment"> * @date Nov 28, 2018</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> username;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> password;<br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>用户服务接口，只提供简单的用户查询和权限查询接口用于模拟。</p><p>UserService.java</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名查找用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    User findByUsername(<span class="hljs-keyword">String</span> username);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查找用户的菜单权限标识集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    Set&lt;<span class="hljs-keyword">String</span>&gt; findPermissions(<span class="hljs-keyword">String</span> username);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>用户服务实现，只简单获取返回模拟数据，实际场景根据情况从DAO获取即可。</p><p>SysUserServiceImpl.java</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Service<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SysUserServiceImpl implements UserService &#123;<br><br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> findByUsername(String username) &#123;<br>        <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>();<br>        <span class="hljs-keyword">user</span>.setId(<span class="hljs-number">1</span>L);<br>        <span class="hljs-keyword">user</span>.setUsername(username);<br>        String <span class="hljs-keyword">password</span> = <span class="hljs-built_in">new</span> BCryptPasswordEncoder().encode(&quot;123&quot;);<br>        <span class="hljs-keyword">user</span>.setPassword(<span class="hljs-keyword">password</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Set</span>&lt;String&gt; findPermissions(String username) &#123;<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; permissions = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        permissions.<span class="hljs-keyword">add</span>(&quot;sys:user:view&quot;);<br>        permissions.<span class="hljs-keyword">add</span>(&quot;sys:user:add&quot;);<br>        permissions.<span class="hljs-keyword">add</span>(&quot;sys:user:edit&quot;);<br>        <span class="hljs-keyword">return</span> permissions;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>用户控制器，提供三个测试接口，其中权限列表中未包含删除接口定义的权限（’sys:user:delete’），登录之后也将无权限调用。</p><p>UserController.java</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户控制器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@RestController</span><br><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;user&quot;</span>)<br>public class UserController &#123;<br><br>    <br>    <span class="hljs-variable">@PreAuthorize</span>(<span class="hljs-string">&quot;hasAuthority(&#x27;sys:user:view&#x27;)&quot;</span>)<br>    <span class="hljs-variable">@GetMapping</span>(value=<span class="hljs-string">&quot;/findAll&quot;</span>)<br>    public HttpResult findAll() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">HttpResult</span><span class="hljs-selector-class">.ok</span>(<span class="hljs-string">&quot;the findAll service is called success.&quot;</span>);<br>    &#125;<br>    <br>    @<span class="hljs-selector-tag">PreAuthorize</span>(<span class="hljs-string">&quot;hasAuthority(&#x27;sys:user:edit&#x27;)&quot;</span>)<br>    @<span class="hljs-selector-tag">GetMapping</span>(value=<span class="hljs-string">&quot;/edit&quot;</span>)<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">HttpResult</span> <span class="hljs-selector-tag">edit</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">HttpResult</span><span class="hljs-selector-class">.ok</span>(<span class="hljs-string">&quot;the edit service is called success.&quot;</span>);<br>    &#125;<br>    <br>    @<span class="hljs-selector-tag">PreAuthorize</span>(<span class="hljs-string">&quot;hasAuthority(&#x27;sys:user:delete&#x27;)&quot;</span>)<br>    @<span class="hljs-selector-tag">GetMapping</span>(value=<span class="hljs-string">&quot;/delete&quot;</span>)<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">HttpResult</span> <span class="hljs-selector-tag">delete</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">HttpResult</span><span class="hljs-selector-class">.ok</span>(<span class="hljs-string">&quot;the delete service is called success.&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登录认证检查过滤器"><a href="#登录认证检查过滤器" class="headerlink" title="登录认证检查过滤器"></a>登录认证检查过滤器</h3><p>访问接口的时候，登录认证检查过滤器 JwtAuthenticationFilter 会拦截请求校验令牌和登录状态，并根据情况设置登录状态。</p><p>JwtAuthenticationFilter.java</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 登录认证检查过滤器</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasicAuthenticationFilter</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    public <span class="hljs-type">JwtAuthenticationFilter</span>(<span class="hljs-type">AuthenticationManager</span> authenticationManager) &#123;<br>        <span class="hljs-keyword">super</span>(authenticationManager);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void doFilterInternal(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response, <span class="hljs-type">FilterChain</span> chain) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span>, <span class="hljs-type">ServletException</span> &#123;<br>        <span class="hljs-comment">// 获取token, 并检查登录状态</span><br>        <span class="hljs-type">SecurityUtils</span>.checkAuthentication(request);<br>        chain.doFilter(request, response);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>SecurityUtils.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取令牌进行认证</span><br><span class="hljs-comment"> * @param request</span><br><span class="hljs-comment"> */</span><br>public static void check<span class="hljs-constructor">Authentication(HttpServletRequest <span class="hljs-params">request</span>)</span> &#123;<br>    <span class="hljs-comment">// 获取令牌并根据令牌获取登录认证信息</span><br>    Authentication authentication = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JwtTokenUtils</span>.</span></span>get<span class="hljs-constructor">AuthenticationeFromToken(<span class="hljs-params">request</span>)</span>;<br>    <span class="hljs-comment">// 设置登录认证信息到上下文</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityContextHolder</span>.</span></span>get<span class="hljs-constructor">Context()</span>.set<span class="hljs-constructor">Authentication(<span class="hljs-params">authentication</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>JwtTokenUtils.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据请求令牌获取登录认证信息</span><br><span class="hljs-comment"> * @param token 令牌</span><br><span class="hljs-comment"> * @return 用户名</span><br><span class="hljs-comment"> */</span><br>public static Authentication get<span class="hljs-constructor">AuthenticationeFromToken(HttpServletRequest <span class="hljs-params">request</span>)</span> &#123;<br>    Authentication authentication = null;<br>    <span class="hljs-comment">// 获取请求携带的令牌</span><br>    String token = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JwtTokenUtils</span>.</span></span>get<span class="hljs-constructor">Token(<span class="hljs-params">request</span>)</span>;<br>    <span class="hljs-keyword">if</span>(token != null) &#123;<br>        <span class="hljs-comment">// 请求令牌不能为空</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>get<span class="hljs-constructor">Authentication()</span><span class="hljs-operator"> == </span>null) &#123;<br>            <span class="hljs-comment">// 上下文中Authentication为空</span><br>            Claims claims = get<span class="hljs-constructor">ClaimsFromToken(<span class="hljs-params">token</span>)</span>;<br>            <span class="hljs-keyword">if</span>(claims<span class="hljs-operator"> == </span>null) &#123;<br>                return null;<br>            &#125;<br>            String username = claims.get<span class="hljs-constructor">Subject()</span>;<br>            <span class="hljs-keyword">if</span>(username<span class="hljs-operator"> == </span>null) &#123;<br>                return null;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(is<span class="hljs-constructor">TokenExpired(<span class="hljs-params">token</span>)</span>) &#123;<br>                return null;<br>            &#125;<br>            Object authors = claims.get(AUTHORITIES);<br>            List&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;GrantedAuthority&gt;<span class="hljs-literal">()</span>;<br>            <span class="hljs-keyword">if</span> (authors != null<span class="hljs-operator"> &amp;&amp; </span>authors instanceof List) &#123;<br>                <span class="hljs-keyword">for</span> (Object <span class="hljs-keyword">object</span> : (List) authors) &#123;<br>                    authorities.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">GrantedAuthorityImpl((String)</span> ((Map) <span class="hljs-keyword">object</span>).get(<span class="hljs-string">&quot;authority&quot;</span>)));<br>                &#125;<br>            &#125;<br>            authentication = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JwtAuthenticatioToken(<span class="hljs-params">username</span>, <span class="hljs-params">null</span>, <span class="hljs-params">authorities</span>, <span class="hljs-params">token</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(validate<span class="hljs-constructor">Token(<span class="hljs-params">token</span>, SecurityUtils.<span class="hljs-params">getUsername</span>()</span>)) &#123;<br>                <span class="hljs-comment">// 如果上下文中Authentication非空，且请求令牌合法，直接返回当前登录认证信息</span><br>                authentication = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>get<span class="hljs-constructor">Authentication()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return authentication;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><p>找到 SpringSecurityApplication， 启动程序， 访问 <a href="http://localhost:8080/swagger-ui.html%EF%BC%8C%E8%BF%9B%E5%85%A5Swagger%E3%80%82">http://localhost:8080/swagger-ui.html，进入Swagger。</a></p><p>![img](Spring Security/3-20181128173706668-177381559.png)</p><p>我们先再未登录没有令牌的时候直接访问接口，发现都返回无权限，禁止访问的结果。</p><p>![img](Spring Security/4-20181128173840193-199335952.png)</p><p>返回拒绝访问结果。</p><p>![img](Spring Security/5-20181128174042582-676639129.png)</p><p> 打开 LoginController，输入我们用户名和密码（username:amdin, password:123）</p><p>![img](Spring Security/6-20181128174231451-1027667004.png)</p><p> 登录成功之后，成功返回令牌，如下图所示。</p><p> ![img](Spring Security/7-20181128174436613-252448914.png)</p><p>拷贝返回的令牌，粘贴到令牌参数输入框，再次访问 /user/edit 接口。</p><p>![img](Spring Security/8-20181128174642788-1883486292.png)</p><p>这个时候，成功的返回了结果： the edit service is called success.</p><p>![img](Spring Security/9-20181128174754351-925193390.png)</p><p>同样的，拷贝返回的令牌，粘贴到令牌参数输入框，访问 /user/delete 接口。</p><p>![img](Spring Security/91-20181128174924465-934756567.png)</p><p>发现还是返回拒绝访问的结果，那是因为访问这个接口需要 ‘sys:user:delete’ 权限，而我们之前返回的权限列表中并没有包含，所以授权访问失败。</p><p>![img](Spring Security/92-20181128175018727-518353637.png)</p><p>我们修改一下 SysUserServiceImpl，添加上‘sys:user:delete’ 权限，重新登录，再次访问一遍。</p><p>![img](Spring Security/93-20181128175401465-494777099.png)</p><p>发现删除接口也可以访问了，记住务必要重新调用登录接口，获取令牌后拷贝到删除接口，再次访问删除接口。</p><p>![img](Spring Security/94-20181128175606389-1013803667.png)</p><p>至此结束。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/Shiro/"/>
    <url>/2021/02/15/Shiro/</url>
    
    <content type="html"><![CDATA[<h3 id="Shiro安全框架"><a href="#Shiro安全框架" class="headerlink" title="Shiro安全框架"></a>Shiro安全框架</h3><p>Apache Shiro是一个<code>强大且易用的Java安全框架</code>，有<code>身份验证</code>、<code>授权</code>、<code>密码学</code>和<code>会话管理</code>。使用Shiro的易于理解的API，您可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。</p><ul><li><p>Spring security是一个重量级的安全框架</p></li><li><p>Apache Shiro是一个轻量级的安全框架</p></li></ul><p><img src="/2021/02/15/Shiro/image-20191214181115794.png" alt="image-20191214181115794"></p><p>Shiro 开发团队称 “ 应用程序的四大基石：身份验证，授权，会话管理和加密 “ 为其目标。</p><p><strong>Authentication(身份认证)：</strong></p><p>有时也简称为“登录”，这是一个证明用户是他们所说的他们是谁的行为。</p><p><strong>Authorization（授权）：</strong></p><p>访问控制的过程，也就是绝对“谁”去访问“什么”权限。</p><p><strong>Session Management（会话管理）：</strong></p><p>管理用户特定的会话，即使在非 Web 或 EJB 应用程序。</p><p><strong>Cryptography（密码学）：</strong></p><p>通过使用加密算法保持数据安全同时易于使用。</p><p>Shiro还提供了额外的功能来支持和加强在不同环境下所关注的方面，尤其是以下这些：</p><p><strong>Web Support：</strong> Shiro 的 web 支持的 API 能够轻松地帮助保护 Web 应用程序。</p><p><strong>Caching：</strong>缓存是 Apache Shiro 中的第一层公民，来确保安全操作快速而又高效。</p><p><strong>Concurrency：</strong> Apache Shiro 利用它的并发特性来支持多线程应用程序。</p><p><strong>Testing：</strong>测试支持的存在来帮助你编写单元测试和集成测试，并确保你的能够如预期的一样安全。</p><p><strong>“Run As”：</strong>一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。</p><p><strong>“Remember Me”：</strong>在会话中记住用户的身份，所以他们只需要在强制时候登录。</p><h4 id="1、Shiro的架构"><a href="#1、Shiro的架构" class="headerlink" title="1、Shiro的架构"></a>1、Shiro的架构</h4><h5 id="1、Shiro外部来说"><a href="#1、Shiro外部来说" class="headerlink" title="1、Shiro外部来说"></a>1、Shiro外部来说</h5><p>从外部来看Shiro，即从应用程序角度来如何使用shiro来完成工作(认证、授权等)。</p><p><img src="/2021/02/15/Shiro/image-20191214182355268.png" alt="image-20191214182355268"></p><p><strong>Subject：</strong>应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject。Subject代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫、机器人等；</p><p>与Subject的所有交互都会委托给SecurityManager，Subject其实就是一个门面，SecurityManager才是实际的执行者；</p><p><strong>SecurityManager：</strong>安全管理器，即所有与安全有关的操作都会SecurityManager交互，并且管理着所有Subject；可以看出他是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMVC中DispatcherServlet的角色；</p><p><strong>Realm：</strong>Shiro从Realm获取安全数据（如用户，角色，权限），就是说SecurityManager要验证用户身份，那么他需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要Realm得到用户相应的角色/权限进行验证用户是否能进行；可以把Realm看成DataSource。</p><h5 id="2、Shiro内部来看"><a href="#2、Shiro内部来看" class="headerlink" title="2、Shiro内部来看"></a>2、Shiro内部来看</h5><p><img src="/2021/02/15/Shiro/image-20191214183943765.png" alt="image-20191214183943765"></p><p><strong>Subject：</strong>倒可可以与应用交互的”用户”；</p><p><strong>SecurityManager：</strong>相当于SpringMVC中的DispatcherServIet；是Shiro的心脏，所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证、授权、会话及缓存的管理；</p><p><strong>Authenticator：</strong>负责Subject认证，是一个扩展点，可以自定义实现；可以使用认证策略（AuthenticationStrategy），即什么情况下算用户认证通过了；</p><p><strong>Authorizer：</strong>授权器、即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能 ；</p><p><strong>Realm：</strong>可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的，可以是JDBC实现也可以是内存实现等等；由用户提供，所以一般在应用中都需要实现自己的Realm；</p><p><strong>SessionManager：</strong>管理Session生命周期的组件，而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境；</p><p><strong>CacheManager：</strong>缓存控制器，来管理如用户、角色、权限等的缓存的，因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能；</p><p><strong>Cryptography：</strong>密码模块Shiro提高了一些常见的加密组件用于如密码加密/解密。</p><p>小结：</p><p>Shiro：是一个apache的安全框架，还有spring security；</p><p>Shiro：能做：身份认证(登录)authentication，授权authorization，密码学，会话管理。</p><p>Shiro路线：应用 –&gt; Subject(当前用户) –&gt; Security Mananger管理 –&gt; Realm –&gt; db</p><h4 id="2、Shiro入门"><a href="#2、Shiro入门" class="headerlink" title="2、Shiro入门"></a>2、Shiro入门</h4><h5 id="2-1、导如相关依赖包"><a href="#2-1、导如相关依赖包" class="headerlink" title="2.1、导如相关依赖包"></a>2.1、导如相关依赖包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- shiro的支持包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- shiro-core --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-2、准备资源"><a href="#2-2、准备资源" class="headerlink" title="2.2、准备资源"></a>2.2、准备资源</h5><p>这个资源我们可以到shiro的源码文件中拷备：/shiro-root-1.4.0-RC2/samples/quickstart/src/main/resources</p><ul><li><strong>shiro.ini</strong></li><li><strong>log4j.properties</strong></li></ul><p>注：users下面代表的登录的用户(用户名=密码)</p><p><strong>shiro.ini</strong>文件(对拷备过来的数据进行了解释)：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-comment"># Users and their assigned roles</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Each line conforms to the format defined in the</span><br><span class="hljs-comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc</span><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-section">[users]</span><br><span class="hljs-comment"># user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; role</span><br><span class="hljs-attr">root</span> = secret, admin<br><span class="hljs-comment"># user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; role</span><br><span class="hljs-attr">guest</span> = guest, guest<br><span class="hljs-comment"># user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27; (&quot;That&#x27;s the same combination on</span><br><span class="hljs-comment"># my luggage!!!&quot; ;)), and role &#x27;president&#x27;</span><br><span class="hljs-attr">presidentskroob</span> = <span class="hljs-number">12345</span>, president<br><span class="hljs-comment"># user &#x27;darkhelmet&#x27; with password &#x27;ludicrousspeed&#x27; and roles &#x27;darklord&#x27; and &#x27;schwartz&#x27;</span><br><span class="hljs-attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz<br><span class="hljs-comment"># user &#x27;lonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;</span><br><span class="hljs-attr">lonestarr</span> = vespa, goodguy, schwartz<br><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-comment"># Roles with assigned permissions</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># Each line conforms to the format defined in the</span><br><span class="hljs-comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-section">[roles]</span><br><span class="hljs-comment"># &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;</span><br><span class="hljs-attr">admin</span> = *<br><span class="hljs-comment"># The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:</span><br><span class="hljs-attr">schwartz</span> = lightsaber:*<br><span class="hljs-comment"># The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with</span><br><span class="hljs-comment"># license plate &#x27;eagle5&#x27; (instance specific id)</span><br><span class="hljs-attr">goodguy</span> = winnebago:drive:eagle5<br></code></pre></td></tr></table></figure><h5 id="2-3、测试"><a href="#2-3、测试" class="headerlink" title="2.3、测试"></a>2.3、测试</h5><p>Session数据、登录、授权</p><p>这个文件位置 : /shiro-root-1.4.0-RC2/samples/quickstart/src/main/java</p><p>我们下面对这个文件进行了中文的解释</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 简单的入门示例，教我们怎么使用shiro中的一个API</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> Quickstart &#123;<br><br>    <span class="hljs-keyword">private</span> static final transient Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(Quickstart.<span class="hljs-params">class</span>)</span>;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">//读取到shiro.ini文件，并且根据文件创建SecurityManager对象</span><br>        <span class="hljs-comment">//  SecurityManager：权限的核心管理对象</span><br>        Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">IniSecurityManagerFactory(<span class="hljs-string">&quot;classpath:shiro.ini&quot;</span>)</span>;<br>        SecurityManager securityManager = factory.get<span class="hljs-constructor">Instance()</span>;<br><br>        <span class="hljs-comment">// 为了程序正常运行，需要设计一个这个securityManager(相当于把这个管理放到环境中去了)</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>set<span class="hljs-constructor">SecurityManager(<span class="hljs-params">securityManager</span>)</span>;<br><br>        <span class="hljs-comment">//拿到当前用户【Subject:操作当前系统的一个用户】</span><br>        Subject currentUser = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>get<span class="hljs-constructor">Subject()</span>;<br><br>        <span class="hljs-comment">//拿到一个会话(它在咱们的所有类型系统都可以使用【不要求必需是web项目】)</span><br>        Session session = currentUser.get<span class="hljs-constructor">Session()</span>;<br>        <span class="hljs-comment">//会话操作【可以在会话中设置值与获取值】</span><br>        session.set<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;someKey&quot;</span>, <span class="hljs-string">&quot;aValue&quot;</span>)</span>;<br>        String value = (String) session.get<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;someKey&quot;</span>)</span>;<br>        <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;aValue&quot;</span>)) &#123;<br>           <span class="hljs-comment">// log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;可以获取到这个值&quot;</span>+value);<br>        &#125;<br><br>        <span class="hljs-comment">//判断这个用户是否经过验证(没有登录我们可以认为是一个游客)</span><br>        <span class="hljs-comment">//没有登录，我们就可以完成登录</span><br>        <span class="hljs-keyword">if</span> (!currentUser.is<span class="hljs-constructor">Authenticated()</span>) &#123;<br>            <span class="hljs-comment">//拿到用户名与密码令牌【拿到用户名与密码】</span><br>            UsernamePasswordToken token = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UsernamePasswordToken(<span class="hljs-string">&quot;lonestarr&quot;</span>, <span class="hljs-string">&quot;vespa&quot;</span>)</span>;<br>            <span class="hljs-comment">//设置记住我的功能</span><br>            token.set<span class="hljs-constructor">RememberMe(<span class="hljs-params">true</span>)</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//完成登录功能</span><br>                currentUser.login(token);<br>            &#125; catch (UnknownAccountException uae) &#123;<br>                <span class="hljs-comment">//log.info(&quot;There is no user with username of &quot; + token.getPrincipal());</span><br>                <span class="hljs-comment">//token.getPrincipal()[ˈprɪnsəpl] -&gt; 拿到主体（登录用户的主要标识【用户名】）</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;这没有这个账号（用户名）&quot;</span>+token.get<span class="hljs-constructor">Principal()</span>);<br>            &#125; catch (IncorrectCredentialsException ice) &#123;<br>                <span class="hljs-comment">//incorrect [ˌɪnkəˈrekt]:不正确的，错误的</span><br>                <span class="hljs-comment">//Credentials[krəˈdenʃlz]:证书; 凭证，证件</span><br>                <span class="hljs-comment">//log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;这个密码是错误的&quot;</span>+token.get<span class="hljs-constructor">Principal()</span>);<br>            &#125; catch (LockedAccountException lae) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;这个账号已经被锁定&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//其它的登录失败异常【它是所有登录异常的父类】</span><br>            catch (AuthenticationException ae) &#123;<br>                <span class="hljs-comment">//unexpected condition?  error?</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//用户登录成功</span><br>        log.info(<span class="hljs-string">&quot;User [&quot;</span> + currentUser.get<span class="hljs-constructor">Principal()</span> + <span class="hljs-string">&quot;] logged in successfully.&quot;</span>);<br><br>        <span class="hljs-comment">//判断这个用户是否是某一个角色</span><br>        <span class="hljs-keyword">if</span> (currentUser.has<span class="hljs-constructor">Role(<span class="hljs-string">&quot;schwartz&quot;</span>)</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;May the Schwartz be with you!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;Hello, mere mortal.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//测试用户是否有某一个权限</span><br>        <span class="hljs-keyword">if</span> (currentUser.is<span class="hljs-constructor">Permitted(<span class="hljs-string">&quot;lightsaber:wield&quot;</span>)</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;You may use a lightsaber ring.  Use it wisely.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//a (very powerful) Instance Level permission:</span><br>        <span class="hljs-keyword">if</span> (currentUser.is<span class="hljs-constructor">Permitted(<span class="hljs-string">&quot;winnebago:drive:eagle5&quot;</span>)</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot;</span> +<br>                    <span class="hljs-string">&quot;Here are the keys - have fun!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//登出(注销当前登录用户)</span><br>        currentUser.logout<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>exit(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4、总结"><a href="#2-4、总结" class="headerlink" title="2.4、总结"></a>2.4、总结</h5><p>通过SecurityManger获取Suject :</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>set<span class="hljs-constructor">SecurityManager(<span class="hljs-params">securityManager</span>)</span>;<br>Subject currentUser = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>get<span class="hljs-constructor">Subject()</span>;<br></code></pre></td></tr></table></figure><p>通过Subject来做事情：</p><p>获取Session-存值和获取值 Subject.getSession、session.setAttribute、session.getAttribute</p><p>认证（登录）:</p><ul><li><p>判断是否登录Suject.isAuthenticated()</p></li><li><p>如果没有登录，通过用户名和密码创建UsernamePasswordToken</p></li><li><p>调用subject.login(UsernamePasswordToken)来进行登录判断</p></li><li><p>登陆成功: 返回principal给当前用户</p></li><li><p>登陆失败: 抛出异常</p></li></ul><p>授权：</p><ul><li><p>判断是否具有某个角色subject .hasRole</p></li><li><p>判断是否有权限subject .isPrermited(resource:操作)</p></li></ul><h4 id="3、自定义Realm"><a href="#3、自定义Realm" class="headerlink" title="3、自定义Realm"></a>3、自定义Realm</h4><p>刚才咱们使用的是准备的好的一个Realm，在Shiro中，除了咱们 刚才使用的IniRealm（通过Shiro.ini拿数据），还有普通SimpleAccountRealm，JDBCRealm等等。</p><p>但是这些Realm都不能满足咱们的需求 (后期咱们Realm的数据肯定是通过JPA去拿的，下一个项目要使用MyBatis去拿)，而这种情况下，就需要我们自己定义一个Realm来实现相应的功能！</p><h5 id="3-1、准备工作"><a href="#3-1、准备工作" class="headerlink" title="3.1、准备工作"></a>3.1、准备工作</h5><p>自定义Realm一般直接继承AuthorizingRealm接口即可(里面包含<code>身份认证</code>与<code>授权</code>两个方法)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义一个Realm</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br><br>    <span class="hljs-comment">//获取到这个Realm的名称(随便取)</span><br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">String</span> getName() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyRealm&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//进行授权判断（权限）</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">AuthorizationInfo</span> doGetAuthorizationInfo(<span class="hljs-type">PrincipalCollection</span> principalCollection) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//进行身份认证(登录)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">AuthenticationInfo</span> doGetAuthenticationInfo(<span class="hljs-type">AuthenticationToken</span> authenticationToken) <span class="hljs-keyword">throws</span> <span class="hljs-type">AuthenticationException</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-2、身份认证（登录）"><a href="#3-2、身份认证（登录）" class="headerlink" title="3.2、身份认证（登录）"></a>3.2、身份认证（登录）</h5><p>身份认证的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义一个Realm</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br><br>    <span class="hljs-comment">//获取到这个Realm的名称(随便取)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyRealm&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//进行授权的认证</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-function"><span class="hljs-title">doGetAuthorizationInfo</span>(<span class="hljs-params">PrincipalCollection principalCollection</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//进行登录的认证</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;<br>        <span class="hljs-comment">//明显的知道：这个authenticationToken就是UsernamePasswordtoken</span><br>        UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken;<br>        <span class="hljs-built_in">String</span> username = token.getUsername(); <span class="hljs-comment">//拿到用户名(注:这个用户名是传过来的)</span><br>        <span class="hljs-comment">//这里根据用户名去获取密码(如果没有获取到，相当于这个用户不存在，就返回null值)</span><br>        <span class="hljs-built_in">String</span> password = getByName(username);<br>        <span class="hljs-keyword">if</span>(password==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//创建一个简单的身份信息(把用户名与密码放进去-注：它会自动的比较获取的密码与你传过来的密码)</span><br>        SimpleAuthenticationInfo authenticationInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username,password,getName());<br>        <span class="hljs-keyword">return</span> authenticationInfo;<br>    &#125;<br><br><span class="hljs-comment">//模拟从数据库中获取信息</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getByName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(username))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;guest&quot;</span>.equals(username))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abcd&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>身份认证测试</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Test<br>public void test<span class="hljs-constructor">MyRealm()</span> throws Exception&#123;<br><br>    <span class="hljs-comment">//创建自己定义的Realm</span><br>    MyRealm myRealm = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyRealm()</span>;<br>   <span class="hljs-comment">//把Realm放到securityManager中去</span><br>    DefaultSecurityManager securityManager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultSecurityManager()</span>;<br>    securityManager.set<span class="hljs-constructor">Realm(<span class="hljs-params">myRealm</span>)</span>;<br>    <span class="hljs-comment">//把权限管理器放到相应的环境中(我们可以在项目任何位置拿到)</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>set<span class="hljs-constructor">SecurityManager(<span class="hljs-params">securityManager</span>)</span>;<br><br>    <span class="hljs-comment">//拿到当前用户(Subject就是当前用户,游客)</span><br>    Subject currentUser = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>get<span class="hljs-constructor">Subject()</span>;<br>    <span class="hljs-comment">//准备登录的令牌(准备用户名与密码)</span><br>    UsernamePasswordToken token = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UsernamePasswordToken(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>)</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//根据令牌进行功能登录(当前用户进行登录)</span><br>        currentUser.login(token);<br>    &#125; catch (UnknownAccountException e) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;这个账号不存在!&quot;</span> + token.get<span class="hljs-constructor">Principal()</span>);<br>        e.print<span class="hljs-constructor">StackTrace()</span>;<br>    &#125; catch (IncorrectCredentialsException ice) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;这个密码不存在!&quot;</span> + token.get<span class="hljs-constructor">Principal()</span>);<br>        ice.print<span class="hljs-constructor">StackTrace()</span>;<br>    &#125;catch (AuthenticationException e)&#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;i don&#x27;t k&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3、授权（权限）认证"><a href="#3-3、授权（权限）认证" class="headerlink" title="3.3、授权（权限）认证"></a>3.3、授权（权限）认证</h5><p>授权认证的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br><br>    <span class="hljs-comment">//获取到这个Realm的名称(随便取)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyRealm&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//进行授权的认证</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-function"><span class="hljs-title">doGetAuthorizationInfo</span>(<span class="hljs-params">PrincipalCollection principalCollection</span>)</span> &#123;<br>    <br>        <span class="hljs-comment">//拿到认证的主要信息(用户名)</span><br>        <span class="hljs-built_in">String</span> username = (<span class="hljs-built_in">String</span>) principalCollection.getPrimaryPrincipal();<br>        <br>        <span class="hljs-comment">//模拟 根据用户名  拿到  角色信息与权限信息</span><br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; roles = getRolesByUsername(username);<br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; permissions = getPermissionsByUsername(username);<br>        <br>        <span class="hljs-comment">//拿到验证信息对象</span><br>        SimpleAuthorizationInfo authorizationInfo = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();<br>        <br>        <span class="hljs-comment">//设置用户的角色</span><br>        authorizationInfo.setRoles(roles);<br>        <br>        <span class="hljs-comment">//设置用户的权限</span><br>        authorizationInfo.setStringPermissions(permissions);<br>        <span class="hljs-keyword">return</span> authorizationInfo;<br>    &#125;<br><br>    <span class="hljs-comment">//模拟 根据用户名  拿到  角色的功能</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">getRolesByUsername</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username</span>)</span> &#123;<br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; roles = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        roles.add(<span class="hljs-string">&quot;admin&quot;</span>);<br>        roles.add(<span class="hljs-string">&quot;it&quot;</span>);<br>        <span class="hljs-keyword">return</span> roles;<br>    &#125;<br>    <span class="hljs-comment">//模拟 根据用户名  拿到  权限的功能</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">getPermissionsByUsername</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username</span>)</span> &#123;<br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; permissions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        permissions.add(<span class="hljs-string">&quot;employee.*&quot;</span>);<br>        permissions.add(<span class="hljs-string">&quot;department.save&quot;</span>);<br>        <span class="hljs-keyword">return</span> permissions;<br>    &#125;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>功能测试</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;是否是这个角色：&quot;</span>+currentUser.has<span class="hljs-constructor">Role(<span class="hljs-string">&quot;admin&quot;</span>)</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;是否是拥有权限：&quot;</span>+currentUser.is<span class="hljs-constructor">Permitted(<span class="hljs-string">&quot;employee.save&quot;</span>)</span>);<br></code></pre></td></tr></table></figure><h4 id="4、密码加密"><a href="#4、密码加密" class="headerlink" title="4、密码加密"></a>4、密码加密</h4><h5 id="4-1、Shiro中的密码加密"><a href="#4-1、Shiro中的密码加密" class="headerlink" title="4.1、Shiro中的密码加密"></a>4.1、Shiro中的密码加密</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  algorithmName:加密算法(md5,sha)</span><br><span class="hljs-comment"> *  source:原始密码</span><br><span class="hljs-comment"> *  salt,加盐</span><br><span class="hljs-comment"> *  hashIterations:遍历次数</span><br><span class="hljs-comment"> */</span><br>SimpleHash simpleHash = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleHash(<span class="hljs-string">&quot;MD5&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;kongwei_liao&quot;</span>,10)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(simpleHash);<br></code></pre></td></tr></table></figure><h5 id="4-2、测试时让自定义Realm加上算法"><a href="#4-2、测试时让自定义Realm加上算法" class="headerlink" title="4.2、测试时让自定义Realm加上算法"></a>4.2、测试时让自定义Realm加上算法</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Test<br>public void test<span class="hljs-constructor">MyRealm()</span> throws Exception&#123;<br><br>    <span class="hljs-comment">//创建自己定义的Realm</span><br>    MyRealm myRealm = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyRealm()</span>;<br>    <br>    <span class="hljs-comment">//把Realm放到securityManager中去</span><br>    DefaultSecurityManager securityManager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultSecurityManager()</span>;<br>    securityManager.set<span class="hljs-constructor">Realm(<span class="hljs-params">myRealm</span>)</span>;<br>    <br>    <span class="hljs-comment">//把权限管理器放到相应的环境中(我们可以在项目任何位置拿到)</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>set<span class="hljs-constructor">SecurityManager(<span class="hljs-params">securityManager</span>)</span>;<br><br><span class="hljs-comment">//设置咱们Realm的密码匹配器(我们的密码要怎么处理)</span><br>    HashedCredentialsMatcher matcher = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HashedCredentialsMatcher()</span>;<br>    matcher.set<span class="hljs-constructor">HashAlgorithmName(<span class="hljs-string">&quot;md5&quot;</span>)</span>; <span class="hljs-comment">//匹配器使用MD5的算法</span><br>    matcher.set<span class="hljs-constructor">HashIterations(10)</span>;<span class="hljs-comment">//加密算法要迭代多少次</span><br>    myRealm.set<span class="hljs-constructor">CredentialsMatcher(<span class="hljs-params">matcher</span>)</span>;<br><br><span class="hljs-comment">//拿到当前用户(Subject就是当前用户,游客)</span><br>    Subject currentUser = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>get<span class="hljs-constructor">Subject()</span>;<br>    <span class="hljs-comment">//准备登录的令牌(准备用户名与密码) -&gt; 这里的密码进行了加密</span><br>    UsernamePasswordToken token = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UsernamePasswordToken(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>)</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//根据令牌进行功能登录(当前用户进行登录)</span><br>        currentUser.login(token);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;登录成功啦。。。。&quot;</span>);<br>     &#125; catch (UnknownAccountException e) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;这个账号不存在!&quot;</span> + token.get<span class="hljs-constructor">Principal()</span>);<br>        e.print<span class="hljs-constructor">StackTrace()</span>;<br>     &#125; catch (IncorrectCredentialsException ice) &#123;<br>         <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;这个密码不存在!&quot;</span> + token.get<span class="hljs-constructor">Principal()</span>);<br>         ice.print<span class="hljs-constructor">StackTrace()</span>;<br>     &#125;catch (AuthenticationException e)&#123;<br>         <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;i don&#x27;t k&quot;</span>);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3、自定义Realm加上盐值"><a href="#4-3、自定义Realm加上盐值" class="headerlink" title="4.3、自定义Realm加上盐值"></a>4.3、自定义Realm加上盐值</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//进行登录的认证</span><br>@Override<br>protected AuthenticationInfo <span class="hljs-keyword">do</span><span class="hljs-constructor">GetAuthenticationInfo(AuthenticationToken <span class="hljs-params">authenticationToken</span>)</span> throws AuthenticationException &#123;<br><br>    <span class="hljs-comment">//明显的知道：这个authenticationToken就是UsernamePasswordtoken</span><br>    UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken;<br>    String username = token.get<span class="hljs-constructor">Username()</span>; <span class="hljs-comment">//拿到用户名(注:这个用户名是传过来的)</span><br><br>    <span class="hljs-comment">//这里根据用户名去获取密码(如果没有获取到，相当于这个用户不存在，就返回陪我)</span><br>    String password = get<span class="hljs-constructor">ByName(<span class="hljs-params">username</span>)</span>;<br>    <span class="hljs-keyword">if</span>(password==null)&#123;<br>        return null;<br>    &#125;<br>    <br>    <span class="hljs-comment">//在这里加盐值需一个ByteSource对象，而Shiro提供了一个ByteSource对象给咱们</span><br>    ByteSource salt = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteSource</span>.</span><span class="hljs-module"><span class="hljs-identifier">Util</span>.</span></span><span class="hljs-built_in">bytes</span>(<span class="hljs-string">&quot;kongwei_liao&quot;</span>);<br>    <br>    <span class="hljs-comment">//创建一个简单的身份信息(把用户名与密码放进去-注：它会自动的比较获取的密码与你传过来的密码)</span><br>    SimpleAuthenticationInfo authenticationInfo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleAuthenticationInfo(<span class="hljs-params">username</span>,<span class="hljs-params">password</span>,<span class="hljs-params">salt</span>,<span class="hljs-params">getName</span>()</span>);<br>    return authenticationInfo;<br>&#125;<br><br><span class="hljs-keyword">private</span> String get<span class="hljs-constructor">ByName(String <span class="hljs-params">username</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(username))&#123;<br>        <span class="hljs-comment">// 4a95737b032e98a50c056c41f2fa9ec6: 123456 迭代10次不加盐的结果</span><br>        <span class="hljs-comment">// 922ad745e6fc8a539f70003fa7473336: 123456 迭代10次加盐(kongwei_liao)的结果</span><br>        return <span class="hljs-string">&quot;922ad745e6fc8a539f70003fa7473336&quot;</span>; <span class="hljs-comment">//修改为加密加盐后的数据</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;guest&quot;</span>.equals(username))&#123;<br>        return <span class="hljs-string">&quot;abcd&quot;</span>;<br>    &#125;<br>    return null;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、Shiro集成Spring"><a href="#5、Shiro集成Spring" class="headerlink" title="5、Shiro集成Spring"></a>5、Shiro集成Spring</h4><p>我们的项目基本都是通过Spring来管理bean的，如果要想使用Shiro，那就要把shiro集成到Spring。集成Spring的核心就是把框架的核心类(SecurityManager，Subject，Realm)交给Spring管理！</p><h5 id="5-1、准备Spring-web项目"><a href="#5-1、准备Spring-web项目" class="headerlink" title="5.1、准备Spring-web项目"></a>5.1、准备Spring-web项目</h5><h5 id="5-2、集成"><a href="#5-2、集成" class="headerlink" title="5.2、集成"></a>5.2、集成</h5><p>导入Shiro包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- shiro的支持包 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- shiro与Spring的集成包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>拷贝ShiroFilter配置到web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Spring与shiro集成:需要定义一个shiro过滤器(这是一个代理过滤器，它会到spring的配置中找一个名称相同的真实过滤器) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>targetFilterLifecycle<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>集成到Spring，拷贝shiro Spring配置到配置文件applicationContext-shiro.xml，在applicationContext.xml中导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 1.配置shiro的核心对象 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;securityManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置一个realm，到数据库中获取权限数据 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;realm&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;MyRealm&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  2.我们可以自定义一个realm，这个必需实现org.apache.shiro.realm.Realm接口 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;MyRealm&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cn.kongwei_liao.realm.MyRealm&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--注入密码匹配器--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;property name=&quot;credentialsMatcher&quot;&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash;加密的方式&amp;ndash;&amp;gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;property name=&quot;hashAlgorithmName&quot; value=&quot;MD5&quot;&gt;&lt;/property&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash;加密次数&amp;ndash;&amp;gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;property name=&quot;hashIterations&quot; value=&quot;10&quot;&gt;&lt;/property&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;/bean&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;/property&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 3.lifecycleBeanPostProcessor：可以自动调用在Spring Ioc窗口中 Shiro bean的生命周期方法 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lifecycleBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 4.启动ioc容器中使用 shiro的注解，但是必需配置在Spring Ioc容器中Shiro bean的生成周期方法 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">depends-on</span>=<span class="hljs-string">&quot;lifecycleBeanPostProcessor&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;securityManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;securityManager&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 5.shiro的核心过滤器(注：这个名称必需和web.xml的代表过滤器【DelegatingFilterProxy】名称一样) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;shiroFilter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;securityManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;securityManager&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 登录的url,如果没有登录，你访问的路径会跳到这个页面 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;loginUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/login.jsp&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 登录成功的url,如果登录成功，会跳转到这个页面 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;successUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/success.jsp&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 没有权限时跳转到这个位置 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;unauthorizedUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/noPermission.jsp&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--定义过滤器链--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;filterChainDefinitions&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--anon:匿名过滤器,表示直接放行--&gt;</span><br>                login.jsp = anon<br>                /login = anon<br>                <span class="hljs-comment">&lt;!--注销--&gt;</span><br>                /logout = logout<br>                <span class="hljs-comment">&lt;!--/**：所有请求包括子请求，authc：必须认证通过才放行--&gt;</span><br>                /** = authc<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            配置哪些资源被保护，哪些资源需要权限</span><br><span class="hljs-comment">            anon：不需要登录也可以访问相应的权限</span><br><span class="hljs-comment">            authc：需要权限才能访问</span><br><span class="hljs-comment">              /** ：所有文件及其子文件</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;property name=&quot;filterChainDefinitionMap&quot; ref=&quot;filterChainDefinitionMap&quot;&gt;&lt;/property&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;bean id=&quot;chainDefinitionMapFactory&quot; class=&quot;cn.itsource.crm.realm.FilterChainDefinitionMapFactory&quot;/&gt;--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;bean id=&quot;filterChainDefinitionMap&quot; factory-bean=&quot;chainDefinitionMapFactory&quot; factory-method=&quot;createFilterChainDefinitionMap&quot;/&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入Shiro的配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-shiro.xml&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>测试：除了登录界面能够被正常访问，其他的都要跳转到登录界面！</p><h5 id="5-3、小结"><a href="#5-3、小结" class="headerlink" title="5.3、小结"></a>5.3、小结</h5><p>注意：需要一个Spring的环境，不能全部都在SpringMVC那儿初始化</p><h4 id="6、Authentication（身份认证）"><a href="#6、Authentication（身份认证）" class="headerlink" title="6、Authentication（身份认证）"></a>6、Authentication（身份认证）</h4><p>在集成Spring的例子中，只有登录页面是不需要登录可以直接访问。其他的页面需要认证（即登录）后才能访问，那怎么来实现登录认证，又叫做身份认证呢？</p><p><strong>身份验证：</strong>一般需要提供如身份ID等一些标识信息来表明登录者的身份，如提供email用户名/密码来证明。</p><p>在Shiro中用户需要提供principals（身份）和credentiaIs（证明）给Shiro，从而应用能验证用户身份：</p><ul><li><strong>principals：</strong>身份，即主体的标识属性，可以是田可属性，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primaryprincipals，一般是用户名/邮箱/手机号。</li><li><strong>credentials：</strong>证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</li><li>最常见的principals和credentials组合就是用户名/密码了</li></ul><p>做认证需要用户名和密码，认证流程，如下图：</p><p><img src="/2021/02/15/Shiro/image-20191214195132572.png" alt="image-20191214195132572"></p><h5 id="6-1、详细步骤分析"><a href="#6-1、详细步骤分析" class="headerlink" title="6.1、详细步骤分析"></a>6.1、详细步骤分析</h5><p>要想实现登录，分前台和后台两部分：</p><ul><li><p>前台：实现一个login.jsp的页面，用来搜集登录信息（用户名和密码）！当点击登录时把登录信息提交到后台完成认证。</p></li><li><p>后台：写一个Controller接收前台传入的登录信息，完成登录认证。</p></li></ul><p>具体步骤如下：</p><ol><li><p>创建LoginConroller，写一个方法接收前台登录请求并接受登录信息(用户名和密码)</p></li><li><p>获取当前的 Subject，调用 SecurityUtils.getSubject();</p></li><li><p>测试当前的用户是否已经被认证。即是否已经登录. 调用 Subject 的 isAuthenticated() </p></li><li><p>若没有被认证，则把用户名和密码封装为 UsernamePasswordToken 对象</p></li><li><p>执行登录: 调用 Subject 的 login(AuthenticationToken) 方法. </p></li><li><p>自定义 Realm 的方法，从数据库中获取对应的记录, 返回给 Shiro.</p><ul><li>入门中使用的是Shiro自带的IniRealm，IniRealm从ini配置文件中读取用户的信息，大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义realm。</li><li>实际上需要继承 org.apache.shiro.realm.AuthenticatingRealm 类</li><li>实现 doGetAuthenticationInfo(AuthenticationToken) 方法. </li></ul></li><li><p>由 shiro 完成对密码的比对.</p></li></ol><h5 id="6-2、简单认证实现"><a href="#6-2、简单认证实现" class="headerlink" title="6.2、简单认证实现"></a>6.2、简单认证实现</h5><p>login.jsp</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span> action=<span class="hljs-string">&quot;/login&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    用户名&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span> /&gt; &lt;<span class="hljs-keyword">br</span> /&gt;<br>    密码:&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;password&quot;</span> /&gt; &lt;<span class="hljs-keyword">br</span> /&gt;<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;登录&quot;</span> /&gt;<br>&lt;/<span class="hljs-keyword">form</span>&gt;<br></code></pre></td></tr></table></figure><p>LoginController</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Controller<br>public <span class="hljs-keyword">class</span> LoginController &#123;<br>    @<span class="hljs-constructor">RequestMapping(<span class="hljs-string">&quot;/login&quot;</span>)</span><br>    public String login(String username,String password)&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取当前的 Subject. 调用 SecurityUtils.getSubject();</span><br><span class="hljs-comment">         * 测试当前的用户是否已经被认证. 即是否已经登录. 调用 Subject 的 isAuthenticated()</span><br><span class="hljs-comment">         * 若没有被认证, 则把用户名和密码封装为 UsernamePasswordToken 对象</span><br><span class="hljs-comment">         * 执行登录: 调用 Subject 的 login(AuthenticationToken) 方法.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//1.拿到访问的主体(当前登录用户)</span><br>        Subject subject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityUtils</span>.</span></span>get<span class="hljs-constructor">Subject()</span>;<br>        <span class="hljs-comment">//2.判断这个用户是否已经登录(通过验证)</span><br>        <span class="hljs-keyword">if</span>(!subject.is<span class="hljs-constructor">Authenticated()</span>)&#123;<br>            <span class="hljs-comment">//3.如果没有验证，就要完成登录</span><br>            UsernamePasswordToken token = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UsernamePasswordToken(<span class="hljs-params">username</span>,<span class="hljs-params">password</span>)</span>;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//4.根据toke完成登录功能</span><br>                subject.login(token);<br>            &#125;catch (UnknownAccountException e)&#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;用户名不存在！！&quot;</span>);<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;catch (IncorrectCredentialsException e)&#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;密码不存在！&quot;</span>);<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;catch (AuthenticationException e)&#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;登录出错！&quot;</span>);<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-string">&quot;redirect:/s/main.jsp&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JpaRealm</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthenticatingRealm</span> </span>&#123;<br><br>    <span class="hljs-comment">//AuthenticationInfo:认证; 身份验证; 证明</span><br>    <span class="hljs-comment">//登录的时候就会调用这个方法来做验证</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">AuthenticationInfo</span> doGetAuthenticationInfo(<span class="hljs-type">AuthenticationToken</span> token) <span class="hljs-keyword">throws</span> <span class="hljs-type">AuthenticationException</span> &#123;<br>        <span class="hljs-comment">//System.out.println(token.getClass().getName());</span><br>        <span class="hljs-comment">//可以转成相应的token</span><br>        <span class="hljs-comment">//UsernamePasswordToken upToken =(UsernamePasswordToken)token;</span><br>        <span class="hljs-comment">//拿到传过来的用户名</span><br>        <span class="hljs-comment">//String username = upToken.getUsername();</span><br>        <span class="hljs-comment">//自定义Realm中，需要根据用户名到数据库中拿到密码，然后返回给shiro</span><br>        <span class="hljs-comment">//String password = &quot;123456&quot;;</span><br>        <span class="hljs-comment">//身份认证(用户名)</span><br>        <span class="hljs-type">Object</span> principal = token.getPrincipal();<br>        <span class="hljs-type">Object</span> credentials = <span class="hljs-string">&quot;123456&quot;</span>; <span class="hljs-comment">//密码假设是根据用户名到数据库中查询出来的</span><br>        <span class="hljs-comment">// Object principal, Object credentials, String realmName</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">SimpleAuthenticationInfo</span>(principal,credentials,getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-3、加密认证"><a href="#6-3、加密认证" class="headerlink" title="6.3、加密认证"></a>6.3、加密认证</h5><p>分析：</p><p> 1、密码不能明文保存到数据库 加密保存，比对也要加密比对，具体的比对CredentialsMatcher，默认使用就是SimpleCredentialsMatcher，不做加密的比对。要想做md5加密要使用HashedCredentialsMatcher，并且设置加密为md5 </p><p>数据库加密保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br></code></pre></td></tr></table></figure><p><img src="/2021/02/15/Shiro/image-20191214195619630.png" alt="image-20191214195619630"></p><p>加密对比代码实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//完成登录的认证</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;<br>    UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken;<br>    <span class="hljs-built_in">String</span> username = token.getUsername();<br>    <span class="hljs-built_in">String</span> dbPassword  = findByUsername(token.getUsername());<br>    <span class="hljs-keyword">if</span>(dbPassword==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    SimpleAuthenticationInfo authorizationInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username,dbPassword,getName());<br>    <span class="hljs-keyword">return</span> authorizationInfo;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">findByUsername</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> username</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(username))&#123;<br>        <span class="hljs-comment">//这里是没有加盐的结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;4a95737b032e98a50c056c41f2fa9ec6&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置Realm的匹配值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 2.我们可以自定义一个realm 这个必需实现org.apache.shiro.realm.Realm接口 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jpaRealm&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cn.kongwei_liao.shiro.realm.JpaRealm&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;credentialsMatcher&quot;</span>&gt;</span><br>        &lt;!—设置加密匹配方案--&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 编码的方式使用:md5 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hashAlgorithmName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;MD5&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 编码的次数:10 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hashIterations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/15/Shiro/image-20191214195742239.png" alt="image-20191214195742239"></p><h5 id="6-4、盐值加密认证"><a href="#6-4、盐值加密认证" class="headerlink" title="6.4、盐值加密认证"></a>6.4、盐值加密认证</h5><p>使用盐值加密，盐值加密，更安全！</p><p>数据库要加密保存</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Test<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testHash() throws <span class="hljs-keyword">Exception</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * algorithmName:加密算法(md5,sha)</span><br><span class="hljs-comment">     *  source:原始密码</span><br><span class="hljs-comment">     *  salt,加盐</span><br><span class="hljs-comment">     *  hashIterations:遍历次数</span><br><span class="hljs-comment">     */</span><br>    SimpleHash simpleHash = <span class="hljs-built_in">new</span> SimpleHash(&quot;MD5&quot;,&quot;123456&quot;,&quot;kongwei_liao&quot;,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(simpleHash);<br>&#125;<br></code></pre></td></tr></table></figure><p>认证时要支持盐值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//AuthenticationInfo:认证; 身份验证; 证明</span><br><span class="hljs-comment">//登录的时候就会调用这个方法来做验证</span><br><span class="hljs-comment">//进行登录的认证</span><br>@Override<br>protected AuthenticationInfo <span class="hljs-keyword">do</span><span class="hljs-constructor">GetAuthenticationInfo(AuthenticationToken <span class="hljs-params">authenticationToken</span>)</span> throws AuthenticationException &#123;<br>    <span class="hljs-comment">//明显的知道：这个authenticationToken就是UsernamePasswordtoken</span><br>    UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken;<br>    String username = token.get<span class="hljs-constructor">Username()</span>; <span class="hljs-comment">//拿到用户名(注:这个用户名是传过来的)</span><br>    <span class="hljs-comment">//这里根据用户名去获取密码(如果没有获取到，相当于这个用户不存在，就返回陪我)</span><br>    String password = get<span class="hljs-constructor">ByName(<span class="hljs-params">username</span>)</span>;<br>    <span class="hljs-keyword">if</span>(password==null)&#123;<br>        return null;<br>    &#125;<br>    <span class="hljs-comment">//在这里加盐值需一个ByteSource对象，而Shiro提供了一个ByteSource对象给咱们</span><br>    ByteSource salt = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteSource</span>.</span><span class="hljs-module"><span class="hljs-identifier">Util</span>.</span></span><span class="hljs-built_in">bytes</span>(<span class="hljs-string">&quot;kongwei_liao&quot;</span>);<br>    <span class="hljs-comment">//创建一个简单的身份信息(把用户名与密码放进去-注：它会自动的比较获取的密码与你传过来的密码)</span><br>    SimpleAuthenticationInfo authenticationInfo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleAuthenticationInfo(<span class="hljs-params">username</span>,<span class="hljs-params">password</span>,<span class="hljs-params">salt</span>,<span class="hljs-params">getName</span>()</span>);<br>    return authenticationInfo;<br>&#125;<br><br><span class="hljs-keyword">private</span> String get<span class="hljs-constructor">ByName(String <span class="hljs-params">username</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(username))&#123;<br>        <span class="hljs-comment">// 4a95737b032e98a50c056c41f2fa9ec6: 123456 迭代10次不加盐的结果</span><br>        <span class="hljs-comment">// 922ad745e6fc8a539f70003fa7473336: 123456 迭代10次加盐(kongwei_liao)的结果</span><br>        return <span class="hljs-string">&quot;922ad745e6fc8a539f70003fa7473336&quot;</span>; <span class="hljs-comment">//修改为加密加盐后的数据</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;guest&quot;</span>.equals(username))&#123;<br>        return <span class="hljs-string">&quot;abcd&quot;</span>;<br>    &#125;<br>    return null;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-5、小结"><a href="#6-5、小结" class="headerlink" title="6.5、小结"></a>6.5、小结</h5><p>普通认证、加密认证、加密加盐认证（<strong>采纳</strong>）</p><h4 id="7、Authorizing（授权）"><a href="#7、Authorizing（授权）" class="headerlink" title="7、Authorizing（授权）"></a>7、Authorizing（授权）</h4><p>有的资源需要有对应的权限才能访问，如果想要某个用户能够访问某个资源，必须给对应用户授权。</p><p>对于授权需要做两个事情：</p><ol><li><code>权限拦截</code>：当用户访问没有权限的资源时进行拦截</li><li><code>权限判断</code>：给用户授权</li></ol><p>授权，也叫访问控制，即在应用中控制谁访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</p><ol><li><code>主体(Subject)</code>：访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。</li><li><code>资源(Resource)</code>：在应用中用户可以访问的URL，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</li><li><code>权限(Permission)</code>：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）等。权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许。</li><li><code>角色(Role)</code>：权限的集合，一般情况下会赋予用户角色而不是权限即这样用户可以拥有一组权限，赋予权限时比较方便典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。</li></ol><p>Shiro支持粗粒度权限（如用户模块的所有权限）和细粒度权限（操作某个用户的权限，即实例级别的）</p><h5 id="7-1、Shiro的三种权限判断方式"><a href="#7-1、Shiro的三种权限判断方式" class="headerlink" title="7.1、Shiro的三种权限判断方式"></a>7.1、Shiro的三种权限判断方式</h5><p>编程式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>通过<span class="hljs-keyword">if</span>/<span class="hljs-keyword">else</span>授权代码块完成<br>Subject subject = SecurityUtils.getSubject();<br><span class="hljs-keyword">if</span>(subject.hasRole(<span class="hljs-string">&quot;admin&quot;</span>)) &#123;<br><span class="hljs-regexp">//</span>有权限<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-regexp">//</span>无权限<br>&#125;<br></code></pre></td></tr></table></figure><p>注解式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//通过在执行的Java方法上放置相应的注解完成</span><br><span class="hljs-meta">@RequiresRoles</span>(<span class="hljs-string">&quot;admin&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-comment">//有权限</span><br>&#125;<br></code></pre></td></tr></table></figure><p>JSP/GSP标签：在JSP/GSP 页面通过相应的标签完成</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erb"><span class="xml">&lt;%</span><span class="ruby"><span class="hljs-variable">@taglib</span> prefix=<span class="hljs-string">&quot;shiro&quot;</span> uri=<span class="hljs-string">&quot;http://shiro.apache.org/tags&quot;</span></span><span class="xml">%&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">shiro:hasRole</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span></span><br><span class="xml">&lt;!— 有权限—&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">shiro:hasRole</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>控制哪些资源要做权限拦截，如果不做拦截，直接放行，如果要拦截就要做权限判断</p><p>获取用户能够访问资源，如果你访问资源在里面，说明有权限。可以访问，否则不能访问。</p><p>不控制直接放行，要控制查看用户是否拥有,如果有直接访问,否则不能访问</p><h5 id="7-2、授权拦截"><a href="#7-2、授权拦截" class="headerlink" title="7.2、授权拦截"></a>7.2、授权拦截</h5><p>权限拦截同样需要从数据库中获取权限或角色信息，所以同样需要自定义Realm。</p><p>注意：现要权限写死在配置中！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 5.shiro的真实过滤器(注：这个名称必需和web.xml的代表过滤器【DelegatingFilterProxy】名称一样) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;shiroFilter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;securityManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;securityManager&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 登录的url,如果没有登录，你访问的路径会跳到这个页面 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;loginUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/s/login.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 登录成功的url,如果登录成功，会跳转到这个页面 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;successUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/s/main.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 没有权限时跳转到这个位置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;unauthorizedUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/s/unauthorized.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        配置哪些资源被保护，哪些资源需要权限</span><br><span class="hljs-comment">        anon：不需要登录也可以访问相应的权限</span><br><span class="hljs-comment">        authc：需要权限才能访问</span><br><span class="hljs-comment">          /** ：所有文件及其子文件</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;filterChainDefinitions&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>            /s/login.jsp = anon<br>            /login = anon<br>            <span class="hljs-comment">&lt;!--对资源进行权限控制，要控制的资源都应该从数据库查出，现在咱们先写死--&gt;</span><br>            /s/permission.jsp = perms[user:*]<br>            /** = authc<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>自定义的Realm授权：</p><p>授权需要继承 AuthorizingRealm 类，并实现其 doGetAuthorizationInfo 方法 </p><p>AuthorizingRealm 类继承自 AuthenticatingRealm，但没有实现 AuthenticatingRealm 中的doGetAuthenticationInfo，所以认证和授权只需要继承 AuthorizingRealm 就可以了。同时实现他的两个抽象方法。</p><p>具体实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> JpaRealm extends AuthorizingRealm &#123;<br>    <span class="hljs-comment">//AuthorizationInfo:授权(是否有权限进入操作)</span><br>    <span class="hljs-comment">// 我们只需要把相应的权限交给Shiro，它就会自动比对</span><br>    @Override<br>    protected AuthorizationInfo <span class="hljs-keyword">do</span><span class="hljs-constructor">GetAuthorizationInfo(PrincipalCollection <span class="hljs-params">principals</span>)</span> &#123;<br>        <span class="hljs-comment">//拿到主体信息(指的就是当前登录用户名) -&gt; 咱们的权限应该是根据当前用户进行查询到的</span><br>        String username = (String) principals.get<span class="hljs-constructor">PrimaryPrincipal()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;后面需要根据用户名获取资源&quot;</span>+username);<br>        <span class="hljs-comment">//获取权限资源(这里假设已经根据用户名到数据库中获取到了)</span><br>        Set&lt;String&gt; permissions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;<span class="hljs-literal">()</span>;<br>        permissions.add(<span class="hljs-string">&quot;user:*&quot;</span>);<br>        <span class="hljs-comment">//拿到授权对象，并且所有权限交给它</span><br>        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleAuthorizationInfo()</span>;<br>        simpleAuthorizationInfo.set<span class="hljs-constructor">StringPermissions(<span class="hljs-params">permissions</span>)</span>;<br>        <span class="hljs-comment">//返回授权对象</span><br>        return simpleAuthorizationInfo;<br>    &#125;<br><br>    <span class="hljs-comment">//AuthenticationInfo:认证; 身份验证; 证明</span><br>    <span class="hljs-comment">//登录的时候就会调用这个方法来做验证</span><br>    @Override<br>    protected AuthenticationInfo <span class="hljs-keyword">do</span><span class="hljs-constructor">GetAuthenticationInfo(AuthenticationToken <span class="hljs-params">token</span>)</span> throws AuthenticationException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Object principal：主体(现在就是登录的用户名)</span><br><span class="hljs-comment">         * Object hashedCredentials：编码后的认证密码</span><br><span class="hljs-comment">         * ByteSource credentialsSalt:加盐</span><br><span class="hljs-comment">         * String realmName</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//身份认证(用户名)</span><br>        Object principal = token.get<span class="hljs-constructor">Principal()</span>;<br>        <span class="hljs-comment">//密码假设是根据用户名到数据库中查询出来的（数据库密码是经过加密的）</span><br>        Object credentials = <span class="hljs-string">&quot;d5a3fedf6c59c2ecbe7f7a6c1a22da37&quot;</span>;<br>        <span class="hljs-comment">//加盐的数据</span><br>        ByteSource byteSource = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteSource</span>.</span><span class="hljs-module"><span class="hljs-identifier">Util</span>.</span></span><span class="hljs-built_in">bytes</span>(<span class="hljs-string">&quot;itsource&quot;</span>);<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleAuthenticationInfo(<span class="hljs-params">principal</span>,<span class="hljs-params">credentials</span>,<span class="hljs-params">byteSource</span>,<span class="hljs-params">getName</span>()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-3、小结"><a href="#7-3、小结" class="headerlink" title="7.3、小结"></a>7.3、小结</h5><p>授权拦截:</p><ol><li><p>写死</p></li><li><p>通过factoryBean动态获取</p></li><li><p>通过Realm获取用户权限返回给框架</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="MyBatis持久层框架"><a href="#MyBatis持久层框架" class="headerlink" title="MyBatis持久层框架"></a>MyBatis持久层框架</h2><p>MyBatis框架，此框架的主要作用就是更加便捷的操作数据库，比如：MyBatis做查询时可以将ResultSet对象返回的数据记录自动封装进Entity实体类或List中、可以把SQL语句配置到XML文件中，也就是将SQL语句与*.java文件进行分离，有利于代码的后期维护，也使代码的分层更加明确。</p><p>MyBatis不是一个独立的技术，它内部的操作数据库的原理还是使用JDBC，其只是对JDBC进行了轻量级的封装，便于程序员更加方便的设计代码去操作数据库。</p><p>MyBatis是一个“持久化ORM框架”，持久化是指内存中的数据保存到硬盘上。ORM（Object Relation Mapping）对象关系映射，从两方面介绍：</p><ol><li>大的方面，一个类对应表中的一行；</li><li>小的方面，一个类中的属性对应一个表中的列。</li></ol><p>也就是说在使用MyBatis框架时，可以将Java类转化成数据表中的记录，或者将数据表中的记录转化成Java中的类，内部技术的原理其实就是JDBC+Java反射技术。</p><p>MyBatis 是一个支持普通 SQL查询、存储过程和高级映射的<code>优秀的持久层框架</code>。MyBatis 消除了几乎所有的 JDBC代码 和 手工设置参数 ，以及结果集的检索。</p><p>MyBatis 使用简单的 <code>XML</code> 或 <code>注解</code> 用于配置和原始映射，将<code>接口</code>和 <code>Java 的POJOs</code>（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。MyBatis不能自动创建表，如果能够自动建表，必须自己事先准备好建表的SQL语句。</p><h3 id="1、对象关系映射ORM（Object-Relation-Mapping）概述"><a href="#1、对象关系映射ORM（Object-Relation-Mapping）概述" class="headerlink" title="1、对象关系映射ORM（Object Relation Mapping）概述"></a>1、对象关系映射ORM（Object Relation Mapping）概述</h3><h4 id="1-1、流行的ORM框架"><a href="#1-1、流行的ORM框架" class="headerlink" title="1.1、流行的ORM框架"></a>1.1、流行的ORM框架</h4><p>1、<strong>JPA</strong>：本身是一种<strong>ORM规范</strong>，不是ORM框架，<strong>由各大ORM框架提供实现</strong>。</p><p>2、<strong>Hibernate</strong>：<code>目前最流行的ORM框架</code>，设计灵巧，性能一般（并且开发人员不能够很好的控制性能），文档丰富。Hibernate是一个完整的ORM框架，常规CRUD我们不需要写一句SQL ( 完全自动操作 ) ；</p><p>3、<strong>MyBatis</strong>：原本是apache的一个开源项目iBatis，提供的持久层框架包括SQL Maps和Dao。MyBatis 并不是一个完整的ORM框架（或称“半自动”的ORM框架），因为我们还需要自己去写全部SQL，开发人员直接编写SQL(更好灵活)。</p><h4 id="1-2、JDBC操作数据库的缺陷"><a href="#1-2、JDBC操作数据库的缺陷" class="headerlink" title="1.2、JDBC操作数据库的缺陷"></a>1.2、JDBC操作数据库的缺陷</h4><p>首先，通过jdbc也能实现<strong>对象实体</strong>和<strong>数据库关系的映射</strong>。那就是采用硬编码方式，为每一种可能的数据库访问操作提供单独的方法， 也就是各种Dao (UserDao、DeptDao等)。</p><p>最大的缺点就是：</p><ol><li>SQL写在JAVA代码中，在修改SQL查询语句时，就连带着修改了Java代码，需要重新编译；</li><li>有很多重复性的操作（比如获取连接，释放资源等）。</li></ol><h4 id="1-3、ORM框架的操作数据库关系方式有许多种，常用的有两种"><a href="#1-3、ORM框架的操作数据库关系方式有许多种，常用的有两种" class="headerlink" title="1.3、ORM框架的操作数据库关系方式有许多种，常用的有两种"></a>1.3、ORM框架的操作数据库关系方式有许多种，常用的有两种</h4><h5 id="1、SQL操作方式-对JDBC进行轻量级封装的MyBatis框架实现"><a href="#1、SQL操作方式-对JDBC进行轻量级封装的MyBatis框架实现" class="headerlink" title="1、SQL操作方式 ( 对JDBC进行轻量级封装的MyBatis框架实现 )"></a>1、SQL操作方式 ( 对JDBC进行轻量级封装的MyBatis框架实现 )</h5><p>配置到配置文件中，通过不同中完成对象实体和数据库关系相互转换的操作。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.ProductMapper&quot;</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;get&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span></span><br><span class="xml">select * from product where id= #</span><span class="hljs-template-variable">&#123;id&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="xml">select : 这个标签里写查询语句</span><br><span class="xml">id : 用来唯一确定这条查询语句</span><br><span class="xml">未来用这条查询时由：namespace + . + id 的方式唯一确定这条查询</span><br><span class="xml">如，cn.kongwei_liao.domain.ProductMapper.get</span><br><span class="xml">parameterType : 传入的参数类型（long：Long、_long：long），具体数据库字段类型对应的高级程序语言类型参见文档</span><br><span class="xml">resultType : 结果类型（第一条数据返回的对象类型），一定是cn.kongwei_liao.domain.Product这样的全限定类名</span><br><span class="xml">--&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="2、完整操作-JPA、Hibenate框架实现方式"><a href="#2、完整操作-JPA、Hibenate框架实现方式" class="headerlink" title="2、完整操作(JPA、Hibenate框架实现方式)"></a>2、完整操作(JPA、Hibenate框架实现方式)</h5><p>直接映射的是对象实体和数据库关系映射。操作数据库关系，不用写SQL由框架自己生成。</p><p><img src="/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/image-20191203144714812.png" alt="image-20191203144714812"></p><h5 id="3、MyBatis与Hibenate对比"><a href="#3、MyBatis与Hibenate对比" class="headerlink" title="3、MyBatis与Hibenate对比"></a>3、MyBatis与Hibenate对比</h5><p>MyBatis使用SQL语句对数据库进行操作的，所以单独对SQL语句进行优化，以提高查询效率，这点与Hibernate框架相比有很大优势，现阶段大部分的软件企业正逐步用MyBatis替换掉Hibernate。</p><p>更严格的来讲，MyBatis是一种“半自动化”的ORM框架，应该算作SQL映射框架（SQL mapper framework）。因为MyBatis操作数据库时还是使用的原始的SQL语句，这些语句仍要由程序员来自行设计。在使用上和全自动的ORM框架Hibernate有着非常大的区别，MyBatis是以SQL语句为映射基础，而Hibernate是彻底的基于实体类与表进行映射。正是由于MyBatis的半自动化特性，可以将SQL语句灵活多变的特性融入到项目的开发中。</p><p>。。。。。。</p><h4 id="1-4、ORM框架工作原理"><a href="#1-4、ORM框架工作原理" class="headerlink" title="1.4、ORM框架工作原理"></a>1.4、ORM框架工作原理</h4><p>1、以一定的映射方式，把实体模型和数据库关系的映射；</p><p>2、ORM框架启动时加载这些映射和数据库配置文件；</p><p>3、ORM通过对最原生JDBC的封装提供更加便利的操作API；</p><p>4、Dao通过ORM提供的便捷API以对象的方式操作数据库关系。</p><p><img src="/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/image-20191203144903564.png" alt="image-20191203144903564"></p><h3 id="3、MyBatis完成CRUD入门举例"><a href="#3、MyBatis完成CRUD入门举例" class="headerlink" title="3、MyBatis完成CRUD入门举例"></a>3、MyBatis完成CRUD入门举例</h3><p>准备步骤：<strong>导包</strong> –&gt; <strong>建表</strong> –&gt; <strong>domain(JavaBean)</strong> –&gt; <strong>准备Dao层(CRUD)</strong> –&gt; <strong>测试及业务代码中使用</strong></p><p>注意：我们要引哪些包?</p><ol><li>一定要引入JDBC驱动包；</li><li>导入MyBatis的核心包；</li><li>导入MyBatis的依赖包。</li></ol><h4 id="3-1、准备工作"><a href="#3-1、准备工作" class="headerlink" title="3.1、准备工作"></a>3.1、准备工作</h4><p>1、创建Java项目</p><p>2、导入所需的Jar包</p><p>MyBatis是一个持久层框架，在Java中框架就是一组Java类最后打成Jar包。所有使用的Java框架，使用前都要先导入相应 的Jar包。在导入jar包之前，我们得先说一下，MyBatis是操作数据库的框架。要操作数据库，还需要导入相应的数据库驱动包。注：数据库驱动包就是各大数据库厂商根据JDBC规范实现的jar包。</p><p>下图为我们使用MyBatis要导入的包：</p><p><img src="/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/image-20191203145413871.png" alt="image-20191203145413871"></p><p>如用Maven包管理工具管理项目，可在配置文件中加入如下依赖：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- mybatis版本号 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.version</span>&gt;</span>3.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.version</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-comment">&lt;!-- mysql驱动版本号 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mysql-driver.version</span>&gt;</span>5.1.29<span class="hljs-tag">&lt;/<span class="hljs-name">mysql-driver.version</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-comment">&lt;!-- log4j日志包版本号 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.7.18<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 添加mybatis依赖 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mybatis.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.18.1-GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-comment">&lt;!-- 添加mysql驱动依赖 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mysql-driver.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-comment">&lt;!-- 添加日志相关jar包 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;log4j.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;slf4j.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;slf4j.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>3、准备相应的数据库表</p><p>现在直接引入我们准备好的product表即可：</p><p><img src="/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/image-20191203150151545.png" alt="image-20191203150151545"></p><p>4、准备实体类JavaBean（domain层，不知道为什么是用domain这个词）</p><p>创建一个Product对象，对象属性 和数据库的 表中字段 对应；</p><p>注：类的名称  和  类型 都和我们的  Product表相对应匹配。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br><span class="hljs-keyword">private</span>Long id;<span class="hljs-comment">//商品名称</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> productName;<span class="hljs-comment">//品牌</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> brand;<span class="hljs-comment">//供应商</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> supplier;<span class="hljs-comment">//零售价</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">Double</span> salePrice;<span class="hljs-comment">//进价</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">Double</span> costPrice;<span class="hljs-comment">//折扣比例</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">Double</span> cutoff;<span class="hljs-comment">//商品分类编号</span><br><span class="hljs-keyword">private</span> Long dir_id; <span class="hljs-comment">//提供getter与setter...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>5、Dao层准备</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 商品的持久操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IProductDao</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span>(<span class="hljs-params">Product p</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Product p</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span>(<span class="hljs-params">Long id</span>)</span>;<br><span class="hljs-function">Product <span class="hljs-title">get</span>(<span class="hljs-params">Long id</span>)</span>;<br><span class="hljs-function">List&lt;Product&gt; <span class="hljs-title">getAll</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2、MyBatis核心配置文件"><a href="#3-2、MyBatis核心配置文件" class="headerlink" title="3.2、MyBatis核心配置文件"></a>3.2、MyBatis核心配置文件</h4><p>入门开始，介绍了MyBatis之后，就在提前知道MyBatis有一个核心对象：<code>SqlSessionFactory</code>，接下来要想方设法拿到这个核心对象。那我们如何拿到这个SqlSessionFactory对象？</p><ol><li>我们需要准备一个核心的xml文件；</li><li>拿到SqlSessionFactory之前需要读取核心的xml配置文件；</li><li>需要构造者(SqlSessionFactoryBuilder)来创建它。</li></ol><h5 id="1、准备核心的xml文件："><a href="#1、准备核心的xml文件：" class="headerlink" title="1、准备核心的xml文件："></a>1、准备核心的xml文件：</h5><p>数据库连接配置，映射文件位置的配置等。</p><p>资源文件加下面创建一个文件，命名为MyBatis-Config.xml</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="xml">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 引入一个外部的Properties文件，如db.properties文件，该文件保存数据库连接属性，包括：驱动、数据库地址、数据库账号及密码 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span> /&gt;</span></span><br><span class="xml">    </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- alias:取的别名 --&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- type：这个别名所对应的Java类 ：别名使用的时候与大小写无关 --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.kongwei-liao.domain.Department&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Department&quot;</span>/&gt;</span></span><br><span class="xml">        </span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 将一个包下面的所有类都取上别名:&lt;package name=&quot;cn.kongwei-liao.domain&quot; /&gt; --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cn.kongwei-liao.domain&quot;</span>/&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></span><br><span class="xml">    </span><br><br><span class="xml">    <span class="hljs-comment">&lt;!-- 环境们 (很多环境的意思)default:默认使用哪一个环境(必需对应一个环境的id) --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 一个环境一个id:为这个环境取唯一一个id名称 --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-comment">&lt;!-- 事务管理 type:JDBC(支持事务)/MANAGED(什么都不做) --&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-comment">&lt;!-- 数据源, 连接池 type(POOLED):MyBatis自带的连接池 --&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="xml">                <span class="hljs-comment">&lt;!-- 连接数据库的参数 --&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.driver&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.username&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 这个mappers代表的是相应的ORM映射文件，添加映射文件的位置 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 添加映射文件：1.前面不添加/，表示相对路径;2.使用的文件路径/,不是包路径. --&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 单表crud --&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- &lt;mapper resource=&quot;cn/kongwei_liao/domain/ProductMapper.xml&quot; /&gt; --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;cn/kongwei_liao/domain/ProductMapper.xml&quot;</span>/&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>Eclipse配置MyBatis-Config.xml提示信息，IDEA没整理不知道咋搞？？</p><p><img src="/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/image-20191203152252675.png" alt="image-20191203152252675"></p><h5 id="2、MyBatis核心配置标签的一个简单介绍："><a href="#2、MyBatis核心配置标签的一个简单介绍：" class="headerlink" title="2、MyBatis核心配置标签的一个简单介绍："></a>2、MyBatis核心配置标签的一个简单介绍：</h5><p>configuration：配置文件根标签；</p><p>environments：里面两个内容(<code>transactionManager</code>, <code>dataSource</code> )；</p><p>dataSource : <code>driver</code>, <code>url</code>, <code>username</code>, <code>password</code>(连接数据库的最小单位)；</p><p>mappers：mapper映射文件地址。</p><h5 id="3、抽取数据库信息-到-db-properties配置文件"><a href="#3、抽取数据库信息-到-db-properties配置文件" class="headerlink" title="3、抽取数据库信息 到 db.properties配置文件"></a>3、抽取数据库信息 到 db.properties配置文件</h5><p>关于数据库连接的信息已经在配置文件(XML)中，但是更多时候，我们还是会把配置文件的信息放到db.properties中。(由于properties的结构简单，便于修改，而这个文件只放数据库的连接信息也更好的体现了职责分离)。</p><p>其实，在官方文档的核心文件配置，就是直接使用的推荐的properties方式。</p><p>只需要我们做如下修改即可：</p><p>资源文件夹新建***.properties文件，如<strong>db.properties</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">db.driver</span>=com.mysql.jdbc.Driver<br><span class="hljs-attr">db.url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/test<br><span class="hljs-attr">db.username</span>=root<br><span class="hljs-attr">db.password</span>=root<br></code></pre></td></tr></table></figure><p>MyBatis-Config.xml文件修改：用${…}符号引入db.properties中参数</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 引入Properties文件 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 根据key拿到properties中的value值 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.driver&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.username&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span> </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="4、映射文件：对象与关系的映射"><a href="#4、映射文件：对象与关系的映射" class="headerlink" title="4、映射文件：对象与关系的映射"></a>4、映射文件：对象与关系的映射</h5><p>MyBatis是一个ORM映射框架，请问ORM体现在哪?</p><p>核心文件中有一个mappers,它指向了一个映射文件。映射文件在哪？</p><p>不是说好的MyBatis要写SQL语句么？SQL语句又在哪里？</p><p>如果直接写xml是没有提示了，在xml文件中加上约束的时候，xml就会有提示。</p><p>而现在使用的约束是通过网络访问，在Eclipse中，我们可以找到相应的约束文件，然后配置到自己本地即可。</p><p>直接找到我们文档中的探究已映射的SQL语句,在这里，我就可以看到一段xml(如下图)，这个xml就是咱们需要的映射文件，它就可以体现出ORM，并且在这里面，也可以愉快的写sql语句了。</p><p><img src="/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/image-20191203155111232.png" alt="image-20191203155111232"></p><p>在这里，我们可以看懂一些配置的意思，但是也有一些东西不是很明白。在下面的实例中，我已经对每一句配置准备好了相应的解释：</p><p>cn/kongwei_liao/domain/ProductMapper.xml文件如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="xml">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><br><span class="xml"><span class="hljs-comment">&lt;!--公共查询句：可由include标签引入--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rootsql&quot;</span>&gt;</span></span><br><span class="xml">select * from product</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-------------------------------------------------------------------------------------&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="xml">这个Mapper的主要功能就是写sql</span><br><span class="xml">mapper:根</span><br><span class="xml">namespace:命令空间 (用来确定唯一) 以前这个是可以不加的,现在必需加</span><br><span class="xml">namespace的值，规则的：映射文件XxxMapper.xml所在的包+domain类名+Mapper</span><br><span class="xml"> --&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.ProductMapper&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 固定书写方法 --&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--</span></span><br><span class="xml">        select : 这里面写查询语句</span><br><span class="xml">        id:用来确定这条sql语句的唯一</span><br><span class="xml">               以后我们确定唯一,也就是找sql语句 : namespace + . + id</span><br><span class="xml">             例: cn.kongwei_liao.domain.ProductMapper.get</span><br><span class="xml">        parameterType : 传入的参数类型  long:大Long  _long:小long (具体的对应请参见文档)</span><br><span class="xml">        resultType : 结果类型(第一条数据返回的对象类型) 自己的对象，一定是cn.kongwei_liao.domain.Product这样的全限定类名</span><br><span class="xml">     --&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!--include refid=&quot;rootsql&quot;&gt;&lt;/include--&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!--OR--&gt;</span></span><br><span class="xml">select * from product</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;rootsql&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="xml">where id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByNameAndId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;employee_department_role&quot;</span> &gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;rootsql&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="xml">where  productname=#</span><span class="hljs-template-variable">&#123;0&#125;</span><span class="xml"> and productid=#</span><span class="hljs-template-variable">&#123;1&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;searchByProductName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span></span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;rootsql&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="xml">where productname like &#x27;%$</span><span class="hljs-template-variable">&#123;productname&#125;</span><span class="xml">%&#x27;</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 若方法传参名于$or#</span></span><span class="hljs-template-variable">&#123;&#125;</span><span class="xml"><span class="hljs-comment">中的不匹配，在方法的传入的参数类型前加@Param(&quot;$or#</span></span><span class="hljs-template-variable">&#123;&#125;</span><span class="xml"><span class="hljs-comment">中的名字&quot;) --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span></span><br><span class="xml">insert into product(productName,salePrice,costPrice,cutoff,supplier,brand,dir_id)</span><br><span class="xml">values</span><br><span class="xml">(#</span><span class="hljs-template-variable">&#123;productName&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;salePrice&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;costPrice&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;cutoff&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;supplier&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;brand&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;dir_id&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span></span><br><span class="xml">update product set productName=#</span><span class="hljs-template-variable">&#123;productName&#125;</span><span class="xml">,salePrice=#</span><span class="hljs-template-variable">&#123;salePrice&#125;</span><span class="xml">,costPrice=#</span><span class="hljs-template-variable">&#123;costPrice&#125;</span><span class="xml">,</span><br><span class="xml">cutoff=#</span><span class="hljs-template-variable">&#123;cutoff&#125;</span><span class="xml">,supplier=#</span><span class="hljs-template-variable">&#123;supplier&#125;</span><span class="xml">,brand=#</span><span class="hljs-template-variable">&#123;brand&#125;</span><span class="xml">,dir_id=#</span><span class="hljs-template-variable">&#123;dir_id&#125;</span><br><span class="xml">where id=#</span><span class="hljs-template-variable">&#123;id&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delete&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Long&quot;</span>&gt;</span></span><br><span class="xml">delete from product where id=#</span><span class="hljs-template-variable">&#123;id&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="3-3、上述映射配置文件的规范及注意事项"><a href="#3-3、上述映射配置文件的规范及注意事项" class="headerlink" title="3.3、上述映射配置文件的规范及注意事项"></a>3.3、上述映射配置文件的规范及注意事项</h4><p>① 我们的映射文件一般情况下是放在 <code>resources类型目录下</code> 和它对应的<code>domain</code>在同一个层级；</p><p>② 这个映射文件的名称一般叫做 XxxMapper.xml (Xxx代表的是实体类名称)；</p><p>③ namespace的名称为了确定唯一性，应按推荐要求取名：</p><p>​    如我们有一个类：</p><p>​        cn.kongwei_liao.domain.Product / cn.kongwei_liao.domain.Student</p><p>​    那这里取名应该是：</p><p>​        cn.kongwei_liao.domain.ProductMapper / cn.kongwei_liao.domain.StudentMapper</p><p>④ 除了MyBatis支持的类型，其它的类型都通通使用<code>全限定名</code> ；</p><p>⑤ 如果将映射文件与实体类放在一起，运行时会遇到访问不到这个映射文件资源错误（放到resources类型目录下就不会出现这种情况），可能是因为资源路径不可达，可在pom.xml文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- build标签内 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><span class="hljs-comment">&lt;!--关键配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-4、完成数据的CRUD"><a href="#3-4、完成数据的CRUD" class="headerlink" title="3.4、完成数据的CRUD"></a>3.4、完成数据的CRUD</h4><p>核心配置文件有了，映射文件也有了，现在就可以完成数据库的CRUD了。首先需要获取的是核心对象SqlSessionFactory，然后通过它去拿到一个SqlSession对象(相当于JDBC的连接)。必需要有SqlSession这个对象，我们才可以去执行相应的SQL。</p><h5 id="1、SqlSession对象的获取"><a href="#1、SqlSession对象的获取" class="headerlink" title="1、SqlSession对象的获取"></a>1、SqlSession对象的获取</h5><p>官方文档从XML 中构建 SqlSessionFactory这一章中，除了配置的核心xml，在上面我们还可以看到几句代码(如下图)，现在咱们就来详细分析一下这几句代码是什么意思：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static SqlSessionFactory sqlSessionFactory;<br>Reader reader = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Resources</span>.</span></span>get<span class="hljs-constructor">ResourceAsReader(<span class="hljs-string">&quot;MyBatis-Config.xml&quot;</span>)</span>;<br>sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SqlSessionFactoryBuilder()</span>.build(reader);<br></code></pre></td></tr></table></figure><p>我们简单解释一下上面的代码：读取核心配置文件，然后再通过SqlSessionFactoryBuilder构建者来创建一个SqlSessionFactory对象。</p><p>注：上面的SqlSession对象是一个通过SqlSessionFactory工厂对象返回的对象:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">SqlSession <span class="hljs-title">getSession</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">return</span> sqlSessionFactory.<span class="hljs-title">openSession</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、获取SqlSession的工具类（MyBatisUtils）抽取"><a href="#2、获取SqlSession的工具类（MyBatisUtils）抽取" class="headerlink" title="2、获取SqlSession的工具类（MyBatisUtils）抽取"></a>2、获取SqlSession的工具类（MyBatisUtils）抽取</h5><p>对于MyBatis的工具类抽取，直接使用静态工具的单例模式。</p><p>注：几种单例模式的区别与使用(单例工具与静态工具的区别)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><br><span class="hljs-keyword">import</span> java.io.Reader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisUtils</span> </span>&#123;<br>    <span class="hljs-comment">// 保证SqlSessionFactory是单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-comment">// SqlSessionFactory类似于JPA的EntityManagerFactory，Hibernate的SessionFactory</span><br>    <span class="hljs-comment">// SqlSession 类似于JPA的EntityManager，Hibernate的Session</span><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Reader reader = Resources.getResourceAsReader(<span class="hljs-string">&quot;MyBatis-Config.xml&quot;</span>);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(reader);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;解析MyBatis的配置文件或者映射文件出现异常：&quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对外提供一个返回SqlSession对象的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSession</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、查询一条数据"><a href="#3、查询一条数据" class="headerlink" title="3、查询一条数据"></a><strong>3、查询一条数据</strong></h5><p>大家要注意咱们传过去的参数，还有在SQL接收的参数！</p><p>传过去的<code>变量名称</code>和<code>#里面的字符串名称</code>不是一回事！</p><p>整个MyBatis的流程再进行一次分析：</p><ol><li><p>我们需要核心文件(提供联系数据库的环境)</p></li><li><p>需要映射文件(提供ORM与运行的SQL语句)</p></li><li><p>拿到SqlSession对象，用于执行SQL</p></li></ol><p>ProductDaoImp.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String NAME_SPACE = <span class="hljs-string">&quot;cn.kongwei_liao.domain.ProductMapper.&quot;</span>;<span class="hljs-comment">//NAME_SPACE怎么写????  最后需要有个点</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function">Product <span class="hljs-title">get</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>    SqlSession sqlSession = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        sqlSession = MyBatisUtils.getSession();<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> sqlSession.<span class="hljs-title">selectOne</span><span class="hljs-params">(NAME_SPACE + <span class="hljs-string">&quot;getById&quot;</span>, id)</span></span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;ProductDaoImpl.get出现异常：&quot;</span> + e.getMessage());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (sqlSession != <span class="hljs-keyword">null</span>) &#123;<br>            sqlSession.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、junit测试（有必要的）"><a href="#4、junit测试（有必要的）" class="headerlink" title="4、junit测试（有必要的）"></a>4、junit测试（有必要的）</h5><p>写代码过程中进行测试是一个好习惯。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductDaoTest</span> &#123;</span><br>IProductDao productDao = <span class="hljs-keyword">new</span> ProductDaoImpl();<br>@Test<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> </span>&#123;<br>Product product = productDao.<span class="hljs-built_in">get</span>(<span class="hljs-number">1L</span>);<br>System.out.<span class="hljs-built_in">println</span>(product);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、查询所有数据"><a href="#5、查询所有数据" class="headerlink" title="5、查询所有数据"></a>5、查询所有数据</h5><p>代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;Product&gt; <span class="hljs-function"><span class="hljs-title">getAll</span>(<span class="hljs-params"></span>)</span> &#123;<br>SqlSession sqlSession = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>sqlSession = MyBatisUtils.getSession();<br><span class="hljs-keyword">return</span> sqlSession.selectList(NAME_SPACE + <span class="hljs-string">&quot;getAll&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;ProductDaoImpl.get出现异常：&quot;</span> + e.getMessage());<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (sqlSession != <span class="hljs-literal">null</span>) &#123;<br>sqlSession.close();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">@Test<br><span class="hljs-keyword">public</span> void testGetAll() &#123;<br>List&lt;<span class="hljs-built_in">Product</span>&gt; list = productDao.getAll();<br>for (<span class="hljs-built_in">Product</span> <span class="hljs-built_in">product</span> : list) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">product</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6、添加数据"><a href="#6、添加数据" class="headerlink" title="6、添加数据"></a>6、添加数据</h5><p>注：添加的时候一定要记住提交事务 ( 配置事务、表结构支持事务 );</p><p><code>JDBC的事务是自动提交的，而JPA、Hibernate、MyBatis事务都是需要手动提交的。</code></p><p>代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">save</span>(<span class="hljs-params">Product product</span>)</span> &#123;<br>SqlSession sqlSession = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>sqlSession = MyBatisUtils.getSession();<br>sqlSession.insert(NAME_SPACE + <span class="hljs-string">&quot;save&quot;</span>, product);<br><br><span class="hljs-comment">// JDBC的事务是自动提交的，而JPA、Hibernate、MyBatis事务都是需要手动提交的</span><br>sqlSession.commit();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;ProductDaoImpl.get出现异常：&quot;</span> + e.getMessage());<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (sqlSession != <span class="hljs-literal">null</span>) &#123;<br>sqlSession.close();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fortran">@Test<br><span class="hljs-keyword">public</span> void testSave() &#123;<br><span class="hljs-built_in">Product</span> <span class="hljs-built_in">product</span> = new <span class="hljs-built_in">Product</span>();<br><span class="hljs-built_in">product</span>.setBrand(<span class="hljs-string">&quot;大力牌&quot;</span>);<br><span class="hljs-built_in">product</span>.setCostPrice(<span class="hljs-number">30.0</span>);<br><span class="hljs-built_in">product</span>.setCutoff(<span class="hljs-number">0.8</span>);<br><span class="hljs-built_in">product</span>.setDir_id(<span class="hljs-number">1</span>L);<br><span class="hljs-built_in">product</span>.setProductName(<span class="hljs-string">&quot;000000&quot;</span>);<br><span class="hljs-built_in">product</span>.setSalePrice(<span class="hljs-number">60</span>D);<br><span class="hljs-built_in">product</span>.setSupplier(<span class="hljs-string">&quot;东莞供应商&quot;</span>);<br>productDao.<span class="hljs-keyword">save</span>(<span class="hljs-built_in">product</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>添加数据的有时候咱们需要拿到当前数据的主键。咱们先移步到MyBatis细节一章的拿到返回主键部分！下一章</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 可选择性插入 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertSelective&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span></span></span><br><span class="xml">        useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="xml">        insert into product</span><br><span class="xml">        product(productName,salePrice,costPrice,cutoff,supplier,brand,dir_id)</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="xml">                id,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;productName != null&quot;</span>&gt;</span></span><br><span class="xml">                vid,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salePrice != null&quot;</span>&gt;</span></span><br><span class="xml">                ntype,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;costPrice != null&quot;</span>&gt;</span></span><br><span class="xml">                canentry,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;supplier != null&quot;</span>&gt;</span></span><br><span class="xml">                title,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brand != null&quot;</span>&gt;</span></span><br><span class="xml">                ispush,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;dir_id != null&quot;</span>&gt;</span></span><br><span class="xml">                entrycount,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;values (&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="xml">                #</span><span class="hljs-template-variable">&#123;id,jdbcType=INTEGER&#125;</span><span class="xml">,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;productName != null&quot;</span>&gt;</span></span><br><span class="xml">                #</span><span class="hljs-template-variable">&#123;productName,jdbcType=VARCHAR&#125;</span><span class="xml">,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;salePrice != null&quot;</span>&gt;</span></span><br><span class="xml">                #</span><span class="hljs-template-variable">&#123;salePrice,jdbcType=TINYINT&#125;</span><span class="xml">,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;costPrice != null&quot;</span>&gt;</span></span><br><span class="xml">                #</span><span class="hljs-template-variable">&#123;costPrice,jdbcType=TINYINT&#125;</span><span class="xml">,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;cutoff != null&quot;</span>&gt;</span></span><br><span class="xml">                #</span><span class="hljs-template-variable">&#123;cutoff,jdbcType=VARCHAR&#125;</span><span class="xml">,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;supplier != null&quot;</span>&gt;</span></span><br><span class="xml">                #</span><span class="hljs-template-variable">&#123;supplier,jdbcType=TINYINT&#125;</span><span class="xml">,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brand != null&quot;</span>&gt;</span></span><br><span class="xml">                #</span><span class="hljs-template-variable">&#123;brand,jdbcType=VARCHAR&#125;</span><span class="xml">,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;dir_id != null&quot;</span>&gt;</span></span><br><span class="xml">                #</span><span class="hljs-template-variable">&#123;dir_id,jdbcType=INTEGER&#125;</span><span class="xml">,</span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="7、修改数据"><a href="#7、修改数据" class="headerlink" title="7、修改数据"></a>7、修改数据</h5><p>代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">Product product</span>)</span> &#123;<br>SqlSession sqlSession = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>sqlSession = MyBatisUtils.getSession();<br>sqlSession.update(NAME_SPACE + <span class="hljs-string">&quot;update&quot;</span>, product);<br><br><span class="hljs-comment">// JDBC的事务是自动提交的，而JPA、Hibernate、MyBatis事务都是需要手动提交的</span><br>sqlSession.commit();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;ProductDaoImpl.get出现异常：&quot;</span> + e.getMessage());<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (sqlSession != <span class="hljs-literal">null</span>) &#123;<br>sqlSession.close();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran">@Test<br><span class="hljs-keyword">public</span> void testUpdate() &#123;<br><span class="hljs-built_in">Product</span> <span class="hljs-built_in">product</span> = productDao.get(<span class="hljs-number">1</span>L);<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">product</span>);<br><br><span class="hljs-built_in">product</span>.setBrand(<span class="hljs-string">&quot;大力牌&quot;</span>);<br><span class="hljs-built_in">product</span>.setCostPrice(<span class="hljs-number">30.0</span>);<br><span class="hljs-built_in">product</span>.setCutoff(<span class="hljs-number">0.8</span>);<br><span class="hljs-built_in">product</span>.setDir_id(<span class="hljs-number">1</span>L);<br><span class="hljs-built_in">product</span>.setProductName(<span class="hljs-string">&quot;000000&quot;</span>);<br><span class="hljs-built_in">product</span>.setSalePrice(<span class="hljs-number">60</span>D);<br><span class="hljs-built_in">product</span>.setSupplier(<span class="hljs-string">&quot;东莞供应商&quot;</span>);<br>productDao.update(<span class="hljs-built_in">product</span>);<br><br><span class="hljs-built_in">product</span> = productDao.get(<span class="hljs-number">1</span>L);<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">product</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8、删除一条数据"><a href="#8、删除一条数据" class="headerlink" title="8、删除一条数据"></a>8、删除一条数据</h5><p>代码：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">delete</span>(Long id) &#123;<br>SqlSession sqlSession = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>sqlSession = MyBatisUtils.getSession();<br>sqlSession.<span class="hljs-keyword">delete</span>(NAME_SPACE + <span class="hljs-string">&quot;delete&quot;</span>, id);<br><span class="hljs-comment">// JDBC的事务是自动提交的，而JPA、Hibernate、MyBatis事务都是需要手动提交的</span><br>sqlSession.commit();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;ProductDaoImpl.delete出现异常：&quot;</span> + e.getMessage());<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (sqlSession != <span class="hljs-literal">null</span>) &#123;<br>sqlSession.close();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@Test<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>productDao.<span class="hljs-keyword">delete</span>(<span class="hljs-number">1L</span>);<br>Product product = productDao.<span class="hljs-built_in">get</span>(<span class="hljs-number">1L</span>);<br>System.out.<span class="hljs-built_in">println</span>(product);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9、CRUD注意事项"><a href="#9、CRUD注意事项" class="headerlink" title="9、CRUD注意事项"></a>9、CRUD注意事项</h5><p>下面是在使用MyBatis的时候经常出现的问题，需要引起重视。出现问题的时候过来好好的来找。基本咱们使用MyBatis中出的错都在这里。</p><p>使用框架的时候配置信息变多，在配置里写的都是字符串，而且经常是要对应的。因为，这里希望大家要切记：写的时候细心，出现错误找字符串要耐心，</p><ol><li>主配置中未配置相应的mapper（当然，这个路径也可能写错）；</li><li>在代码中调用Sql的时候路径写错；</li><li>Sql写错，这个应该还好找；</li><li>当我们在配置文件中很多地方如果写错，即便是你还没有使用也可能会报错；</li><li>写Sql的标签不需要全部一致（如添加不一定必需使用insert），但是它的属性会不同；</li><li>在传入与返回参数时全限定类名写错。</li></ol><p>在开发的时候，要边做边测试。 在某一步出现错误后，删除新加的代码看有没有问题，如果删除部分代码后运行成功，就相应的可以缩小排错的范围。</p><h3 id="4、MyBatis三大核心对象介绍，及其生命周期"><a href="#4、MyBatis三大核心对象介绍，及其生命周期" class="headerlink" title="4、MyBatis三大核心对象介绍，及其生命周期"></a>4、MyBatis三大核心对象介绍，及其生命周期</h3><h4 id="4-1、SqlSessionFactoryBuilder"><a href="#4-1、SqlSessionFactoryBuilder" class="headerlink" title="4.1、SqlSessionFactoryBuilder"></a>4.1、SqlSessionFactoryBuilder</h4><p>建造者模式：我们最后拿到的这个对象是非常复杂的。用这个建造者就它先为我们把这些复杂的代码完成。</p><p>这个类可以被实例化，使用和丢弃。<strong>一旦你创建了SqlSessionFactory后，这个SqlSessionFactoryBuilder类就不需要存在了。</strong>因此SqlSessionFactoryBuilder实例的最佳范围是方法范围（也就是本地方法变量）。</p><p>你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好的方式是</p><p>不需要保持它一直存在来保证所有XML解析资源，因为还有更重要的事情要做。 </p><h4 id="4-2、SqlSessionFactory"><a href="#4-2、SqlSessionFactory" class="headerlink" title="4.2、SqlSessionFactory"></a>4.2、SqlSessionFactory</h4><p>类似于JPA的EntityManagerFactory，Hibernate的SessionFactory</p><p><strong>一旦被创建，SqlSessionFactory应该在你的应用执行期间都存在。</strong>没有理由来处理或重新创建它。使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次。这样的操作将被视为是非常糟糕的，因此SqlSessionFactory的最佳范围是应用范围。</p><p>有很多方法可以做到，最简单的就是<code>使用单例模式</code>或者<code>静态单例模式</code>。然而这两种方法都不认为是最佳实践。这样的话，你可以<strong>考虑依赖注入容器，比如Google Guice或Spring。这样的框架允许你创建支持程序来管理单例SqlSessionFactory的生命周期。</strong> </p><h4 id="4-3、SqlSession"><a href="#4-3、SqlSession" class="headerlink" title="4.3、SqlSession"></a>4.3、SqlSession</h4><p>类似于JPA的EntityManager，Hibernate的Session</p><p><strong>每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能被共享，也是线程不安全的。</strong>因此最佳的范围是请求或方法范围。</p><p>绝对不能将SqlSession实例的引用放在一个类的静态字段甚至是实例字段中。</p><p>也绝不能将SqlSession实例的引用放在任何类型的管理范围中，比如Serlvet架构中的HttpSession。</p><p>如果你现在正用任意的Web框架，要考虑SqlSession放在一个和HTTP请求对象相似的范围内。换句话说，基于收到的HTTP请求，你可以打开了一个SqlSession，然后返回响应，就可以关闭它了。关闭Session很重要！</p><p>为什么在这里我们要先说这三大核心对象呢，因为在我们必需要了解这三个对象的特性。才可以更好的根据这个特性来完成MyBatisUtils工具类代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><br><span class="hljs-keyword">import</span> java.io.Reader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisUtils</span> </span>&#123;<br>    <span class="hljs-comment">// 保证SqlSessionFactory是单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-comment">// SqlSessionFactory类似于JPA的EntityManagerFactory，Hibernate的SessionFactory</span><br>    <span class="hljs-comment">// SqlSession 类似于JPA的EntityManager，Hibernate的Session</span><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Reader reader = Resources.getResourceAsReader(<span class="hljs-string">&quot;MyBatis-Config.xml&quot;</span>);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(reader);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;解析MyBatis的配置文件或者映射文件出现异常：&quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对外提供一个类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSession</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、MyBatis的使用细节"><a href="#5、MyBatis的使用细节" class="headerlink" title="5、MyBatis的使用细节"></a>5、MyBatis的使用细节</h3><h4 id="5-1、添加时拿到返回的主键"><a href="#5-1、添加时拿到返回的主键" class="headerlink" title="5.1、添加时拿到返回的主键"></a>5.1、添加时拿到返回的主键</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- </span></span><br><span class="xml">parameterType：需要传入我们的对象;</span><br><span class="xml">useGeneratedKeys: 是否需要主键;</span><br><span class="xml">keyColumn:主键所在的表字段（列），可以不用配置;</span><br><span class="xml">keyProperty:Java对象中的属性 (代表主键的那个属性)。</span><br><span class="xml"> --&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;save&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span></span></span><br><span class="xml">useGeneratedKeys=&quot;true&quot; </span><br><span class="xml">keyColumn=&quot;id&quot;</span><br><span class="xml">keyProperty=&quot;id&quot;&gt;</span><br><span class="xml">insert into product (productName,dir_id,salePrice,supplier,brand,cutoff,costPrice)</span><br><span class="xml">values (#</span><span class="hljs-template-variable">&#123;productName&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;dir_id&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;salePrice&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;supplier&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;brand&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;cutoff&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;costPrice&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上述的插入操作，没有进行主键的插入，再插入这条记录时主键以递增的方式插入记录。MyBatis会自动把这个主键set到对象的属性上。</p><h4 id="5-2、Log4j日志框架"><a href="#5-2、Log4j日志框架" class="headerlink" title="5.2、Log4j日志框架"></a>5.2、Log4j日志框架</h4><p>在使用MyBatis的很多时候，我们可能需要把日志打印出来，帮助我们进行分析与排错。</p><p>打开后我们可以看到执行的SQL语句，可以看到我们传递的参数。</p><p>而MyBatis中打印日志使用的是Log4j。</p><p>1、Log4j简介</p><p>Log4j有三个主要的组件：<code>Loggers（记录器）</code>，<code>Appenders（输出源）</code>和 <code>Layouts（布局）</code>。</p><p>可简单理解为<code>日志类别</code>，日志<code>要输出的地方</code>和日志<code>以何种形式输出</code>。综合使用这三个组件可以轻松地记录<code>信息的类型</code>和<code>级别</code>，并可以在运行时<code>控制日志输出的样式和位置</code>。</p><p>2、日志等级</p><blockquote><p>等级从低到高</p><ol><li><p>TRACE：详细</p></li><li><p>DEBUG：调试，类似于System.out.print</p></li><li><p>INFO：信息，类似于JPA打印sql等级</p></li><li><p>WARN：警告，程序可以正常运行，出现提示</p></li><li><p>ERROR：错误，出现异常</p></li></ol></blockquote><p>3、log4j.properties</p><p>要在项目中打开日志，在资源文件根目录下创建一个log4j.properties的文件，并把下面的代码拷备到里面。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log4j.rootLogger</span>=ERROR, STDOUT<br><span class="hljs-comment">#log4j.rootLogger=NONE</span><br><span class="hljs-attr">log4j.logger.cn.kongwei_liao</span>=TRACE   <span class="hljs-comment">#把左边包名改成你自己的包名</span><br><br><span class="hljs-attr">log4j.appender.stdout</span>=org.apache.log4j.ConsoleAppender<br><span class="hljs-attr">log4j.appender.stdout.layout</span>=org.apache.log4j.PatternLayout<br><span class="hljs-attr">log4j.appender.stdout.layout.ConversionPattern</span>=%d %p [%c] - %m%n<br></code></pre></td></tr></table></figure><p>注意：cn.kongwei_liao：一定要根据自己的包名情况进行修改。</p><p>如果配置成功，那么在MyBatis运行操作数据时就可以看到相应的日志了。</p><h4 id="5-3、MyBatis中为一个类取别名"><a href="#5-3、MyBatis中为一个类取别名" class="headerlink" title="5.3、MyBatis中为一个类取别名"></a>5.3、MyBatis中为一个类取别名</h4><p>别名：分两种 –&gt; <code>内置别名</code>和<code>自定义别名</code></p><p><img src="/2021/02/15/MyBatis-%E5%9F%BA%E7%A1%80/image-20191211110636317.png" alt="image-20191211110636317"></p><p>自定义别名：</p><p>在我们前面传参与接收结果的时候，咱们一直是使用的全限定名；</p><p>但是MyBatis自己在使用很多自己的内置类型的时候（如Integer，Boolean）却可以直接使用别名；</p><p>那么，咱们自己的写的类能不能使用别名呢？当然可以，看下面的案例：</p><p>取别名有什么用？我认识一个朋友，他叫做：特雷西 · 麦克格雷迪，我叫他麦迪。</p><p>下面为取别名的代码：</p><p>在MyBatis-Config.xml配置文件中配置别名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">1、将一个包下面的所有类都取上别名:&lt;package name=&quot;cn.kongwei_liao.domain&quot;，别名就是类名。/&gt;</span><br><span class="hljs-comment">2、单独的为各JavaBean实体类取别名</span><br><span class="hljs-comment">alias:取的别名</span><br><span class="hljs-comment">type：这个别名所对应的Java类</span><br><span class="hljs-comment">3、别名使用的时候与大小写无关</span><br><span class="hljs-comment"> --&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置繁琐很少使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;product&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 做项目的时候使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring集成项目中的applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>... ...<br><span class="hljs-comment">&lt;!--别名的配置:domain query--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;edu.zzu.domain,edu.zzu.query&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--&lt;property name=&quot;typeAliases&quot;  value=&quot;&quot;/&gt;--&gt;</span><br>... ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注：必需在主配置文件中设置别名，其它地方（如映射文件中）才可以使用（切记！切记！）。</p><h4 id="5-4、列名与属性名不对应的解决resultMap"><a href="#5-4、列名与属性名不对应的解决resultMap" class="headerlink" title="5.4、列名与属性名不对应的解决resultMap"></a>5.4、列名与属性名不对应的解决resultMap</h4><p>之前做映射文件的时候，只做了<code>数据库表</code>与<code>Java对象</code>之间的联系。并没有做<code>表字段</code>与<code>Java对象属性</code>之间的联系。它们之间是如何联系的？</p><p><strong>由于之前咱们的  <code>数据库表字段名</code> 与  <code>JavaBean属性名</code> 是一致的，因此MyBatis框架可以对此进行自动识别。</strong></p><p><strong>那么：</strong>如果咱们的  列名  与  Java对象属性名  不一致了 ( 对应不上 )，这时候应该怎么办呢？</p><p>这时候，就需要我们开发人员告诉MyBatis框架，我们需要把哪些字段名与属性名对应上。</p><p>在MyBatis中，提供了一个<code>resultMap的标签</code>，就是让我们来<code>完成返回结果的关系对应</code>的，使用方式如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- </span></span><br><span class="xml">返回的数据映射 </span><br><span class="xml">type：代表是要映射的对象</span><br><span class="xml">id：代表唯一(过会我们要拿到它)</span><br><span class="xml">--&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- </span></span><br><span class="xml">column: 数据库表中的列名</span><br><span class="xml">property: JavaBean中的属性名</span><br><span class="xml"> --&gt;</span><br><span class="xml"> </span><br><span class="xml"><span class="hljs-comment">&lt;!-- product表主键为id，对应Product对象中的id属性 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>  /&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 其他表字段，与Product对象中属性对应 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;productName&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryOne&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="xml">select * from product where id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="6、常见异常"><a href="#6、常见异常" class="headerlink" title="6、常见异常"></a>6、常见异常</h3><ol><li><p>java.lang.ClassNotFoundException: Cannot find class: id</p><p>&lt;delete id=”delete” parameterType=”id”&gt;    应该传入long类型，而不是id；</p></li><li><p>Caused by: org.xml.sax.SAXParseException; lineNumber: 23; columnNumber: 4</p><p>元素类型 “select” 必须由匹配的结束标记 “&lt;/select&gt;” 终止；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- select标签开始，insert标签结束导致的错误 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span><br>select id,productName,salePrice,costPrice,cutoff,supplier,brand,dir_id from<br>product<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Caused by: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for cn.kongwei_liao.domain.ProductMapper.get</p><p>配置文件里面没有匹配的映射关系（错误映射，或未映射）；</p></li><li><p>Caused by: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named ‘productName’ in ‘class cn.kongwei_liao.domain.Product’</p><p>Product 类里面没有 ‘productName’ 这个属性。</p></li></ol><h3 id="7、常见问题"><a href="#7、常见问题" class="headerlink" title="7、常见问题"></a>7、常见问题</h3><ol><li>   没有导入数据库的驱动包；</li><li>   在XML中很多都是字符串，细心，不要写错；</li><li>   在映射文件中全限定类名可能会写错；</li><li>   找不到相应的Statement(sql语句)；</li><li>   找SQL的Statement写错了；</li><li>   在核心XML中没有找相应的映射文件；</li><li>   在我们调用Statement（sql语句）的时候，经常会忘记传参；</li><li>   执行成功后，数据库却没有反映，很有可能是没有提交事务；</li><li>   可能我们忘了写执行的代码了；</li><li>   错误一定要打印出来（执行的时候没效果，但是又不报错）；</li><li>   Mapper中就算一个语句没有使用，它的错也可能会影响到其它正确的语句；</li><li>   框架的错往往从后向前找；</li><li>   使用未定义的别名；</li><li>   Mysql乱码，添加字符编码、设置时区：useUnicode=true&amp;characterEncoding=UTF-8。</li></ol><h3 id="8、JDBC类型与Java类型对照"><a href="#8、JDBC类型与Java类型对照" class="headerlink" title="8、JDBC类型与Java类型对照"></a>8、JDBC类型与Java类型对照</h3><table><thead><tr><th align="left"><strong>JDBC 类型</strong></th><th align="left"><strong>Java 类型</strong></th></tr></thead><tbody><tr><td align="left"><code>CHAR</code></td><td align="left"><code>String</code></td></tr><tr><td align="left"><code>VARCHAR</code></td><td align="left"><code>String</code></td></tr><tr><td align="left"><code>LONGVARCHAR</code></td><td align="left"><code>String</code></td></tr><tr><td align="left"><code>NUMERIC</code></td><td align="left"><code>java.math.BigDecimal</code></td></tr><tr><td align="left"><code>DECIMAL</code></td><td align="left"><code>java.math.BigDecimal</code></td></tr><tr><td align="left"><code>BIT</code></td><td align="left"><code>boolean</code></td></tr><tr><td align="left"><code>TINYINT</code></td><td align="left"><code>byte</code></td></tr><tr><td align="left"><code>SMALLINT</code></td><td align="left"><code>short</code></td></tr><tr><td align="left"><code>INTEGER</code></td><td align="left"><code>int</code></td></tr><tr><td align="left"><code>BIGINT</code></td><td align="left"><code>long</code></td></tr><tr><td align="left"><code>REAL</code></td><td align="left"><code>float</code></td></tr><tr><td align="left"><code>FLOAT</code></td><td align="left"><code>double</code></td></tr><tr><td align="left"><code>DOUBLE</code></td><td align="left"><code>double</code></td></tr><tr><td align="left"><code>BINARY</code></td><td align="left"><code>byte[]</code></td></tr><tr><td align="left"><code>VARBINARY</code></td><td align="left"><code>byte[]</code></td></tr><tr><td align="left"><code>LONGVARBINARY</code></td><td align="left"><code>byte[]</code></td></tr><tr><td align="left"><code>DATE</code></td><td align="left"><code>java.sql.Date</code>继承了java.util.Date</td></tr><tr><td align="left"><code>TIME</code></td><td align="left"><code>java.sql.Time</code>继承了java.util.Date</td></tr><tr><td align="left"><code>TIMESTAMP</code></td><td align="left"><code>java.sql.Timestamp</code>继承了java.util.Date</td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//数据库中Date类型、Java中Date数据类型到前端显示时间问题 的处理</span><br><span class="hljs-keyword">import</span> java.text.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Datetransform</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将Date类日期转为字符串日期</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>date、 <span class="hljs-doctag">@param </span>format、 <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-comment">//String DateFormatStr = &quot;yyyy-MM-dd HH:mm:ss&quot;;//年-月-日 时:分:秒</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">param</span>(<span class="hljs-params"><span class="hljs-built_in">Date</span> date, <span class="hljs-built_in">String</span> format</span>)</span> &#123;<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(format);<br><span class="hljs-built_in">String</span> strDate = sdf.format(date);<span class="hljs-comment">//SimpleDateFormat.format(Date)--&gt;String时间字符串</span><br><span class="hljs-keyword">return</span> strDate;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将字符串日期转化未Date类日期</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>strDate、 <span class="hljs-doctag">@param </span>format、 <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">Date</span> <span class="hljs-function"><span class="hljs-title">parse</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> pStrDate, <span class="hljs-built_in">String</span> pformat</span>)</span> &#123;<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(pformat);<br><span class="hljs-built_in">Date</span> date = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>date = sdf.parse(pStrDate);<span class="hljs-comment">//SimpleDateFormat.parse(String)--&gt;Date类时间对象</span><br>&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> date;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9、MyBatis-SQL参数传递-…-、-…"><a href="#9、MyBatis-SQL参数传递-…-、-…" class="headerlink" title="9、MyBatis SQL参数传递#{…}、${…}"></a>9、MyBatis SQL参数传递#{…}、${…}</h3><p><code>#&#123;OGNL表达式&#125;</code> 和 <code>$&#123;OGNL表达式&#125;</code> 的区别</p><h4 id="9-1、-OGNL表达式"><a href="#9-1、-OGNL表达式" class="headerlink" title="9.1、#{OGNL表达式}"></a>9.1、#{OGNL表达式}</h4><p>MyBatis会把这个表达式使用   “ ?(占位符) ”   替换，作为<code>一个sql参数</code>使用</p><p>比如name的值为: </p><p>​        定义SQL: <code>select * from t_user where name = #&#123;name&#125;</code></p><p>​        最终SQL: <code>select * from t_user where name = ?</code></p><h4 id="9-2、-OGNL表达式"><a href="#9-2、-OGNL表达式" class="headerlink" title="9.2、${OGNL表达式}"></a>9.2、${OGNL表达式}</h4><p>MyBatis会把这个表达式的值  替换到sql中  ，作为<code>sql的组成部分</code></p><p>该方式主要用于程序拼接SQL</p><p>比如name的值为: ‘<code>1 or 1=1</code>‘</p><p>​        定义SQL: select * from t_user where name = ${id}</p><p>​        最终SQL: select * from t_user where name = <code>1 or 1=1</code> 出现sql注入</p><p>如果sql中使用${OGNL}，并且参数的类型是(Integer，String….)那么OGNL表达式可以写成任意东西;</p><h4 id="9-3、SQL注入"><a href="#9-3、SQL注入" class="headerlink" title="9.3、SQL注入"></a>9.3、SQL注入</h4><p>预防sql注入，使用 占位符(?PrepareStatement) 查询</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> username=? <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span>=?<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> username=<span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span>=<span class="hljs-string">&#x27;admin&#x27;</span><br></code></pre></td></tr></table></figure><p>字符串拼接，会导致出现sql注入</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> username=<span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span>=<span class="hljs-string">&#x27;0000&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="9-4、-OGNL-表达式的应用场景"><a href="#9-4、-OGNL-表达式的应用场景" class="headerlink" title="9.4、${OGNL}表达式的应用场景"></a>9.4、${OGNL}表达式的应用场景</h4><p>不能用在登录场景，会出现sql注入；</p><p>用在 <code>order by的场景</code> 或 <code>复杂的参数传递</code>：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Map&lt;String,Object&gt;  <br><span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;orderBy&quot;</span>,&#x27;name desc&#x27;);<br><span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;begin&quot;</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-number">10</span>);<br><br><span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;minAge&quot;</span>,<span class="hljs-number">19</span>);<br><span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;maxAge&quot;</span>,<span class="hljs-number">90</span>);<br>List&lt;User&gt; users1=session.selectList(<span class="hljs-string">&quot;cn.kongwei_liao.mapper.UserMapper&quot;</span>+<span class="hljs-string">&quot;.selectRange&quot;</span>,<span class="hljs-built_in">map</span>);<br>List&lt;User&gt; users2=session.selectList(<span class="hljs-string">&quot;cn.kongwei_liao.mapper.UserMapper&quot;</span>+<span class="hljs-string">&quot;.findByOrderBy&quot;</span>,<span class="hljs-built_in">map</span>);<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;select id=<span class="hljs-string">&quot;findByOrderBy&quot;</span> parameterType=<span class="hljs-string">&quot;map&quot;</span> resultType=cn.kongwei_liao.domain.Use<span class="hljs-string">r&quot;&gt;</span><br><span class="hljs-string">select * from t_user order by $&#123;orderBy&#125; limit $&#123;begin&#125;,$&#123;end&#125;</span><br><span class="hljs-string">&lt;/select&gt;</span><br><span class="hljs-string">&lt;select id=&quot;</span>selectRange<span class="hljs-string">&quot; parameterType=&quot;</span>map<span class="hljs-string">&quot; resultType=cn.kongwei_liao.domain.User&quot;</span>&gt;<br>select * from t_user where age between <span class="hljs-comment">#&#123;minAge&#125; and #&#123;maxAge&#125;</span><br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><p>在jdbc的sql代码order by后面不能使用占位符?   只能进行字符串的拼接。</p><h3 id="10、关联查询映射（多对一）"><a href="#10、关联查询映射（多对一）" class="headerlink" title="10、关联查询映射（多对一）"></a>10、关联查询映射（多对一）</h3><p>在有多个员工对应有同一个部门的情况，根据用户id查询该用户信息及其所在的部门名称。</p><h4 id="10-1、创建案例数据库"><a href="#10-1、创建案例数据库" class="headerlink" title="10.1、创建案例数据库"></a>10.1、创建案例数据库</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`t_dept`</span> (<br><br><span class="hljs-symbol">`id`</span> bigint(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br><span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br> <br><span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`t_user`</span> (<br><br><span class="hljs-symbol">`id`</span> bigint(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br> <span class="hljs-symbol">`name`</span> varchar(<span class="hljs-number">255</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br> <span class="hljs-symbol">`password`</span> varchar(<span class="hljs-number">255</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br> <span class="hljs-symbol">`dept_id`</span> bigint(<span class="hljs-number">20</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br> <br> <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br> <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`fk1`</span> (<span class="hljs-symbol">`dept_id`</span>),<br> CONSTRAINT <span class="hljs-symbol">`fk1`</span> FOREIGN <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`dept_id`</span>) REFERENCES <span class="hljs-symbol">`t_dept`</span> (<span class="hljs-symbol">`id`</span>)<br> <br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>[^CONSTRAINT]: CONSTRAINT [kənˈstreɪnt]  n. 限制; 限定; 约束; 严管;</p><h4 id="10-2、建立模型层：Dept、User等的JavaBean"><a href="#10-2、建立模型层：Dept、User等的JavaBean" class="headerlink" title="10.2、建立模型层：Dept、User等的JavaBean"></a>10.2、建立模型层：Dept、User等的JavaBean</h4><h4 id="10-3、配置文件MyBatis-Config-xml"><a href="#10-3、配置文件MyBatis-Config-xml" class="headerlink" title="10.3、配置文件MyBatis-Config.xml"></a>10.3、配置文件MyBatis-Config.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 单向多对一 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;cn/kongwei_liao/mapper/DomainMapper.xml&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="10-4、映射文件DomainMapper-xml"><a href="#10-4、映射文件DomainMapper-xml" class="headerlink" title="10.4、映射文件DomainMapper.xml"></a>10.4、映射文件DomainMapper.xml</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.DomainMapper&quot;</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 保存部门 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveDept&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.Dept&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span></span><br><span class="xml">keyProperty=&quot;id&quot;&gt;</span><br><span class="xml">insert into t_dept(name) values(#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 保存用户 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.User&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span></span><br><span class="xml">keyProperty=&quot;id&quot;&gt;</span><br><span class="xml">insert into t_user(name,password,dept_id) values(#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;password&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;dept.id&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="10-5、保存测试数据"><a href="#10-5、保存测试数据" class="headerlink" title="10.5、保存测试数据"></a>10.5、保存测试数据</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">String NAME_SPACE = &quot;cn.kongwei_liao.mapper.DomainMapper&quot;;<br><br>@Test<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testSave() &#123;<br>SqlSession <span class="hljs-keyword">session</span> = MyBatisUtils.getSession();<br>// 先保存部门<br>Dept dept1 = <span class="hljs-built_in">new</span> Dept();<br>dept1.setName(&quot;部门1&quot;);//未设主键，插入记录主键自增<br>Dept dept2 = <span class="hljs-built_in">new</span> Dept();<br>dept2.setName(&quot;部门2&quot;);<br><span class="hljs-keyword">session</span>.<span class="hljs-keyword">insert</span>(NAME_SPACE + &quot;.saveDept&quot;, dept1);<br><span class="hljs-keyword">session</span>.<span class="hljs-keyword">insert</span>(NAME_SPACE + &quot;.saveDept&quot;, dept2);<br><br>// 在保存用户<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br><span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>();<br><span class="hljs-keyword">user</span>.setName(&quot;user&quot; + i);<br><span class="hljs-keyword">user</span>.setPassword(&quot;admin&quot;);<br><span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">user</span>.setDept(dept1); // <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user(dept_id) <span class="hljs-keyword">values</span>(#&#123;dept.id&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">user</span>.setDept(dept2);<br>&#125;<br><span class="hljs-keyword">session</span>.<span class="hljs-keyword">insert</span>(NAME_SPACE + &quot;.saveUser&quot;, <span class="hljs-keyword">user</span>);<br>&#125;<br><br><span class="hljs-keyword">session</span>.<span class="hljs-keyword">commit</span>();<br><span class="hljs-keyword">session</span>.<span class="hljs-keyword">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-6、多个表关联查询"><a href="#10-6、多个表关联查询" class="headerlink" title="10.6、多个表关联查询"></a>10.6、多个表关联查询</h4><h5 id="10-6-1、单表查询，不能查询部门的名称"><a href="#10-6-1、单表查询，不能查询部门的名称" class="headerlink" title="10.6.1、单表查询，不能查询部门的名称"></a>10.6.1、单表查询，不能查询部门的名称</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.DomainMapper&quot;</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 保存部门 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveDept&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.Dept&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span></span><br><span class="xml">keyProperty=&quot;id&quot;&gt;</span><br><span class="xml">insert into t_dept(name) values(#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 保存用户 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.User&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span></span><br><span class="xml">keyProperty=&quot;id&quot;&gt;</span><br><span class="xml">insert into t_user(name,password,dept_id) values(#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;password&#125;</span><span class="xml">,#</span><span class="hljs-template-variable">&#123;dept.id&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 查询用户 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resuleType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.User&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span></span><br><span class="xml">select * from t_user</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="10-6-2、等值连接查询"><a href="#10-6-2、等值连接查询" class="headerlink" title="10.6.2、等值连接查询"></a>10.6.2、等值连接查询</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select u.*,d.*<br><span class="hljs-keyword">from</span> t_user u,t_dept d<br><span class="hljs-keyword">where</span> u.dept_id=d.<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h5 id="10-6-3、内连接查询"><a href="#10-6-3、内连接查询" class="headerlink" title="10.6.3、内连接查询"></a>10.6.3、内连接查询</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> u.*,d.*<br><span class="hljs-keyword">from</span> t_user u <br><span class="hljs-keyword">join</span> t_dept d<br><span class="hljs-keyword">on</span> u.dept_id=d.id<br></code></pre></td></tr></table></figure><h5 id="10-6-4、左外连接查询"><a href="#10-6-4、左外连接查询" class="headerlink" title="10.6.4、左外连接查询"></a>10.6.4、左外连接查询</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> u.*,d.*<br><span class="hljs-keyword">from</span> t_user u <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> t_dept d<br><span class="hljs-keyword">on</span> u.dept_id=d.id<br></code></pre></td></tr></table></figure><h5 id="10-6-5、测试用例"><a href="#10-6-5、测试用例" class="headerlink" title="10.6.5、测试用例"></a>10.6.5、测试用例</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Test<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testGetAll() &#123;<br>SqlSession <span class="hljs-keyword">session</span> = MyBatisUtils.getSession();<br>List&lt;<span class="hljs-keyword">User</span>&gt; list = <span class="hljs-keyword">session</span>.selectList(NAME_SPACE + &quot;.getAll&quot;);//NAME_SPACE + &quot;.？&quot;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> : list) &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>.getDept());<br>&#125;<br><span class="hljs-keyword">session</span>.<span class="hljs-keyword">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-7、MyBatis提供两种方式处理associate关联对象"><a href="#10-7、MyBatis提供两种方式处理associate关联对象" class="headerlink" title="10.7、MyBatis提供两种方式处理associate关联对象"></a>10.7、MyBatis提供两种方式处理associate关联对象</h4><h5 id="10-7-1、嵌套结果"><a href="#10-7-1、嵌套结果" class="headerlink" title="10.7.1、嵌套结果"></a>10.7.1、嵌套结果</h5><p>发一条左外连接sql解决问题，映射文件Mapper结果的手动封装ResultMap</p><p>使用嵌套结果映射来处理重复的联合结果的子集。这种方式，所有属性映射都要自己来，没办法通过代码生成器生成！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.DomainMapper&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- User:Dept  多对一关系 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- User表主键id 与 User实体类id属性 对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- User表其他字段 与 User实体类其它属性 对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 此处associate标签的property属性值应是在User实体类内定义的属性，属性名dept，该属性类型是cn.kongwei_liai.Dept --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.Dept&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Dept表主键id 与 Dept实体类id属性 对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- Dept表其它字段 与 Dept实体类其它属性 对应 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dname&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 嵌套结果（发一条左外连接sql解决问题，映射文件Mapper结果的手动封装ResultMap） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>select u.id,u.name,u.password,d.id did,d.name dname<br>from t_user u<br>left join t_dept d<br>on u.dept_id=d.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="10-7-2、嵌套查询"><a href="#10-7-2、嵌套查询" class="headerlink" title="10.7.2、嵌套查询"></a>10.7.2、嵌套查询</h5><p>发  一条查询user  和  n条查询dept   解决问题，映射文件Mapper结果的自动封装userResultMap</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.DomainMapper&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.User&quot;</span> &gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span></span><br><span class="xml">   </span><br><span class="xml"><span class="hljs-comment">&lt;!-- 此处associate标签的</span></span><br><span class="xml">   property属性值：此处应是User实体类的属性，属性名dept； </span><br><span class="xml">   column属性值：传给嵌套查询，做查询条件。</span><br><span class="xml">   --&gt;</span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.DomainMapper.findDeptBydeptId&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 嵌套了column=&quot;dept_id&quot; --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 根据返回来的n条user记录中的dept_id字段，查询dept --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findDeptBydeptId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Dept&quot;</span>&gt;</span></span><br><span class="xml">   select id,name from t_dept where id=#</span><span class="hljs-template-variable">&#123;dept_id&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 一条查询user表，返回n条user记录 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="xml">   select u.id,u.username,u.password,u.dept_id</span><br><span class="xml">   from t_user u</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="11、集合查询映射（一对多，多对多）"><a href="#11、集合查询映射（一对多，多对多）" class="headerlink" title="11、集合查询映射（一对多，多对多）"></a>11、集合查询映射（一对多，多对多）</h3><h4 id="11-1、常见关系"><a href="#11-1、常见关系" class="headerlink" title="11.1、常见关系"></a>11.1、常见关系</h4><p>员工和部门：一对多，根据部门查询员工</p><ul><li><p>在部门方，需要查询到当前部门下的所有员工。</p></li><li><p>一个部门  拥有  多个员工</p></li></ul><p>学生和课程：多对多，根据学生查询其选修课程，或根据课程查询查询选修该课程的学生</p><ul><li><p>一个学生  可以学习  多门课程</p></li><li><p>一门课程  可以有   多个学生</p></li></ul><h4 id="11-2、collection"><a href="#11-2、collection" class="headerlink" title="11.2、collection"></a>11.2、collection</h4><p>返回结果 （返回结果对象有一个属性List或Set&lt;关联表对象&gt;）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;集合数据属性名&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;集合中元素类型&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- extends: 集成已有resultMap；--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Department&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DepartmentAndUsersResultMap&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;DepartmentResultMap&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="xml">关联集合：</span><br><span class="xml">property：集合数据</span><br><span class="xml">ofType：集合元素类型****</span><br><span class="xml">select：通过这条SQL查询对应关联集合</span><br><span class="xml">select * from t_user where dept_id = #</span><span class="hljs-template-variable">&#123;id&#125;</span><br><span class="xml">column：关联对象表t_dept中的主键id  对应  当前对象表中t_user外键dept_id</span><br><span class="xml">--&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.User&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.DomainMapper.getByUserDept_Id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="11-3、嵌套结果（使用一条SQL语句）"><a href="#11-3、嵌套结果（使用一条SQL语句）" class="headerlink" title="11.3、嵌套结果（使用一条SQL语句）"></a>11.3、嵌套结果（使用一条SQL语句）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.DomainMapper&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Dept&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DepartmentResultMap&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 处理一方：部门 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 处理多方：员工 --&gt;</span><br><span class="hljs-comment">&lt;!-- // 单向一对多，结果保存再Set或List中 --&gt;</span><br><span class="hljs-comment">&lt;!-- private Set&lt;User&gt; users; --&gt;</span><br><span class="hljs-comment">&lt;!-- private List&lt;User&gt; users; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.User&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 嵌套结果（发一条左外连接sql解决问题，映射文件Mapper结果的手动封装ResultMap） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;DepartmentResultMap&quot;</span>&gt;</span><br>select d.id,d.name,u.id uid,u.name uname,u.password<br>from t_dept d<br>left join t_user u<br>on d.id=u.dept_id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="11-4、嵌套查询"><a href="#11-4、嵌套查询" class="headerlink" title="11.4、嵌套查询"></a>11.4、嵌套查询</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.DomainMapper&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Dept&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DepartmentResultMap&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 处理一方：部门 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 处理多方：员工 --&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- // 单向一对多，结果保存再Set或List中 --&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- private Set&lt;User&gt; users; --&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- private List&lt;User&gt; users; --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.User&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.DomainMapper.getByUserDept_Id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getByUserDept_Id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.User&quot;</span> &gt;</span></span><br><span class="xml">select * from t_user where dept_id=$</span><span class="hljs-template-variable">&#123;id&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 嵌套结果（发一条左外连接sql解决问题，映射文件Mapper结果的手动封装ResultMap） --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;DepartmentResultMap&quot;</span>&gt;</span></span><br><span class="xml">select id,name</span><br><span class="xml">from t_dept</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="12、嵌套结果和嵌套查询的使用场景"><a href="#12、嵌套结果和嵌套查询的使用场景" class="headerlink" title="12、嵌套结果和嵌套查询的使用场景"></a>12、嵌套结果和嵌套查询的使用场景</h3><h4 id="12-1、嵌套结果：一条SQL语句"><a href="#12-1、嵌套结果：一条SQL语句" class="headerlink" title="12.1、嵌套结果：一条SQL语句"></a>12.1、嵌套结果：一条SQL语句</h4><ol><li><p>用在多对一的表结构；</p></li><li><p>多个数据字典明细和一个数据字典类型；</p></li><li><p>多个员工属于一个部门；</p></li><li><p>多个部门有一个部门经理。</p></li></ol><h4 id="12-2、嵌套查询：1-n条SQL语句"><a href="#12-2、嵌套查询：1-n条SQL语句" class="headerlink" title="12.2、嵌套查询：1+n条SQL语句"></a>12.2、嵌套查询：1+n条SQL语句</h4><ol><li><p>用在 一对多 或者 多对多 的表结构；</p></li><li><p>展示数据的时候，在一行第一列显示一方，第二列显示多个多方；</p></li><li><p>一对多：（部门1  ：员工1。。。员工n）；</p></li><li><p>多对多：（员工1  ：角色1。。。角色n）。</p></li></ol><h3 id="13、SQL映射器Mapper"><a href="#13、SQL映射器Mapper" class="headerlink" title="13、SQL映射器Mapper"></a>13、SQL映射器Mapper</h3><p>MyBatis框架  <code>基于代理机制</code>，可以让我们<code>无需再编写Dao的实现</code>。</p><h4 id="13-1、传统Dao层接口，现在名称统一以Mapper结尾"><a href="#13-1、传统Dao层接口，现在名称统一以Mapper结尾" class="headerlink" title="13.1、传统Dao层接口，现在名称统一以Mapper结尾"></a>13.1、传统Dao层接口，现在名称统一以Mapper结尾</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义MaBatis映射器（映射器其实就是操作数据库的对象，等效于之前的Dao层接口</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">映射器配置于xml配置对应：</span><br><span class="hljs-comment">接口中的方法名于SQL的id对应；</span><br><span class="hljs-comment">接口中的方法返回值于SQL中的resultType/resultMap对应；</span><br><span class="hljs-comment">接口中的方法参数类型于SQL中的parameterType对应。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-built_in">public</span> interface UserMapper&#123;<br><span class="hljs-keyword">User</span> <span class="hljs-keyword">get</span>(Long id);<br>List&lt;<span class="hljs-keyword">User</span>&gt; <span class="hljs-keyword">select</span>(Map&lt;String,<span class="hljs-keyword">Object</span>&gt; paramMap);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-2、接口实现方式一（传统）"><a href="#13-2、接口实现方式一（传统）" class="headerlink" title="13.2、接口实现方式一（传统）"></a>13.2、接口实现方式一（传统）</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserMapper</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function">User <span class="hljs-title">get</span><span class="hljs-params">(Long id)</span></span>&#123;<br>SqlSession sqlSession = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>sqlSession = MyBatisUtils.getSqlSession();<br><span class="hljs-function"><span class="hljs-keyword">return</span> sqlSession.<span class="hljs-title">selectone</span><span class="hljs-params">(<span class="hljs-string">&quot;cn.kongwei_liao.mapper.UserMapper.get&quot;</span>,id)</span></span>;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-keyword">if</span>(sqlSession!=<span class="hljs-keyword">null</span>)&#123;<br>sqlSession.close();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-3、接口实现方式二（映射器）"><a href="#13-3、接口实现方式二（映射器）" class="headerlink" title="13.3、接口实现方式二（映射器）"></a>13.3、接口实现方式二（映射器）</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义一个映射器Mapper接口，使用MyBatis自动为我们创建的代理类；</span><br><span class="hljs-comment">*/</span><br>public <span class="hljs-keyword">class</span> MyBatisMapperTest&#123;<br>@Test<br>public void test<span class="hljs-constructor">Proxy()</span> throws Exception&#123;<br><span class="hljs-comment">//getMapper(Mapper接口)，通过MyBatis为我们创建指定Mapper接口代理对象；</span><br>UserMapper mapper = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyBatisUtils</span>.</span></span>get<span class="hljs-constructor">SqlSession()</span>.get<span class="hljs-constructor">Mapper(UserMapper.<span class="hljs-params">class</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(mapper.get(<span class="hljs-number">1L</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14、缓存"><a href="#14、缓存" class="headerlink" title="14、缓存"></a>14、缓存</h3><p>默认支持一级缓存，二级缓存需要配置，同JPA一致</p><p>缓存是一种典型的  “以空间换时间”  的策略。</p><h4 id="14-1、一级缓存"><a href="#14-1、一级缓存" class="headerlink" title="14.1、一级缓存"></a>14.1、一级缓存</h4><p>SqlSession级别缓存，缓存对象存储周期为第一次获取，到sqlsession被销毁掉，或是sqlSession().clearCache()；</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Test<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testProxy()&#123;<br>    SqlSession <span class="hljs-keyword">session</span> = MyBatisUtils.getSession();<br>    UserMapper mapper = <span class="hljs-keyword">session</span>.getMapper(UserMapper.<span class="hljs-keyword">class</span>);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(mapper.<span class="hljs-keyword">get</span>(<span class="hljs-number">8</span>L));//发送一条<span class="hljs-keyword">sql</span><br>    <span class="hljs-keyword">session</span>.clearCache();<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(mapper.<span class="hljs-keyword">get</span>(<span class="hljs-number">8</span>L));//清除缓存之后 在发送一条<span class="hljs-keyword">sql</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="14-2、二级缓存"><a href="#14-2、二级缓存" class="headerlink" title="14.2、二级缓存"></a>14.2、二级缓存</h4><p>SqlSessionFactory级别缓存，缓存对象存储周期为第一次获取，到SqlSessionFactory被销毁掉(应用停止了)；</p><p>默认情况下，只开启一级缓存，如果需要开启二级缓存我们需要在Mapper.xml添加一个&lt;cache&gt;标签。</p><ol><li>注意：需要缓存的对象，应该实现java.io.Serializable；</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">&lt;mapper <span class="hljs-keyword">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.UserMapper&quot;</span>&gt;<br>   &lt;cache/&gt;<br>…<br>&lt;/mapper&gt;<br>同时类要进行序列化<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Test<br>public void test<span class="hljs-constructor">SecondLevel()</span>&#123;<br><br>SqlSession session1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyBatisUtils</span>.</span></span>get<span class="hljs-constructor">Session()</span>;<br>UserMapper mapper1 = session1.get<span class="hljs-constructor">Mapper(UserMapper.<span class="hljs-params">class</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(mapper1.get(<span class="hljs-number">8L</span>));<span class="hljs-comment">//发送一条sql</span><br>session1.close<span class="hljs-literal">()</span>;<br><br>SqlSession session2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyBatisUtils</span>.</span></span>get<span class="hljs-constructor">Session()</span>;<br>UserMapper mapper2 = session2.get<span class="hljs-constructor">Mapper(UserMapper.<span class="hljs-params">class</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(mapper2.get(<span class="hljs-number">8L</span>));<br>session2.close<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/MyBatis-%E9%AB%98%E7%BA%A7/"/>
    <url>/2021/02/15/MyBatis-%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="MyBatis代码生成器"><a href="#MyBatis代码生成器" class="headerlink" title="MyBatis代码生成器"></a>MyBatis代码生成器</h3><p>我们在学习MyBatis的时候，总是要做很多基础的CRUD，这些代码都是比较重复的。</p><p>为了解决这个问题，我们可以使用MyBatis的代码生成器：数据库的表–domain–mapper接口–mapper映射</p><p>需要先导入相应的MyBatis的基本包和MySql的驱动包。另外，还要下载一个mybatis-generator-1.3.5.zip，在官网下载即可:<a href="https://github.com/mybatis/generator/releases">https://github.com/mybatis/generator/releases</a></p><p>中文文档：<a href="http://mbg.cndocs.ml/">http://mbg.cndocs.ml</a></p><h4 id="1、使用MyBatis-Generator生成代码"><a href="#1、使用MyBatis-Generator生成代码" class="headerlink" title="1、使用MyBatis-Generator生成代码"></a>1、使用MyBatis-Generator生成代码</h4><h5 id="1-1、创建一下新的项目"><a href="#1-1、创建一下新的项目" class="headerlink" title="1.1、创建一下新的项目"></a>1.1、创建一下新的项目</h5><p>创建IDEA Maven项目，并且以pom方式导入相应的jar包：</p><p>导入mybatis(核心包和mysql的驱动包,日志包)相关包：因为生成的代码要在mybatis中运行:</p><p>Pom.xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- MySql数据库驱动 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!--mybatis的jar--&gt;</span><br>  <span class="hljs-comment">&lt;!--mybatis的核心包--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>  <span class="hljs-comment">&lt;!--mybatis集成spring--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!--代码生成器的jar包--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 以插件的方式引入代码生成器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-comment">&lt;!-- 不能放到pluginManagement里面 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/02/15/MyBatis-%E9%AB%98%E7%BA%A7/image-20191212170325227.png" alt="image-20191212170325227"></p><h5 id="1-2、准备配置文件"><a href="#1-2、准备配置文件" class="headerlink" title="1.2、准备配置文件"></a>1.2、准备配置文件</h5><p>默认是在classpath找generatorConfig.xml文件</p><p>(注:这个文件是代码生成器最重要的一步，大家可以拷备下来进行相应的修改即可)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 自动生成器的配置(根目录，不做过多介绍)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">       classPathEntry：可以配置多个，也不配置</span><br><span class="hljs-comment">       数据库驱动:这里找到相应的驱动jar包就可以了(注:不同数据库的jar不一样)</span><br><span class="hljs-comment">          location:里面的是路径(也可以直接写绝对路径 -&gt; 如:E:\mybatis\mysql-connector-java-5.1.26-bin.jar)</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">classPathEntry</span>   <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;D:\Program Files\apache-maven-3.6.1\repo\mysql\mysql-connector-java\5.1.6\mysql-connector-java-5.1.6.jar&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">       context：用于生成一组对象的环境(至少配置1个，可以配置多个)</span><br><span class="hljs-comment">       id:表达唯一的名称</span><br><span class="hljs-comment">       targetRuntime：用于指定生成的代码的运行环境(MyBatis3/MyBatis3Simple)</span><br><span class="hljs-comment">          MyBatis3:默认值</span><br><span class="hljs-comment">          MyBatis3Simple：不会生成与Example(案例)相关的方法</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span>   <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span> &gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            用于配置如果生成注释信息(最多可以配置一下)</span><br><span class="hljs-comment">            suppressAllComments:阻止生成注释 ，默认为false</span><br><span class="hljs-comment">            suppressDate:阻止生成的注释 时间戳，默认为false</span><br><span class="hljs-comment">            addRemarkComments：注释是否添加数据库表的备注信息，默认为false</span><br><span class="hljs-comment">         --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressDate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">           这个应该比较清楚，配置连接数据库的基本信息</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis01&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">                MyBatis Generator 生成器把其他数据库的同名表生成下来的问题</span><br><span class="hljs-comment">                [WARNING] Table Configuration *** matched more than one table </span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">           用于指定JDBC类型和Java类型如何转换，最多可以配置一个</span><br><span class="hljs-comment">           forceBigDecimals:控制是否强制将DECIMAL和NUMERIC类型的JDBC字段转换成Java类型的 BigDecimal</span><br><span class="hljs-comment">                        默认为false,一般不需要配置</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaTypeResolver</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;forceBigDecimals&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaTypeResolver</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">           javaModelGenerator:用来控制生成的实体类</span><br><span class="hljs-comment">              targetPackage：生成Model类存放位置(包名)</span><br><span class="hljs-comment">              targetProject：指定目标项目路径(根目录)</span><br><span class="hljs-comment">              对应的子属性:</span><br><span class="hljs-comment">                 trimStrings：判断是否对数据库查询结果进行trim操作(默认false)</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;D:\IdeaProjects\Templet\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">           sqlMapGenerator：生成映射文件存放位置(Mapper.xml文件)</span><br><span class="hljs-comment">              targetPackage:生成SQL映射文件(XML文件)在哪个包中</span><br><span class="hljs-comment">              targetProject:指定目标项目路径(根目录)</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;D:\IdeaProjects\Templet\src\main\resources&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">           javaClientGenerator：Java客户端生成器(生成Dao/Mapper的接口)</span><br><span class="hljs-comment">                          该 标签可选(最多配置一个)，如果不配置，就不会生成Mapper接口</span><br><span class="hljs-comment">              type:选择客户端代码生成器</span><br><span class="hljs-comment">                 MyBatis3</span><br><span class="hljs-comment">                    ANNOTATEDMAPPER：基于注解的Mapper接口，不会有对应的XML映射文件</span><br><span class="hljs-comment">                    MIXEDMAPPER:XML和注解混合形式</span><br><span class="hljs-comment">                    XMLMAPPER：所有方法都在XML中(接口调用依赖XML)</span><br><span class="hljs-comment">                 MyBatis3Simple</span><br><span class="hljs-comment">                    ANNOTATEDMAPPER：基于注解的Mapper接口，不会有对应的XML映射文件</span><br><span class="hljs-comment">                    XMLMAPPER：所有方法都在XML中(接口调用依赖XML)</span><br><span class="hljs-comment">              targetPackage：生成Mapper接口存放的包名</span><br><span class="hljs-comment">              targetProject：指定目标项目路径</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;D:\IdeaProjects\Templet\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">           table：生成对应表及类名</span><br><span class="hljs-comment">              tableName：对应表名(注:%代表所有)</span><br><span class="hljs-comment">              domainObjectName:对应的类名</span><br><span class="hljs-comment">              generatedKey：主键自增的id字段(针对当前 数据库配置MySQL)</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;product&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Product&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">generatedKey</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">sqlStatement</span>=<span class="hljs-string">&quot;MySql&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-3、运行生成代码"><a href="#1-3、运行生成代码" class="headerlink" title="1.3、运行生成代码"></a>1.3、运行生成代码</h5><p><img src="/2021/02/15/MyBatis-%E9%AB%98%E7%BA%A7/image-20191213151734365.png" alt="image-20191213151734365"></p><p><img src="/2021/02/15/MyBatis-%E9%AB%98%E7%BA%A7/image-20191213152409343.png" alt="image-20191213152409343"></p><p>Product.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.kongwei_liao.domain;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> productname;<br>    <span class="hljs-keyword">private</span> Long dirId;<br>    <span class="hljs-keyword">private</span> Double saleprice;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> supplier;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> brand;<br>    <span class="hljs-keyword">private</span> Double cutoff;<br>    <span class="hljs-keyword">private</span> Double costprice;<br>    <span class="hljs-keyword">public</span> Long <span class="hljs-function"><span class="hljs-title">getId</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> id;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setId</span>(<span class="hljs-params">Long id</span>)</span> &#123;<span class="hljs-built_in">this</span>.id = id;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getProductname</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> productname;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setProductname</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> productname</span>)</span> &#123;<span class="hljs-built_in">this</span>.productname = productname == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : productname.trim();&#125;<br>    <span class="hljs-keyword">public</span> Long <span class="hljs-function"><span class="hljs-title">getDirId</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> dirId;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setDirId</span>(<span class="hljs-params">Long dirId</span>)</span> &#123;<span class="hljs-built_in">this</span>.dirId = dirId;&#125;<br>    <span class="hljs-keyword">public</span> Double <span class="hljs-function"><span class="hljs-title">getSaleprice</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> saleprice;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setSaleprice</span>(<span class="hljs-params">Double saleprice</span>)</span> &#123;<span class="hljs-built_in">this</span>.saleprice = saleprice;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getSupplier</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> supplier;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setSupplier</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> supplier</span>)</span> &#123;<span class="hljs-built_in">this</span>.supplier = supplier == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : supplier.trim();&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getBrand</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> brand;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setBrand</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> brand</span>)</span> &#123;<span class="hljs-built_in">this</span>.brand = brand == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : brand.trim();&#125;<br>    <span class="hljs-keyword">public</span> Double <span class="hljs-function"><span class="hljs-title">getCutoff</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> cutoff;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setCutoff</span>(<span class="hljs-params">Double cutoff</span>)</span> &#123;<span class="hljs-built_in">this</span>.cutoff = cutoff;&#125;<br>    <span class="hljs-keyword">public</span> Double <span class="hljs-function"><span class="hljs-title">getCostprice</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> costprice;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setCostprice</span>(<span class="hljs-params">Double costprice</span>)</span> &#123;<span class="hljs-built_in">this</span>.costprice = costprice;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ProductMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.mapper;<br><span class="hljs-keyword">import</span> cn.kongwei_liao.domain.Product;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductMapper</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Long id)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Product record)</span></span>;<br>    <span class="hljs-function">Product <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Long id)</span></span>;<br>    <span class="hljs-function">List&lt;Product&gt; <span class="hljs-title">selectAll</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(Product record)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ProductMapper.xml</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;cn.kongwei_liao.mapper.ProductMapper&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;productName&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productname&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dir_id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dirId&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;salePrice&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;DOUBLE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;saleprice&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;supplier&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;supplier&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;brand&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;brand&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;cutoff&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;DOUBLE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;cutoff&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;costPrice&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;DOUBLE&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;costprice&quot;</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByPrimaryKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="xml">    delete from product</span><br><span class="xml">    where id = #</span><span class="hljs-template-variable">&#123;id,jdbcType=BIGINT&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="xml">      SELECT LAST_INSERT_ID()</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><br><span class="xml">    insert into product (id, productName, dir_id, </span><br><span class="xml">      salePrice, supplier, brand, </span><br><span class="xml">      cutoff, costPrice)</span><br><span class="xml">    values (#</span><span class="hljs-template-variable">&#123;id,jdbcType=BIGINT&#125;</span><span class="xml">, #</span><span class="hljs-template-variable">&#123;productname,jdbcType=VARCHAR&#125;</span><span class="xml">, #</span><span class="hljs-template-variable">&#123;dirId,jdbcType=BIGINT&#125;</span><span class="xml">, </span><br><span class="xml">      #</span><span class="hljs-template-variable">&#123;saleprice,jdbcType=DOUBLE&#125;</span><span class="xml">, #</span><span class="hljs-template-variable">&#123;supplier,jdbcType=VARCHAR&#125;</span><span class="xml">, #</span><span class="hljs-template-variable">&#123;brand,jdbcType=VARCHAR&#125;</span><span class="xml">, </span><br><span class="xml">      #</span><span class="hljs-template-variable">&#123;cutoff,jdbcType=DOUBLE&#125;</span><span class="xml">, #</span><span class="hljs-template-variable">&#123;costprice,jdbcType=DOUBLE&#125;</span><span class="xml">)</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateByPrimaryKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;cn.kongwei_liao.domain.Product&quot;</span>&gt;</span></span><br><span class="xml">    update product</span><br><span class="xml">    set productName = #</span><span class="hljs-template-variable">&#123;productname,jdbcType=VARCHAR&#125;</span><span class="xml">,</span><br><span class="xml">      dir_id = #</span><span class="hljs-template-variable">&#123;dirId,jdbcType=BIGINT&#125;</span><span class="xml">,</span><br><span class="xml">      salePrice = #</span><span class="hljs-template-variable">&#123;saleprice,jdbcType=DOUBLE&#125;</span><span class="xml">,</span><br><span class="xml">      supplier = #</span><span class="hljs-template-variable">&#123;supplier,jdbcType=VARCHAR&#125;</span><span class="xml">,</span><br><span class="xml">      brand = #</span><span class="hljs-template-variable">&#123;brand,jdbcType=VARCHAR&#125;</span><span class="xml">,</span><br><span class="xml">      cutoff = #</span><span class="hljs-template-variable">&#123;cutoff,jdbcType=DOUBLE&#125;</span><span class="xml">,</span><br><span class="xml">      costPrice = #</span><span class="hljs-template-variable">&#123;costprice,jdbcType=DOUBLE&#125;</span><br><span class="xml">    where id = #</span><span class="hljs-template-variable">&#123;id,jdbcType=BIGINT&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByPrimaryKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="xml">    select id, productName, dir_id, salePrice, supplier, brand, cutoff, costPrice</span><br><span class="xml">    from product</span><br><span class="xml">    where id = #</span><span class="hljs-template-variable">&#123;id,jdbcType=BIGINT&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="xml">    select id, productName, dir_id, salePrice, supplier, brand, cutoff, costPrice</span><br><span class="xml">    from product</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>生成代码后正常操作即可(注:测试请加上MyBatis.xml文件)</p><h4 id="2、使用细节"><a href="#2、使用细节" class="headerlink" title="2、使用细节"></a>2、使用细节</h4><h5 id="2-1、配置多个表和所有表"><a href="#2-1、配置多个表和所有表" class="headerlink" title="2.1、配置多个表和所有表"></a>2.1、配置多个表和所有表</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot;&gt;</span><br><span class="hljs-comment">     &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; /&gt;</span><br><span class="hljs-comment"> &lt;/table&gt;</span><br><span class="hljs-comment"> &lt;table tableName=&quot;t_employee&quot; domainObjectName=&quot;Employee&quot;&gt;</span><br><span class="hljs-comment">     &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; /&gt;</span><br><span class="hljs-comment"> &lt;/table&gt;</span><br><span class="hljs-comment">--&gt;</span><br> <span class="hljs-comment">&lt;!--把所有的表全部都生成（不建议的做法）:</span><br><span class="hljs-comment">  注意:domain是根据表名字来的,驼峰式命名,创建表的时候,可能不要写t_user==&gt;user</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;%&quot;</span> &gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">generatedKey</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">sqlStatement</span>=<span class="hljs-string">&quot;MySql&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-2、自定义配置路径（不建议修改）"><a href="#2-2、自定义配置路径（不建议修改）" class="headerlink" title="2.2、自定义配置路径（不建议修改）"></a>2.2、自定义配置路径（不建议修改）</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 默认是classpath的generatorConfig.xml --&gt;</span><br>      <span class="hljs-comment">&lt;!-- 自定义配置文件路径 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>src/main/resources/testGeneratorCofig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--执行的内容输出到控制台--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 重写，有就覆盖 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="MyBatis拦截器"><a href="#MyBatis拦截器" class="headerlink" title="MyBatis拦截器"></a>MyBatis拦截器</h3><p>咱们做MyBatis也提供了一种插件机制，实际上是拦截器的机制。MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。对于拦截器，Mybatis为我们提供了一个Interceptor接口，通过实现该接口就可以定义我们自己的拦截器。</p><p>通用拦截器步骤：</p><p>1）创建一个拦截器类：实现接口Interceptor</p><p>2）实现拦截逻辑：复写三个方法</p><p>3）配置拦截器生效：配置到主配置文件</p><h4 id="1、创建并实现拦截器"><a href="#1、创建并实现拦截器" class="headerlink" title="1、创建并实现拦截器"></a>1、创建并实现拦截器</h4><h5 id="1-1、创建拦截器"><a href="#1-1、创建拦截器" class="headerlink" title="1.1、创建拦截器"></a>1.1、创建拦截器</h5><p>MyBatis中创建拦截器必需要有两个元素</p><p>元素1：实现org.apache.ibatis.plugin.Interceptor接口</p><p>元素2：实现拦截器签名(这个签名比较复杂，咱们后面再单独介绍)</p><p>HelloInterceptor.java</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package cn.kongwei_liao.interceptor;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.<span class="hljs-keyword">Method</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-keyword">sql</span>.<span class="hljs-keyword">Statement</span>;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.executor.resultset.ResultSetHandler;<br><span class="hljs-keyword">import</span> org.apache.ibatis.plugin.Interceptor;<br><span class="hljs-keyword">import</span> org.apache.ibatis.plugin.Intercepts;<br><span class="hljs-keyword">import</span> org.apache.ibatis.plugin.Invocation;<br><span class="hljs-keyword">import</span> org.apache.ibatis.plugin.Plugin;<br><span class="hljs-keyword">import</span> org.apache.ibatis.plugin.Signature;<br><br>//下面配置方法签名(可以是多个)<br>@Intercepts(&#123;<br>@Signature(<br><span class="hljs-keyword">type</span>=ResultSetHandler.<span class="hljs-keyword">class</span>, //一个结果集处理的接口<br><span class="hljs-keyword">method</span> = &quot;handleResultSets&quot;, //除存储过程 及返回值类型为<span class="hljs-keyword">Cursor</span>以外的查询方法中被调用 <br>args=&#123;<span class="hljs-keyword">Statement</span>.<span class="hljs-keyword">class</span>&#125; //这个方法中必需传的值<br>)<br>&#125;)<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> HelloInterceptor implements Interceptor &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个方法就是运行时的拦截方法(invocation中有很多有用的信息)</span><br><span class="hljs-comment"> */</span><br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> intercept(Invocation invocation) throws Throwable &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;执行到了intercept...&quot;);<br><span class="hljs-keyword">Object</span> target = invocation.getTarget();//获取当前被拦截的对象 <br><span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span> = invocation.getMethod();//被拦截的方法<br><span class="hljs-keyword">Object</span>[] args = invocation.getArgs(); //方法中的参数<br>//proceed：实际上执行了 <span class="hljs-keyword">method</span>.invoke(target,args);<br><span class="hljs-keyword">Object</span> result = invocation.proceed();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法中参数target就是拦截器要拦截的对象 </span><br><span class="hljs-comment"> * 调用时机:创建被拦截的接口实现类时被调用</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> plugin(<span class="hljs-keyword">Object</span> target) &#123;<br><span class="hljs-keyword">return</span> Plugin.wrap(target, this);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来传递插件的参数，可以通过参数改变 插件的行为</span><br><span class="hljs-comment"> * 这个参数需要在 mybatis.xml中进行配置</span><br><span class="hljs-comment"> *  调用 时机:拦截器初始化的时候这里就可以拿到值</span><br><span class="hljs-comment"> */</span><br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> setProperties(Properties properties) &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(properties.getProperty(&quot;prop1&quot;));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2、配置拦截器"><a href="#1-2、配置拦截器" class="headerlink" title="1.2、配置拦截器"></a>1.2、配置拦截器</h5><p>Mybatis.xml</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="xml">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span> /&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 配置插件 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;cn.zhao.interceptor.HelloInterceptor&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 这里配置的就是参数 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prop1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prop2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value2&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.driver&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.username&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;db.password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;cn/zhao/mapping/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="1-3、测试"><a href="#1-3、测试" class="headerlink" title="1.3、测试"></a>1.3、测试</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Test<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testSearch() throws <span class="hljs-keyword">Exception</span> &#123;<br>SqlSession <span class="hljs-keyword">session</span> = MyBatisUtils.openSession();<br>UserMapper mapper = <span class="hljs-keyword">session</span>.getMapper(UserMapper.<span class="hljs-keyword">class</span>);<br>List&lt;<span class="hljs-keyword">User</span>&gt; users = mapper.selectAll();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(users);<br><br><span class="hljs-keyword">session</span>.<span class="hljs-keyword">commit</span>();<br><span class="hljs-keyword">session</span>.<span class="hljs-keyword">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-4、结果（查询的时候可以找到相应的拦截器了）"><a href="#1-4、结果（查询的时候可以找到相应的拦截器了）" class="headerlink" title="1.4、结果（查询的时候可以找到相应的拦截器了）"></a>1.4、结果（查询的时候可以找到相应的拦截器了）</h5><p><strong>value1</strong></p><p>log4j:WARN No appenders could be found for logger (org.apache.ibatis.logging.LogFactory).</p><p>log4j:WARN Please initialize the log4j system properly.</p><p>log4j:WARN See <a href="http://logging.apache.org/log4j/1.2/faq.html#noconfig">http://logging.apache.org/log4j/1.2/faq.html#noconfig</a> for more info.</p><p><strong>执行到了intercept…</strong></p><p>[User [id=2, name=xxxxxxxx], User [id=3, name=yyyyyyyyyyyyy], User [id=4, name=yyyyyyyyyyyyy], User [id=5, name=yyyyyyyyyyyyy]]</p><h4 id="2、拦截器中的方法"><a href="#2、拦截器中的方法" class="headerlink" title="2、拦截器中的方法"></a>2、拦截器中的方法</h4><h5 id="2-1、setProperties-Properties-properties"><a href="#2-1、setProperties-Properties-properties" class="headerlink" title="2.1、setProperties(Properties properties)"></a>2.1、setProperties(Properties properties)</h5><p>这个方法主要是可以拿到配置文件的参数，我们根据这些参数进行相应的操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置插件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;cn.zhao.interceptor.HelloInterceptor&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里配置的就是参数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prop1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;MySql&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prop2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Oracle&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过相应的代码就可以得到上面的参数，当拦截器初始化的时候可以拿到值。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void ser<span class="hljs-constructor">Properties(Properties <span class="hljs-params">properties</span>)</span>&#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(properties.get<span class="hljs-constructor">Property(<span class="hljs-string">&quot;prop1&quot;</span>)</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2、Object-plugin-Object-target"><a href="#2-2、Object-plugin-Object-target" class="headerlink" title="2.2、Object plugin(Object target)"></a>2.2、Object plugin(Object target)</h5><p>里面的target就是拦截器要拦截的对象，创建被连接的接口实现类时被调用，这个方法实现很简单，直接调用即可。</p><p>Plugin.wrap方法会自动判断拦截器的签名和被拦截对象、接口是否匹配，只有匹配的情况下才会使用动态代理拦截目标对象，这个方法不需要做任何的逻辑判断。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function">Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object <span class="hljs-keyword">target</span>)</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">return</span> Plugin.<span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-keyword">target</span>,<span class="hljs-keyword">this</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3、Object-intercept-Invocation-invocation-throws-Throwable"><a href="#2-3、Object-intercept-Invocation-invocation-throws-Throwable" class="headerlink" title="2.3、Object intercept(Invocation invocation) throws Throwable"></a>2.3、Object intercept(Invocation invocation) throws Throwable</h5><p>这个算是核心方法，它可以拿到被拦截的对象，方法，参数等等，我们修改结果，创建功能也一般是在这个方法中完成。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs processing">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> intercept(Invocation invocation)<span class="hljs-keyword">throws</span> Throwable&#123;<br><span class="hljs-keyword">Object</span> target = invocation.getTarget();<span class="hljs-comment">//获得当前被拦截的对象</span><br>Method method = invocation.getMethod();<span class="hljs-comment">//被拦截的方法</span><br><span class="hljs-keyword">Object</span>[] args = invocation.getArgs();<span class="hljs-comment">//方法中的参数</span><br><span class="hljs-comment">//proceed：实际上执行了method.invoke(target, args);</span><br><span class="hljs-keyword">Object</span> result = invocation.proceed();<br>System.out.<span class="hljs-built_in">println</span>(result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、拦截器的签名配置认识"><a href="#3、拦截器的签名配置认识" class="headerlink" title="3、拦截器的签名配置认识"></a>3、拦截器的签名配置认识</h4><p><img src="/2021/02/15/MyBatis-%E9%AB%98%E7%BA%A7/image-20191213013118657.png" alt="image-20191213013118657"></p><p>签名指的就是咱们配置拦截器上面的注解，这个注解是写拦截器的时候必需要配置的,其实就是抓住这些拦截器的时机。接下来，我们来介绍一下这个签名：</p><p>基本格式:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Intercepts</span>(&#123;<br><span class="hljs-variable">@Signature</span>(<br>type=签名类型.class,<br>method = <span class="hljs-string">&quot;这个类型对应的方法&quot;</span>,<br>args=&#123;参数&#125;<br>),<br>... <span class="hljs-comment">//注:这个签名是可以直接配置多个的</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>签名类型分别有： <code>Executor.class</code>,<code>ResultSetHandler.class</code>,<code>ParameterHandler.class</code>,<code>StatementHandler.class</code> 这四种方式 ，每种方式对应不同的method方法，每个方法的参数又不一样(这里方法中的参数方法都是对应上的，根据相应的要求加上即可)</p><h5 id="3-1、Executor接口"><a href="#3-1、Executor接口" class="headerlink" title="3.1、Executor接口"></a>3.1、Executor接口</h5><p>对应的Method</p><p>update：会在所有的insert,update,delete执行时被调用</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=Executor.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">update</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;MappedStatement.class,Object.class&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>query:会在所有select查询方法调用时被执行(这个是最常用的被拦截的方法)</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=Executor.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">query</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;MappedStatement.class,Object.class,RowBounds.class,ResultHandler.class&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>queryCursor：返回值类型为Cursor时被调用</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=Executor.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">queryCursor</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;MappedStatement.class,Object.class,RowBounds.class,ResultHandler.class&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>flushStatements:在SqlSession方法调用 flushStatements方法时调用</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=Executor.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">flushStatements</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>后面几个和上面的flushStatements使用方式一样，只是改方法名，调用时机不一样，用得都不多<br>commit：在SqlSession方法调用 commit方法时调用<br>rollback在SqlSession方法调用 rollback方法时调用<br>close：延时加载执行查询方法前被执行</p><h5 id="3-2、ResultSetHandler接口"><a href="#3-2、ResultSetHandler接口" class="headerlink" title="3.2、ResultSetHandler接口"></a>3.2、ResultSetHandler接口</h5><p>对应的Method<br>handleResultSets：除存储过程及返回值类型为Cursor以外的查询方法中被调用<br>对于拦截处理查询结果非常有用(被调用的位置在处理二级缓存之前)</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=ResultSetHandler.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">handleResultSets</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;Statement.class&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>handleOutputParameters：只在使用存储过程处理出参时被调用(用处不大)</p><h5 id="3-3、ParameterHandler接口"><a href="#3-3、ParameterHandler接口" class="headerlink" title="3.3、ParameterHandler接口"></a>3.3、ParameterHandler接口</h5><p>对应的Method<br>getParameterObject:只在执行存储过程处理参数的时候调用</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=ParameterHandler.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">getParameterObject</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>setParameters：所有数据库方法设置SQL参数时被调用  #{id}   ?</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=ParameterHandler.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">setParameters</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;PreparedStatement.class&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><h5 id="3-4、StatementHandler"><a href="#3-4、StatementHandler" class="headerlink" title="3.4、StatementHandler"></a>3.4、StatementHandler</h5><p>对应的Method<br>prepare：在数据库执行前被调用  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=StatementHandler.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">prepare</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;Connection.class,Integer.class&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>Parameterize:在prepare方法之后执行，用于处理参数信息</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=StatementHandler.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">Parameterize</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;Statement.class&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>query:执行select方法时调用 </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">@Signature(<br><span class="hljs-keyword">type</span>=StatementHandler.class,<br><span class="hljs-function"><span class="hljs-keyword">method</span> = &quot;<span class="hljs-title">prepare</span>&quot;,</span><br><span class="hljs-function"><span class="hljs-title">args</span>=<span class="hljs-comment">&#123;Statement.class,ResultHandler.class&#125;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><h3 id="MyBatis分页插件的使用"><a href="#MyBatis分页插件的使用" class="headerlink" title="MyBatis分页插件的使用"></a>MyBatis分页插件的使用</h3><h4 id="1、为什么要使用分页插件"><a href="#1、为什么要使用分页插件" class="headerlink" title="1、为什么要使用分页插件"></a>1、为什么要使用分页插件</h4><p>要做分页时，原理必须在sql中写入limit，其实这个过程可以使用拦截器拦截下来动态加入。</p><h4 id="2、引入分页插件"><a href="#2、引入分页插件" class="headerlink" title="2、引入分页插件"></a>2、引入分页插件</h4><p>非Maven项目，需要导入jar包</p><p><img src="/2021/02/15/MyBatis-%E9%AB%98%E7%BA%A7/image-20191213014541386.png" alt="image-20191213014541386"></p><p>是Maven项目，在pom.xml中添加依赖</p><h4 id="3、配置拦截器插件"><a href="#3、配置拦截器插件" class="headerlink" title="3、配置拦截器插件"></a>3、配置拦截器插件</h4><p>在 MyBatis 配置 xml 中配置拦截器插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 Spring 配置文件中配置拦截器插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 注意其他配置 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;plugins&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>没有spring环境的时候:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4、实现过程"><a href="#4、实现过程" class="headerlink" title="4、实现过程"></a>4、实现过程</h4><p>使用PageHelper.startPage 静态方法调用startPage ：<br>特点：</p><ol><li>静态方法，传递两个参数（当前页码，每页查询条数）</li><li>使用pageHelper 分页的时候，不再关注分页语句，查询全部的语句</li><li>自动的对PageHelper.startPage 方法下的第一个sql 查询进行分页<br>PageHelper.startPage(1,5);<br>//紧跟着的第一个select 方法会被分页<br>List<Country> list = countryMapper.findAll();</Country></li></ol><p>也就是说再Service层PageHelper.startPage(1,5)；语句后一定是紧跟查询语句。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public PageInfo find<span class="hljs-constructor">Page(<span class="hljs-params">int</span> <span class="hljs-params">page</span>,<span class="hljs-params">int</span> <span class="hljs-params">pageSize</span>)</span>&#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageHelper</span>.</span></span>start<span class="hljs-constructor">Page(<span class="hljs-params">page</span>,<span class="hljs-params">pageSize</span>)</span>;<br>  List&lt;Company&gt; List=companyDao.select<span class="hljs-constructor">All()</span>;<br>  PageInfo pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PageInfo(<span class="hljs-params">list</span>)</span>;<br>  return pageInfo;<br> &#125;<br></code></pre></td></tr></table></figure><p>返回的信息就是pageInfo对象，该类是插件里的类，这个类里面的属性还是值得看一看</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PageInfo&lt;T&gt; <span class="hljs-keyword">implements</span> Serializable &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1</span>L;<br><span class="hljs-comment">//当前页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pageNum;<br><span class="hljs-comment">//每页的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pageSize;<br><span class="hljs-comment">//当前页的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>;<br><span class="hljs-comment">//由于startRow 和endRow 不常用，这里说个具体的用法</span><br><span class="hljs-comment">//可以在页面中&quot;显示startRow 到endRow 共size 条数据&quot;</span><br><span class="hljs-comment">//当前页面第一个元素在数据库中的行号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> startRow;<br><span class="hljs-comment">//当前页面最后一个元素在数据库中的行号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> endRow;<br><span class="hljs-comment">//总记录数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> total;<br><span class="hljs-comment">//总页数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pages;<br><span class="hljs-comment">//结果集</span><br><span class="hljs-keyword">private</span> List&lt;T&gt; list;<br><span class="hljs-comment">//前一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> prePage;<br><span class="hljs-comment">//下一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nextPage;<br><span class="hljs-comment">//是否为第一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isFirstPage = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">//是否为最后一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isLastPage = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">//是否有前一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> hasPreviousPage = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">//是否有下一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> hasNextPage = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">//导航页码数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> navigatePages;<br><span class="hljs-comment">//所有导航页号</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] navigatepageNums;<br><span class="hljs-comment">//导航条上的第一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> navigateFirstPage;<br><span class="hljs-comment">//导航条上的最后一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> navigateLastPage;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在jsp页面中的取值根据PageInfo中的get方法，使用EL表达式取出保存的值。</p><h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">RunWith(SpringJUnit4ClassRunner.<span class="hljs-params">class</span>)</span><br>@<span class="hljs-constructor">ContextConfiguration( <span class="hljs-params">locations</span> = <span class="hljs-string">&quot;classpath:applicationContext.xml&quot;</span>)</span><br>public <span class="hljs-keyword">class</span> PageHalperTest &#123;<br>    @Autowired<br>    StaffMapper staffMapper;<br><br>    @Test<br>    public void <span class="hljs-constructor">TestPageHelper()</span>&#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageHelper</span>.</span></span>start<span class="hljs-constructor">Page(1,5)</span>;<br>        List&lt;Staff&gt; users = staffMapper.select<span class="hljs-constructor">All()</span>;<br>        PageInfo pageInfo=<span class="hljs-keyword">new</span> <span class="hljs-constructor">PageInfo(<span class="hljs-params">users</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(pageInfo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>//第一种，Mapper接口方式的调用，推荐这种使用方式。<br>PageHelper.startPage(1, 3);<br>List&lt;User&gt; users = userMapper.selectAll();</p><p><img src="/2021/02/15/MyBatis-%E9%AB%98%E7%BA%A7/image-20191213015127810.png" alt="image-20191213015127810"></p><h4 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h4><p>MyBatis中我们可以配置相应的插件，而这个插件是使用MyBatis的拦截器完成的。</p><p>MyBatis插件必需要实现org.apache.ibatis.plugin.Interceptor，并且要去实现拦截器的签名，我们需要清楚接口中几个方法的运行时机。</p><p>对应拦截器的签名配置，就是对于MyBatis内部的一些方法的拦截。大家在以后如果遇到，需要灵活的思考应该用哪一种签名进行拦截。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/JDBC%E7%B1%BB%E5%9E%8B%E4%B8%8EJava%E7%B1%BB%E5%9E%8B%E5%AF%B9%E7%85%A7/"/>
    <url>/2021/02/15/JDBC%E7%B1%BB%E5%9E%8B%E4%B8%8EJava%E7%B1%BB%E5%9E%8B%E5%AF%B9%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left"><strong>JDBC 类型</strong></th><th align="left"><strong>Java 类型</strong></th></tr></thead><tbody><tr><td align="left"><code>CHAR</code></td><td align="left"><code>String</code></td></tr><tr><td align="left"><code>VARCHAR</code></td><td align="left"><code>String</code></td></tr><tr><td align="left"><code>LONGVARCHAR</code></td><td align="left"><code>String</code></td></tr><tr><td align="left"><code>NUMERIC</code></td><td align="left"><code>java.math.BigDecimal</code></td></tr><tr><td align="left"><code>DECIMAL</code></td><td align="left"><code>java.math.BigDecimal</code></td></tr><tr><td align="left"><code>BIT</code></td><td align="left"><code>boolean</code></td></tr><tr><td align="left"><code>TINYINT</code></td><td align="left"><code>byte</code></td></tr><tr><td align="left"><code>SMALLINT</code></td><td align="left"><code>short</code></td></tr><tr><td align="left"><code>INTEGER</code></td><td align="left"><code>int</code></td></tr><tr><td align="left"><code>BIGINT</code></td><td align="left"><code>long</code></td></tr><tr><td align="left"><code>REAL</code></td><td align="left"><code>float</code></td></tr><tr><td align="left"><code>FLOAT</code></td><td align="left"><code>double</code></td></tr><tr><td align="left"><code>DOUBLE</code></td><td align="left"><code>double</code></td></tr><tr><td align="left"><code>BINARY</code></td><td align="left"><code>byte[]</code></td></tr><tr><td align="left"><code>VARBINARY</code></td><td align="left"><code>byte[]</code></td></tr><tr><td align="left"><code>LONGVARBINARY</code></td><td align="left"><code>byte[]</code></td></tr><tr><td align="left"><code>DATE</code></td><td align="left"><code>java.sql.Date</code></td></tr><tr><td align="left"><code>TIME</code></td><td align="left"><code>java.sql.Time</code></td></tr><tr><td align="left"><code>TIMESTAMP</code></td><td align="left"><code>java.sql.Timestamp</code></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/JavaCollectionsFramework/"/>
    <url>/2021/02/15/JavaCollectionsFramework/</url>
    
    <content type="html"><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><h2 id="一、集合框架图"><a href="#一、集合框架图" class="headerlink" title="一、集合框架图"></a>一、集合框架图</h2><p><img src="/2021/02/15/JavaCollectionsFramework/249993-20161122112853268-1919394058.gif"></p><p><img src="/2021/02/15/JavaCollectionsFramework/249993-20161122113410534-705560500.jpg"></p><blockquote><p>说明：对于以上的框架图有如下几点说明</p><ol><li><p>所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。</p></li><li><p>集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。</p></li><li><p>抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。</p></li><li><p>实现类：8个实现类（实线表示），对接口的具体实现。</p></li><li><p>Collection 接口是一组允许重复的对象。</p></li><li><p>Set 接口继承 Collection，集合元素不重复。</p></li><li><p>List 接口继承 Collection，允许重复，维护元素插入顺序。</p></li><li><p>Map接口是键－值对象，与Collection接口没有什么关系。</p></li><li><p>Set、List和Map可以看做集合的三大类：</p><p>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。<br>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。<br>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</p></li></ol></blockquote><h2 id="二、总体分析"><a href="#二、总体分析" class="headerlink" title="二、总体分析"></a>二、总体分析</h2><p><img src="/2021/02/15/JavaCollectionsFramework/249993-20170119151138921-1550766941.jpg"></p><p>从上面的框架图中很容易看出有两个主干：<code>Collection</code>和<code>Map</code>。</p><ol><li>Collection是一个接口，高度抽象的集合，包含了集合的基本操作和属性。Collection又包含了List和Set两大分支。<ul><li>List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。</li><li>Set是一个不允许有重复元素的集合。Set的实现类有HashSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</li></ul></li><li>Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。</li><li>接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。</li><li>再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。</li><li>最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。</li></ol><h2 id="三、Collection接口"><a href="#三、Collection接口" class="headerlink" title="三、Collection接口"></a>三、Collection接口</h2><p>Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set，注意Map不是Collection的子接口，这个要牢记。</p><p><img src="/2021/02/15/JavaCollectionsFramework/image-20200419221637399.png" alt="image-20200419221637399"></p><p>其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。</p><p>另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</p><h3 id="1、Collection子接口List"><a href="#1、Collection子接口List" class="headerlink" title="1、Collection子接口List"></a>1、Collection子接口List</h3><p><img src="/2021/02/15/JavaCollectionsFramework/image-20200419222504675.png" alt="image-20200419231037188"></p><p>List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。</p><p>List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p><p>List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><h4 id="1-1、ArrayList"><a href="#1-1、ArrayList" class="headerlink" title="1.1、ArrayList"></a>1.1、ArrayList</h4><p>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p><p>size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p><p>ArrayList擅长于随机访问。同时ArrayList是非同步的。</p><h4 id="1-2、LinkedList"><a href="#1-2、LinkedList" class="headerlink" title="1.2、LinkedList"></a>1.2、LinkedList</h4><p>同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p><p>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p><p>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(…));</p><h4 id="1-3、Vector"><a href="#1-3、Vector" class="headerlink" title="1.3、Vector"></a>1.3、Vector</h4><p>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</p><h4 id="1-4、Stack"><a href="#1-4、Stack" class="headerlink" title="1.4、Stack"></a>1.4、Stack</h4><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><h3 id="2、Collection子接口Set"><a href="#2、Collection子接口Set" class="headerlink" title="2、Collection子接口Set"></a>2、Collection子接口Set</h3><p>Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</p><p>Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。</p><p>此外需要说明一点，在set接口中的不重复是有特殊要求的。<br>举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class Test&#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123; <br>     Set&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">set</span>=<span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-keyword">String</span>&gt;(); <br>     <span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;Hello&quot;</span>); <br>     <span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;world&quot;</span>); <br>     <span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;Hello&quot;</span>); <br>     System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;集合的尺寸为:&quot;</span>+<span class="hljs-built_in">set</span>.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">//集合的尺寸为:2</span><br>     System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;集合中的元素为:&quot;</span>+<span class="hljs-built_in">set</span>.toString()); <span class="hljs-comment">//集合中的元素为:[world, Hello]</span><br>     <br>     Set&lt;<span class="hljs-keyword">String</span>&gt; books = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-keyword">String</span>&gt;();<br>     <span class="hljs-comment">//添加一个字符串对象</span><br>     books.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;Struts2权威指南&quot;</span>));<br>     <span class="hljs-comment">//再次添加一个字符串对象，</span><br>     <span class="hljs-comment">//因为两个字符串对象通过equals方法比较相等，所以添加失败，返回false</span><br>     <span class="hljs-built_in">boolean</span> result = books.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;Struts2权威指南&quot;</span>));<br>     System.out.<span class="hljs-built_in">println</span>(result);  <br>     <span class="hljs-comment">//下面输出看到集合只有一个元素</span><br>     System.out.<span class="hljs-built_in">println</span>(books);  <span class="hljs-comment">//[Struts2权威指南]</span><br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p>分析：</p><p>由于String类中重写了hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个Hello是加不进去的。</p><p>程序中，book集合两次添加的字符串对象明显不是一个对象（程序通过new关键字来创建字符串对象），当使用==运算符判断返回false，使用equals方法比较返回true，所以不能添加到Set集合中，最后只能输出一个元素。</p></blockquote><h4 id="2-1、HashSet"><a href="#2-1、HashSet" class="headerlink" title="2.1、HashSet"></a>2.1、HashSet</h4><p>HashSet 是一个<strong>没有重复</strong>元素的集合。它是由<strong>HashMap实现的</strong>，<strong>不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素</strong>。HashSet是<strong>非同步的，</strong>如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。</p><p>HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</p><p>HashSet使用和理解中容易出现的误区:</p><ol><li>HashSet中存放null值<br> HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。</li><li>HashSet中存储元素的位置是固定的<br> HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。</li><li>必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</li></ol><h4 id="2-2、LinkedHashSet"><a href="#2-2、LinkedHashSet" class="headerlink" title="2.2、LinkedHashSet"></a>2.2、LinkedHashSet</h4><p>LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><h4 id="2-3、TreeSet"><a href="#2-3、TreeSet" class="headerlink" title="2.3、TreeSet"></a>2.3、TreeSet</h4><p>TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。</p><p>注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。</p><h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h3><p>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</p><h3 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2.LinkedHashMap"></a>2.LinkedHashMap</h3><p>LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。</p><p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p><p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</p><p>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p><p>由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。</p><h3 id="3-TreeMap"><a href="#3-TreeMap" class="headerlink" title="3.TreeMap"></a>3.TreeMap</h3><p>TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p><p>自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p><p>定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p><p>TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。</p><p>如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。</p><p><img src="/2021/02/15/JavaCollectionsFramework/image-20200419223344332.png" alt="image-20200419223344332"></p><h2 id="Iterator与ListIterator"><a href="#Iterator与ListIterator" class="headerlink" title="Iterator与ListIterator"></a>Iterator与ListIterator</h2><h3 id="1-Iterator"><a href="#1-Iterator" class="headerlink" title="1.Iterator"></a>1.Iterator</h3><p>Iterator的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口如下：</p><p>boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。<br>Object next()：返回集合里下一个元素。<br>void remove()：删除集合里上一次next方法返回的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; a = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        a.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        a.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        a.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Before iterate : &quot;</span> + a);<br>        Iterator&lt;String&gt; it = a.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            String t = it.next();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bbb&quot;</span>.equals(t)) &#123;<br>                it.remove();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;After iterate : &quot;</span> + a);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Before iterate : [aaa, bbb, ccc]</span><br><span class="hljs-comment">//After iterate : [aaa, ccc] </span><br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><p>（1）Iterator只能单向移动。</p><p>（2）Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常。</p></blockquote><h3 id="2-ListIterator"><a href="#2-ListIterator" class="headerlink" title="2.ListIterator"></a><strong>2.ListIterator</strong></h3><p>ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator.</p><p>ListIterator接口定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ListIterator</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPrevious</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">E <span class="hljs-title">previous</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nextIndex</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">previousIndex</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由以上定义我们可以推出ListIterator可以:</p><ol><li>双向移动（向前/向后遍历）；</li><li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引；</li><li>可以使用set()方法替换它访问过的最后一个元素；</li><li>可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素。</li></ol><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIteratorExample</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; a = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        a.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        a.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        a.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Before iterate : &quot;</span> + a);<br>        ListIterator&lt;String&gt; it = a.listIterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            System.out.println(it.next() + <span class="hljs-string">&quot;, &quot;</span> + it.previousIndex() + <span class="hljs-string">&quot;, &quot;</span> + it.nextIndex());<br>        &#125;<br>        <span class="hljs-keyword">while</span> (it.hasPrevious()) &#123;<br>            System.out.print(it.previous() + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>        it = a.listIterator(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            String t = it.next();<br>            System.out.println(t);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ccc&quot;</span>.equals(t)) &#123;<br>                it.set(<span class="hljs-string">&quot;nnn&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                it.add(<span class="hljs-string">&quot;kkk&quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;After iterate : &quot;</span> + a);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Before iterate : [aaa, bbb, ccc]</span><br><span class="hljs-comment">aaa, 0, 1</span><br><span class="hljs-comment">bbb, 1, 2</span><br><span class="hljs-comment">ccc, 2, 3</span><br><span class="hljs-comment">ccc bbb aaa </span><br><span class="hljs-comment">bbb</span><br><span class="hljs-comment">ccc</span><br><span class="hljs-comment">After iterate : [aaa, bbb, kkk, nnn]*/</span><br></code></pre></td></tr></table></figure><h2 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h2><h3 id="1-ArrayList和LinkedList"><a href="#1-ArrayList和LinkedList" class="headerlink" title="1.ArrayList和LinkedList"></a>1.ArrayList和LinkedList</h3><p>（1）ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>（2）对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。<br>（3）对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</p><h3 id="2-HashTable与HashMap"><a href="#2-HashTable与HashMap" class="headerlink" title="2.HashTable与HashMap"></a>2.HashTable与HashMap</h3><p><strong>相同点：</strong></p><ol><li>都实现了Map、Cloneable、java.io.Serializable接口。</li><li>都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。</li></ol><p><strong>不同点：</strong></p><ol><li><p>历史原因:HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。</p></li><li><p>同步性:HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</p></li><li><p>对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。</p></li><li><p>基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。</p><blockquote><p>Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代M器)去遍历。 然而由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。</p><p>AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。</p></blockquote></li><li><p>支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 </p></li></ol><h3 id="3-HashMap、Hashtable、LinkedHashMap和TreeMap比较"><a href="#3-HashMap、Hashtable、LinkedHashMap和TreeMap比较" class="headerlink" title="3.HashMap、Hashtable、LinkedHashMap和TreeMap比较"></a>3.HashMap、Hashtable、LinkedHashMap和TreeMap比较</h3><p>Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p><p>Hashtable 与 HashMap类似，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。</p><p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。</p><p>TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。</p><p>一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。</p><p>TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</p><p>LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//HashMap</span><br>        HashMap&lt;String,String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap();<br>        hashMap.put(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>        hashMap.put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        hashMap.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        hashMap.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br><br>        Iterator&lt;String&gt; iteratorHashMap = hashMap.keySet().iterator();<br><br>        System.out.println(<span class="hljs-string">&quot;HashMap--&gt;&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (iteratorHashMap.hasNext())&#123;<br>            Object key1 = iteratorHashMap.next();<br>            System.out.println(key1 + <span class="hljs-string">&quot;--&quot;</span> + hashMap.get(key1));<br>        &#125;<br><br>        <span class="hljs-comment">//LinkedHashMap</span><br>        LinkedHashMap&lt;String,String&gt; linkedHashMap = <span class="hljs-keyword">new</span> LinkedHashMap();<br>        linkedHashMap.put(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>        linkedHashMap.put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        linkedHashMap.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        linkedHashMap.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br><br>        Iterator&lt;String&gt; iteratorLinkedHashMap = linkedHashMap.keySet().iterator();<br>        System.out.println(<span class="hljs-string">&quot;LinkedHashMap--&gt;&quot;</span>);<br>        <span class="hljs-keyword">while</span> (iteratorLinkedHashMap.hasNext())&#123;<br>            Object key2 = iteratorLinkedHashMap.next();<br>            System.out.println(key2 + <span class="hljs-string">&quot;--&quot;</span> + linkedHashMap.get(key2));<br>        &#125;<br><br>        <span class="hljs-comment">//TreeMap</span><br>        TreeMap&lt;String,String&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap();<br>        treeMap.put(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>        treeMap.put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        treeMap.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        treeMap.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>        <br>        Iterator&lt;String&gt; iteratorTreeMap = treeMap.keySet().iterator();<br>        System.out.println(<span class="hljs-string">&quot;TreeMap--&gt;&quot;</span>);<br>        <span class="hljs-keyword">while</span> (iteratorTreeMap.hasNext())&#123;<br>            Object key3 = iteratorTreeMap.next();<br>            System.out.println(key3 + <span class="hljs-string">&quot;--&quot;</span> + treeMap.get(key3));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*HashMap--&gt;</span><br><span class="hljs-comment">3--c</span><br><span class="hljs-comment">2--b</span><br><span class="hljs-comment">1--a</span><br><span class="hljs-comment">4--d</span><br><span class="hljs-comment">LinkedHashMap--&gt;</span><br><span class="hljs-comment">4--d</span><br><span class="hljs-comment">3--c</span><br><span class="hljs-comment">2--b</span><br><span class="hljs-comment">1--a</span><br><span class="hljs-comment">TreeMap--&gt;</span><br><span class="hljs-comment">1--a</span><br><span class="hljs-comment">2--b</span><br><span class="hljs-comment">3--c</span><br><span class="hljs-comment">4--d*/</span><br></code></pre></td></tr></table></figure><h3 id="4-HashSet、LinkedHashSet、TreeSet比较"><a href="#4-HashSet、LinkedHashSet、TreeSet比较" class="headerlink" title="4.HashSet、LinkedHashSet、TreeSet比较"></a><strong>4.HashSet、LinkedHashSet、TreeSet比较</strong></h3><p><strong>1、Set接口</strong><br>Set<strong>不允许包含相同的元素</strong>，如果试图把两个相同元素加入同一个集合中，add方法返回false。<br>Set判断两个对象相同不是使用==运算符，而是<strong>根据equals方法</strong>。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。</p><p><strong>2、HashSet</strong><br>HashSet有以下特点：<br>-&gt; 不能保证元素的排列顺序，顺序有可能发生变化。<br>-&gt; 不是同步的。<br>-&gt; 集合元素可以是null，但只能放入一个null。<br>  当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。<br>  注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。</p><p><strong>3、LinkedHashSet</strong><br>  LinkedHashSet集合同样是<strong>根据元素的hashCode值来决定元素的存储位置</strong>，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>  LinkedHashSet在迭代访问Set中的全部元素时，<strong>性能比HashSet好，但是插入时性能稍微逊色于HashSet。</strong></p><p><strong>4、TreeSet类</strong><br>  TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。<br>  TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。<br>自然排序<br>  自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。<br>  Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是负数，则表明obj1小于obj2。如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0。<br>定制排序<br>  自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;  <br>  <br><span class="hljs-keyword">import</span> java.util.HashSet;  <br><span class="hljs-keyword">import</span> java.util.LinkedHashSet;  <br><span class="hljs-keyword">import</span> java.util.TreeSet;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 几个set的比较  </span><br><span class="hljs-comment"> *    HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；  </span><br><span class="hljs-comment"> *    LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；  </span><br><span class="hljs-comment"> *    TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Zhou-Jingxian  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetDemo</span> </span>&#123;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>  <br>        HashSet&lt;String&gt; hs = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();  <br>        hs.add(<span class="hljs-string">&quot;B&quot;</span>);  <br>        hs.add(<span class="hljs-string">&quot;A&quot;</span>);  <br>        hs.add(<span class="hljs-string">&quot;D&quot;</span>);  <br>        hs.add(<span class="hljs-string">&quot;E&quot;</span>);  <br>        hs.add(<span class="hljs-string">&quot;C&quot;</span>);  <br>        hs.add(<span class="hljs-string">&quot;F&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;HashSet 顺序:\n&quot;</span>+hs);  <br>          <br>        LinkedHashSet&lt;String&gt; lhs = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;();  <br>        lhs.add(<span class="hljs-string">&quot;B&quot;</span>);  <br>        lhs.add(<span class="hljs-string">&quot;A&quot;</span>);  <br>        lhs.add(<span class="hljs-string">&quot;D&quot;</span>);  <br>        lhs.add(<span class="hljs-string">&quot;E&quot;</span>);  <br>        lhs.add(<span class="hljs-string">&quot;C&quot;</span>);  <br>        lhs.add(<span class="hljs-string">&quot;F&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;LinkedHashSet 顺序:\n&quot;</span>+lhs);  <br>          <br>        TreeSet&lt;String&gt; ts = <span class="hljs-keyword">new</span> TreeSet&lt;String&gt;();  <br>        ts.add(<span class="hljs-string">&quot;B&quot;</span>);  <br>        ts.add(<span class="hljs-string">&quot;A&quot;</span>);  <br>        ts.add(<span class="hljs-string">&quot;D&quot;</span>);  <br>        ts.add(<span class="hljs-string">&quot;E&quot;</span>);  <br>        ts.add(<span class="hljs-string">&quot;C&quot;</span>);  <br>        ts.add(<span class="hljs-string">&quot;F&quot;</span>);  <br>        System.out.println(<span class="hljs-string">&quot;TreeSet 顺序:\n&quot;</span>+ts);  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">HashSet 顺序:[D, E, F, A, B, C]</span><br><span class="hljs-comment">LinkedHashSet 顺序:[B, A, D, E, C, F]</span><br><span class="hljs-comment">TreeSet 顺序:[A, B, C, D, E, F]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="5、Iterator和ListIterator区别"><a href="#5、Iterator和ListIterator区别" class="headerlink" title="5、Iterator和ListIterator区别"></a><strong>5、Iterator和ListIterator区别</strong></h3><p>我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。但是在使用的时候也是有不同的。List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：</p><p>（1）ListIterator有add()方法，可以向List中添加对象，而Iterator不能</p><p>（2）ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</p><p>（3）ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</p><p>（4）都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</p><p>因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</p><h3 id="6、Collection-和-Collections区别"><a href="#6、Collection-和-Collections区别" class="headerlink" title="6、Collection 和 Collections区别"></a>6、Collection 和 Collections区别</h3><p>（1）java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p><blockquote><p> Collection<br>        ├——List<br>        │├——LinkedList<br>        │├——ArrayList<br>        │└——Vector<br>        │　└—Stack<br>        └——Set </p></blockquote><p>（2）java.util.Collections 是一个包装类（工具类/帮助类）。它包含有各种有关集合操作的<strong>静态多态方法</strong>。此类<strong>不能实例化</strong>，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList; <br><span class="hljs-keyword">import</span> java.util.Collections; <br><span class="hljs-keyword">import</span> java.util.List; <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCollections</span> </span>&#123; <br>      <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123; <br>        <span class="hljs-comment">//注意List是实现Collection接口的 </span><br>        List list = <span class="hljs-keyword">new</span> ArrayList(); <br>        <span class="hljs-keyword">double</span> array[] = &#123; <span class="hljs-number">112</span>, <span class="hljs-number">111</span>, <span class="hljs-number">23</span>, <span class="hljs-number">456</span>, <span class="hljs-number">231</span> &#125;; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123; <br>            list.add(<span class="hljs-keyword">new</span> Double(array[i])); <br>        &#125; <br>        Collections.sort(list); <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123; <br>            System.out.println(list.get(i)); <br>        &#125; <br>        <span class="hljs-comment">// 结果：23.0 111.0 112.0 231.0 456.0 </span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>Map跟collection应该是平级，没有依赖关系</p><p>并且少了QUEUE这个数据结构、</p><p>这个图对吗？我看从jdk1.5开始，源代码就是这样了：<br>public interface Collection<E> extends Iterable<E> {<br>}<br>大家可以看一下。<br>jdk1.4的源代码如下，1.4还琐有引入iterable<br>public interface Collection {<br>}</E></E></p><p>其他内容可以参考，学习一下。但类图觉得有问题的。</p><p>Map中的values 是以Collection类型存储的</p><p>类图的实线三角是泛化关系，虚线三角是实现接口关系，类图有点问题</p><p>LinkedList还有insert方法？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/02/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>问题及描述：<br> –1.学生表<br> Student(SID,Sname,Sage,Ssex) –SID 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别<br> –2.课程表<br> Course(CID,Cname,TID) –CID –课程编号,Cname 课程名称,TID 教师编号<br> –3.教师表<br> Teacher(TID,Tname) –TID 教师编号,Tname 教师姓名<br> –4.成绩表<br> SC(SID,CID,score) –SID 学生编号,CID 课程编号,score 分数</p><p> –创建测试数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Student(SID <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Sname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Sage <span class="hljs-type">date</span>,Ssex <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;赵雷&#x27;</span> , <span class="hljs-string">&#x27;1990-01-01&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;钱电&#x27;</span> , <span class="hljs-string">&#x27;1990-12-21&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;孙风&#x27;</span> , <span class="hljs-string">&#x27;1990-05-20&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;李云&#x27;</span> , <span class="hljs-string">&#x27;1990-08-06&#x27;</span> , <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;周梅&#x27;</span> , <span class="hljs-string">&#x27;1991-12-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;吴兰&#x27;</span> , <span class="hljs-string">&#x27;1992-03-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;郑竹&#x27;</span> , <span class="hljs-string">&#x27;1989-07-01&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Student <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;08&#x27;</span> , <span class="hljs-string">&#x27;王菊&#x27;</span> , <span class="hljs-string">&#x27;1990-01-20&#x27;</span> , <span class="hljs-string">&#x27;女&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Course(CID <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Cname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),TID <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;语文&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;数学&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Course <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;英语&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Teacher(TID <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),Tname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;张三&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;李四&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> Teacher <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;王五&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(SID <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),CID <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),score <span class="hljs-type">decimal</span>(<span class="hljs-number">18</span>,<span class="hljs-number">1</span>));<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">90</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">99</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">70</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">60</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">80</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">50</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">30</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;04&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">20</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">76</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;05&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">87</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;01&#x27;</span> , <span class="hljs-number">31</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;06&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">34</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;02&#x27;</span> , <span class="hljs-number">89</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SC <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;07&#x27;</span> , <span class="hljs-string">&#x27;03&#x27;</span> , <span class="hljs-number">98</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2021/02/15/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="200、岛屿数量"><a href="#200、岛屿数量" class="headerlink" title="200、岛屿数量"></a>200、岛屿数量</h1><p><code>广度优先搜索</code>、<code>深度优先搜索</code>、<code>并查集</code></p><h2 id="深度优先搜索求解"><a href="#深度优先搜索求解" class="headerlink" title="深度优先搜索求解"></a>深度优先搜索求解</h2><p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 11 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 00。</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数。</p><p><img src="/2021/02/15/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/DFS.gif" alt="CYhQBcBWPF"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> nr = grid.length;<br>        <span class="hljs-keyword">int</span> nc = grid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || c &lt; <span class="hljs-number">0</span> || r &gt;= nr || c &gt;= nc || grid[r][c] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        dfs(grid, r - <span class="hljs-number">1</span>, c);<br>        dfs(grid, r + <span class="hljs-number">1</span>, c);<br>        dfs(grid, r, c - <span class="hljs-number">1</span>);<br>        dfs(grid, r, c + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (grid == <span class="hljs-keyword">null</span> || grid.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> nr = grid.length;<br>        <span class="hljs-keyword">int</span> nc = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> num_islands = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; nr; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; nc; ++c) &#123;<br>                <span class="hljs-keyword">if</span> (grid[r][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ++num_islands;<br>                    dfs(grid, r, c);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num_islands;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(MN)，其中 M 和 N 分别为行数和列数。</p></li><li><p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 MN。</p></li></ul><h2 id="广度优先搜索求解"><a href="#广度优先搜索求解" class="headerlink" title="广度优先搜索求解"></a>广度优先搜索求解</h2><p>同样地，我们也可以使用广度优先搜索代替深度优先搜索。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 00。直到队列为空，搜索结束。</p><p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs maxima">class Solution &#123;<br>    public int numIslands(char[][] <span class="hljs-built_in">grid</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">grid</span> == null || <span class="hljs-built_in">grid</span>.<span class="hljs-built_in">length</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        int nr = <span class="hljs-built_in">grid</span>.<span class="hljs-built_in">length</span>;<br>        int nc = <span class="hljs-built_in">grid</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>;<br>        int num_islands = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (int r = <span class="hljs-number">0</span>; r &lt; nr; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (int c = <span class="hljs-number">0</span>; c &lt; nc; ++c) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">grid</span>[r][c] == &#x27;<span class="hljs-number">1</span>&#x27;) &#123;<br>                    ++num_islands;<br>                    <span class="hljs-built_in">grid</span>[r][c] = &#x27;<span class="hljs-number">0</span>&#x27;;<br>                    Queue&lt;Integer&gt; <span class="hljs-built_in">neighbors</span> = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>                    <span class="hljs-built_in">neighbors</span>.add(r * nc + c);<br>                    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">neighbors</span>.isEmpty()) &#123;<br>                        int id = <span class="hljs-built_in">neighbors</span>.<span class="hljs-built_in">remove</span>();<br>                        int <span class="hljs-built_in">row</span> = id / nc;<br>                        int <span class="hljs-built_in">col</span> = id <span class="hljs-symbol">%</span> nc;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">row</span> - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">grid</span>[<span class="hljs-built_in">row</span>-<span class="hljs-number">1</span>][<span class="hljs-built_in">col</span>] == &#x27;<span class="hljs-number">1</span>&#x27;) &#123;<br>                            <span class="hljs-built_in">neighbors</span>.add((<span class="hljs-built_in">row</span>-<span class="hljs-number">1</span>) * nc + <span class="hljs-built_in">col</span>);<br>                            <span class="hljs-built_in">grid</span>[<span class="hljs-built_in">row</span>-<span class="hljs-number">1</span>][<span class="hljs-built_in">col</span>] = &#x27;<span class="hljs-number">0</span>&#x27;;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">row</span> + <span class="hljs-number">1</span> &lt; nr &amp;&amp; <span class="hljs-built_in">grid</span>[<span class="hljs-built_in">row</span>+<span class="hljs-number">1</span>][<span class="hljs-built_in">col</span>] == &#x27;<span class="hljs-number">1</span>&#x27;) &#123;<br>                            <span class="hljs-built_in">neighbors</span>.add((<span class="hljs-built_in">row</span>+<span class="hljs-number">1</span>) * nc + <span class="hljs-built_in">col</span>);<br>                            <span class="hljs-built_in">grid</span>[<span class="hljs-built_in">row</span>+<span class="hljs-number">1</span>][<span class="hljs-built_in">col</span>] = &#x27;<span class="hljs-number">0</span>&#x27;;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">col</span> - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">grid</span>[<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>-<span class="hljs-number">1</span>] == &#x27;<span class="hljs-number">1</span>&#x27;) &#123;<br>                            <span class="hljs-built_in">neighbors</span>.add(<span class="hljs-built_in">row</span> * nc + <span class="hljs-built_in">col</span>-<span class="hljs-number">1</span>);<br>                            <span class="hljs-built_in">grid</span>[<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>-<span class="hljs-number">1</span>] = &#x27;<span class="hljs-number">0</span>&#x27;;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">col</span> + <span class="hljs-number">1</span> &lt; nc &amp;&amp; <span class="hljs-built_in">grid</span>[<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>+<span class="hljs-number">1</span>] == &#x27;<span class="hljs-number">1</span>&#x27;) &#123;<br>                            <span class="hljs-built_in">neighbors</span>.add(<span class="hljs-built_in">row</span> * nc + <span class="hljs-built_in">col</span>+<span class="hljs-number">1</span>);<br>                            <span class="hljs-built_in">grid</span>[<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>+<span class="hljs-number">1</span>] = &#x27;<span class="hljs-number">0</span>&#x27;;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">return</span> num_islands;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(MN)，其中 M 和 N 分别为行数和列数。</p></li><li><p>空间复杂度：O(min(M,N))，在最坏情况下，整个网格均为陆地，队列的大小可以达到 min(M,N)。</p></li></ul><h2 id="并查集求解"><a href="#并查集求解" class="headerlink" title="并查集求解"></a>并查集求解</h2><p>同样地，我们也可以使用并查集代替搜索。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则将其与相邻四个方向上的 11 在并查集中进行合并。</p><p>最终岛屿的数量就是并查集中连通分量的数目。</p><p><img src="/2021/02/15/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/ddmxKaScd6.gif" alt="ddmxKaScd6"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>        <span class="hljs-keyword">int</span> count;<br>        <span class="hljs-keyword">int</span>[] parent;<br>        <span class="hljs-keyword">int</span>[] rank;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>            count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> m = grid.length;<br>            <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length;<br>            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m * n];<br>            rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m * n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        parent[i * n + j] = i * n + j;<br>                        ++count;<br>                    &#125;<br>                    rank[i * n + j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (parent[i] != i) parent[i] = <span class="hljs-built_in">find</span>(parent[i]);<br>            <span class="hljs-keyword">return</span> parent[i];<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootx = <span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-keyword">int</span> rooty = <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-keyword">if</span> (rootx != rooty) &#123;<br>                <span class="hljs-keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;<br>                    parent[rooty] = rootx;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;<br>                    parent[rootx] = rooty;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    parent[rooty] = rootx;<br>                    rank[rootx] += <span class="hljs-number">1</span>;<br>                &#125;<br>                --count;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (grid == null || grid.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> nr = grid.length;<br>        <span class="hljs-keyword">int</span> nc = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> num_islands = <span class="hljs-number">0</span>;<br>        UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(grid);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; nr; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; nc; ++c) &#123;<br>                <span class="hljs-keyword">if</span> (grid[r][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r<span class="hljs-number">-1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.<span class="hljs-keyword">union</span>(r * nc + c, (r<span class="hljs-number">-1</span>) * nc + c);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[r+<span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.<span class="hljs-keyword">union</span>(r * nc + c, (r+<span class="hljs-number">1</span>) * nc + c);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.<span class="hljs-keyword">union</span>(r * nc + c, r * nc + c - <span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        uf.<span class="hljs-keyword">union</span>(r * nc + c, r * nc + c + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> uf.getCount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：O(MN∗α(MN))，其中 M 和 N 分别为行数和列数。注意当使用路径压缩（见 find 函数）和按秩合并（见数组 rank）实现并查集时，单次操作的时间复杂度为 α(MN)，其中α(x) 为反阿克曼函数，当自变量 x 的值在人类可观测的范围内（宇宙中粒子的数量）时，函数 α(x) 的值不会超过 5，因此也可以看成是常数时间复杂度。</p><p>空间复杂度：O(MN)，这是并查集需要使用的空间。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/15/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
    <url>/2021/02/15/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="unicode、codepoint、UTF"><a href="#unicode、codepoint、UTF" class="headerlink" title="unicode、codepoint、UTF"></a>unicode、codepoint、UTF</h1><h2 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h2><blockquote><p>unicode是计算机科学领域里的一项业界标准，包括字符集、编码方案等。计算机采用八比特一个字节，一个字节最大整数是255，还要表示中文一个字节也是不够的，至少需要两个字节，为了统一所有的文字编码，unicode为每种语言中的每个字符设定了统一并且唯一的二进制编码，通常用两个字节表示一个字符，所以unicode每个平面可以组合出65535种不同的字符，一共17个平面。</p></blockquote><p>由于英文符号只需要用到低8位，所以其高8位永远是0，因此保存英文文本时会多浪费一倍的空间。</p><p>比如汉子“汉”的unicode，在java中输出</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;\u5B57&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>unicode在计算机中如何存储呢，就是用unicode字符集转换格式，即我们常见的UTF-8、UTF-16等。</p><p>UTF-8就是以字节为单位对unicode进行编码，对不同范围的字符使用不同长度的编码。</p><table><thead><tr><th>Unicode</th><th>Utf-8</th></tr></thead><tbody><tr><td>000000-00007F</td><td>0xxxxxxx</td></tr><tr><td>000080-0007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>000800-00FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>010000-10FFFF</td><td>11110xxx10xxxxxx10xxxxxx10xxxxxx</td></tr></tbody></table><p>Java中的String对象就是一个unicode编码的字符串。</p><p>java中想知道一个字符的unicode编码我们可以通过Integer.toHexString()方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> str = <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//String str = &quot;编&quot;;</span><br><span class="hljs-built_in">StringBuffer</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>();<br>char [] source_char = str.toCharArray();<br>System.out.println(source_char.length);<span class="hljs-comment">//1</span><br>System.out.println(source_char[<span class="hljs-number">0</span>]);<span class="hljs-comment">//a    编</span><br><span class="hljs-built_in">String</span> unicode = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;source_char.length;i++) &#123;<br>    unicode = Integer.toHexString(source_char[i]);<br>    System.out.println(unicode);<span class="hljs-comment">//a:61   编：7f16</span><br>    <span class="hljs-keyword">if</span> (unicode.length() &lt;= <span class="hljs-number">2</span>) &#123;<br>        unicode = <span class="hljs-string">&quot;00&quot;</span> + unicode;<br>    &#125;<br>    sb.append(<span class="hljs-string">&quot;\\u&quot;</span> + unicode);<br>&#125;<br>System.out.println(sb);<span class="hljs-comment">//a:\u0061  编：\u7f16</span><br></code></pre></td></tr></table></figure><p>对应的utf-8编码是什么呢?</p><p>7f16在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。<br>7f16写成二进制是：0111 1111 0001 0110<br>按三字节模板分段方法分为0111 111100 010110，代替模板中的x，得到11100111 10111100 10010110，即“编”对应的utf-8的编码是e7 bc 96，占3个字节</p><h2 id="codepoint"><a href="#codepoint" class="headerlink" title="codepoint"></a>codepoint</h2><p>unicode的范围从000000 - 10FFFF，char的范围只能是在\u0000到\uffff，也就是标准的 2 字节形式通常称作 UCS-2，在Java中，char类型用UTF-16编码描述一个代码单元，但unicode大于0x10000的部分如何用char表示呢，比如一些emoji：😀</p><p>java的char类型占两个字节，想要表示😀这个表情就需要2个char，看如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> testCode = <span class="hljs-string">&quot;ab\uD83D\uDE03cd&quot;</span>;<br><span class="hljs-built_in">int</span> length = testCode.length();<span class="hljs-comment">//length=6</span><br><span class="hljs-built_in">int</span> count = testCode.codePointCount(<span class="hljs-number">0</span>, testCode.length());<span class="hljs-comment">//count=5</span><br></code></pre></td></tr></table></figure><p>第三个和第四个字符合起来代表😀，是一个代码点，如果我们想取到每个代码点做一些判断可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">String testCode = <span class="hljs-string">&quot;ab\uD83D\uDE03cd&quot;</span>;<br><span class="hljs-keyword">int</span> length = testCode.length();<span class="hljs-comment">//length=6</span><br><br>System.out.println(testCode);<span class="hljs-comment">//ab😃cd</span><br><span class="hljs-keyword">int</span> cpCount = testCode.codePointCount(<span class="hljs-number">0</span>, testCode.length());<span class="hljs-comment">//cpCount=5</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; cpCount; ++index) &#123;<br>    <span class="hljs-comment">//这里的i是字符的位置</span><br>    <span class="hljs-keyword">int</span> i = testCode.offsetByCodePoints(<span class="hljs-number">0</span>, index);<br>    <span class="hljs-keyword">int</span> codepoint = testCode.codePointAt(i);<br>    System.out.println(<span class="hljs-string">&quot;i: &quot;</span>+i+<span class="hljs-string">&quot; index: &quot;</span>+index+<span class="hljs-string">&quot; codePoint: &quot;</span>+codepoint);<br>    <span class="hljs-comment">/*输出</span><br><span class="hljs-comment">        i:0 index: 0 codePoint: 97</span><br><span class="hljs-comment">        i:1 index: 1 codePoint: 98</span><br><span class="hljs-comment">        i:2 index: 2 codePoint: 128515</span><br><span class="hljs-comment">        i:4 index: 3 codePoint: 99</span><br><span class="hljs-comment">        i:5 index: 4 codePoint: 100*/</span><br>&#125;<br><br><span class="hljs-keyword">int</span>[] abc = testCode.chars().toArray();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;abc.length;i++)&#123;<br>System.out.println(abc[i]);<span class="hljs-comment">//[97,98,55357,56835,99,100]</span><br>&#125;<br>abc = testCode.codePoints().toArray();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;abc.length;i++)&#123;<br>System.out.println(abc[i]);<span class="hljs-comment">//[97,98,128515,99,100]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>codePointIndex和char的index的区别:</p><p>按照codePointindex取字符，0取到a，1取到b，2取到\uD83D\uDE03也就是😀，3取到c，4取到d；<br>按照String的index取字符，0取到a，1取到b，2取到\uD83D，3取到\uDE03，4取到c，5取到d。</p><p>取到codePoint就可以按照unicode值进行字符的过滤等操作。</p><p>如果有个需求是既可以按照unicode值过滤字符，也能按照正则表达式过滤字符，并且还有白名单，应该如何实现呢。</p><p>其实unicode过滤和正则表达式过滤并不冲突，自己实现自己的过滤就好了，如果需求加入了过滤白名单就会复杂一些，不能直接过滤，需要先检验是否是白名单的index。</p><p>我的思路是记录白名单char的index，正则表达式或其他过滤方式可以获得违规char的index，unicode黑名单的codepointIndex可以转换成char的index，在获取codePont的index时可以判断当前字符是单char字符还是双char字符，双char字符需要添加2个下标，方法如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//取到unicode值           </span><br><span class="hljs-built_in">int</span> codepoint = testCode.codePointAt(i);<br><span class="hljs-comment">//将unicode值转换成char数组</span><br><span class="hljs-built_in">char</span>[] chars = Character.toChars(codepoint);<br>charIndexs.<span class="hljs-keyword">add</span>(pointIndex);<br><span class="hljs-keyword">if</span> (chars.length &gt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">//表示不是单char字符，记录index时同时添加i+1</span><br>charIndexs.<span class="hljs-keyword">add</span>(pointIndex + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>//例<br>String str = “ab\uD83D\uDE03汉字”;<br>想处理emoji，那记录的下标就是2、3，最后和白名单下标比较后统一删除</p><h4 id="如何区别char是一对还是单个"><a href="#如何区别char是一对还是单个" class="headerlink" title="如何区别char是一对还是单个"></a>如何区别char是一对还是单个</h4><p>就之前的例子ab\uD83D\uDE03cd，换种写法\u0061\u0062\uD83D\uDE0\u0063\u0064<br>程序是如何将\uD83D\uDE03解析成一个字符的呢。这就需要Surrogate这个概念，来自UTF-16。</p><p>UTF-16是16bit最多编码65536，那大于65536如何编码？Unicode 标准制定组想出的办法是，从这65536个编码里，拿出2048个，规定他们是「Surrogates」，让他们两个为一组，来代表编号大于65536的那些字符。<br>编号为 U+D800 至 U+DBFF 的规定为「High Surrogates」，共1024个。<br>编号为 U+DC00 至 U+DFFF 的规定为「Low Surrogates」，也是1024个。<br>他们组合出现，就又可以多表示1048576中字符。</p><p>看一下String.codePointAt这个方法，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">codePointAtImpl</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> c1 = a[index];<br>    <span class="hljs-keyword">if</span> (isHighSurrogate(c1) &amp;&amp; ++index &lt; limit) &#123;<br>        <span class="hljs-keyword">char</span> c2 = a[index];<br>        <span class="hljs-keyword">if</span> (isLowSurrogate(c2)) &#123;<br>            <span class="hljs-keyword">return</span> toCodePoint(c1, c2);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c1;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中有两个方法isHighSurrogate、isLowSurrogate。<br>第一个方法判断是否为高代理项代码单元，即在’\uD800’与’\uDBFF’之间，<br>第二个方法判断是否为低代理项代码单元，即在’\uDC00’与’\uDFFF’之间。</p><p>codePointAtImpl方法判断当前char是高代理项代码单元，下一个是低代理项代码单元，则这两个char是一个codepoint。</p><p>再来看一下unicode转UTF-16的方法</p><blockquote><p>如果U&lt;0x10000，U的UTF-16编码就是U对应的16位无符号整数（为书写简便，下文将16位无符号整数记作WORD）。<br>如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。</p></blockquote><p>还是以U+1F603这个😃为例子，U’=U-0x10000=F603<br>写成2进制就是1111011000000011，不足20位前面补0，<br>变成0000111101-1000000011，替换y和x就是1101100000111101，1101111000000011，最后UTF-16编码就是[d83d，de03] 和上面一样。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/15/hello-world/"/>
    <url>/2021/02/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows技巧:笔记本的电池状态</title>
    <link href="/2020/01/05/Windows%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E7%94%B5%E6%B1%A0%E7%8A%B6%E6%80%81/"/>
    <url>/2020/01/05/Windows%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E7%94%B5%E6%B1%A0%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h4 id="使用powercfg查询笔记本电脑电池状态"><a href="#使用powercfg查询笔记本电脑电池状态" class="headerlink" title="使用powercfg查询笔记本电脑电池状态"></a>使用powercfg查询笔记本电脑电池状态</h4><p>管理员身份运行cmd</p><p>1、键入powercfg -energy，程序将会自动开始对系统的60秒状态跟踪，并分析所获得的数据然后给出报告，这个过程最好不要操作电脑</p><p><img src="/2020/01/05/Windows%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E7%94%B5%E6%B1%A0%E7%8A%B6%E6%80%81/image-20200105183628739.png" alt="image-20200105183628739"></p><p>完成分析后，生成HTML报告，提示报告位置，找到报告位置打开查看：</p><p><img src="/2020/01/05/Windows%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E7%94%B5%E6%B1%A0%E7%8A%B6%E6%80%81/image-20200105184023940.png" alt="image-20200105184023940"></p><p>2、键入powercfg /batteryreport，系统会在指定路径形成电池使用报告，打开查看电池使用报告：</p><p><img src="/2020/01/05/Windows%E6%8A%80%E5%B7%A7-%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E7%94%B5%E6%B1%A0%E7%8A%B6%E6%80%81/image-20200105184403519.png" alt="image-20200105184403519"></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>使用技巧</tag>
      
      <tag>电池状态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVN</title>
    <link href="/2019/12/10/SVN/"/>
    <url>/2019/12/10/SVN/</url>
    
    <content type="html"><![CDATA[<h3 id="1、SVN版本控制"><a href="#1、SVN版本控制" class="headerlink" title="1、SVN版本控制"></a>1、SVN版本控制</h3><p>Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。</p><h4 id="1-1、引入：为什么需要引入版本控制"><a href="#1-1、引入：为什么需要引入版本控制" class="headerlink" title="1.1、引入：为什么需要引入版本控制"></a>1.1、引入：为什么需要引入版本控制</h4><h5 id="1-1-1、问题"><a href="#1-1-1、问题" class="headerlink" title="1.1.1、问题"></a>1.1.1、问题</h5><p>在软件开发中, 经常会有下面这些问题</p><ol><li><p>如何确保电脑故障或开发人员离职的情况下, 资料不会丢失?</p></li><li><p>多人开发同一个项目, 代码如何合并到一起?</p></li><li><p>如何追溯代码的历史状态? 将每一个版本压缩放到网盘上吗?</p></li><li><p>如何控制代码的访问权限? 例如项目核心算法不能让新程序员修改, 如何做?</p></li></ol><p>版本控制系统就是解决这些问题的答案</p><h5 id="1-1-2、常用的版本控制系统"><a href="#1-1-2、常用的版本控制系统" class="headerlink" title="1.1.2、常用的版本控制系统"></a>1.1.2、常用的版本控制系统</h5><p>有 SVN, Git等</p><h5 id="1-1-3、SVN-的一些概念："><a href="#1-1-3、SVN-的一些概念：" class="headerlink" title="1.1.3、SVN 的一些概念："></a>1.1.3、SVN 的一些概念：</h5><ul><li>**repository（源代码库）:**源代码统一存放的地方</li><li>**Checkout（提取）:**当你手上没有源代码的时候，你需要从repository checkout一份</li><li>**Commit（提交）:**当你已经修改了代码，你就需要Commit到repository</li><li>**Update (更新):**当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更</li></ul><p>日常开发过程其实就是这样的（假设你已经Checkout并且已经工作了几天）：Update(获得最新的代码) –&gt;作出自己的修改并调试成功 –&gt; Commit(大家就可以看到你的修改了) 。</p><p>如果两个程序员同时修改了同一个文件呢, SVN 可以合并这两个程序员的改动，实际上SVN管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN都会自动合并两种修改。如果是同一行，SVN 会提示文件 Conflict, 冲突，需要手动确认。</p><h4 id="1-2、SVN-的主要功能"><a href="#1-2、SVN-的主要功能" class="headerlink" title="1.2、SVN 的主要功能"></a>1.2、SVN 的主要功能</h4><p>（1）目录版本控制</p><p>CVS 只能跟踪单个文件的历史, 不过 Subversion 实作了一个 “虚拟” 的版本控管文件系统, 能够依时间跟踪整个目录的变动。 目录和文件都能进行版本控制。</p><p>（2）真实的版本历史</p><p>自从CVS限制了文件的版本记录，CVS并不支持那些可能发生在文件上，但会影响所在目录内容的操作，如同复制和重命名。除此之外，在CVS里你不能用拥有同样名字但是没有继承老版本历史或者根本没有关系的文件替换一个已经纳入系统的文件。在Subversion中，你可以增加（add）、删除（delete）、复制（copy）和重命名（rename），无论是文件还是目录。所有的新加的文件都从一个新的、干净的版本开始。</p><p>（3）自动提交</p><p>一个提交动作，不是全部更新到了档案库中，就是不完全更新。这允许开发人员以逻辑区间建立并提交变动，以防止当部分提交成功时出现的问题。</p><p>（4）纳入版本控管的元数据</p><p>每一个文件与目录都附有一組属性关键字并和属性值相关联。你可以创建, 并儲存任何你想要的Key/Value对。 属性是随着时间来作版本控管的,就像文件內容一样。</p><p>（5）选择不同的网络层</p><p>Subversion 有抽象的档案库存取概念, 可以让人很容易地实作新的网络机制。 Subversion 可以作为一个扩展模块嵌入到Apache HTTP 服务器中。这个为Subversion提供了非常先进的稳定性和协同工作能力，除此之外还提供了许多重要功能: 举例来说, 有身份认证, 授权, 在线压缩, 以及文件库浏览等等。还有一个轻量级的独立Subversion服务器， 使用的是自定义的通信协议, 可以很容易地通过 ssh 以 tunnel 方式使用。</p><p>（6）一致的数据处理方式</p><p>Subversion 使用二进制差异算法来异表示文件的差异, 它对文字(人类可理解的)与二进制文件(人类无法理解的) 两类的文件都一视同仁。 这两类的文件都同样地以压缩形式储存在档案库中, 而且文件差异是以两个方向在网络上传输的。</p><p>（7）有效的分支(branch)与标签(tag)</p><p>在分支与标签上的消耗并不必一定要与项目大小成正比。 Subversion 建立分支与标签的方法, 就只是复制该项目, 使用的方法就类似于硬连接（hard-link）。 所以这些操作只会花费很小, 而且是固定的时间。</p><p>（8）Hackability</p><p>Subversion没有任何的历史包袱; 它主要是一群共用的 C 程序库, 具有定义完善的API。这使得 Subversion 便于维护, 并且可被其它应用程序与程序语言使用。</p><h4 id="1-3、安装SVN仓库"><a href="#1-3、安装SVN仓库" class="headerlink" title="1.3、安装SVN仓库"></a>1.3、安装SVN仓库</h4><h5 id="1-3-1、安装SVN服务器"><a href="#1-3-1、安装SVN服务器" class="headerlink" title="1.3.1、安装SVN服务器"></a>1.3.1、安装SVN服务器</h5><p>安装VisualSVN Server<a href="https://www.visualsvn.com/server/download/">下载地址</a></p><p><img src="/2019/12/10/SVN/image-20191210163958278.png" alt="image-20191210163958278"></p><p>下载完毕后点击安装，同意用户协议</p><p><img src="/2019/12/10/SVN/image-20191210164356133.png" alt="image-20191210164356133"></p><p><img src="/2019/12/10/SVN/image-20191210164554790.png" alt="image-20191210164554790"></p><p><img src="/2019/12/10/SVN/image-20191210164635265.png" alt="image-20191210164635265"></p><p>点击下一步可能出现如下状况，原因是：由于各种原因导致HTTPS协议默认使用的443端口被占用，可以换用其它端口、解决443端口的争用或者换用其它如HTTP协议等。这里直接使用HTTPS协议换用8443端口。</p><p><img src="/2019/12/10/SVN/image-20191210165143514.png" alt="image-20191210165143514"></p><p><img src="/2019/12/10/SVN/image-20191210165416069.png" alt="image-20191210165416069"></p><p><img src="/2019/12/10/SVN/image-20191210165507110.png" alt="image-20191210165507110"></p><p><img src="/2019/12/10/SVN/image-20191210165547214.png" alt="image-20191210165547214"></p><h5 id="1-3-2、新建仓库"><a href="#1-3-2、新建仓库" class="headerlink" title="1.3.2、新建仓库"></a>1.3.2、新建仓库</h5><p><code>Trunk：</code> 存放开发的主线，团队成员在开发的时候一直要用这个库中的内容</p><p><code>Branches：</code>存放支线副本：当项目稳定以后，先发布到tags下，如果发现了bug，再从tags下检出到branches下。在该版本下进行bug的修复，把修复完毕的稳定的版本重新发布到tags下。</p><p><code>Tags：</code>存放标签副本，也就是存放稳定版本</p><p><img src="/2019/12/10/SVN/image-20191210091559139.png" alt="image-20191210091559139"></p><h5 id="1-3-3、新建用户-amp-组"><a href="#1-3-3、新建用户-amp-组" class="headerlink" title="1.3.3、新建用户&amp;组"></a>1.3.3、新建用户&amp;组</h5><p><img src="/2019/12/10/SVN/image-20191210165818343.png" alt="image-20191210165818343"></p><p><img src="/2019/12/10/SVN/image-20191210165916450.png" alt="image-20191210165916450"></p><h5 id="1-3-4、配置权限"><a href="#1-3-4、配置权限" class="headerlink" title="1.3.4、配置权限"></a>1.3.4、配置权限</h5><p><img src="/2019/12/10/SVN/image-20191210170115155.png" alt="image-20191210170115155"></p><h5 id="1-3-5、访问仓库简单测试"><a href="#1-3-5、访问仓库简单测试" class="headerlink" title="1.3.5、访问仓库简单测试"></a>1.3.5、访问仓库简单测试</h5><p><img src="/2019/12/10/SVN/image-20191210170602059.png" alt="image-20191210170602059"></p><p>访问结果如下：</p><p><img src="/2019/12/10/SVN/image-20191210170652117.png" alt="image-20191210170652117"></p><h5 id="1-3-6、Linux系统版本安装配置"><a href="#1-3-6、Linux系统版本安装配置" class="headerlink" title="1.3.6、Linux系统版本安装配置"></a><a href="https://www.runoob.com/svn/svn-tutorial.html">1.3.6、Linux系统版本安装配置</a></h5><p>大多数 GNU/Linux 发行版系统自带了Subversion ，所以它很有可能已经安装在你的系统上了。可以使用下面命令检查是否安装了。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">svn <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>如果 Subversion 客户端没有安装，命令将报告svn命令找不到的错误。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d">[kongwei<span class="hljs-keyword">@centos6</span> ~]$ svn --<span class="hljs-keyword">version</span><br>bash: svn: command not found<br></code></pre></td></tr></table></figure><p>我们可以使用 <code>yum install subversion 命令</code>或<code>apt-get install subversion命令</code>进行安装。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">kongwei@centos6 root</span>]$ su -<br>密码：<br>[<span class="hljs-meta">root@centos6 ~</span>]<span class="hljs-meta"># yum install subversion</span><br>已加载插件：fastestmirror, security<br>设置安装进程<br>Loading mirror speeds <span class="hljs-keyword">from</span> cached hostfile<br> * <span class="hljs-keyword">base</span>: mirrors.aliyun.com<br> * epel: mirrors.neusoft.edu.cn<br> * extras: mirrors.zju.edu.cn<br> * updates: mirrors.aliyun.com<br>解决依赖关系<br>--&amp;gt; 执行事务检查<br>...<br></code></pre></td></tr></table></figure><p>安装成功之后，执行 svn –version 命令。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">[root@ce<span class="hljs-symbol">ntos6</span> ~]<span class="hljs-attr"># svn --version</span><br><span class="hljs-attr">svn，版本 1</span><span class="hljs-number">.6</span><span class="hljs-number">.11</span> <span class="hljs-comment">(r934486)</span><br>   编译于 Aug <span class="hljs-number">17</span> <span class="hljs-number">2015</span>，<span class="hljs-number">08</span>:<span class="hljs-number">37</span>:<span class="hljs-number">43</span><br></code></pre></td></tr></table></figure><p>至此，centos下的SVN安装完成。</p><p>首先，在服务端进行SVN版本库的相关配置</p><p>手动新建版本库目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/opt/</span>svn<br></code></pre></td></tr></table></figure><p>利用svn命令创建版本库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">svnadmin create <span class="hljs-regexp">/opt/</span>svn/kongwei<br></code></pre></td></tr></table></figure><p>创建完版本库后会在/opt/svn/kongwei/conf目录 建立默认配置文件，包括svnserve.conf、passwd、authz 配置相关用户和权限。</p><p>使用命令svnserve启动服务</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">svnserve -d -r 目录 <span class="hljs-comment">--listen-port 端口号</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>-r:</strong> 配置方式决定了版本库访问方式。</p></li><li><p><strong>–listen-port:</strong> 指定SVN监听端口，不加此参数，<code>SVN默认监听3690</code></p></li><li><p>由于-r 配置方式的不一样，SVN启动就可以有两种不同的访问方式</p></li><li><p>方式一：-r直接指定到版本库(称之为<code>单库svnserve方式</code>)</p></li><li><p>```<br>svnserve -d -r /opt/svn/kongwei</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>- 在这种情况下，一个svnserve只能为一个版本库工作。<br><br>- authz配置文件中对版本库权限的配置应这样写：<br><br>- ```<br>  [groups]<br>  <span class="hljs-attribute">admin</span>=user1<br>  <span class="hljs-attribute">dev</span>=user2<br>  [/]<br>  @<span class="hljs-attribute">admin</span>=rw<br>  <span class="hljs-attribute">user2</span>=r<br></code></pre></td></tr></table></figure></li><li><p>使用类似这样的URL：svn://192.168.0.1/　即可访问runoob版本库</p></li><li><p>方式二：指定到版本库的上级目录(称之为<code>多库svnserve方式</code>)</p></li><li><p>```<br>svnserve -d -r /opt/svn</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>- 这种情况，一个svnserve可以为多个版本库工作<br><br>- 配置文件：<br><br>- 进入/opt/svn/kongwei/conf目录 修改默认配置文件配置，包括svnserve.conf、passwd、authz 配置相关用户和权限。<br><br>- authz配置文件中对版本库权限的配置应这样写：<br><br>- ```<br>  [groups]<br>  <span class="hljs-attribute">admin</span>=user1<br>  <span class="hljs-attribute">dev</span>=user2<br>  [runoob:/]<br>  @<span class="hljs-attribute">admin</span>=rw<br>  <span class="hljs-attribute">user2</span>=r<br>  <br>  [kongwei01:/]<br>  @<span class="hljs-attribute">admin</span>=rw<br>  <span class="hljs-attribute">user2</span>=r<br></code></pre></td></tr></table></figure></li><li><p>如果此时你还用[/]，则表示所有库的根目录，同理，[/src]表示所有库的根目录下的src目录。</p></li><li><p>使用类似这样的URL：svn://192.168.0.1/kongwei即可访问kongwei版本库。</p></li></ul><h4 id="1-4、SVN客户端-Tortoisesvn的使用"><a href="#1-4、SVN客户端-Tortoisesvn的使用" class="headerlink" title="1.4、SVN客户端-Tortoisesvn的使用"></a>1.4、SVN客户端-Tortoisesvn的使用</h4><p><a href="https://www.runoob.com/svn/svn-life-cycle.html">生命周期</a>：</p><p>创建版本库–》检出–》更新–》执行变更–》复查变化–》修复错误–》解决冲突–》提交更改。</p><p>这里有几个概念要必须掌握：</p><p><code>checkout</code>—&gt;将SVN仓库的代码拷贝到本地，比如你现在参与一个团队项目，项目代码在你之前肯定已经写了很多了，你可以通过checkout项目代码，获得整个项目。</p><p><code>update</code>—&gt;在你写代码的过程中，同事很可能已经提交过代码到SVN服务器，而你本地项目显然没有同事新提交的代码，你可以通过update SVN获得SVN最新的代码。即更新本地代码与SVN服务器上最新的版本一致，只要在需要更新的文件夹上点击右键或者在文件下空白处点击右键，选择”SVN Update” (获取指定版本中的内容，点击右键执行SVN菜单中的“Update to reversion“)，就可以了。</p><p><code>commit</code>—&gt;当你完成一部分开发后，你可以通过commit提交代码到SVN服务器，这样别人就可以获得你写的代码，记得先update再commit。</p><h5 id="1-4-1、安装svn客户端"><a href="#1-4-1、安装svn客户端" class="headerlink" title="1.4.1、安装svn客户端"></a>1.4.1、安装svn客户端</h5><p><a href="https://tortoisesvn.net/downloads.zh.html">TortoiseSVN及其中文语言包的下载路径</a></p><p><img src="/2019/12/10/SVN/image-20191210171050514.png" alt="image-20191210171050514"></p><p>TortoiseSVN 是通过右键菜单与 Windows 资源管理器集成，没有自己的窗口界面</p><h5 id="1-4-2、安装TortoiseSVN中文语言包"><a href="#1-4-2、安装TortoiseSVN中文语言包" class="headerlink" title="1.4.2、安装TortoiseSVN中文语言包"></a>1.4.2、安装TortoiseSVN中文语言包</h5><p>运行LanguagePack_1.6.16.21511-x64-zh_CN.msi汉化</p><p>桌面空白的地方点击右键，svn，设置</p><p><img src="/2019/12/10/SVN/image-20191210092535433.png" alt="image-20191210092535433"></p><h5 id="1-4-3、文件导入"><a href="#1-4-3、文件导入" class="headerlink" title="1.4.3、文件导入"></a>1.4.3、文件导入</h5><p>进入欲导入文件的文件夹右键</p><p><img src="/2019/12/10/SVN/image-20191210200520012.png" alt="image-20191210200520012"></p><p>键入要访问的仓库地址：</p><p><img src="/2019/12/10/SVN/image-20191210200656780.png" alt="image-20191210200656780"></p><p>把文件添加到SVN库中进行管理：</p><p><img src="/2019/12/10/SVN/image-20191210200827528.png" alt="image-20191210200827528"></p><h5 id="1-4-4、检出文件"><a href="#1-4-4、检出文件" class="headerlink" title="1.4.4、检出文件"></a>1.4.4、检出文件</h5><p><code>checkout</code>—&gt;将SVN仓库的代码拷贝到本地，比如你现在参与一个团队项目，项目代码在你之前肯定已经写了很多了，你可以通过checkout项目代码，获得整个项目。</p><p>在某个文件夹位置，直接右键检出</p><p><img src="/2019/12/10/SVN/image-20191210173332323.png" alt="image-20191210173332323"></p><p><img src="/2019/12/10/SVN/image-20191210173447183.png" alt="image-20191210173447183"></p><p><img src="/2019/12/10/SVN/image-20191210093213531.png" alt="image-20191210173537683"></p><p>执行完上述操作以后demo仓库里的内容就被下载到了user1中。</p><p>注意：**.svn**这个隐藏目录记录着两项关键的信息: 工作文件的基准版本和一个本地副本最后更新的时间戳。千万不要手工修改或删除这个 .svn隐藏目录和里面的文件！！！ </p><p>否则将会导致你本地的工作拷贝 （静态视图）被破坏，无法再进行操作。</p><h5 id="1-4-5、创建新文件"><a href="#1-4-5、创建新文件" class="headerlink" title="1.4.5、创建新文件"></a>1.4.5、创建新文件</h5><p>新建一个txt文件，“新建文本文档.txt”</p><p>我们利用svn把 ”新建文本文档.txt “ 添加到版本控制</p><p>先要标记文件状态：</p><p><img src="/2019/12/10/SVN/image-20191210174443095.png" alt="image-20191210174443095"></p><p>添加完毕后</p><p><img src="/2019/12/10/SVN/image-20191210192304365.png" alt="image-20191210192304365"></p><p>利用svn Commit上传到服务器</p><p><img src="/2019/12/10/SVN/image-20191210192450630.png" alt="image-20191210192450630"></p><p><img src="/2019/12/10/SVN/image-20191210192622829.png" alt="image-20191210192622829"></p><h5 id="1-4-6、修改-“新建文本文档-txt文件”"><a href="#1-4-6、修改-“新建文本文档-txt文件”" class="headerlink" title="1.4.6、修改  “新建文本文档.txt文件”"></a>1.4.6、修改  “新建文本文档.txt文件”</h5><p>在user2中利用上面的知识，创建仓库检出文件。这样，user2的本地仓库中也有 “新建文本文档.txt文件”了。</p><p><img src="/2019/12/10/SVN/image-20191210193009385.png" alt="image-20191210193009385"></p><p>我们在User2中修改 “新建文本文档.txt文件”</p><p>这时我们发现 user2中的a.txt 文件的图标发生了变化：</p><p><img src="/2019/12/10/SVN/image-20191210193217711.png" alt="image-20191210193217711"></p><p>我们在user2再执行commit操作：</p><p><img src="/2019/12/10/SVN/image-20191210193442560.png" alt="image-20191210193442560"></p><p>我们在user1执行update操作：</p><p><img src="/2019/12/10/SVN/image-20191210193730368.png" alt="image-20191210193730368"></p><p>我们可以在user1文件夹看到修改后的   ”新建文本文档.txt“   文件了。</p><p><img src="/2019/12/10/SVN/image-20191210193848021.png" alt="image-20191210193848021"></p><h5 id="1-4-7、删除文件"><a href="#1-4-7、删除文件" class="headerlink" title="1.4.7、删除文件"></a>1.4.7、删除文件</h5><p>不仅仅是本地删除文件，而是让服务器上的文件同步删除。</p><p>我们先把user1 中的   ”新建文本文档.txt“   删除，然后执行commit操作。</p><p><img src="/2019/12/10/SVN/image-20191210194238244.png" alt="image-20191210194238244"></p><p>注意操作状态是<strong>missing</strong>，和新增一样我们需要<strong>修改它的状态</strong></p><p><img src="/2019/12/10/SVN/image-20191210194426104.png" alt="image-20191210194426104"></p><p><img src="/2019/12/10/SVN/image-20191210194714364.png" alt="image-20191210194714364"></p><p>然后再进行确认提交。</p><p>此时我们在回到user2中更新项目：</p><p><img src="/2019/12/10/SVN/image-20191210194946765.png" alt="image-20191210194946765"></p><p>”新建文本文档.txt“    文件一同被删除。</p><h5 id="1-4-8、恢复被删除的文件"><a href="#1-4-8、恢复被删除的文件" class="headerlink" title="1.4.8、恢复被删除的文件"></a>1.4.8、恢复被删除的文件</h5><p>使用版本控制工具，我们可以轻易的恢复被误删的文件</p><p>在User1 中选择<strong>更新至版本</strong>…</p><p><img src="/2019/12/10/SVN/image-20191210195258450.png" alt="image-20191210195258450"></p><p>如果我们记不清版本，可以通过<strong>日志进行查询</strong>，找到需要恢复历史版本：</p><p><img src="/2019/12/10/SVN/image-20191210195513070.png" alt="image-20191210195513070"></p><p><img src="/2019/12/10/SVN/image-20191210195723374.png" alt="image-20191210195723374"></p><h5 id="1-4-9、分支"><a href="#1-4-9、分支" class="headerlink" title="1.4.9、分支"></a>1.4.9、分支</h5><p>项目中为何要创建分支，及合并？</p><p>比如我现在项目所有的文件放在主干上(trunk)中，由于需求的变更，需要增加新的需求，但是我们主干上还要继续往下开发，在此我们可以新建一个分支，来做增加新的需求那一块，主干上继续开发，等分支上代码没有问题的时候，再合并到主干上来。</p><p>创建分支的最大的目的就是跟主线进行并行开发时候不影响主线的开发。</p><p><strong>如何操作？</strong></p><p>假如我本地新建一个文件夹SVNDemo下有2个文件夹trunk(存放主干上的代码)和branch(存放分支上的代码)，如下所示：</p><p><img src="/2019/12/10/SVN/image-20191210210727941.png" alt="image-20191210210727941"></p><p><strong>1、先提取主干代码到trunk文件夹</strong></p><p><img src="/2019/12/10/SVN/image-20191210211058403.png" alt="image-20191210211058403"></p><p><img src="/2019/12/10/SVN/image-20191210211203767.png" alt="image-20191210211203767"></p><p><strong>2、新建分支</strong></p><p> 从trunk（主干上）创建分支(branch)步骤如下：</p><p>右键trunk –&gt; branch/Tag 如下图：</p><p><img src="/2019/12/10/SVN/image-20191210211522739.png" alt="image-20191210211522739"></p><p>弹出对话框，填入新分支路径：</p><p><img src="/2019/12/10/SVN/image-20191210211712652.png" alt="image-20191210211712652"></p><p>确认：</p><p><img src="/2019/12/10/SVN/image-20191210211828529.png" alt="image-20191210211828529"></p><p>查看：</p><p>在VisualSVN Serval服务器上新增NewBranch，是从如上服务器Ant_Nest上的文件拷贝一份的</p><p><img src="/2019/12/10/SVN/image-20191210212044298.png" alt="image-20191210212044298"></p><p><strong>3、现在我们可以再来看看本地branch文件夹了，我现在直接进入branch文件下</strong></p><p>右键 –&gt; Chenckout下，就可以把NewBranch下的所有文件提取出来了，如下所示：</p><p><img src="/2019/12/10/SVN/image-20191210212502331.png" alt="image-20191210212502331"></p><p><img src="/2019/12/10/SVN/image-20191210212635660.png" alt="image-20191210212635660"></p><p>对本地branch文件夹 右键–&gt; update即可，就可以更新到分支代码</p><p><strong>4、合并分支到主干</strong></p><p>比如我现在对branch分支上新增    “新建文本文档.txt”   文件，然后提交上去，如下所示：</p><p><img src="/2019/12/10/SVN/image-20191210213302464.png" alt="image-20191210213302464"></p><p>我现在想把分支上的代码   “新建文本文档.txt”   合并到主干上trunk，现在要怎么合并呢？步骤如下：</p><p>回到我们刚刚的主干（trunk）文件夹下，鼠标右键该文件夹 –&gt; TortoiseSVN –&gt; Merge 如下图所示：</p><p><img src="/2019/12/10/SVN/image-20191210213501736.png" alt="image-20191210213501736"></p><p>弹窗：</p><p><img src="/2019/12/10/SVN/image-20191210213814603.png" alt="image-20191210213814603"></p><p><img src="/2019/12/10/SVN/image-20191210214037444.png" alt="image-20191210214037444"></p><p><img src="/2019/12/10/SVN/image-20191210214129993.png" alt="image-20191210214129993"></p><p>因为服务端的<strong>历史创建主干和分支不当，二者产生上下级关系</strong>，在修改分支内容并提交后，如果没有更新主干就进行合并操作就会产生如下的树冲突：</p><p><img src="/2019/12/10/SVN/image-20191210214902189.png" alt="image-20191210214902189"></p><p><img src="/2019/12/10/SVN/image-20191210215345663.png" alt="image-20191210215345663"></p><p><strong>6、合并主干到分支</strong></p><p>如果主干上有一些更新，比如说jar包更新等等，那么这些要更新到分支上去，如何操作呢？比如我现在在主干上新建一个  ”新建文本文档(2).txt“  文件，比如如下：</p><p>trunk添加并提交文件    ”新建文本文档(2).txt“  </p><p><img src="/2019/12/10/SVN/image-20191210215614630.png" alt="image-20191210215614630"></p><p>当前分支目录内容如下：</p><p><img src="/2019/12/10/SVN/image-20191210215853622.png" alt="image-20191210215853622"></p><p>在分支点击branch –&gt; 右键TortoiseSVN –&gt; Merge 如下图所示：</p><p><img src="/2019/12/10/SVN/image-20191210220049308.png" alt="image-20191210220049308"></p><p><img src="/2019/12/10/SVN/image-20191210220527393.png" alt="image-20191210220527393"></p><h5 id="1-4-10、解决冲突"><a href="#1-4-10、解决冲突" class="headerlink" title="1.4.10、解决冲突"></a>1.4.10、解决冲突</h5><p>为什么会产生冲突代码呢？原因很简单就是因为不同的人，同时修改了同一个文件的同一个地方，这时候，他提交了，我没有提交，我就提交不了，这个时候我们要进行先更新，然后在进行提交即可，那如果产生冲突，会生成如上3个文件。 </p><p>案例：</p><p>产生冲突SVNDemo文件夹下创建user1和user2文件夹，两个文件夹<strong>检出（checkout）</strong>同一项目，各自修改同一文件的内容，各自提交前都不更新内容：</p><p><img src="/2019/12/10/SVN/image-20191210223120590.png" alt="image-20191210223120590"></p><p>user1先提交：</p><p><img src="/2019/12/10/SVN/image-20191210223416362.png" alt="image-20191210223416362"></p><p>user2在提交：产生冲突</p><p><img src="/2019/12/10/SVN/image-20191210223513139.png" alt="image-20191210223513139"></p><p><img src="/2019/12/10/SVN/image-20191210224145486.png" alt="image-20191210224145486"></p><p><img src="/2019/12/10/SVN/image-20191210224550424.png" alt="image-20191210224550424"></p><p>对于每个冲突的文件Subversion在你的目录下放置了三个文件内容如下：<strong>（后缀.r14和.r15为版本区别）</strong></p><p><img src="/2019/12/10/SVN/image-20191210225655087.png" alt="image-20191210225655087"></p><p>解决方案：</p><p>1、使用revert(回滚)操作，该操作表示用户放弃自己的更新代码，然后直接提交，这个时候你的代码就会使服务器上最新的代码，即A用户提交的新代码，你的代码不会被提交，如下所示：</p><p><img src="/2019/12/10/SVN/image-20191210230932749.png" alt="image-20191210230932749"></p><p><img src="/2019/12/10/SVN/image-20191210231033429.png" alt="image-20191210231033429"></p><p>2、选择文件-&gt;右键Editconficts：这种方法需要<strong>冲突双方经过协商</strong>之后将代码更改统一之后再提交。不仅解决了冲突而且还保证了代码是正确的，因为只有一方的代码被提交：</p><p><img src="/2019/12/10/SVN/image-20191210232141891.png" alt="image-20191210232141891"></p><p><img src="/2019/12/10/SVN/image-20191210232352963.png" alt="image-20191210232352963"></p><p>状态由<strong>冲突</strong>变成<strong>修改：</strong></p><p><img src="/2019/12/10/SVN/image-20191210232538468.png" alt="image-20191210232538468"></p><h5 id="1-4-11、小结"><a href="#1-4-11、小结" class="headerlink" title="1.4.11、小结"></a>1.4.11、小结</h5><p>SVN简单使用: SVN基本操作</p><p>工作中最常用的 SVN 操作</p><ul><li>​    检出 – SVN Checkout : 第一次从 SVN 服务器下载版本库数据</li><li>​    更新 – SVN Update : 客户端从 SVN 服务器下载最新的版本</li><li>​    提交 – SVN Commit : 客户端将改劢上传到 SVN 服务器</li><li>​    增加 – Add : 将新文件戒文件夹纳入 SVN 控制之下</li><li>​    还原 – Revert : 放弃本地修改, 将数据恢复到之前的版本状态</li></ul><h3 id="2、Eclipse中使用SVN"><a href="#2、Eclipse中使用SVN" class="headerlink" title="2、Eclipse中使用SVN"></a>2、Eclipse中使用SVN</h3><p>在Eclipse中通过插件使用SVN</p><p><strong>插件安装：</strong></p><p>把文件添加到Eclipse的dropins文件夹中，重启Eclipse即可</p><p><img src="/2019/12/10/SVN/image-20191210095204957.png" alt="image-20191210095204957"></p><p><strong>在线安装：</strong></p><p>也可使用在线安装的方式为Eclipse添加SVN插件</p><p>打开Eclipse-&gt;Help-&gt;Install New Software…</p><p><img src="/2019/12/10/SVN/image-20191210095441246.png" alt="image-20191210095441246"></p><p>其中<strong><a href="http://subclipse.tigris.org/update_1.10.x">http://subclipse.tigris.org/update_1.10.x</a></strong>是最新版本的SVN插件的下载站点【subclipse是Eclipse的SVN插件】。</p><p><img src="/2019/12/10/SVN/image-20191210095540977.png" alt="image-20191210095540977"></p><p>下一步</p><p><img src="/2019/12/10/SVN/image-20191210095618932.png" alt="image-20191210095618932"></p><p>下一步 选择同意安装</p><p><img src="/2019/12/10/SVN/image-20191210095746998.png" alt="image-20191210095746998"></p><p>点击【Finish】按钮开始安装SVN插件</p><p>安装过程中弹出警告框，不用理会，直接点击【OK】按钮继续安装</p><p>安装完成之后需要重启Eclipse，点击【Yes】按钮重启Eclipse即可。</p><p><strong>查看安装好的SVN插件</strong></p><p><img src="/2019/12/10/SVN/image-20191210100828986.png" alt="image-20191210100828986"></p><h4 id="2-1、项目添加到SVN中"><a href="#2-1、项目添加到SVN中" class="headerlink" title="2.1、项目添加到SVN中"></a>2.1、项目添加到SVN中</h4><h5 id="2-1-1、新建项目，如下操作："><a href="#2-1-1、新建项目，如下操作：" class="headerlink" title="2.1.1、新建项目，如下操作："></a>2.1.1、新建项目，如下操作：</h5><p><img src="/2019/12/10/SVN/image-20191210101011113.png" alt="image-20191210101011113"></p><h5 id="2-1-2、选择SVN"><a href="#2-1-2、选择SVN" class="headerlink" title="2.1.2、选择SVN"></a>2.1.2、选择SVN</h5><p><img src="/2019/12/10/SVN/image-20191210101134344.png" alt="image-20191210101134344"></p><h5 id="2-1-3、选择SVN仓库地址的位置："><a href="#2-1-3、选择SVN仓库地址的位置：" class="headerlink" title="2.1.3、选择SVN仓库地址的位置："></a>2.1.3、选择SVN仓库地址的位置：</h5><p><img src="/2019/12/10/SVN/image-20191210101228328.png" alt="image-20191210101228328"></p><p><img src="/2019/12/10/SVN/image-20191210101303735.png" alt="image-20191210101303735"></p><p><img src="/2019/12/10/SVN/image-20191210101339503.png" alt="image-20191210101339503"></p><p>输入用户名密码，确定导入完成。</p><h4 id="2-2、提交代码到SVN项目"><a href="#2-2、提交代码到SVN项目" class="headerlink" title="2.2、提交代码到SVN项目"></a>2.2、提交代码到SVN项目</h4><p>现在我们只是把项目和SVN进行了关联，所有的项目文件并没有上传到服务器。</p><p><img src="/2019/12/10/SVN/image-20191210101503691.png" alt="image-20191210101503691"></p><p>忽略.class文件和classes文件夹不提交</p><p><img src="/2019/12/10/SVN/image-20191210101537605.png" alt="image-20191210101537605"></p><p>提交项目，可以看到classes文件并不在其</p><p><img src="/2019/12/10/SVN/image-20191210101634177.png" alt="image-20191210101634177"></p><p>提交之后，可以到项目图标已经发生了变化</p><p><img src="/2019/12/10/SVN/image-20191210101739951.png" alt="image-20191210101739951"></p><h4 id="2-3、把SVN项目检出到Eclipse"><a href="#2-3、把SVN项目检出到Eclipse" class="headerlink" title="2.3、把SVN项目检出到Eclipse"></a>2.3、把SVN项目检出到Eclipse</h4><p>我们新到公司，往往已经有开发好了的项目，我们要加入，就需要用<strong>项目的检出的方式来新建项目</strong>。<br>操作如下：在创建项目的时候，选择从svn上检出项目</p><p><img src="/2019/12/10/SVN/image-20191210102113334.png" alt="image-20191210102113334"></p><p>现有资源库的位置</p><p><img src="/2019/12/10/SVN/image-20191210102145794.png" alt="image-20191210102145794"></p><p>选择之前提交的项目路径</p><p><img src="/2019/12/10/SVN/image-20191210102230164.png" alt="image-20191210102230164"></p><p>指定项目名：</p><p><img src="/2019/12/10/SVN/image-20191210102303893.png" alt="image-20191210102303893"></p><p>检出项目到Eclipse中</p><p><img src="/2019/12/10/SVN/image-20191210102340569.png" alt="image-20191210102340569"></p><h4 id="2-4、小结"><a href="#2-4、小结" class="headerlink" title="2.4、小结"></a>2.4、小结</h4><p>了解项目管理项目构建和版本控制这些工程软件</p><p>理解 SVN 的基本功能, 掌握 Tortoise SVN 的使用，掌握Eclipse的SVN插件使用</p><p>在企业中应用：项目经理会发一个word文档</p><p>​    1、 svn的仓库的地址</p><p>​    2、 使用svn的用户名和密码</p><p>​    3、 把svn上的项目导入到Elicpse中</p><p>​    4、 做自己的模块，把自己写的东西上传到svn上</p><p>​    5、 版本的对比，合并版本</p><h3 id="3、IDEA中使用SVN"><a href="#3、IDEA中使用SVN" class="headerlink" title="3、IDEA中使用SVN"></a>3、IDEA中使用SVN</h3><p>确保已经建立了SVN服务和安装了SVN客户端，然后做如下配置：</p><p><img src="/2019/12/10/SVN/image-20191210205848204.png" alt="image-20191210205848204"></p>]]></content>
    
    
    
    <tags>
      
      <tag>版本控制</tag>
      
      <tag>SVN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2019/11/28/SpringMVC/"/>
    <url>/2019/11/28/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h3 id="1、SpringMVC概述"><a href="#1、SpringMVC概述" class="headerlink" title="1、SpringMVC概述"></a>1、SpringMVC概述</h3><h4 id="1-1、为什么引入SpringMVC？"><a href="#1-1、为什么引入SpringMVC？" class="headerlink" title="1.1、为什么引入SpringMVC？"></a>1.1、为什么引入SpringMVC？</h4><h5 id="1-1-1、传统MVC模式的问题"><a href="#1-1-1、传统MVC模式的问题" class="headerlink" title="1.1.1、传统MVC模式的问题"></a>1.1.1、传统MVC模式的问题</h5><p><strong>1、回顾JSP中所讲的MVC</strong></p><p>数据模型（Model）：负责封装应用的状态，并实现应用的功能。</p><p>视图展现（View）：界面，视图从模型获得要展示的数据，然后用自己的方式展现给用户。</p><p>控制器（Controller）：用来控制应用程序的流程和处理视图所发出的请求。当控制器接收到用户的请求后，会将用户的数据和模型的更新相映射，也就是调用模型来实现用户请求的功能；然后控制器会选择用于响应的视图，把模型更新后的数据展示给用户。</p><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_09-21-37.png"></p><p>最典型的MVC：JSP(view)+Servlet(controller)+JavaBean(dao model)模式</p><p><strong>2、 Jsp + Servlet + JavaBean存在问题：</strong></p><ol><li><p>web.xml 很臃肿</p></li><li><p>Servlet：</p></li></ol><p>接收参数：接收参数过程非常麻烦</p><p>调用业务逻辑：service</p><p>跳转页面：实现forward和redirect不方便</p><ol start="3"><li>Servlet职责不单一：（文件上传下载、令牌、字符编码等等）</li></ol><p>Servlet应只做核心功能，其他的功能交给框架做</p><h5 id="1-1-2、解决方案"><a href="#1-1-2、解决方案" class="headerlink" title="1.1.2、解决方案"></a>1.1.2、解决方案</h5><p>针对以上问题，我们现在选择SpringMVC 框架解决。  </p><h4 id="1-2、SpringMVC是什么？"><a href="#1-2、SpringMVC是什么？" class="headerlink" title="1.2、SpringMVC是什么？"></a>1.2、SpringMVC是什么？</h4><h5 id="1-2-1、基本概念"><a href="#1-2-1、基本概念" class="headerlink" title="1.2.1、基本概念"></a>1.2.1、基本概念</h5><p>SpringMVC是一个基于MVC模式的WEB表现层框架，它解决WEB开发中常见的问题(参数接收、文件上传/下载、表单验证、国际化等等)，使用非常简单，SpringMVC作为Spring中的一个模块,可以与Spring无缝集成。</p><p>目前很多公司都使用SpringMVC，90%的招聘单位要求熟悉使用SpringMVC。</p><p>它是一个典型的mvc构架，它是<code>一个纯正的servlet系统</code>，这也是它相比其他MVC框架所具有的优势。</p><h5 id="1-2-2、核心前端控制器"><a href="#1-2-2、核心前端控制器" class="headerlink" title="1.2.2、核心前端控制器"></a>1.2.2、核心前端控制器</h5><p>顾名思义核心控制器用于Web层核心功能的处理以及在所有控制器执行之前，所有的WebMvc框架都采用了这种方式，<code>在SpringMVC中使用的是DispatcherServlet为核心控制器</code>。</p><p>DispatcherServlet核心控制器会拦截匹配的请求，把拦截下来的请求，依据相应的规则【映射（url=控制器）】分发到目标Controller来处理。</p><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_09-30-21.png"></p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_09-30-58.png" style="zoom:80%;"><h3 id="2、SpringMVC入门案例"><a href="#2、SpringMVC入门案例" class="headerlink" title="2、SpringMVC入门案例"></a>2、SpringMVC入门案例</h3><h4 id="2-1、实现步骤"><a href="#2-1、实现步骤" class="headerlink" title="2.1、实现步骤"></a>2.1、实现步骤</h4><p>我们要用SpringMVC，需要先准备些什么事:</p><ol><li><p>使用SpringMVC必须先保证，你的项目拥有Spring的运行环境。</p></li><li><p>在添加SpringMVC相关jar包</p><ul><li>spring-webmvc-4.1.2.RELEASE.jar SpringMVC的jar文件。</li><li>spring-web-4.1.2.RELEASE.jar   Spring对Web项目运行的支持。</li></ul></li><li><p>在web.xml，配置核心控制器</p><p>SpringMVC框架的心脏就是核心控制器，负责所有请求的公共功能,他和我们之前的普通Servlet一样需要在web.xml中配置&lt;servlet-mapping&gt;</p></li><li><p>新建Controller控制器，处理请求，进行响应</p><p>SpringMVC中的控制器有一定规范，要求实现Controller接口或子接口</p></li><li><p>配置我们的Controller控制器</p><p>SpringMVC是基于Spring，Spring中的核心就是Ioc容器。SpringMVC中的控制器也是一个一个&lt;bean&gt;，需要在applicationContext.xml中进行配置</p></li><li><p>测试访问</p></li></ol><h4 id="2-2、具体实现"><a href="#2-2、具体实现" class="headerlink" title="2.2、具体实现"></a>2.2、具体实现</h4><h5 id="2-2-1、创建Web工程"><a href="#2-2-1、创建Web工程" class="headerlink" title="2.2.1、创建Web工程"></a>2.2.1、创建Web工程</h5><h5 id="2-2-2、导入Jar包"><a href="#2-2-2、导入Jar包" class="headerlink" title="2.2.2、导入Jar包"></a>2.2.2、导入Jar包</h5><p>从资料中导入springMVC独立运行的jar包</p><p>不要使用spring 3.x的jar和4.x的jar文件混用，危险的很</p><ul><li><p>   com.springsource.org.apache.commons.logging-1.1.1.jar</p></li><li><p>   spring-beans-4.1.2.RELEASE.jar</p></li><li><p>   spring-context-4.1.2.RELEASE.jar</p></li><li><p>   spring-core-4.1.2.RELEASE.jar</p></li><li><p>   spring-expression-4.1.2.RELEASE.jar</p></li><li><p>   spring-aop-4.1.2.RELEASE.jar</p></li><li><p>   spring orm、jdbc、tx相关jar根据项目使用自行添加;</p></li></ul><p>加入相关SpringMVC相关jar包。</p><ul><li><p>   spring-web-4.1.2.RELEASE.jar      spring 对web项目的支持。</p></li><li><p>   spring-webmvc-4.1.2.RELEASE.jar     SpringMVC核心包。</p></li></ul><h5 id="2-3-3、加入配置文件"><a href="#2-3-3、加入配置文件" class="headerlink" title="2.3.3、加入配置文件"></a>2.3.3、加入配置文件</h5><p><strong>1、创建ApplicationContext.xml</strong></p><p>SpringMVC本身就是Spring的子项目，对Spring兼容性很好，不需要做很多配置。</p><p>这里只配置一个Controller扫描就可以了，让Spring对页面控制层Controller进行管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置controller包扫描器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;cn.kongwei_liao.springmvc.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2、配置前端控制器</strong></p><p>Webmvc框架的心脏就是<strong>核心控制器</strong>，负责所有请求的公共功能，然后在分发给具体的控制器（我们编写的控制器），完成业务逻辑，响应视图。</p><p>在web.xml中配置SpringMVC的<strong>前端控制器DispatcherServlet</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置sringmvc前端控制器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-comment">&lt;!--若不止一个&lt;init-param&gt;标签，第一个优先--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">1. /* :拦截所有.包括静态资源 (不建议使用)</span><br><span class="hljs-comment">2. .action .do : 拦截以action和do结尾的请求 (主要用于后台系统.)</span><br><span class="hljs-comment">3. / :拦截所有,但是不包含jsp...</span><br><span class="hljs-comment">其他静态资源如:.css,.js等       需要用例外的配置进行放行 (主要用于前台系统)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-3-4、创建MyController"><a href="#2-3-4、创建MyController" class="headerlink" title="2.3.4、创建MyController"></a>2.3.4、创建MyController</h5><p>SpringMVC中的控制器与以前我们以前学习的servlet作用一样，处理用户请求，调用业务逻辑，返回结果视图。</p><p>SpringMVC中的控制器有一定规范，要么实现接口，要么使用POJO对象与注解配合使用。</p><table><thead><tr><th>规范要求</th><th>说明</th></tr></thead><tbody><tr><td><code>实现Controller接口或子接口。</code>  注意：子接口很多已经过时了。</td><td>核心方法为handleRequest(req,resp)，处理用户请求</td></tr><tr><td>普通的类(常用的哦)</td><td>使用一个普通的类作为我们的控制器，每一个方法就是一个处理器，这种方式需要配合注解标签才能使用。</td></tr></tbody></table><p>这里作为演示案例：</p><p>MyController需要<code>实现Controller接口</code>，<code>重写handleRquest方法</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-5、创建ModelAndView"><a href="#2-3-5、创建ModelAndView" class="headerlink" title="2.3.5、创建ModelAndView"></a>2.3.5、创建ModelAndView</h5><p>handleRequest方法的两个参数与我们以前的Servlet中service方法一样，request和response对象，我们可以使用这个两个对象完成一次请求的所有工作，比如你可以使用request接受参数，或者使用response重定向等等，<strong>注意该方法还有一个返回值ModelAndView</strong>。</p><p>ModelAndView是SpringMVC控制器中特有一个对象，<strong>描述一次请求响应的 数据（Model）和 视图（View）</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public ModelAndView handle<span class="hljs-constructor">Request(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span> throws Exception &#123;<br><span class="hljs-comment">// 处理请求： 接收参数  业务调用  页面跳转</span><br><br><span class="hljs-comment">// 创建 ModelAndView 对象</span><br>ModelAndView mav = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ModelAndView()</span>;<br><br><span class="hljs-comment">// 添加模型数据</span><br>mav.add<span class="hljs-constructor">Object(<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-string">&quot;&lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&quot;</span>)</span>;<br><br><span class="hljs-comment">// 设置视图路径</span><br>mav.set<span class="hljs-constructor">ViewName(<span class="hljs-string">&quot;index.jsp&quot;</span>)</span>;<br><br>return mav;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-6、配置我们的控制器"><a href="#2-3-6、配置我们的控制器" class="headerlink" title="2.3.6、配置我们的控制器"></a>2.3.6、配置我们的控制器</h5><p>**name: ** /hello.do 为<code>控制器的访问路径</code></p><p><strong>class:</strong>  cn.kongwei_liao.springmvc.controller.MyController<code>控制器类的全限定名</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;/index.do&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;cn.kongwei_liao.springmvc.controller.MyController&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="2-3-7、JSP页面"><a href="#2-3-7、JSP页面" class="headerlink" title="2.3.7、JSP页面"></a>2.3.7、JSP页面</h5><p>和我们之前的jsp页面一样，里面接收一下Controller 传递过来的数据</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">$</span><span class="hljs-template-variable">&#123;message&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="2-3-8、启动项目"><a href="#2-3-8、启动项目" class="headerlink" title="2.3.8、启动项目"></a>2.3.8、启动项目</h5><ol><li>启动Tomcat报错（？？？是否是Tomcat报错存疑）</li></ol><p>错误信息如下：</p><p><img src="/2019/11/28/SpringMVC/clip_image002.jpg" alt="img"></p><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_15-40-56.png"></p><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_15-31-47.png"></p><p>没找到<code>/WEB-INF/springmvc-servlet.xml</code>文件OR没找到<code>/WEB-INF/DispatcherServlet-servlet.xml</code>文件，因为在启动Tomcat服务器的时候会初始化SpringMVC中的DispatcherServlet，而这个DispatcherServlet会根据配置文件初始化Spring容器，默认配置文件路径为：**/WEB-INF/&lt;servlet-name&gt;-servlet.xml**（？？？解释存疑）</p><p><img src="/2019/11/28/SpringMVC/clip_image004.jpg" alt="img"></p><ol start="2"><li>解决问题方式：</li></ol><p>1.可以把我们的配置文件更名为DispatcherServlet-servlet.xml，然后拷贝到WEB-INF中。</p><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_15-43-48.png" alt="img"></p><p>2.一般spring的配置文件都在放在src中或者Resources文件夹中，我们可以通过以下配置告诉SpringMVC我们的配置文件路径。<strong>（常见做法）</strong></p><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_15-48-33.png" alt="img"></p><h5 id="2-3-9、测试"><a href="#2-3-9、测试" class="headerlink" title="2.3.9、测试"></a>2.3.9、测试</h5><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_15-50-54.png"></p><h4 id="2-4、小结"><a href="#2-4、小结" class="headerlink" title="2.4、小结"></a>2.4、小结</h4><p>以上我们，实现了一个使用SpringMVC请求响应过程。</p><p>我们自己<strong>创建了MyController用于接收请求并处理</strong>，通过<strong>ModelAndView传递了数据到我们的index.jsp</strong>，</p><p>这个<strong>jsp将视图页面响应给用户</strong>。</p><p>另外，需要注意的事：配置文件时一定要细心</p><p>我们在web.xml 中配置了前端控制器，并指定了Spring的applicationContext.xml 配置文件的位置。</p><p><strong>在applicationContext.xml，通过&lt;bean&gt;标签，配置了我们的Controller。</strong></p><h3 id="3、SpringMVC执行流程"><a href="#3、SpringMVC执行流程" class="headerlink" title="3、SpringMVC执行流程"></a>3、SpringMVC执行流程</h3><h4 id="3-1、引入"><a href="#3-1、引入" class="headerlink" title="3.1、引入"></a>3.1、引入</h4><p>刚刚我们实现了一个使用SpringMVC请求响应过程。那为什么可以这样用呢？SpringMVC的实现原理又是怎样的呢？我们需要分析一下springMVC的架构图</p><h4 id="3-2、SpringMVC框架结构"><a href="#3-2、SpringMVC框架结构" class="headerlink" title="3.2、SpringMVC框架结构***"></a>3.2、SpringMVC框架结构***</h4><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_10-29-33.png"></p><p><code>控制器(Controller) = 处理器(Handler)</code></p><h4 id="3-3、SpringMVC工作流程"><a href="#3-3、SpringMVC工作流程" class="headerlink" title="3.3、SpringMVC工作流程"></a>3.3、SpringMVC工作流程</h4><h5 id="3-3-1、详细描述"><a href="#3-3-1、详细描述" class="headerlink" title="3.3.1、详细描述"></a>3.3.1、详细描述</h5><p>1.用户发送请求至<code>前端控制器DispatcherServlet</code></p><p>2.DispatcherServlet收到请求调用<code>HandlerMapping处理器映射器</code>。</p><p>3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p><p>4.DispatcherServlet通过<code>HandlerAdapter处理器适配器</code>调用处理器</p><p>5.执行处理器(Controller，也叫后端控制器)。</p><p>6.Controller执行完成返回<code>ModelAndView</code></p><p>7.HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</p><p>8.DispatcherServlet将ModelAndView传给<code>ViewReslover视图解析器</code></p><p>9.ViewReslover解析后返回具体View</p><p>10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p><p>11.DispatcherServlet响应用户。</p><h5 id="3-3-2、简易版本–面试回答"><a href="#3-3-2、简易版本–面试回答" class="headerlink" title="3.3.2、简易版本–面试回答"></a>3.3.2、简易版本–面试回答</h5><ol><li><p>客户端请求提交到DispatcherServlet</p></li><li><p>由DispatcherServlet控制器查询HandlerMapping，找到处理请求的Controller。</p></li><li><p>DispatcherServlet将请求转发给到Controller。</p></li><li><p>Controller调用业务逻辑处理后，返回ModelAndView</p></li><li><p>DispatcherServlet查询ViewResolver视图解析器，找到ModelAndView指定的视图。</p></li><li><p>视图负责将填充了数据的结果响应到客户端。</p></li></ol><h4 id="3-4、SpringMVC核心对象"><a href="#3-4、SpringMVC核心对象" class="headerlink" title="3.4、SpringMVC核心对象"></a>3.4、SpringMVC核心对象</h4><h5 id="3-4-1、DispatcherServlet：前端控制器"><a href="#3-4-1、DispatcherServlet：前端控制器" class="headerlink" title="3.4.1、DispatcherServlet：前端控制器"></a>3.4.1、DispatcherServlet：前端控制器</h5><p>用户请求到达前端控制器，它就相当于mvc模式中的C，<code>DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求</code>，DispatcherServlet的存在降低了组件之间的耦合性。</p><h5 id="3-4-2、HandlerMapping：处理器映射器"><a href="#3-4-2、HandlerMapping：处理器映射器" class="headerlink" title="3.4.2、HandlerMapping：处理器映射器"></a>3.4.2、HandlerMapping：处理器映射器</h5><p><code>HandlerMapping负责根据用户请求url找到最合适的处理器Handler.</code><br>我们刚才是通过<strong>配置文件的方式</strong>：<br>处理器映射器通过&lt;bean name=”/xxx”&gt;注册的控制器。控制器需要实现Controller接口。<br>也可以通过<strong>注解的方式</strong>去实现，<br>等一下我们介绍完SpringMVC的核心对象后，会带着大家通过全注解的方式实现一个Controller。</p><h5 id="3-4-3、HandlerAdapter：处理器适配器"><a href="#3-4-3、HandlerAdapter：处理器适配器" class="headerlink" title="3.4.3、HandlerAdapter：处理器适配器"></a>3.4.3、HandlerAdapter：处理器适配器</h5><p>支持多种类型的处理器，如何执行我们的控制器（Controller有多种不同实现方式）。<br>SpringMVC的常用的处理器适配器有：<br><code>HttpRequestHandlerAdapter</code> 处理实现了<code>HttpRequestHandler接口</code>对应的处理器。<br><code>SimpleControllerHandlerAdapter</code> 处理实现了<code>Controller接口</code>对应的控制器。<br>说明：<br>直接配置处理器映射器和处理器适配器比较麻烦，SpringMVC 3.2以上会自动加载默认的映射器RequestMappingHandlerMapping和 默认的适配器RequestMappingHandlerAdapter。</p><h5 id="3-4-4、Handler：处理器"><a href="#3-4-4、Handler：处理器" class="headerlink" title="3.4.4、Handler：处理器"></a>3.4.4、Handler：处理器</h5><p><code>Handler是继DispatcherServlet前端控制器的后端控制器</code>，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。<br>我们刚才创建的 MyController 就是一个处理器。</p><h5 id="3-4-5、ViewResolver：视图解析器"><a href="#3-4-5、ViewResolver：视图解析器" class="headerlink" title="3.4.5、ViewResolver：视图解析器"></a>3.4.5、ViewResolver：视图解析器</h5><p>View Resolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。<br>视图解析器使用SpringMVC框架默认的<code>InternalResourceViewResolver</code>，这个视图解析器支持JSP视图解析。通常我们会配置前后缀来减少代码的重复。可以修改我们的入门案例来看一下：<br>在applicationContext.xml配置文件中配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置视图解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 指定视图的前缀 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 指定视图的后缀 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>逻辑视图名需要在Controller中返回ModelAndView指定</code>，比如逻辑视图名为hello，则最终返回的jsp视图地址是：<code>前缀+逻辑视图名+后缀</code>、即</p><p>“WEB-INF/jsp/hello.jsp”</p><h5 id="3-4-6、View：视图"><a href="#3-4-6、View：视图" class="headerlink" title="3.4.6、View：视图"></a>3.4.6、View：视图</h5><p>SpringMVC框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView等。目前我们最常用的视图就是jsp。</p><p>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p><h4 id="3-5、小结"><a href="#3-5、小结" class="headerlink" title="3.5、小结"></a>3.5、小结</h4><p>1、在SpringMVC 的六个核心组件中，DispatcherServlet前端控制器是整个流程控制的中心<br>2、一般我们称：处理器映射器、处理器适配器、视图解析器 为SpringMVC的三大组件。<br>3、需要用户开发的组件有处理器(Controller)、视图view</p><h3 id="4、Controller实现方式"><a href="#4、Controller实现方式" class="headerlink" title="4、Controller实现方式"></a>4、Controller实现方式</h3><h4 id="4-1、引入"><a href="#4-1、引入" class="headerlink" title="4.1、引入"></a>4.1、引入</h4><p>我们刚刚在介绍的SpringMVC的核心时有提到，处理器适配器可以执行的Controller其实是有不同的实现方式，在入门案例中我们也演示了通过实现Controller接口的方式。接下来我们在看看其他实现控制器的方式，并重点掌握也是Spring推荐使用的方式–全注解去实现自己的Controller。</p><h4 id="4-2、三种实现方式"><a href="#4-2、三种实现方式" class="headerlink" title="4.2、三种实现方式"></a>4.2、三种实现方式</h4><h5 id="4-2-1、实现Controller接口"><a href="#4-2-1、实现Controller接口" class="headerlink" title="4.2.1、实现Controller接口"></a>4.2.1、实现Controller接口</h5><p>就是我们刚才入门案例演示的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现Controller接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>System.out.println(<span class="hljs-keyword">this</span>.getClass());<br><span class="hljs-comment">//模型数据和视图对象</span><br>ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>modelAndView.setViewName(<span class="hljs-string">&quot;/WEB-INF/controller.jsp&quot;</span>);<br><span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;/controller01.do&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;cn.kongwei_liao.springmvc.controller.ControllerDemo1&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="4-2-2、实现HttpRequestHandler接口"><a href="#4-2-2、实现HttpRequestHandler接口" class="headerlink" title="4.2.2、实现HttpRequestHandler接口"></a>4.2.2、实现HttpRequestHandler接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现了HttpRequestHandler接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpRequestHandler</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>System.out.println(<span class="hljs-keyword">this</span>.getClass());<br>request.getRequestDispatcher(<span class="hljs-string">&quot;/WEB-INF/controller.jsp&quot;</span>).forward(request, response);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;/controller02.do&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;cn.itsource.springmvc.controller.ControllerDemo2&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><h5 id="4-2-3、普通类和注解（建议使用）"><a href="#4-2-3、普通类和注解（建议使用）" class="headerlink" title="4.2.3、普通类和注解（建议使用）***"></a>4.2.3、普通类和注解（建议使用）***</h5><p>SpringMVC中控制器建议使用注解方式，是官方推荐的，外面公司也是多使用此方式。<br>这种方式只要配置SpringMVC开启注解支持，然后在类上添加注解即可。</p><p>具体步骤如下：</p><p>第一步：SpringMVC开启支持注解</p><p>只要在 Spring 配置文件中添加如下标签即可实现：处理通过注解方式实现的控制器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 支持注解 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置controller包扫描器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;cn.ant_nest.springmvc.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>说明：<br>在Spring中一般采用<code>@RequestMapping</code>注解来完成映射关系，要想使@RequestMapping注解生效必须向上下文中注册<code>DefaultAnnotationHandlerMapping</code>和一个<code>AnnotationMethodHandlerAdapter</code>实例，这两个实例分别在类级别和方法级别处理。</p><p>而<code>&lt;mvc:annotation-driven/&gt;</code>配置帮助我们自动完成上述两个实例的注入。</p><p>第二步：创建一个普通Java类<code>不需要实现任何接口</code></p><p>只需要在类上添加@Controller注解，把Controller交由Spring管理。</p><p>在方法上面添加@RequestMapping注解，里面指定请求的url。使处理器映射器可以找到它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnController</span> </span>&#123;<br><br><span class="hljs-meta">@RequestMapping(&quot;/anncon.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m01</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;AnnController!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@RequestMapping</strong> <strong>注解说明：</strong></p><p>@RequestMapping 中常用的属性有以下几个:</p><ol><li><p>value: 默认属性，请求的实际路径，可以配置多路径映射</p></li><li><p>method:请求方法的限定。可以限定 GET,POST,DELETE,PUT 请求方式</p></li></ol><p>value 的使用：</p><p>①使用在方法上，可以将 url 映射到指定的方法</p><p>②使用在类上，如果该 controller 的映射路径都有固定的前缀</p><p>/user/addUser.do</p><p>/user/deleteUser.do</p><p>/user/updateUser.do</p><p>修改一下 AnnController 测试一下</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Controller</span><br><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/anncon&quot;</span>)<br>public class AnnController &#123;<br><br><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/m01.do&quot;</span>)<br>public void m01()&#123;<br><span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Method01 !&quot;</span>);<br>&#125;<br><br>@<span class="hljs-selector-tag">RequestMapping</span>(<span class="hljs-string">&quot;/m02.do&quot;</span>)<br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">m02</span>()&#123;<br><span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Method2 !&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后访问路径：<a href="http://localhost:8080/demo/anncon/m01.do">http://localhost:8080/demo/anncon/m01.do</a></p><h4 id="4-3、小结"><a href="#4-3、小结" class="headerlink" title="4.3、小结"></a>4.3、小结</h4><p>常见的Controller实现方式有三种，我们<code>一般采用全注解的方式</code>：</p><p>需要在Spring配置文件中开启全注解支持，怎么开启？</p><p>然后在我们自己的Controller类上添加@Controller和@RequestMapping注解</p><h3 id="5、接收参数，页面跳转，传递对象（Servlet原来做的事情）"><a href="#5、接收参数，页面跳转，传递对象（Servlet原来做的事情）" class="headerlink" title="5、接收参数，页面跳转，传递对象（Servlet原来做的事情）"></a>5、接收参数，页面跳转，传递对象（Servlet原来做的事情）</h3><h4 id="5-1、引入"><a href="#5-1、引入" class="headerlink" title="5.1、引入"></a>5.1、引入</h4><p>我们用过注解实现了一个Controller，但是这样一个Controller又如何才能实现原来Servlet的作用呢? 要怎样才能接收参数，实现页面跳转并且传递数据的呢? 下面我们来一一介绍。  </p><h4 id="5-2、接收参数的四种方式"><a href="#5-2、接收参数的四种方式" class="headerlink" title="5.2、接收参数的四种方式"></a>5.2、接收参数的四种方式</h4><h5 id="5-2-1、接收普通参数"><a href="#5-2-1、接收普通参数" class="headerlink" title="5.2.1、接收普通参数"></a>5.2.1、接收普通参数</h5><p>1、形参名称与传递参数一致</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@Controller<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DataController &#123;<br>// 普通数据接收<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * http://localhost:8080/demo/params01.do?name=admin&amp;age=24</span><br><span class="hljs-comment"> */</span><br>@RequestMapping(&quot;/params01.do&quot;)<br><span class="hljs-built_in">public</span> ModelAndView params01(String <span class="hljs-type">name</span>, <span class="hljs-type">Integer</span> age) &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;name:&quot; + <span class="hljs-type">name</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;age:&quot; + age);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、形参名称与传递参数不一致</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果传过来的名称与接收的名称不一致</span><br><span class="hljs-comment"> * http://localhost:8080/demo/params02?name=admin&amp;age=24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/params02.do&quot;</span>)<br>public ModelAndView params02(<span class="hljs-variable">@RequestParam</span>(<span class="hljs-string">&quot;name&quot;</span>) String username,Integer age)&#123;<br><span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;username:&quot;</span>+username);<br><span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;age:&quot;</span>+age);<br><span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-2-2、使用对象接收参数"><a href="#5-2-2、使用对象接收参数" class="headerlink" title="5.2.2、使用对象接收参数"></a>5.2.2、使用对象接收参数</h5><p>准备对象</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> class User &#123;<br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> age;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">Date</span> <span class="hljs-built_in">date</span>;<br><span class="hljs-comment">// 其它的getter,setter省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * http://localhost:8080/anncon/params03.do?name=admin&amp;age=24&amp;date=2018-12-09</span><br><span class="hljs-comment"> * 注意：接收日期必需在</span><br><span class="hljs-comment"> * set时间前配置：@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span><br><span class="hljs-comment"> */</span><br>@RequestMapping(&quot;/params03.do&quot;)<br><span class="hljs-built_in">public</span> ModelAndView params03(<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>) &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;name:&quot; + <span class="hljs-keyword">user</span>.getName());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;age:&quot; + <span class="hljs-keyword">user</span>.getAge());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;date:&quot; + <span class="hljs-keyword">user</span>.getDate());<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>特别注意：在对象部分咱们加了一个日期，而日期格式的数据接收需要加相应的注解:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@DateTimeFormat</span>(pattern = <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setDate</span>(<span class="hljs-params"><span class="hljs-built_in">Date</span> date</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.date = date;<br>&#125;<br></code></pre></td></tr></table></figure><p>注: @DateTimeFormat要生效，则applicationContext.xml 中一定要配置<strong>支持注解</strong>的适配器和映射器</p><h5 id="5-2-3、HttpServletRequest接收参数（不建议使用）"><a href="#5-2-3、HttpServletRequest接收参数（不建议使用）" class="headerlink" title="5.2.3、HttpServletRequest接收参数（不建议使用）"></a>5.2.3、HttpServletRequest接收参数（不建议使用）</h5><p>SpringMVC想要拿Request，Session，Response直接在参数中写即可(它很强大)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用HttpServletRequest接收(不建议使用)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * http://localhost:8080/demo/params04?name=admin&amp;age=24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(<span class="hljs-meta-string">&quot;/params04&quot;</span>)</span><br><span class="hljs-keyword">public</span> ModelAndView params04(HttpServletRequest request) &#123;<br>System.<span class="hljs-keyword">out</span>.println(request.getParameter(<span class="hljs-string">&quot;name&quot;</span>));<br>System.<span class="hljs-keyword">out</span>.println(request.getParameter(<span class="hljs-string">&quot;age&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-2-4、URL地址提取数据，RESTful风格"><a href="#5-2-4、URL地址提取数据，RESTful风格" class="headerlink" title="5.2.4、URL地址提取数据，RESTful风格"></a>5.2.4、URL地址提取数据，RESTful风格</h5><p>什么是 RESTful</p><p><img src="/2019/11/28/SpringMVC/clip_image001.jpg" alt="img"></p><p>当你到公司被要求写一个接口时，很有可能就需要提供一个符合Restful风格的方法实现。</p><p>我们来对比传统开发和 RESTful 开发 url 的对比.</p><p>功能           传统开发                                                          RESTful 风格开发</p><p>​                    url                                        提交方式            url                      提交方式</p><p>添加用户    /ems/addUser.do                 POST              /ems/user          POST</p><p>删除用户    /ems/deleteUser.do?id=1   GET/POST      /ems/user/1      DELETE</p><p>修改用户    /ems/updateUser.do           POST              /ems/user          PUT</p><p>查询用户    /ems/getUser.do?id=1         GET                /ems/user/1       GET</p><p>代码实现</p><p>根据 RESTful 风格.我们请求的 url 是: <a href="http://localhost/params05/user/10">http://localhost/params05/user/10</a></p><p><strong>controller</strong> <strong>代码</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收url中参数的请求,接收用户请求参数值 </span><br><span class="hljs-comment"> * http://localhost:8080/demo/params05/user/10</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/params05/user/&#123;id&#125;&quot;</span>)<br>public ModelAndView params05(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">&quot;id&quot;</span>)Long id)&#123;<br><span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(id);<br><span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>将动态的 id 用 { } 括起来.</p><p>在方法的形参前,使用**@PathVariable** 注解, 将 url 上的参数封装到形参上；</p><p>如果是使用domain对象接收参数这里无需 @pathVariable注解；</p><p>如果是<code>多参数 url</code> 应为: /user/{name}/{id}, 多个参数使用 / 隔开；</p><p>对于多参数的 url，在方法的形参上使用多个参数接收, 每个参数前都要添@PathVariable 。</p><p><strong>web.xml</strong> <strong>修改</strong></p><p>因为之前我们配置的前端控制器拦截规则是*.do，所以 RESTful 风格的请求无法进入 controller，因此我们将拦截规则修改为 / </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>说明：</p><p>&lt;url-pattern&gt; 配置的3种方式 </p><table><thead><tr><th>&lt;url-pattern&gt;</th><th>配置说明</th></tr></thead><tbody><tr><td>/*</td><td>不用，所有都会拦截，包括jsp</td></tr><tr><td>*.do</td><td>配置简单,可以访问静态资源(不支持RESTful风格)</td></tr><tr><td>/</td><td>配置复杂一点，支持RESTful风格</td></tr></tbody></table><p><strong>Spring配置：对静态资源放行</strong></p><p>当拦截规则修改之后，静态资源（.html, .css, .js…）也会被拦截，所以我们需要对静态资源放行. </p><p>在 applicationContext.xml 文件中 映射器和适配器的后面 进行放行配置.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 自动加载推荐的处理器映射器和适配器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 静态资源放行 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们就可以正常访问静态资源了，再次访问<a href="http://localhost:8080/anncon/data.html%E8%AF%95%E8%AF%95">http://localhost:8080/anncon/data.html试试</a></p><h5 id="5-2-5、小结"><a href="#5-2-5、小结" class="headerlink" title="5.2.5、小结"></a>5.2.5、小结</h5><p>1.接收参数常用方式（普通参数，对象接收，URL地址提取）</p><p>2.形参名称不一致使用@RequestParam(“name”)String username </p><p>3.日期接收参数添加标签@DateTimeFormat(setXxx)</p><p>4.URL地址提取 /路径/{id} @PathVariable(“id”)Long id</p><h4 id="5-3、页面跳转"><a href="#5-3、页面跳转" class="headerlink" title="5.3、页面跳转"></a>5.3、页面跳转</h4><h5 id="5-3-1、跳转方式"><a href="#5-3-1、跳转方式" class="headerlink" title="5.3.1、跳转方式"></a>5.3.1、跳转方式</h5><p>咱们学习的跳转方式有两种: 重定向与请求转发</p><table><thead><tr><th></th><th>请求转发(forward)</th><th>重定向(redirect)</th></tr></thead><tbody><tr><td>访问WEB-INF</td><td><strong>√</strong></td><td><strong>X</strong></td></tr><tr><td>request传参</td><td><strong>√</strong></td><td><strong>X</strong></td></tr><tr><td>全新请求(URL变化)</td><td><strong>X</strong></td><td><strong>√</strong></td></tr><tr><td>访问外网</td><td><strong>X</strong></td><td><strong>√</strong></td></tr></tbody></table><p><strong>请求转发(forward)</strong></p><p>上面4个案例都是转发，转发的值都是放到request请求作用域，下一个页面可以取出，Url地址不会改变</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用请求转发</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/path06&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">data5</span>(<span class="hljs-params">Model model,HttpSession session</span>)</span>&#123;<br>model.addAttribute(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<span class="hljs-comment">//可以取出数据</span><br>session.setAttribute(<span class="hljs-string">&quot;testsession&quot;</span>, <span class="hljs-string">&quot;张三session&quot;</span>);<span class="hljs-comment">//可以取出数据</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/data.jsp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重定向(redirect)</strong></p><p>重定向就是发出一个全新的请求，如果把值放到request请求，下一个页面不能取出</p><p>如果把值放到session会话请求，下一个页面可以取出</p><p>Url地址会改变</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用重定向</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/path07&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">data6</span>(<span class="hljs-params">Model model,HttpSession session</span>)</span>&#123;<br>model.addAttribute(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<span class="hljs-comment">//不可以取出数据</span><br>session.setAttribute(<span class="hljs-string">&quot;testsession&quot;</span>, <span class="hljs-string">&quot;张三session&quot;</span>);<span class="hljs-comment">//可以取出数据</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/data.jsp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-3-2、前缀使用"><a href="#5-3-2、前缀使用" class="headerlink" title="5.3.2、前缀使用"></a>5.3.2、前缀使用</h5><p>视图名规则</p><p>​    不写前缀默认为 “转发” </p><p>​    视图名字符串前缀:</p><p>​        forward:/xxx.jsp 采用转发。</p><p>​        redirect:/xxx.jsp 采用重定向。</p><p>我们之前已经配置了视图解析器，我们再次看一下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置视图解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 指定视图的前缀 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 指定视图的后缀 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有没有发现什么样的问题？</p><p>说明：</p><p><code>使用了forword 或 redirect跳转页面通过视图解析器时是不会添加前缀和后缀的。</code></p><p>用于跳转到一些特殊的路径，比如：</p><p>页面不在前缀路径中的情况（或者页面路径不是以.jsp为后缀）</p><h4 id="5-4、传递参数的四种方式"><a href="#5-4、传递参数的四种方式" class="headerlink" title="5.4、传递参数的四种方式"></a>5.4、传递参数的四种方式</h4><h5 id="5-4-1、通用ModelAndView方式"><a href="#5-4-1、通用ModelAndView方式" class="headerlink" title="5.4.1、通用ModelAndView方式"></a>5.4.1、通用ModelAndView方式</h5><p>在之前的入门案例里我们就看到过了ModelAndView，使用ModelAndView 可以传递参数到指定视图路径。我们再来试一下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">/**<br> * 通过ModelAndView 传递普通参数<br> * http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/demo/</span>data01<br> * @return<br> */<br>@RequestMapping(<span class="hljs-string">&quot;/data01&quot;</span>)<br>public ModelAndView data01()&#123;<br><span class="hljs-regexp">//</span>创建ModelAndView.用于保存数据和视图<br>ModelAndView mav = new ModelAndView();<br><span class="hljs-regexp">//</span>设置数据到模型中<br>mav.addObject(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;ModelAndView 传递数据&quot;</span>);<br><span class="hljs-regexp">//</span>设置jsp视图<br>mav.setViewName(<span class="hljs-string">&quot;view&quot;</span>);<br><span class="hljs-regexp">//</span>返回模型视图<br>return mav;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以传递JavaBean 对象：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过ModelAndView 传递对象参数</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br>@<span class="hljs-constructor">RequestMapping(<span class="hljs-string">&quot;/data02&quot;</span>)</span><br>public ModelAndView data02<span class="hljs-literal">()</span>&#123;<br><span class="hljs-comment">//创建ModelAndView.用于保存数据和视图</span><br>ModelAndView mav = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ModelAndView()</span>;<br><span class="hljs-comment">//设置数据到模型中</span><br>User user = <span class="hljs-keyword">new</span> <span class="hljs-constructor">User()</span>;<br>user.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;李四&quot;</span>)</span>;<br>mav.add<span class="hljs-constructor">Object(<span class="hljs-params">user</span>)</span>;<br><br><span class="hljs-comment">//设置jsp视图</span><br>mav.set<span class="hljs-constructor">ViewName(<span class="hljs-string">&quot;view&quot;</span>)</span>;<br><span class="hljs-comment">//返回模型视图</span><br>return mav;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：<br>我们<code>使用addObject（String attributeName,Object attributeValue）方法添加返回的数据</code>。<br>当使用Object类型的对象的时候，必须指定一个名字。<code>ModelAndView，也可以接收没有明显名字的对象</code>，原因在于ModelAndView，将调用<code>spring自己定义的方法Conventions.getVariableName()来为这个model生成一个名字</code>。显然，<code>对model而言，名字是必须的</code>。<br>Conventions.getVariableName()生成名字的规则是<code>（使用对象的类名的小写模式来作model名字，能够由EL表达式访问）</code>。当这个model是集合或数组的时候，使用集合的第一个元素的类名加s来作model的名字。</p><h5 id="5-4-2、使用Model方式（强烈建议使用）"><a href="#5-4-2、使用Model方式（强烈建议使用）" class="headerlink" title="5.4.2、使用Model方式（强烈建议使用）"></a>5.4.2、使用Model方式（强烈建议使用）</h5><p>使用ModelAndView 需要我们自己创建对象，其实体贴的SpringMVC框架已经为我们的参数传递准备了专门的对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过Model 传递参数</span><br><span class="hljs-comment"> * SpringMVC会自动创建模型对象传到方法中，我们只需要往这个模型对象中添加数据即可</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>返回值为字符串,我们可以理解为就是一个视图的名称(写路径即可)</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/data03&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">data03</span>(<span class="hljs-params">Model model</span>)</span>&#123;<br><span class="hljs-comment">//添加数据</span><br>model.addAttribute(<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-string">&quot;Model 传递数据&quot;</span>);<br><br>    <span class="hljs-comment">//指定要返回的视图路径</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;view&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ModelAndView与 Model的区别：</p><p>Model是每次请求中都存在的默认参数；</p><p>利用其addAttribute()方法即可将服务器的值传递到jsp页面中</p><p>ModelAndView包含model和view两部分</p><p>使用时需要自己实例化，利用ModelMap用来传值，也可以设置view的名称</p><p><code>无论是ModelAndView还是Model传递的对象是存放在request Scope中的</code>，如果需要在session域中传值，可以像Model一样在方法的参数里添加Session 即可使用。</p><h5 id="5-4-3、HttpServletRequest方式（不建议使用）"><a href="#5-4-3、HttpServletRequest方式（不建议使用）" class="headerlink" title="5.4.3、HttpServletRequest方式（不建议使用）"></a>5.4.3、HttpServletRequest方式（不建议使用）</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//通过request对象进行数据传递(不建议使用)</span><br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/data04&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> data04(HttpServletRequest request,HttpServletResponse response) <br><span class="hljs-keyword">throws</span> ServletException, IOException&#123;<br>request.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;HttpServletRequest&quot;</span>);<br><span class="hljs-comment">//需要自己指定跳转页面的全路径</span><br>request.getRequestDispatcher(<span class="hljs-string">&quot;/WEB-INF/jsp/view.jsp&quot;</span>).forward(request, response);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-4-4、返回值传参（不建议使用）"><a href="#5-4-4、返回值传参（不建议使用）" class="headerlink" title="5.4.4、返回值传参（不建议使用）"></a>5.4.4、返回值传参（不建议使用）</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回值就是模型数据</span><br><span class="hljs-comment"> * SpringMVC会自动创建一个ModelAndView对象，并且调用添加模型 mdv.addObject(&quot;user&quot;, user);</span><br><span class="hljs-comment"> * 并且访问路径就是视图的名称 /data05  mdv.setViewName(&quot;/data05&quot;);</span><br><span class="hljs-comment"> * 在这里我们的视图肯定没有data05的视图，所以会报一个错</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br>@RequestMapping(&quot;/data05&quot;)<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> data05()&#123;<br><span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>();<br><span class="hljs-keyword">user</span>.setName(&quot;张三&quot;);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不要使用这种方式直接返回对象，<code>这种方式只用在我们需要把返回的对象转换为Json数据时</code>。</p><h4 id="5-5、小结"><a href="#5-5、小结" class="headerlink" title="5.5、小结"></a>5.5、小结</h4><ol><li><p>接收和传参的4种方式，建议使用Model方式</p></li><li><p>跳转时可以配置视图解析器ViewResolver，简化咱们的跳转</p></li><li><p>怎么使用不同的方式(forward/redirect)进行跳转 ?</p></li></ol><h3 id="6、SpringMVC返回JSON"><a href="#6、SpringMVC返回JSON" class="headerlink" title="6、SpringMVC返回JSON"></a>6、SpringMVC返回JSON</h3><h4 id="6-1、引入"><a href="#6-1、引入" class="headerlink" title="6.1、引入"></a>6.1、引入</h4><h5 id="6-1-1-什么是json？"><a href="#6-1-1-什么是json？" class="headerlink" title="6.1.1.  什么是json？"></a>6.1.1.  什么是json？</h5><p>json是一种轻量级的前端后端以及网络传输的数据交换格式，就是一串字符串。也就是说在后端可以把一个复杂对象，通过json来转换成特定的字符串传到前端去。</p><p>简单的：var json = ‘{“name”:”张三” , “age”:18 }’;</p><h5 id="6-1-2-为什么要用json？"><a href="#6-1-2-为什么要用json？" class="headerlink" title="6.1.2.  为什么要用json？"></a>6.1.2.  为什么要用json？</h5><p>json本来是javascript里的内容，有时后端要传各种各样的数据格式来适应前端，所以需要用到json来转换，用它来表示各种各样复杂的数据。 </p><p>数据格式比较简单, 易于读写, 能够直接为服务器端代码使用, 大大简化了服务器端和客户端的代码开发量, 且易于维护，语言无关。</p><h4 id="6-2、实现"><a href="#6-2、实现" class="headerlink" title="6.2、实现"></a>6.2、实现</h4><h5 id="6-2-1、步骤分析"><a href="#6-2-1、步骤分析" class="headerlink" title="6.2.1、步骤分析"></a>6.2.1、步骤分析</h5><p>要我们的Controller返回一个Json字符串非常简单，只需要添加相关jar包，并在我们的方法上添加@ResponseBody注解即可。</p><h5 id="6-2-2、添加jackson的jar包"><a href="#6-2-2、添加jackson的jar包" class="headerlink" title="6.2.2、添加jackson的jar包"></a>6.2.2、添加jackson的jar包</h5><p>如果需要 springMVC 支持 json，必须加入 json 的处理 jar 包。</p><p>springmvc 官方使用 Jackson 这个 jar 包：</p><blockquote><p>jackson-annotations-2.5.0.jar</p><p>jackson-core-2.5.0.jar</p><p>jackson-databind-2.5.0.jar</p></blockquote><h5 id="6-2-3、JsonController"><a href="#6-2-3、JsonController" class="headerlink" title="6.2.3、JsonController"></a>6.2.3、JsonController</h5><p>在方法上添加 @ResponseBody  注解，方法返回的字符串不在被ViewResolver解析为视图，而是直接返回字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonController</span> </span>&#123;<br><span class="hljs-meta">@RequestMapping(&quot;/json1&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">json1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果方法的返回值是复杂对象，@ResponseBody注解，会将 java 对象解析为 json 格式的字符串返回</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/json2&quot;</span>)<br><span class="hljs-variable">@ResponseBody</span><br>public User json3() throws Exception &#123;<br><span class="hljs-comment">//返回一个javaBean 对象</span><br><span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">User</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当返回的对象有Date日期格式的属性：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/json03&quot;</span>)<br><span class="hljs-variable">@ResponseBody</span><br>public User json4() throws Exception &#123;<br><span class="hljs-comment">// 返回一个javaBean 对象</span><br><span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">User</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">20</span>, new Date());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/28/SpringMVC/Snipaste_2019-11-28_14-28-37.png"></p><p>默认返回的日期格式为时间戳，而在前台我们希望显示出指定规则的日期字符串。</p><p>解决：在日期get属性字段上，添加一个格式化注解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@JsonFormat</span>(pattern=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>,timezone=<span class="hljs-string">&quot;GMT+8&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">Date</span> <span class="hljs-function"><span class="hljs-title">getDate</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> date;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-3、注意事项"><a href="#6-3、注意事项" class="headerlink" title="6.3、注意事项"></a>6.3、注意事项</h4><h5 id="6-3-1、处理有乱码的问题"><a href="#6-3-1、处理有乱码的问题" class="headerlink" title="6.3.1、处理有乱码的问题"></a>6.3.1、处理有乱码的问题</h5><p>当返回的Json字符串对像中有中文，会出现乱码问题：这时我们可以为SpringMVC的适配器配置一个字符转换器，设置支持的媒体类型：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span> <span class="hljs-attr">register-defaults</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 注册一个转换器 解决返回的json乱码问题 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;supportedMediaTypes&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>text/html;charset=UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json;charset=UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注：如果不使用注解驱动&lt;mvc:annotation-driven /&gt;，配置媒体类型的话，就需要给处理器适配器配置json转换器：</p><p>在springmvc.xml配置文件中，需要给处理器适配器注入json转换器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--处理器适配器 --&gt;</span><br>&lt;bean<br>class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;messageConverters&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.</span></span><br><span class="hljs-tag"><span class="hljs-string">MappingJackson2HttpMessageConverter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="6-4、小结"><a href="#6-4、小结" class="headerlink" title="6.4、小结"></a>6.4、小结</h4><p>Json格式的数据，是一种非常常见且有用的数据格式，今天我们只是简单的学习了通过@ResponseBody 注解返回Json格式的数据，并解决了响应类型不匹配，中文乱码，日期转换的问题。后面我们学习了Ajax后还会学习如果接收Json格式的数据，希望大家多多重视。</p><h3 id="7、SpringMVC拦截器-放到项目中做登录拦截"><a href="#7、SpringMVC拦截器-放到项目中做登录拦截" class="headerlink" title="7、SpringMVC拦截器-放到项目中做登录拦截"></a>7、SpringMVC拦截器-放到项目中做登录拦截</h3><h4 id="7-1、引入"><a href="#7-1、引入" class="headerlink" title="7.1、引入"></a>7.1、引入</h4><p>我们的项目需要实现登录拦截的功能，之前我们学习Servlet的时候，也使用过Filter拦截器，SpringMVC 提供了处理器拦截器类，它的使用比Filter更方便，更强大，用于对处理器进行预处理和后处理。</p><h4 id="7-2、实现"><a href="#7-2、实现" class="headerlink" title="7.2、实现"></a>7.2、实现</h4><p>实现SpringMVC拦截器非常简单，我们只需要实现拦截器接口，并把他配置到SpringMVC的配置文件中即可。</p><h5 id="7-2-1、定义拦截器"><a href="#7-2-1、定义拦截器" class="headerlink" title="7.2.1、定义拦截器"></a>7.2.1、定义拦截器</h5><p>自定义类实现 <strong>HandlerInterceptor</strong> 接口.返回值决定是否放行.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Interceptor1 implements HandlerInterceptor &#123;<br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> preHandle(HttpServletRequest request, HttpServletResponse response, <span class="hljs-keyword">Object</span> <span class="hljs-keyword">handler</span>)<br>throws <span class="hljs-keyword">Exception</span> &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;拦截器 1----方法执行之前&quot;);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> postHandle(HttpServletRequest request, HttpServletResponse response, <span class="hljs-keyword">Object</span> <span class="hljs-keyword">handler</span>,<br>ModelAndView modelAndView) throws <span class="hljs-keyword">Exception</span> &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;拦截器 1----方法执行之后&quot;);<br>&#125;<br><br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> afterCompletion(HttpServletRequest request, HttpServletResponse response, <span class="hljs-keyword">Object</span> <span class="hljs-keyword">handler</span>, <span class="hljs-keyword">Exception</span> ex)<br>throws <span class="hljs-keyword">Exception</span> &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;拦截器 1----页面渲染完成&quot;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复制一份,命名为 HandlerInterceptor2,输出内容做相应的修改.</p><h5 id="7-2-2、拦截器配置"><a href="#7-2-2、拦截器配置" class="headerlink" title="7.2.2、拦截器配置"></a>7.2.2、拦截器配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置拦截器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.istourec.interceptor.Interceptor1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.istourec.interceptor.Interceptor2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="7-2-3、拦截器拦截流程"><a href="#7-2-3、拦截器拦截流程" class="headerlink" title="7.2.3、拦截器拦截流程"></a>7.2.3、拦截器拦截流程</h5><ol><li>拦截器 1 放行</li></ol><p><img src="/2019/11/28/SpringMVC/clip_image003.jpg" alt="img"></p><ol start="2"><li>拦截器 1 不放行</li></ol><p><img src="/2019/11/28/SpringMVC/clip_image005.jpg" alt="img"></p><ol start="3"><li>拦截器 2 不放行</li></ol><p><img src="/2019/11/28/SpringMVC/clip_image007.jpg" alt="img"></p><p>说明：</p><ol><li><p>preHandle 按拦截器定义顺序调用</p></li><li><p>postHandler 按拦截器定义逆序调用</p></li><li><p>afterCompletion 按拦截器定义逆序调用</p></li><li><p>postHandler 在拦截器链内所有拦截器返成功调用</p></li><li><p>afterCompletion 只有 preHandle 返回 true 才调用</p></li></ol><h5 id="7-2-4、指定不拦截方法"><a href="#7-2-4、指定不拦截方法" class="headerlink" title="7.2.4、指定不拦截方法"></a>7.2.4、指定不拦截方法</h5><p>通过&lt;mvc:exclude-mapping/&gt;标签指定不拦截的方法.但是配置这个标签之前,必须配置&lt;mvc:mapping /&gt;标签.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置拦截器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/userList&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.istourec.interceptor.Interceptor1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.istourec.interceptor.Interceptor2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们访问 localhost:8082/userList.观察拦截器执行效果.</p><p><img src="/2019/11/28/SpringMVC/clip_image009.jpg" alt="img"></p><p>仅有拦截器 2 执行了.</p><h4 id="7-3、小结"><a href="#7-3、小结" class="headerlink" title="7.3、小结"></a>7.3、小结</h4><p>以上，我们学习了拦截器的配置与放行方式，所以我们的登录拦截可以这样来实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置拦截器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/toLogin&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/loginUser&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cn.itsourece.ems.interceptor.MyLogInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8、文件上传-放到项目中去做"><a href="#8、文件上传-放到项目中去做" class="headerlink" title="8、文件上传-放到项目中去做"></a>8、文件上传-放到项目中去做</h3><h4 id="8-1、引入"><a href="#8-1、引入" class="headerlink" title="8.1、引入"></a>8.1、引入</h4><p>原始的Servlet文件上传，需要对提交的流对象进行复制的解析，SpringMVC 为我们提供了一个方便的解析器可以方便的实现文件上传。如果要实现文件的上传,只要在 spring-mvc.xml 中注册相应的 MultipartResolver 即可。</p><h4 id="8-2、实现步骤"><a href="#8-2、实现步骤" class="headerlink" title="8.2、实现步骤"></a>8.2、实现步骤</h4><h5 id="8-2-1、加入文件上传所需依赖的jar包"><a href="#8-2-1、加入文件上传所需依赖的jar包" class="headerlink" title="8.2.1、加入文件上传所需依赖的jar包"></a>8.2.1、加入文件上传所需依赖的jar包</h5><p><img src="/2019/11/28/SpringMVC/image-20191128144118730.png" alt="image-20191128144118730"></p><h5 id="8-2-2、配置上传解析器"><a href="#8-2-2、配置上传解析器" class="headerlink" title="8.2.2、配置上传解析器"></a>8.2.2、配置上传解析器</h5><p>在 springmvc.xml 中配置上传文件的解析器CommonsMultipartResolver</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 文件上传解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 设置文件大小限制,单位 B --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5242880&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="8-2-3、页面调整"><a href="#8-2-3、页面调整" class="headerlink" title="8.2.3、页面调整"></a>8.2.3、页面调整</h5><p>修改表单提交的 enctype 为 multipart/form-data 多部分表单.</p><p><img src="/2019/11/28/SpringMVC/image-20191128144301227.png" alt="image-20191128144301227"></p><h5 id="8-2-4、上传文件"><a href="#8-2-4、上传文件" class="headerlink" title="8.2.4、上传文件"></a>8.2.4、上传文件</h5><p>在 Controller 方法的形参中,使用 MultipartFile 来接收上传的文件.注意方法形参的名称要与表单提交的 name 保持一致</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 修改用户信息</span><br><span class="hljs-comment"> */</span><br>@<span class="hljs-constructor">RequestMapping(<span class="hljs-string">&quot;/update&quot;</span>)</span><br>public String update(User user, MultipartFile file, Model model) throws Exception &#123;<br><span class="hljs-comment">// ----------------------- 准备上传图片 ----------------------</span><br><span class="hljs-comment">// 1. 准备上传的文件名</span><br>String uuid = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>.replace<span class="hljs-constructor">All(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)</span>;<br>String extension = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FilenameUtils</span>.</span></span>get<span class="hljs-constructor">Extension(<span class="hljs-params">file</span>.<span class="hljs-params">getOriginalFilename</span>()</span>);<br>String newFileName = uuid + <span class="hljs-string">&quot;.&quot;</span> + extension;<br><span class="hljs-comment">// 2. 上传文件</span><br>String webapp = request.get<span class="hljs-constructor">ServletContext()</span>.get<span class="hljs-constructor">RealPath(<span class="hljs-string">&quot;/uploads/&quot;</span>)</span>;<br>file.transfer<span class="hljs-constructor">To(<span class="hljs-params">new</span> File(<span class="hljs-params">webapp</span> + <span class="hljs-string">&quot;\\&quot;</span> + <span class="hljs-params">newFileName</span>)</span>);<br><span class="hljs-comment">// 3. 给 user 赋值</span><br>user.set<span class="hljs-constructor">Img(<span class="hljs-params">newFileName</span>)</span>;<br>us.update(user);<br><span class="hljs-comment">// 4. 获取修改后的用户信息,保存到 model 中</span><br>User queryUser = us.select<span class="hljs-constructor">ById(<span class="hljs-params">user</span>.<span class="hljs-params">getUid</span>()</span>);<br>model.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-params">queryUser</span>)</span>;<br>return <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-2-5、准备显示页面"><a href="#8-2-5、准备显示页面" class="headerlink" title="8.2.5、准备显示页面"></a>8.2.5、准备显示页面</h5><p>通过el表达式取出查询的值</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs erb"><span class="xml">&lt;%</span><span class="ruby">@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span></span><br><span class="ruby">    pageEncoding=<span class="hljs-string">&quot;utf-8&quot;</span></span><span class="xml">%&gt;</span><br><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> 上传成功！~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;上传的图片&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/img/ems/$&#123;user.img&#125;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">100</span> <span class="hljs-attr">height</span>=<span class="hljs-string">100</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="8-3、小结"><a href="#8-3、小结" class="headerlink" title="8.3、小结"></a>8.3、小结</h4><p>通过配置上传解析器CommonsMultipartResolver实现文件上传。</p><h3 id="9、SpringMVC小结"><a href="#9、SpringMVC小结" class="headerlink" title="9、SpringMVC小结"></a>9、SpringMVC小结</h3><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><ol><li><p>SpringMVC的执行流程。</p></li><li><p>配置核心组件</p></li><li><p>接收参数、页面跳转、响应数据</p></li></ol><h4 id="400-类型不匹配"><a href="#400-类型不匹配" class="headerlink" title="400(类型不匹配)"></a>400(类型不匹配)</h4><p>如果传参类型不匹配，则会报400错误。大家在传参的时候一定要小心注意，特别咱们以后都是使用ajax操作，那么这个报错需要在前端调试工具(如firebug)中去查看。</p><h4 id="DateTimeFormat-接收日期格式（分清楚）"><a href="#DateTimeFormat-接收日期格式（分清楚）" class="headerlink" title="@DateTimeFormat 接收日期格式（分清楚）"></a>@DateTimeFormat 接收日期格式（分清楚）</h4><ol><li><p>接收日期格式使用**@DateTimeFormat(yyyy-MM-dd)**,特别注意千万不要把后台传参与前台接收参数搞混淆：</p></li><li><p>后台-&gt;前台:@JsonFormat(pattern=”yyyy-MM-dd hh:mm:ssS”,timezone=”GMT+8”)</p></li><li><p>前台-&gt;后台:@DateTimeFormat(pattern=”yyyy-MM-dd”)</p></li></ol><h4 id="tomcat6-x，7-x中文编码问题"><a href="#tomcat6-x，7-x中文编码问题" class="headerlink" title="tomcat6.x，7.x中文编码问题"></a>tomcat6.x，7.x中文编码问题</h4><p>Get请求：</p><p>/conf/server.xml </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">port</span>=<span class="hljs-string">&quot;80&quot;</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attribute">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span><br><span class="hljs-attribute">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span><br><span class="hljs-attribute">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>Post请求：</p><p>注意：SpringMVC框架本身没有处理请求编码，需要配置一个spring内置请求编码过滤器。</p><p><img src="/2019/11/28/SpringMVC/clip_image0022.jpg" alt="img"></p><p>web.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Post请求编码过滤器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span><br>org.springframework.web.filter.CharacterEncodingFilter<br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.1.5.  出现406状态异常，加入jackson json工具包</p><p><img src="/2019/11/28/SpringMVC/clip_image0021.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaBean&amp;EL&amp;JSTL</title>
    <link href="/2019/11/21/JavaBean&amp;EL&amp;JSTL/"/>
    <url>/2019/11/21/JavaBean&amp;EL&amp;JSTL/</url>
    
    <content type="html"><![CDATA[<h3 id="1、JavaBean"><a href="#1、JavaBean" class="headerlink" title="1、JavaBean"></a>1、JavaBean</h3><h4 id="1-1、什么是JavaBean"><a href="#1-1、什么是JavaBean" class="headerlink" title="1.1、什么是JavaBean"></a>1.1、什么是JavaBean</h4><p>JavaBean 是一种Java语言遵守JavaBean API规范写成的<code>可重用组件</code>。</p><p>JavaBean 与其它 Java 类相比而言独一无二的特征：</p><ul><li><pre><code> 提供一个默认的无参构造函数。</code></pre></li><li><pre><code> 需要被序列化并且实现了 Serializable 接口。</code></pre></li><li><pre><code> 可能有一系列可读写属性。</code></pre></li><li><pre><code> 可能有一系列的 getter 或 **setter** 方法。</code></pre></li></ul><p>简单一点：建一个类,给一个无参的构造方法. 它就是JavaBean</p><h4 id="1-2、JavaBean的规范"><a href="#1-2、JavaBean的规范" class="headerlink" title="1.2、JavaBean的规范"></a>1.2、JavaBean的规范</h4><p>JavaBean分两种：</p><blockquote><p>①、复杂的，组件性的（GUI），比如事件监听器；</p><p>②、简单的JavaBean：有属性和方法。</p></blockquote><p>JavaBean是一个特殊的Java类，它遵守了一定的规范（有一个公共的无参构造器，可能还有get和set方法）</p><p>注意：以Java来说get/set属于方法，但是以JavaBean来说get/set相当于属性。</p><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">get<strong>PropertyName</strong>()</td><td align="left">举例来说，如果属性的名称为 myName，那么这个方法的名字就要写成 getMyName() 来读取这个属性。这个方法也称为访问器。</td></tr><tr><td align="left">set<strong>PropertyName</strong>()</td><td align="left">举例来说，如果属性的名称为 myName，那么这个方法的名字就要写成  setMyName()来写入这个属性。这个方法也称为写入器。</td></tr></tbody></table><p><img src="/2019/11/21/JavaBean&EL&JSTL/getset.png"></p><p>一个 JavaBean 对象的属性应该是可访问的。这个属性可以是任意合法的 Java 数据类型，包括自定义 Java 类。一个 JavaBean 对象的属性可以是可读写，或只读，或只写。</p><p>JavaBean的属性与普通类的属性不一样，属性以方法的形式出现（getter，setter）</p><p>写法：getXxx，setXxx            注：xxx未在JavaBean的字段中，不代表xxx不是它属性</p><p>特殊：</p><p>  ①getBbs 这里的bbs也是JavaBean的属性，即使bbs未在字段中定义</p><p>  ②如果是boolean 使用is判断JavaBean属性</p><p>注意：以后我们使用JavaBean，<strong>全用包装类型</strong>（后面要用），JavaBean是一个可重用的组件（反复使用，可以少些代码），今天使用JavaBean主要是要与后面的EL相结合使用。</p><h4 id="1-2、jsp-useBean"><a href="#1-2、jsp-useBean" class="headerlink" title="1.2、jsp:useBean"></a>1.2、jsp:useBean</h4><h5 id="1-2-1、-lt-jsp-useBean-gt-标签可以在-JSP-中声明一个-JavaBean，然后使用。"><a href="#1-2-1、-lt-jsp-useBean-gt-标签可以在-JSP-中声明一个-JavaBean，然后使用。" class="headerlink" title="1.2.1、&lt;jsp:useBean&gt; 标签可以在 JSP 中声明一个 JavaBean，然后使用。"></a>1.2.1、&lt;jsp:useBean&gt; 标签可以在 JSP 中声明一个 JavaBean，然后使用。</h5><p>声明后，JavaBean 对象就成了脚本变量，可以通过脚本元素或其他自定义标签来访问。&lt;jsp:useBean&gt; 标签的语法格式如下： </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;jsp:useBean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;bean 的名字&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;bean 的作用域&quot;</span> typeSpec/&gt;<br></code></pre></td></tr></table></figure><p> 其中，根据具体情况，scope 的值可以是 <code>page</code>，<code>request</code>，<code>session</code> 或 <code>application</code>。id值可任意只要不和同一 JSP 文件中其它 &lt;jsp:useBean&gt; 中 id 值一样就行了。</p><p> 接下来给出的是 &lt;jsp:useBean&gt; 标签的一个简单的用法：</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs erb"><span class="xml">&lt;%</span><span class="ruby">@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="ruby">    pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span></span><span class="xml">%&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>useBean 实例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp:useBean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.util.Date&quot;</span> /&gt;</span> </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>日期为：&lt;%=</span><span class="ruby"> date </span><span class="xml">%&gt;</span><br><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p> 它将会产生如下结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">日期为：Tue Jun <span class="hljs-number">28 15:22:24</span> CST <span class="hljs-number">2016</span><br></code></pre></td></tr></table></figure><h5 id="1-2-2、-lt-jsp-getProperty-gt-和-lt-jsp-getProperty-gt"><a href="#1-2-2、-lt-jsp-getProperty-gt-和-lt-jsp-getProperty-gt" class="headerlink" title="1.2.2、&lt;jsp:getProperty/&gt;和&lt;jsp:getProperty/&gt;"></a>1.2.2、&lt;jsp:getProperty/&gt;和&lt;jsp:getProperty/&gt;</h5><p>在&lt;jsp:useBean&gt;标签主体中使用&lt;jsp:getProperty/&gt;标签来调用 <strong>getter</strong> 方法，使用&lt;jsp:getProperty/&gt;标签来调用 <strong>setter</strong> 方法，语法格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;jsp:useBean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;bean 编译的类&quot;</span> scope=<span class="hljs-string">&quot;bean 作用域&quot;</span>&gt;<br>   &lt;jsp:setProperty <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;bean 的 id&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;属性名&quot;</span>  <br>                    value=<span class="hljs-string">&quot;value&quot;</span>/&gt;<br>   &lt;jsp:getProperty <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;bean 的 id&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;属性名&quot;</span>/&gt;<br>   ...........<br>&lt;/jsp:useBean&gt;<br></code></pre></td></tr></table></figure><p> name属性指的是Bean的id属性。property属性指的是想要调用的getter或setter方法。</p><p> 接下来给出使用以上语法进行属性访问的一个简单例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span><br>    pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span>%&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;<span class="hljs-keyword">get</span> 和 <span class="hljs-keyword">set</span> 属性实例&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;jsp:useBean id=<span class="hljs-string">&quot;students&quot;</span> <br>                    <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">StudentsBean</span>&quot;&gt; <br>   &lt;<span class="hljs-symbol">jsp:<span class="hljs-symbol">setProperty</span></span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">students</span>&quot; <span class="hljs-symbol">property</span>=&quot;<span class="hljs-symbol">firstName</span>&quot;<br>                    <span class="hljs-symbol">value</span>=&quot;小强&quot;/&gt;<br>   &lt;<span class="hljs-symbol">jsp:<span class="hljs-symbol">setProperty</span></span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">students</span>&quot; <span class="hljs-symbol">property</span>=&quot;<span class="hljs-symbol">lastName</span>&quot; <br>                    <span class="hljs-symbol">value</span>=&quot;王&quot;/&gt;<br>   &lt;<span class="hljs-symbol">jsp:<span class="hljs-symbol">setProperty</span></span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">students</span>&quot; <span class="hljs-symbol">property</span>=&quot;<span class="hljs-symbol">age</span>&quot;<br>                    <span class="hljs-symbol">value</span>=&quot;<span class="hljs-symbol">10</span>&quot;/&gt;<br>&lt;/<span class="hljs-symbol">jsp:<span class="hljs-symbol">useBean</span></span>&gt;<br><br>&lt;<span class="hljs-symbol">p</span>&gt;学生名字: <br>   &lt;<span class="hljs-symbol">jsp:<span class="hljs-symbol">getProperty</span></span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">students</span>&quot; <span class="hljs-symbol">property</span>=&quot;<span class="hljs-symbol">firstName</span>&quot;/&gt;<br>&lt;/<span class="hljs-symbol">p</span>&gt;<br>&lt;<span class="hljs-symbol">p</span>&gt;学生姓氏: <br>   &lt;<span class="hljs-symbol">jsp:<span class="hljs-symbol">getProperty</span></span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">students</span>&quot; <span class="hljs-symbol">property</span>=&quot;<span class="hljs-symbol">lastName</span>&quot;/&gt;<br>&lt;/<span class="hljs-symbol">p</span>&gt;<br>&lt;<span class="hljs-symbol">p</span>&gt;学生年龄: <br>   &lt;<span class="hljs-symbol">jsp:<span class="hljs-symbol">getProperty</span></span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">students</span>&quot; <span class="hljs-symbol">property</span>=&quot;<span class="hljs-symbol">age</span>&quot;/&gt;<br>&lt;/<span class="hljs-symbol">p</span>&gt;<br><br>&lt;/<span class="hljs-symbol">body</span>&gt;<br>&lt;/<span class="hljs-symbol">html</span>&gt;<br></code></pre></td></tr></table></figure><p> 访问以上 JSP，运行结果如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">学生名字: 小强</span><br><span class="hljs-section">学生姓氏: 王</span><br><span class="hljs-section">学生年龄: 10</span><br></code></pre></td></tr></table></figure><h4 id="1-3、JavaBean的反（自）省机制"><a href="#1-3、JavaBean的反（自）省机制" class="headerlink" title="1.3、JavaBean的反（自）省机制"></a>1.3、JavaBean的反（自）省机制</h4><p>什么是JavaBean自省机制？</p><p>​    我们拿到一个JavaBean，就可以拿到它的可读和可写的属性 或者属性名，字段；</p><p>一般来说我们需要拿到可读可写属性；有个这些属性，可以通过反射去完成读写功能；</p><p>使用JavaBean的API：<code>Introspector</code>（通过它拿到JavaBean）</p><p><img src="/2019/11/21/JavaBean&EL&JSTL/getBeanInfo.png"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BeanInfo beanInfo= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Introspector</span>.</span></span>get<span class="hljs-constructor">BeanInfo(JavaBeanDemo.<span class="hljs-params">class</span>,Object.<span class="hljs-params">class</span>)</span>;<br>PropertyDescriptor<span class="hljs-literal">[]</span> pds=beanInfo.get<span class="hljs-constructor">PropertyDescriptors()</span>;<br></code></pre></td></tr></table></figure><p><strong>BeanInfo</strong>(就是一个JavaBean对象，也可以称为Javabean的描述器)  </p><p><strong>getBeanInfo</strong>(JavaBeanDemo.class)：得到<code>JavaBeanDemo</code>以及它的<code>父类Object的属性</code></p><h5 id="1-3-1、getBeanInfo-JavaBeanDemo-class-：得到StuJavaBeanDemodent的属性-包含它父类Object的属性"><a href="#1-3-1、getBeanInfo-JavaBeanDemo-class-：得到StuJavaBeanDemodent的属性-包含它父类Object的属性" class="headerlink" title="1.3.1、getBeanInfo(JavaBeanDemo.class)：得到StuJavaBeanDemodent的属性,包含它父类Object的属性"></a>1.3.1、getBeanInfo(JavaBeanDemo.class)：得到StuJavaBeanDemodent的属性,包含它父类Object的属性</h5><p><img src="/2019/11/21/JavaBean&EL&JSTL/getBeanInfo1.png"></p><p><img src="/2019/11/21/JavaBean&EL&JSTL/shuchu.png"></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">//输出分析</span><br>java.beans.PropertyDescriptor[<br><span class="hljs-keyword">name</span>=<span class="hljs-keyword">class</span>; <br>propertyType=<span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">Class</span>; <br>readMethod=<span class="hljs-keyword">public</span> final native java.lang.<span class="hljs-keyword">Class</span> java.lang.<span class="hljs-keyword">Object</span>.getClass()<br>]<br>java.beans.PropertyDescriptor[<br><span class="hljs-keyword">name</span>=<span class="hljs-keyword">name</span>; <br>propertyType=<span class="hljs-keyword">class</span> java.lang.<span class="hljs-keyword">String</span>; <br>readMethod=<span class="hljs-keyword">public</span> java.lang.<span class="hljs-keyword">String</span> cn.ant_nest.JavaBean.JavaBeanDemo.getName(); <br>writeMethod=<span class="hljs-keyword">public</span> void cn.ant_nest.JavaBean.JavaBeanDemo.setName(java.lang.<span class="hljs-keyword">String</span>)<br>]<br><span class="hljs-comment">//id不会被输出</span><br></code></pre></td></tr></table></figure><h5 id="1-3-2、getBeanInfo-JavaBeanDemo-class-Object-class-：得到StuJavaBeanDemodent的属性-不包含它父类Object的属性"><a href="#1-3-2、getBeanInfo-JavaBeanDemo-class-Object-class-：得到StuJavaBeanDemodent的属性-不包含它父类Object的属性" class="headerlink" title="1.3.2、getBeanInfo(JavaBeanDemo.class,Object.class)：得到StuJavaBeanDemodent的属性,不包含它父类Object的属性"></a>1.3.2、getBeanInfo(JavaBeanDemo.class,Object.class)：得到StuJavaBeanDemodent的属性,不包含它父类Object的属性</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> testBeanInfo &#123;<br>    @Test<br>    public void test<span class="hljs-constructor">Bean()</span> throws IntrospectionException &#123;<br>        <span class="hljs-comment">//获取一个BeanInfo，就是一个JavaBean的描述器，从Student开始（含），到Object结束（不含）</span><br>        BeanInfo beanInfo= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Introspector</span>.</span></span>get<span class="hljs-constructor">BeanInfo(JavaBeanDemo.<span class="hljs-params">class</span>,Object.<span class="hljs-params">class</span>)</span>;<br>        <span class="hljs-comment">//拿到这个JavaBean的属性描述器</span><br>        PropertyDescriptor<span class="hljs-literal">[]</span> pds=beanInfo.get<span class="hljs-constructor">PropertyDescriptors()</span>;<br>        <span class="hljs-keyword">for</span>(PropertyDescriptor pd:pds)&#123;<br>            <span class="hljs-comment">//获取JavaBean的字段名</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(pd.get<span class="hljs-constructor">Name()</span>);<br>            <span class="hljs-comment">//得到可读写方法</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(pd.get<span class="hljs-constructor">ReadMethod()</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(pd.get<span class="hljs-constructor">WriteMethod()</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*打印输出</span><br><span class="hljs-comment">name</span><br><span class="hljs-comment">public java.lang.String cn.ant_nest.JavaBean.JavaBeanDemo.getName()</span><br><span class="hljs-comment">public void cn.ant_nest.JavaBean.JavaBeanDemo.setName(java.lang.String)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//id不会被输出</span><br></code></pre></td></tr></table></figure><h4 id="1-4、BeanUtils的使用（主要进行属性的拷贝）"><a href="#1-4、BeanUtils的使用（主要进行属性的拷贝）" class="headerlink" title="1.4、BeanUtils的使用（主要进行属性的拷贝）"></a>1.4、BeanUtils的使用（主要进行属性的拷贝）</h4><p>引入：</p><p>​    有人对JavaBean做了一整套的解决实施方案，我们学习一个属性的拷贝，很多框架都是在用这个属性的拷贝的功能，在用这个的还是，需要导入对应的jar包:</p><p>先进行导包:</p><p><strong>①同一个类之间的属性拷贝</strong></p><p><img src="/2019/11/21/JavaBean&EL&JSTL/copy.png"></p><p><strong>②不同类之间属性拷贝</strong></p><p><img src="/2019/11/21/JavaBean&EL&JSTL/copy2.png"></p><p><strong>③把Map里面的元素拷贝到对象中去（但是不能把对象的元素拷贝到map）</strong></p><p><img src="/2019/11/21/JavaBean&EL&JSTL/copy3.png"></p><h3 id="2、EL表达式语言"><a href="#2、EL表达式语言" class="headerlink" title="2、EL表达式语言"></a>2、EL表达式语言</h3><p>JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。</p><h4 id="2-1、EL是啥？"><a href="#2-1、EL是啥？" class="headerlink" title="2.1、EL是啥？"></a>2.1、EL是啥？</h4><p>EL就表达式语言,可以获取<code>作用域</code>里的共享数据</p><p>作用域：pageContext,request,session,application</p><h4 id="2-2、EL的使用"><a href="#2-2、EL的使用" class="headerlink" title="2.2、EL的使用"></a>2.2、EL的使用</h4><p>想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">&lt;%@ page isELIgnored =<span class="hljs-string">&quot;true|false&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><p>这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。</p><p><strong>以下是EL的使用举例：</strong></p><p><strong>1、User.java</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.ant_nest.JavaBean;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> pwd;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getPwd</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> pwd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setPwd</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> pwd</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pwd = pwd;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、LoginServlet.java</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> cn.ant_nest.<span class="hljs-type">JavaBean</span>;<br><br><span class="hljs-keyword">import</span> cn.ant_nest.<span class="hljs-type">JavaBean</span>.<span class="hljs-type">User</span>;<br><br><span class="hljs-keyword">import</span> javax.servlet.<span class="hljs-type">ServletException</span>;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.<span class="hljs-type">WebServlet</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServlet</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServletRequest</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServletResponse</span>;<br><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">IOException</span>;<br><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">UnsupportedEncodingException</span>;<br><br><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/LoginServlet&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span>, <span class="hljs-type">ServletException</span> &#123;<br>        <span class="hljs-comment">//设置编码</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">//接收参数</span><br>        <span class="hljs-type">String</span> name=req.getParameter(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">String</span> pwd=req.getParameter(<span class="hljs-string">&quot;pwd&quot;</span>);<br><br>        <span class="hljs-type">User</span> user=<span class="hljs-keyword">new</span> <span class="hljs-type">User</span>();<br>        user.setName(name);<br>        user.setPwd(pwd);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;admin&quot;</span>.equals(name)&amp;&amp;<span class="hljs-string">&quot;123&quot;</span>.equals(pwd))&#123;<br>            <span class="hljs-comment">//登录成功</span><br>            req.getSession().setAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>            <span class="hljs-comment">//登陆成功调整main.jsp</span><br>            resp.sendRedirect(<span class="hljs-string">&quot;main.jsp&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果用户不存在</span><br>        req.setAttribute(<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-string">&quot;登录失败&quot;</span>);<br>        req.getRequestDispatcher(<span class="hljs-string">&quot;login.jsp&quot;</span>).forward(req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在Servlet中可以用上面代码中的方法设置和访问作用域的属性，在JSP中：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;jsp:useBean id=&quot;box&quot; scope=&quot;page&quot; <span class="hljs-keyword">class</span>=&quot;cn.ant_nest.JavaBean.User&quot;&gt;<br>&lt;jsp:setProperty <span class="hljs-type">name</span>=&quot;box&quot; property=&quot;name&quot; <span class="hljs-keyword">value</span>=&quot;Kongwei-Liao&quot;/&gt;<br>&lt;/jsp:useBean&gt;<br><br>$&#123;<span class="hljs-type">box</span>.name&#125;<br><br>&lt;%<br>    <span class="hljs-keyword">out</span>.println(pageContext.getAttribute(&quot;box&quot;));//&quot;box.name&quot;这里行不通，显示出来的是<span class="hljs-keyword">null</span><br>%&gt;<br><br>&lt;%<span class="hljs-comment">--浏览器页面显示的是：</span><br>Kongwei-Liao<br>cn.ant_nest.JavaBean.<span class="hljs-keyword">User</span>@<span class="hljs-number">1584</span>c339<br><span class="hljs-comment">--%&gt;</span><br></code></pre></td></tr></table></figure><p><strong>3、login.jsp</strong></p></blockquote><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="vbscript">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="vbscript">&lt;%--&lt;%=<span class="hljs-built_in">request</span>.getAttribute(<span class="hljs-string">&quot;error&quot;</span>)==<span class="hljs-literal">null</span>?<span class="hljs-string">&quot;&quot;</span>:<span class="hljs-built_in">request</span>.getAttribute(<span class="hljs-string">&quot;error&quot;</span>)%&gt;</span><span class="xml">--%&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>$&#123;error&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;LoginServlet&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span></span><br><span class="xml">    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="xml">    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>4、main.jsp</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xquery">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">欢迎您$</span><span class="xquery">&#123;user<span class="hljs-built_in">.name</span>&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p> <img src="/2019/11/21/JavaBean&EL&JSTL/el.png"></p><p><strong>注：</strong>如果浏览器上直接显示的是EL表达式，而不是表达式的值，将web.xml的内容替换成以下内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee</span></span><br><span class="hljs-tag"><span class="hljs-string">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-3、EL在四大作用域的取值"><a href="#2-3、EL在四大作用域的取值" class="headerlink" title="2.3、EL在四大作用域的取值"></a>2.3、EL在四大作用域的取值</h4><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="vbscript">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="vbscript">&lt;%</span><br><span class="vbscript">    pageContext.setAttribute(<span class="hljs-string">&quot;pageInfo&quot;</span>,<span class="hljs-string">&quot;page中的值&quot;</span>);</span><br><span class="vbscript">    <span class="hljs-built_in">request</span>.setAttribute(<span class="hljs-string">&quot;requestInfo&quot;</span>,<span class="hljs-string">&quot;request中的值&quot;</span>);</span><br><span class="vbscript">    session.setAttribute(<span class="hljs-string">&quot;sessionInfo&quot;</span>,<span class="hljs-string">&quot;session中的值&quot;</span>);</span><br><span class="vbscript">    application.setAttribute(<span class="hljs-string">&quot;applicationInfo&quot;</span>,<span class="hljs-string">&quot;application中的值&quot;</span>);</span><br><span class="vbscript">%&gt;</span><br><span class="xml">$&#123;pageInfo&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="xml">$&#123;requestInfo&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="xml">$&#123;sessionInfo&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><span class="xml">$&#123;applicationInfo&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/JavaBean&EL&JSTL/el1.png"></p><h5 id="2-3-1、EL取值的顺序："><a href="#2-3-1、EL取值的顺序：" class="headerlink" title="2.3.1、EL取值的顺序："></a>2.3.1、EL取值的顺序：</h5><p>在作用域范围我们的名字取成一样了,怎么去找到特定的一个作用域中的值呢?</p><p><img src="/2019/11/21/JavaBean&EL&JSTL/el2.png"></p><p>结论：它查询找的顺序：从小至大，先取小的范围的值，小的没有，在取到大的范围的值</p><p>pageContext–&gt;request–&gt;session–&gt;application</p><h5 id="2-3-2、不同作用域间属性名冲突解决"><a href="#2-3-2、不同作用域间属性名冲突解决" class="headerlink" title="2.3.2、不同作用域间属性名冲突解决"></a>2.3.2、不同作用域间属性名冲突解决</h5><p>以后我们常用的是request和session，有时候，如果没有一个规范的时候，我们取的名字会重复，使用下面的第一种解决方案。</p><p><strong>第一种解决方案：</strong>前面添加一个前缀，确定到哪个作用域拿，比如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;pageScope.Info&#125;</span><br><span class="hljs-variable">$&#123;requestScope.Info&#125;</span><br><span class="hljs-variable">$&#123;sessionScope.Info&#125;</span><br><span class="hljs-variable">$&#123;applicationScope.Info&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/JavaBean&EL&JSTL/el3.png"></p><p><strong>第二种解决方案：</strong>名字规范 比如：XXX_IN_SESSION  </p><h4 id="2-4、EL的注意事项"><a href="#2-4、EL的注意事项" class="headerlink" title="2.4、EL的注意事项"></a>2.4、EL的注意事项</h4><p>1、</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">session.setAttribute(<span class="hljs-string">&quot;KEY.IN.SESSION&quot;</span>, <span class="hljs-string">&quot;你是session&quot;</span>);<br><span class="hljs-variable">$&#123;</span>KEY.IN.SESSION&#125;&lt;<span class="hljs-string">%--</span>取不到值--%&gt;<br><span class="hljs-variable">$&#123;</span>sessionScope.KEY.IN.SESSION&#125;&lt;<span class="hljs-string">%--</span>取不到值--%&gt;<br><span class="hljs-variable">$&#123;</span>sessionScope[<span class="hljs-string">&quot;KEY.IN.SESSION&quot;</span>]&#125;&lt;<span class="hljs-string">%--</span>OK哒！取的到值--%&gt;<br></code></pre></td></tr></table></figure><p>2、</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">$</span><span class="hljs-template-variable">&#123;pageContext.request.contextPath&#125;</span><span class="xml">&lt;%--拿到上下文路径--%&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;pageContext.request.contextPath&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">/***&quot;</span>&gt;</span>XXX<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>3、Tomcat7之后EL表达式可以调用方法：</p><p>之前2.2节中给session对象传了一个User类对象user，我们这里调用里面的getName方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;user.getName()&#125;</span><br></code></pre></td></tr></table></figure><p>4、JavaBean的取值方式</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">$&#123;<span class="hljs-keyword">user</span>.<span class="hljs-keyword">user</span>Info&#125;<span class="hljs-variable">&lt;%--相当于调用getUserInfo()--%&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/JavaBean&EL&JSTL/huoqu.png"></p><h4 id="2-5、EL的其它特性"><a href="#2-5、EL的其它特性" class="headerlink" title="2.5、EL的其它特性"></a>2.5、EL的其它特性</h4><h5 id="2-5-1、EL算术运算符"><a href="#2-5-1、EL算术运算符" class="headerlink" title="2.5.1、EL算术运算符"></a>2.5.1、EL算术运算符</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;1+2&#125;</span> <span class="hljs-variable">$&#123;2-1&#125;</span> <span class="hljs-variable">$&#123;2*3&#125;</span> <span class="hljs-variable">$&#123;16/5&#125;</span> <span class="hljs-variable">$&#123;16%5&#125;</span><br></code></pre></td></tr></table></figure><h5 id="2-5-2、EL-关系运算符"><a href="#2-5-2、EL-关系运算符" class="headerlink" title="2.5.2、EL 关系运算符"></a>2.5.2、EL 关系运算符</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>&#123;<span class="hljs-number">16</span>&gt;<span class="hljs-number">5</span>&#125; 或<span class="hljs-symbol">$</span>&#123;<span class="hljs-number">16</span> <span class="hljs-keyword">gt</span> <span class="hljs-number">5</span>&#125;<br><span class="hljs-symbol">$</span>&#123;<span class="hljs-number">16</span>&lt;<span class="hljs-number">5</span>&#125; 或<span class="hljs-symbol">$</span>&#123;<span class="hljs-number">16</span> <span class="hljs-keyword">lt</span> <span class="hljs-number">5</span>&#125;<br><span class="hljs-symbol">$</span>&#123;<span class="hljs-number">16</span>&gt;=<span class="hljs-number">5</span>&#125; 或<span class="hljs-symbol">$</span>&#123;<span class="hljs-number">16</span> <span class="hljs-keyword">ge</span> <span class="hljs-number">5</span>&#125;<br><span class="hljs-symbol">$</span>&#123;<span class="hljs-number">16</span>&lt;=<span class="hljs-number">5</span>&#125; 或<span class="hljs-symbol">$</span>&#123;<span class="hljs-number">16</span> <span class="hljs-keyword">le</span> <span class="hljs-number">5</span>&#125;<br><span class="hljs-symbol">$</span>&#123;<span class="hljs-number">1</span>=<span class="hljs-number">2</span>&#125; 或<span class="hljs-symbol">$</span>&#123;<span class="hljs-number">1</span> <span class="hljs-keyword">eq</span> <span class="hljs-number">2</span>&#125;<br><span class="hljs-symbol">$</span>&#123;<span class="hljs-number">2</span>!=<span class="hljs-number">1</span>&#125; 或<span class="hljs-symbol">$</span>&#123;<span class="hljs-number">2</span> <span class="hljs-keyword">ne</span> <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-3、EL-逻辑运算符"><a href="#2-5-3、EL-逻辑运算符" class="headerlink" title="2.5.3、EL 逻辑运算符"></a>2.5.3、EL 逻辑运算符</h5><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$&#123;</span><span class="hljs-keyword">true</span> &amp;&amp; <span class="hljs-keyword">true</span>&#125;结果 <span class="hljs-keyword">true</span><br><span class="hljs-variable">$&#123;</span><span class="hljs-keyword">true</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">true</span>&#125; 结果<span class="hljs-keyword">true</span><br><br><span class="hljs-variable">$&#123;</span><span class="hljs-keyword">true</span> || <span class="hljs-keyword">false</span>&#125; 结果 <span class="hljs-keyword">true</span><br><span class="hljs-variable">$&#123;</span><span class="hljs-keyword">true</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">false</span>&#125; 结果 <span class="hljs-keyword">true</span><br><br><span class="hljs-variable">$&#123;</span>!<span class="hljs-keyword">true</span>&#125; 结果<span class="hljs-keyword">false</span><br><span class="hljs-variable">$&#123;</span><span class="hljs-keyword">not</span> <span class="hljs-keyword">true</span>&#125; 结果<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><h5 id="2-5-4、EL-其他运算符"><a href="#2-5-4、EL-其他运算符" class="headerlink" title="2.5.4、EL 其他运算符"></a>2.5.4、EL 其他运算符</h5><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">$&#123;empty <span class="hljs-built_in">param</span>.<span class="hljs-built_in">name</span>&#125; 如果<span class="hljs-built_in">param</span>.<span class="hljs-built_in">name</span> 为空 返回<span class="hljs-literal">true</span> 否则<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h5 id="2-5-5、EL-三目运算符"><a href="#2-5-5、EL-三目运算符" class="headerlink" title="2.5.5、EL 三目运算符"></a>2.5.5、EL 三目运算符</h5><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$&#123;</span>A?<span class="hljs-symbol">B:</span>C&#125; 比如 <span class="hljs-variable">$&#123;</span>user.sex?<span class="hljs-string">&quot;男&quot;</span><span class="hljs-symbol">:<span class="hljs-string">&quot;女&quot;</span></span>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6、EL隐含对象"><a href="#2-6、EL隐含对象" class="headerlink" title="2.6、EL隐含对象"></a>2.6、EL隐含对象</h4><p>JSP EL支持下表列出的隐含对象：</p><table><thead><tr><th align="left"><strong>隐含对象</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">pageScope</td><td align="left">page 作用域</td></tr><tr><td align="left">requestScope</td><td align="left">request 作用域</td></tr><tr><td align="left">sessionScope</td><td align="left">session 作用域</td></tr><tr><td align="left">applicationScope</td><td align="left">application 作用域</td></tr><tr><td align="left">param</td><td align="left"><code>Request 对象</code>的参数，字符串</td></tr><tr><td align="left">paramValues</td><td align="left"><code>Request对象</code>的参数，字符串集合</td></tr><tr><td align="left">header</td><td align="left">HTTP 信息头，字符串</td></tr><tr><td align="left">headerValues</td><td align="left">HTTP 信息头，字符串集合</td></tr><tr><td align="left">initParam</td><td align="left">上下文初始化参数</td></tr><tr><td align="left">cookie</td><td align="left">Cookie值</td></tr><tr><td align="left">pageContext</td><td align="left">当前页面的pageContext</td></tr></tbody></table><h5 id="2-6-1、pageContext对象"><a href="#2-6-1、pageContext对象" class="headerlink" title="2.6.1、pageContext对象"></a>2.6.1、pageContext对象</h5><p>pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;pageContext.request.queryString&#125;</span><br></code></pre></td></tr></table></figure><h5 id="2-6-2、Scope对象"><a href="#2-6-2、Scope对象" class="headerlink" title="2.6.2、Scope对象"></a>2.6.2、Scope对象</h5><p>pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。<br>举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。</p><h5 id="2-6-3、param和paramValues对象"><a href="#2-6-3、param和paramValues对象" class="headerlink" title="2.6.3、param和paramValues对象"></a>2.6.3、param和paramValues对象</h5><p>param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。<br>接下来的例子表明了如何访问<code>request对象</code>中的username参数：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt;</span><br><span class="hljs-params">&lt;%</span><br><span class="hljs-params">    String title = &quot;Accessing Request Param&quot;;</span><br><span class="hljs-params">%&gt;</span><br><span class="hljs-params">&lt;html&gt;</span><br><br><span class="hljs-params">&lt;head&gt;</span><br><span class="hljs-params">&lt;title&gt;</span><span class="hljs-params">&lt;% out.print(title); %&gt;</span><span class="hljs-params">&lt;/title&gt;</span><br><span class="hljs-params">&lt;/head&gt;</span><br><br><span class="hljs-params">&lt;body&gt;</span><br><br><span class="hljs-params">&lt;center&gt;</span><br><span class="hljs-params">&lt;h1&gt;</span><span class="hljs-params">&lt;% out.print(title); %&gt;</span><span class="hljs-params">&lt;/h1&gt;</span><br><span class="hljs-params">&lt;/center&gt;</span><br><span class="hljs-params">&lt;div align=&quot;center&quot;&gt;</span><br><span class="hljs-params">&lt;p&gt;</span>$&#123;param[<span class="hljs-string">&quot;username&quot;</span>]&#125;<span class="hljs-params">&lt;/p&gt;</span><br><span class="hljs-params">&lt;/div&gt;</span><br><br><span class="hljs-params">&lt;/body&gt;</span><br><span class="hljs-params">&lt;/html&gt;</span><br></code></pre></td></tr></table></figure><p>param对象返回单一的字符串，而paramValues对象则返回一个字符串数组。</p><h5 id="2-6-4、header和headerValues对象"><a href="#2-6-4、header和headerValues对象" class="headerlink" title="2.6.4、header和headerValues对象"></a>2.6.4、header和headerValues对象</h5><p>header和headerValues对象用来访问信息头，通过使用 request.getHeader方法和request.getHeaders方法。<br>举例来说，要访问一个名为user-agent的信息头，可以这样使用表达式：${header.user-agent}，或者${header[“user-agent”]}。<br>接下来的例子表明了如何访问user-agent信息头：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;%@ page import=&quot;java.io.*,java.util.*&quot; %&gt;</span><br><span class="hljs-params">&lt;%</span><br><span class="hljs-params">    String title = &quot;User Agent Example&quot;;</span><br><span class="hljs-params">%&gt;</span><br><span class="hljs-params">&lt;html&gt;</span><br><br><span class="hljs-params">&lt;head&gt;</span><br><span class="hljs-params">&lt;title&gt;</span><span class="hljs-params">&lt;% out.print(title); %&gt;</span><span class="hljs-params">&lt;/title&gt;</span><br><span class="hljs-params">&lt;/head&gt;</span><br><br><span class="hljs-params">&lt;body&gt;</span><br><br><span class="hljs-params">&lt;center&gt;</span><br><span class="hljs-params">&lt;h1&gt;</span><span class="hljs-params">&lt;% out.print(title); %&gt;</span><span class="hljs-params">&lt;/h1&gt;</span><br><span class="hljs-params">&lt;/center&gt;</span><br><span class="hljs-params">&lt;div align=&quot;center&quot;&gt;</span><br><span class="hljs-params">&lt;p&gt;</span>$&#123;header[<span class="hljs-string">&quot;user-agent&quot;</span>]&#125;<span class="hljs-params">&lt;/p&gt;</span><br><span class="hljs-params">&lt;/div&gt;</span><br><br><span class="hljs-params">&lt;/body&gt;</span><br><span class="hljs-params">&lt;/html&gt;</span><br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2019/11/21/JavaBean&EL&JSTL/res.png"></p><h3 id="3、JSTL"><a href="#3、JSTL" class="headerlink" title="3、JSTL"></a><a href="https://www.runoob.com/jsp/jsp-jstl.html">3、JSTL</a></h3><p>使用JSTL帮助我们我们去消除Java代码，比如可以消除 &lt;% … %&gt;这里面的内容</p><p>JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。</p><p>JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。</p><p>根据JSTL标签所提供的功能，可以将其分为5个类别。</p><blockquote><ul><li>核心标签 </li><li>格式化标签</li><li>SQL 标签 </li><li>XML 标签 </li><li>JSTL 函数</li></ul></blockquote><h4 id="3-1、JSTL是啥？"><a href="#3-1、JSTL是啥？" class="headerlink" title="3.1、JSTL是啥？"></a>3.1、JSTL是啥？</h4><p>JSTL: 标准标签库, 由<code>标签库</code>和<code>EL表达式语言</code>两个部分组成，可用来消除JAVA代码；</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">&lt;<span class="hljs-comment">%</span><br>int age = <span class="hljs-number">23</span>;<br>if(age&gt;<span class="hljs-number">18</span>)&#123;<br><span class="hljs-comment">%&gt;</span><br>你真棒！<br>&lt;<span class="hljs-comment">%</span><br>&#125;<br><span class="hljs-comment">%&gt;</span><br></code></pre></td></tr></table></figure><p>可以将上面的代码变成标签：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;c:if test=&quot;age&gt;</span>18&quot;&gt;<br>你真棒！<br><span class="hljs-attribute">&lt;/c:if&gt;</span><br>或<br><span class="hljs-attribute">&lt;如果 表达式=&quot;age&gt;</span>18&quot;&gt;<br>你真棒！<br><span class="hljs-attribute">&lt;/如果&gt;</span><br></code></pre></td></tr></table></figure><p>但是这个标签不能随便写，Java已经帮我们统一了一套标签，叫做JSTL；</p><p>所以要使用JSTL，必须使用标签，所以也必须导入Java提供好的标签库</p><h4 id="3-2、使用JSTL标签库"><a href="#3-2、使用JSTL标签库" class="headerlink" title="3.2、使用JSTL标签库"></a>3.2、使用JSTL标签库</h4><p>第一步：导Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第二步：引用JSTL标签库</p><p><img src="/2019/11/21/JavaBean&EL&JSTL/JSTL.png"></p><p>我们学习的是core标签库:需在进行导入:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;<span class="hljs-meta">%</span>@ taglib uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-meta">%</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/JavaBean&EL&JSTL/jstl1.png"></p><h4 id="3-3、核心标签库"><a href="#3-3、核心标签库" class="headerlink" title="3.3、核心标签库"></a>3.3、核心标签库</h4><p><img src="/2019/11/21/JavaBean&EL&JSTL/bao.png"></p><h5 id="3-3-1、if标签（判断）"><a href="#3-3-1、if标签（判断）" class="headerlink" title="3.3.1、if标签（判断）"></a>3.3.1、if标签（判断）</h5><p><img src="/2019/11/21/JavaBean&EL&JSTL/jstl1.png"></p><h5 id="3-3-2、choose标签（选择）"><a href="#3-3-2、choose标签（选择）" class="headerlink" title="3.3.2、choose标签（选择）"></a>3.3.2、choose标签（选择）</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">c:choose</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">c:when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;age&lt;=18&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">        </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">c:when</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">c:when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;age&gt;18&amp;&amp;age&lt;60&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">        </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">c:when</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">c:otherwise</span>&gt;</span></span><br><span class="xml">        </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">c:otherwise</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">c:choose</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="3-3-3、c-set、c-out和c-remove标签"><a href="#3-3-3、c-set、c-out和c-remove标签" class="headerlink" title="3.3.3、c:set、c:out和c:remove标签"></a>3.3.3、c:set、c:out和c:remove标签</h5><p>scope取值：[session,page,request,application]</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;c:<span class="hljs-builtin-name">set</span> <span class="hljs-attribute">var</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;session&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;ZhangSan&quot;</span>/&gt;<br>&lt;c:out <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;name&#125;</span>&quot;</span>/&gt;<br>&lt;c:<span class="hljs-builtin-name">remove</span> <span class="hljs-attribute">var</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;session&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h5 id="3-3-4、c-url标签"><a href="#3-3-4、c-url标签" class="headerlink" title="3.3.4、c:url标签"></a>3.3.4、c:url标签</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">c:url</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;login&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">c:param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cm&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">c:url</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;login&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>login1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="3-3-5、forEach标签（循环）"><a href="#3-3-5、forEach标签（循环）" class="headerlink" title="3.3.5、forEach标签（循环）"></a>3.3.5、forEach标签（循环）</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&lt;c:<span class="hljs-keyword">forEach</span> <span class="hljs-keyword">begin</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-keyword">end</span>=<span class="hljs-string">&quot;10&quot;</span> var=<span class="hljs-string">&quot;s&quot;</span>&gt;<br><span class="hljs-variable">$</span>&#123;s&#125;<br>&lt;/c:<span class="hljs-keyword">forEach</span>&gt;<br></code></pre></td></tr></table></figure><blockquote><p>begin:从哪里开始、end：到哪里结束、var：取了名字，放到作用域里面</p><p>forEach的常用用法是从数据库拿数据，展示到页面：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;c:<span class="hljs-keyword">forEach</span> items=<span class="hljs-string">&quot;$&#123;emails&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;e&quot;</span> varStatus=<span class="hljs-string">&quot;s&quot;</span>&gt;<br><span class="hljs-variable">$&#123;s</span>.<span class="hljs-keyword">count</span>&#125;||<span class="hljs-variable">$&#123;e</span>.id&#125;-<span class="hljs-variable">$&#123;e</span>.title&#125;-<span class="hljs-variable">$&#123;e</span>.intro&#125;&lt;<span class="hljs-keyword">br</span>&gt;<br>&lt;/c:<span class="hljs-keyword">forEach</span>&gt;<br></code></pre></td></tr></table></figure><p>items : 要循环的集合(数组)、var :每一个数据的名称</p><p>varStatus: 当前循环的状态（s它是个javabean，里面有属性 index(循环索引，从0开始),count（计数））</p></blockquote><h4 id="lt-frameset-gt-Deprecated-HTML-tag"><a href="#lt-frameset-gt-Deprecated-HTML-tag" class="headerlink" title="&lt;frameset&gt;:Deprecated HTML tag"></a>&lt;frameset&gt;:Deprecated HTML tag</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">frameset</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;20%,80%&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 头部页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/xxx/top.jsp&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 中间区域 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">frameset</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;25%,75%&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/xxx/menu.jsp&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;frame_main&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">frameset</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">frameset</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaBean</tag>
      
      <tag>JSP</tag>
      
      <tag>EL</tag>
      
      <tag>JSTL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet交互与JSP</title>
    <link href="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/"/>
    <url>/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Java-Servlet"><a href="#1、Java-Servlet" class="headerlink" title="1、Java Servlet"></a><a href="https://www.runoob.com/servlet/servlet-tutorial.html">1、Java Servlet</a></h3><h4 id="1-1、Servlet介绍"><a href="#1-1、Servlet介绍" class="headerlink" title="1.1、Servlet介绍"></a>1.1、Servlet介绍</h4><p>Java Servlet 是运行在支持 Java Servlet 规范的解释器的Web 服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p><p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 <strong>Java 企业版的标准组成部分</strong>，Java 企业版是支持<strong>大型开发项目的 Java 类库的扩展版本</strong>。这些类实现 Java Servlet 和 JSP 规范。</p><h5 id="1-1-1、Servlet-执行以下主要任务"><a href="#1-1-1、Servlet-执行以下主要任务" class="headerlink" title="1.1.1、Servlet 执行以下主要任务"></a>1.1.1、Servlet 执行以下主要任务</h5><ul><li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li><li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li><li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li><li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li><li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li></ul><h5 id="1-1-2、Servlet和CGI"><a href="#1-1-2、Servlet和CGI" class="headerlink" title="1.1.2、Servlet和CGI"></a>1.1.2、Servlet和CGI</h5><p>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</p><blockquote><ul><li>性能明显更好。</li><li>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li><li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li><li>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li><li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。</li></ul></blockquote><h4 id="1-2、Servlet架构"><a href="#1-2、Servlet架构" class="headerlink" title="1.2、Servlet架构"></a>1.2、Servlet架构</h4><p>下图显示了 Servlet 在 Web 应用程序中的位置。</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/servlet1.png"></p><h4 id="1-3、Servlet生命周期"><a href="#1-3、Servlet生命周期" class="headerlink" title="1.3、Servlet生命周期:"></a><a href="https://www.runoob.com/servlet/servlet-life-cycle.html">1.3、Servlet生命周期:</a></h4><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><ul><li>Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/lificycle.png"></p><h4 id="正式开始码Servlet前先1-20看Servlet如何配置部署"><a href="#正式开始码Servlet前先1-20看Servlet如何配置部署" class="headerlink" title="正式开始码Servlet前先1.20看Servlet如何配置部署"></a>正式开始码Servlet前先1.20看Servlet如何配置部署</h4><h4 id="1-4、Servlet处理表单数据"><a href="#1-4、Servlet处理表单数据" class="headerlink" title="1.4、Servlet处理表单数据"></a><a href="https://www.runoob.com/servlet/servlet-form-data.html">1.4、Servlet处理表单数据</a></h4><h5 id="1-4-1、客户端向Web服务器发送数据"><a href="#1-4-1、客户端向Web服务器发送数据" class="headerlink" title="1.4.1、客户端向Web服务器发送数据"></a>1.4.1、客户端向Web服务器发送数据</h5><p>以表单形式传递。浏览器使用两种方法传递这些数据，分别是<code>GET</code>和<code>POST</code>方法。</p><p><strong>GET方法:</strong></p><p>GET 方法是默认的从浏览器向 Web 服务器传递数据的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。</p><p>如果您要向服务器传递的是密码或其他的敏感信数据，请不要使用 GET 方法。GET 方法还有大小限制：请求字符串中最多只能有 1024 个字符。</p><p>这些信息使用 <strong>QUERY_STRING  头传递</strong>，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 <strong>doGet() 方法处理这种类型的请求</strong>。</p><p>GET 方法向页面请求发送已编码的用户数据。页面和已编码的数据中间用 ? 字符分隔，如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://www.test.com/hello?key<span class="hljs-number">1</span>=value<span class="hljs-number">1</span>&amp;key<span class="hljs-number">2</span>=value<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>POST方法:</strong></p><p>另一个向后台程序传递信息的比较可靠的方法。POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不是<code>把信息作为 URL</code> 中 ? 字符后的文本字符串进行发送，而是把这些信息作为一个<code>单独的消息</code>。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet 使用 <strong>doPost() 方法处理这种类型的请求</strong>。</p><h5 id="1-4-2、Servlet使用从浏览器传递来的数据"><a href="#1-4-2、Servlet使用从浏览器传递来的数据" class="headerlink" title="1.4.2、Servlet使用从浏览器传递来的数据"></a>1.4.2、Servlet使用从浏览器传递来的数据</h5><p>Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：</p><ul><li><strong>getParameter()：</strong>您可以调用 request.getParameter() 方法来获取表单参数的值。</li><li><strong>getParameterValues()：</strong>如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。</li><li><strong>getParameterNames()：</strong>如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。</li></ul><p><strong>(1)、get方式举例：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs swift">package cn.ant_nest.www;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><br><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/Index&quot;</span> )<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-title">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    protected void doPost(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br>            doGet(request, response);<br>    &#125;<br><br>    protected void doGet(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br><br>        <span class="hljs-comment">// 设置响应内容类型</span><br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><br>        <span class="hljs-type">PrintWriter</span> out <span class="hljs-operator">=</span> response.getWriter();<br>        <span class="hljs-type">String</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&quot;读取表单数据&quot;</span>;<br>        <span class="hljs-comment">// 处理中文</span><br>        <span class="hljs-type">String</span> name <span class="hljs-operator">=</span>new <span class="hljs-type">String</span>(request.getParameter(<span class="hljs-string">&quot;name&quot;</span>).getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//处理表单传递中文信息乱码问题</span><br>        <span class="hljs-type">String</span> docType <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; <span class="hljs-subst">\n</span>&quot;</span>;<br>        out.println(docType <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;html&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;body bgcolor=<span class="hljs-subst">\&quot;</span>#f0f0f0<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;h1 align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/h1&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;ul&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;  &lt;li&gt;&lt;b&gt;站点名&lt;/b&gt;：&quot;</span><br>                <span class="hljs-operator">+</span> name <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;  &lt;li&gt;&lt;b&gt;网址&lt;/b&gt;：&quot;</span><br>                <span class="hljs-operator">+</span> request.getParameter(<span class="hljs-string">&quot;url&quot;</span>) <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;/ul&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;ul&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;  &lt;li&gt;&lt;b&gt;百度标识：&lt;/b&gt;: &quot;</span><br>                <span class="hljs-operator">+</span> request.getParameter(<span class="hljs-string">&quot;baidu&quot;</span>) <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;  &lt;li&gt;&lt;b&gt;Google 标识：&lt;/b&gt;: &quot;</span><br>                <span class="hljs-operator">+</span> request.getParameter(<span class="hljs-string">&quot;google&quot;</span>) <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;  &lt;li&gt;&lt;b&gt;淘宝标识：&lt;/b&gt;: &quot;</span><br>                <span class="hljs-operator">+</span> request.getParameter(<span class="hljs-string">&quot;taobao&quot;</span>) <span class="hljs-operator">+</span> <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;/ul&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; <span class="hljs-keyword">language</span>=&quot;java&quot; %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;form action=&quot;Index&quot; <span class="hljs-keyword">method</span>=&quot;get&quot;&gt;<br>        网址名：&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;text&quot; <span class="hljs-type">name</span>=&quot;name&quot;&gt;<br>        &lt;br /&gt;<br>        网址：&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;text&quot; <span class="hljs-type">name</span>=&quot;url&quot; /&gt;&lt;br&gt;<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-type">name</span>=&quot;baidu&quot; checked=&quot;checked&quot; /&gt; 百度<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-type">name</span>=&quot;google&quot;  /&gt; Google<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-type">name</span>=&quot;taobao&quot; checked=&quot;checked&quot; /&gt; 淘宝<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;submit&quot; <span class="hljs-keyword">value</span>=&quot;提交&quot; /&gt;<br>    &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/get.png"></p><p><strong>（2）、post方式举例：</strong></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/post.png"></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/post1.png"></p><p><strong>（3）、遍历表单元素：</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sas">Enumeration paramNames = request.getParameterNames();//获取所有面单元素名<br><br><span class="hljs-meta">while</span>(paramNames.hasMoreElements()) &#123;<br>String paramName = (String)paramNames.nextElement();<br><span class="hljs-meta">out</span>.p<span class="hljs-meta">rint(</span><span class="hljs-string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> + paramName + <span class="hljs-string">&quot;&lt;/td&gt;\n&quot;</span>);<br>String[] paramValues =<br>request.getParameterValues(paramName);<br>// 读取单个值的数据<br><span class="hljs-meta">if</span> (paramValues.<span class="hljs-meta">length</span> == 1) &#123;<br>String paramValue = paramValues[0];<br><span class="hljs-meta">if</span> (paramValue<span class="hljs-meta">.length(</span>) == 0)<br><span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span><span class="hljs-string">&quot;&lt;td&gt;&lt;i&gt;没有值&lt;/i&gt;&lt;/td&gt;&quot;</span>);<br><span class="hljs-meta">else</span><br><span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span><span class="hljs-string">&quot;&lt;td&gt;&quot;</span> + paramValue + <span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>);<br>&#125; <span class="hljs-meta">else</span> &#123;<br>// 读取多个值的数据<br><span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span><span class="hljs-string">&quot;&lt;td&gt;&lt;ul&gt;&quot;</span>);<br>for(int i=0; i &lt; paramValues.<span class="hljs-meta">length</span>; i++) &#123;<br><span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span><span class="hljs-string">&quot;&lt;li&gt;&quot;</span> + paramValues[i]);<br>&#125;<br><span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span><span class="hljs-string">&quot;&lt;/ul&gt;&lt;/td&gt;&quot;</span>);<br>&#125;<br><span class="hljs-meta">out</span>.p<span class="hljs-meta">rint(</span><span class="hljs-string">&quot;&lt;/tr&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/bianli.png"></p><h4 id="1-5、Servlet于HTTP请求响应"><a href="#1-5、Servlet于HTTP请求响应" class="headerlink" title="1.5、Servlet于HTTP请求响应"></a>1.5、Servlet于HTTP请求响应</h4><p>浏览器请求网页时，它会向 Web 服务器发送特定信息，这些信息不能被直接读取，因为这些信息是作为 <code>HTTP 请求的头</code>的一部分进行传输的。您可以查看 <a href="https://www.runoob.com/http/http-tutorial.html">HTTP 协议</a> 了解更多相关信息。</p><p><strong>（1）、以下是来自于浏览器端的重要头信息：</strong></p><table><thead><tr><th align="left">头信息</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">这个头信息指定浏览器或其他客户端可以处理的 MIME 类型。值 <strong>image/png</strong> 或 <strong>image/jpeg</strong> 是最常见的两种可能值。</td></tr><tr><td align="left">Accept-Charset</td><td align="left">这个头信息指定浏览器可以用来显示信息的字符集。例如 ISO-8859-1。</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">这个头信息指定浏览器知道如何处理的编码类型。值 <strong>gzip</strong> 或 <strong>compress</strong> 是最常见的两种可能值。</td></tr><tr><td align="left">Accept-Language</td><td align="left">这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果。例如，en、en-us、ru 等。</td></tr><tr><td align="left">Authorization</td><td align="left">这个头信息用于客户端在访问受密码保护的网页时识别自己的身份。</td></tr><tr><td align="left">Connection</td><td align="left">这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过<code>（单个请求来检索多个文件？？？）</code>。值 <strong>Keep-Alive</strong> 意味着使用了持续连接。</td></tr><tr><td align="left">Content-Length</td><td align="left">这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。</td></tr><tr><td align="left">Cookie</td><td align="left">这个头信息把之前发送到浏览器的 cookies 返回到服务器。</td></tr><tr><td align="left">Host</td><td align="left">这个头信息指定原始的 URL 中的主机和端口。</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">这个头信息表示只有当页面在指定的日期后已更改时，客户端想要的页面。如果没有新的结果可以使用，服务器会发送一个 304 代码，表示 <strong>Not Modified</strong> 头信息。</td></tr><tr><td align="left">If-Unmodified-Since</td><td align="left">这个头信息是 If-Modified-Since 的对立面，它指定只有当文档早于指定日期时，操作才会成功。</td></tr><tr><td align="left">Referer</td><td align="left">这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。</td></tr><tr><td align="left">User-Agent</td><td align="left">这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。</td></tr></tbody></table><p><strong>（2）、下表总结了从 Web 服务器端返回到浏览器的最有用的 HTTP 1.1 响应报头：</strong></p><table><thead><tr><th align="left">头信息</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Allow</td><td align="left">这个头信息指定服务器支持的请求方法（GET、POST 等）。</td></tr><tr><td align="left">Cache-Control</td><td align="left">这个头信息指定响应文档在何种情况下可以安全地缓存。可能的值有：<strong>public、private</strong> 或 <strong>no-cache</strong> 等。Public 意味着文档是可缓存，Private 意味着文档是单个用户私用文档，且只能存储在私有（非共享）缓存中，no-cache 意味着文档不应被缓存。</td></tr><tr><td align="left">Connection</td><td align="left">这个头信息指示浏览器是否使用持久 HTTP 连接。值 <strong>close</strong> 指示浏览器不使用持久 HTTP 连接，值 <strong>keep-alive</strong> 意味着使用持久连接。</td></tr><tr><td align="left">Content-Disposition</td><td align="left">这个头信息可以让您请求浏览器要求用户以给定名称的文件把响应保存到磁盘。</td></tr><tr><td align="left">Content-Encoding</td><td align="left">在传输过程中，这个头信息指定页面的编码方式。</td></tr><tr><td align="left">Content-Language</td><td align="left">这个头信息表示文档编写所使用的语言。例如，en、en-us、ru 等。</td></tr><tr><td align="left">Content-Length</td><td align="left">这个头信息指示响应中的字节数。只有当浏览器使用持久（keep-alive）HTTP 连接时才需要这些信息。</td></tr><tr><td align="left">Content-Type</td><td align="left">这个头信息提供了响应文档的 MIME（Multipurpose Internet Mail Extension）类型。</td></tr><tr><td align="left">Expires</td><td align="left">这个头信息指定内容过期的时间，在这之后内容不再被缓存。</td></tr><tr><td align="left">Last-Modified</td><td align="left">这个头信息指示文档的最后修改时间。然后，客户端可以缓存文件，并在以后的请求中通过 <strong>If-Modified-Since</strong> 请求头信息提供一个日期。</td></tr><tr><td align="left">Location</td><td align="left">这个头信息应被包含在所有的带有状态码的响应中。在 300s 内，这会通知浏览器文档的地址。浏览器会自动重新连接到这个位置，并获取新的文档。</td></tr><tr><td align="left">Refresh</td><td align="left">这个头信息指定浏览器应该如何尽快请求更新的页面。您可以指定页面刷新的秒数。</td></tr><tr><td align="left">Retry-After</td><td align="left">这个头信息可以与 503（Service Unavailable 服务不可用）响应配合使用，这会告诉客户端多久就可以重复它的请求。</td></tr><tr><td align="left">Set-Cookie</td><td align="left">这个头信息指定一个与页面关联的 cookie。</td></tr></tbody></table><h5 id="1-5-1、Servlet处理浏览器HTTP请求"><a href="#1-5-1、Servlet处理浏览器HTTP请求" class="headerlink" title="1.5.1、Servlet处理浏览器HTTP请求"></a>1.5.1、Servlet处理浏览器HTTP请求</h5><p>通过 <code>HttpServletRequest</code> 对象：</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>Cookie[] getCookies()</strong> 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td></tr><tr><td align="left">2</td><td align="left"><strong>Enumeration getAttributeNames()</strong> 返回一个枚举，包含提供给该请求可用的属性名称。</td></tr><tr><td align="left">3</td><td align="left"><strong>Enumeration getHeaderNames()</strong> 返回一个枚举，包含在该请求中包含的所有的头名。</td></tr><tr><td align="left">4</td><td align="left"><strong>Enumeration getParameterNames()</strong> 返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。</td></tr><tr><td align="left">5</td><td align="left"><strong>HttpSession getSession()</strong> 返回与该请求关联的当前 session 会话，或者<strong>如果请求没有 session 会话，则创建一个。</strong></td></tr><tr><td align="left">6</td><td align="left"><strong>HttpSession getSession(boolean create)</strong> 返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。</td></tr><tr><td align="left">7</td><td align="left"><strong>Locale getLocale()</strong> 基于 Accept-Language 头，返回<strong>客户端接受内容的首选的区域设置</strong>。</td></tr><tr><td align="left">8</td><td align="left"><strong>Object getAttribute(String name)</strong> 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</td></tr><tr><td align="left">9</td><td align="left"><strong>ServletInputStream getInputStream()</strong> 使用 ServletInputStream，以二进制数据形式检索请求的主体。</td></tr><tr><td align="left">10</td><td align="left"><strong>String getAuthType()</strong> 返回用于保护 Servlet 的<strong>身份验证方案的名称</strong>，例如，”BASIC” 或 “SSL”，如果JSP没有受到保护则返回 null。</td></tr><tr><td align="left">11</td><td align="left"><strong>String getCharacterEncoding()</strong> 返回请求主体中使用的字符编码的名称。</td></tr><tr><td align="left">12</td><td align="left"><strong>String getContentType()</strong> 返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td></tr><tr><td align="left">13</td><td align="left"><strong>String getContextPath()</strong> 返回指示请求上下文的请求 URI 部分。</td></tr><tr><td align="left">14</td><td align="left"><strong>String getHeader(String name)</strong> 以字符串形式返回指定的请求头的值。</td></tr><tr><td align="left">15</td><td align="left"><strong>String getMethod()</strong> 返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td></tr><tr><td align="left">16</td><td align="left"><strong>String getParameter(String name)</strong> 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td></tr><tr><td align="left">17</td><td align="left"><strong>String getPathInfo()</strong> 当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td></tr><tr><td align="left">18</td><td align="left"><strong>String getProtocol()</strong> 返回请求协议的名称和版本。</td></tr><tr><td align="left">19</td><td align="left"><strong>String getQueryString()</strong> 返回包含在路径后的请求 URL 中的<strong>查询字符串</strong>。</td></tr><tr><td align="left">20</td><td align="left"><strong>String getRemoteAddr()</strong> 返回发送请求的客户端的互联网协议（IP）地址。</td></tr><tr><td align="left">21</td><td align="left"><strong>String getRemoteHost()</strong> 返回发送请求的客户端的完全限定名称。</td></tr><tr><td align="left">22</td><td align="left"><strong>String getRemoteUser()</strong> 如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td></tr><tr><td align="left">23</td><td align="left"><strong>String getRequestURI()</strong> 从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td></tr><tr><td align="left">24</td><td align="left"><strong>String getRequestedSessionId()</strong> 返回由客户端指定的 session 会话 ID。</td></tr><tr><td align="left">25</td><td align="left"><strong>String getServletPath()</strong> 返回调用 JSP 的请求的 URL 的一部分。</td></tr><tr><td align="left">26</td><td align="left"><strong>String[] getParameterValues(String name)</strong> 返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。</td></tr><tr><td align="left">27</td><td align="left"><strong>boolean isSecure()</strong> 返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。</td></tr><tr><td align="left">28</td><td align="left"><strong>int getContentLength()</strong> 以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td></tr><tr><td align="left">29</td><td align="left"><strong>int getIntHeader(String name)</strong> 返回指定的请求头的值为一个 int 值。</td></tr><tr><td align="left">30</td><td align="left"><strong>int getServerPort()</strong> 返回接收到这个请求的端口号。</td></tr><tr><td align="left">31</td><td align="left"><strong>int getParameterMap()</strong> 将参数封装成 Map 类型。</td></tr></tbody></table><p>HTTP Header 请求实例：</p><p>使用 HttpServletRequest 的 <strong>getHeaderNames()</strong> 和**getHeader()**方法读取 HTTP 头信息。该方法返回一个枚举，包含与当前的 HTTP 请求相关的头信息。使用 <em>hasMoreElements()</em> 方法来确定何时停止，使用 <em>nextElement()</em> 方法来获取每个参数的名称。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> void doGet(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span><br>&#123;<br>    <span class="hljs-comment">// 设置响应内容类型</span><br>    response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><br>    <span class="hljs-type">PrintWriter</span> out <span class="hljs-operator">=</span> response.getWriter();<br>    <span class="hljs-type">String</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP Header 请求实例&quot;</span>;<br>    <span class="hljs-type">String</span> docType <span class="hljs-operator">=</span><span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; <span class="hljs-subst">\n</span>&quot;</span>;<br>    out.println(docType <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;html&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;head&gt;&lt;meta charset=<span class="hljs-subst">\&quot;</span>utf-8<span class="hljs-subst">\&quot;</span>&gt;&lt;title&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;<span class="hljs-subst">\n</span>&quot;</span><span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;body bgcolor=<span class="hljs-subst">\&quot;</span>#f0f0f0<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;h1 align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/h1&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;table width=<span class="hljs-subst">\&quot;</span>100%<span class="hljs-subst">\&quot;</span> border=<span class="hljs-subst">\&quot;</span>1<span class="hljs-subst">\&quot;</span> align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;tr bgcolor=<span class="hljs-subst">\&quot;</span>#949494<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;<span class="hljs-subst">\n</span>&quot;</span><span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;/tr&gt;<span class="hljs-subst">\n</span>&quot;</span>);<br><br>    <span class="hljs-type">Enumeration</span> headerNames <span class="hljs-operator">=</span> request.getHeaderNames();<br><br>    <span class="hljs-keyword">while</span>(headerNames.hasMoreElements()) &#123;<br>        <span class="hljs-type">String</span> paramName <span class="hljs-operator">=</span> (<span class="hljs-type">String</span>)headerNames.nextElement();<br>        out.print(<span class="hljs-string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> <span class="hljs-operator">+</span> paramName <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/td&gt;<span class="hljs-subst">\n</span>&quot;</span>);<br>        <span class="hljs-type">String</span> paramValue <span class="hljs-operator">=</span> request.getHeader(paramName);<br>        out.println(<span class="hljs-string">&quot;&lt;td&gt; &quot;</span> <span class="hljs-operator">+</span> paramValue <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/td&gt;&lt;/tr&gt;<span class="hljs-subst">\n</span>&quot;</span>);<br>    &#125;<br>    out.println(<span class="hljs-string">&quot;&lt;/table&gt;<span class="hljs-subst">\n</span>&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/header.png"></p><h5 id="1-5-2、Servlet服务器HTTP响应"><a href="#1-5-2、Servlet服务器HTTP响应" class="headerlink" title="1.5.2、Servlet服务器HTTP响应"></a>1.5.2、Servlet服务器HTTP响应</h5><p>HTTP 请求和 HTTP 响应消息的格式是类似的，结构如下：</p><ul><li>初始状态行 + 回车换行符（回车+换行）</li><li>零个或多个标题行+回车换行符</li><li>一个空白行，即回车换行符</li><li>一个可选的消息主体，比如文件、查询数据或查询输出</li></ul><p>一个典型的响应如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK<br>Content-Type: text/html<br>Header2: ...<br>...<br>HeaderN: ...<br>  (Blank Line)<br><span class="hljs-meta">&lt;!doctype ...&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。</p><p>设置HTTP响应报头的方法</p><p>通过 <code>HttpServletResponse</code> 对象，在 Servlet 程序中设置 HTTP 响应报头</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>String encodeRedirectURL(String url)</strong> 为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td></tr><tr><td align="left">2</td><td align="left"><strong>String encodeURL(String url)</strong> 对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td></tr><tr><td align="left">3</td><td align="left"><strong>boolean containsHeader(String name)</strong> 返回一个布尔值，指示是否已经设置已命名的响应报头。</td></tr><tr><td align="left">4</td><td align="left"><strong>boolean isCommitted()</strong> 返回一个布尔值，指示响应是否已经提交。</td></tr><tr><td align="left">5</td><td align="left"><strong>void addCookie(Cookie cookie)</strong> 把指定的 cookie 添加到响应。</td></tr><tr><td align="left">6</td><td align="left"><strong>void addDateHeader(String name, long date)</strong> 添加一个带有给定的名称和日期值的响应报头。</td></tr><tr><td align="left">7</td><td align="left"><strong>void addHeader(String name, String value)</strong> 添加一个带有给定的名称和值的响应报头。</td></tr><tr><td align="left">8</td><td align="left"><strong>void addIntHeader(String name, int value)</strong> 添加一个带有给定的名称和整数值的响应报头。</td></tr><tr><td align="left">9</td><td align="left"><strong>void flushBuffer()</strong> 强制任何在缓冲区中的内容被写入到客户端。</td></tr><tr><td align="left">10</td><td align="left"><strong>void reset()</strong> 清除缓冲区中存在的任何数据，包括状态码和头。</td></tr><tr><td align="left">11</td><td align="left"><strong>void resetBuffer()</strong> 清除响应中基础缓冲区的内容，不清除状态码和头。</td></tr><tr><td align="left">12</td><td align="left"><strong>void sendError(int sc)</strong> 使用指定的状态码（通常404）发送错误响应到客户端，并清除缓冲区。</td></tr><tr><td align="left">13</td><td align="left"><strong>void sendError(int sc, String msg)</strong> 使用指定的状态发送错误响应到客户端。</td></tr><tr><td align="left">14</td><td align="left"><strong>void sendRedirect(String location)</strong> 使用指定的重定向位置 URL 发送临时重定向响应到客户端。该方法生成一个 <code>302 响应</code>，连同一个带有新文档 URL 的 <em>Location</em> 头。</td></tr><tr><td align="left">15</td><td align="left"><strong>void setBufferSize(int size)</strong> 为响应主体设置首选的缓冲区大小。</td></tr><tr><td align="left">16</td><td align="left"><strong>void setCharacterEncoding(String charset)</strong> 设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。</td></tr><tr><td align="left">17</td><td align="left"><strong>void setContentLength(int len)</strong> 设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。</td></tr><tr><td align="left">18</td><td align="left"><strong>void setContentType(String type)</strong> 如果响应还未被提交，设置被发送到客户端的响应的内容类型。</td></tr><tr><td align="left">19</td><td align="left"><strong>void setDateHeader(String name, long date)</strong> 设置一个带有给定的名称和日期值的响应报头。</td></tr><tr><td align="left">20</td><td align="left"><strong>void setHeader(String name, String value)</strong> 设置一个带有给定的名称和值的响应报头。</td></tr><tr><td align="left">21</td><td align="left"><strong>void setIntHeader(String name, int value)</strong> 设置一个带有给定的名称和整数值的响应报头。</td></tr><tr><td align="left">22</td><td align="left"><strong>void setLocale(Locale loc)</strong> 如果响应还未被提交，设置响应的区域。</td></tr><tr><td align="left">23</td><td align="left"><strong>void setStatus(int sc)</strong> 为该响应设置状态码。</td></tr></tbody></table><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> void doGet(<span class="hljs-type">HttpServletRequest</span> request,<br>                  <span class="hljs-type">HttpServletResponse</span> response)<br>          <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span><br>&#123;<br>    <span class="hljs-comment">// 设置刷新自动加载时间为 5 秒</span><br>    response.setIntHeader(<span class="hljs-string">&quot;Refresh&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 设置响应内容类型</span><br>    response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>   <br>    <span class="hljs-comment">//使用默认时区和语言环境获得一个日历  </span><br>    <span class="hljs-type">Calendar</span> cale <span class="hljs-operator">=</span> <span class="hljs-type">Calendar</span>.getInstance();  <br>    <span class="hljs-comment">//将Calendar类型转换成Date类型  </span><br>    <span class="hljs-type">Date</span> tasktime<span class="hljs-operator">=</span>cale.getTime();  <br>    <span class="hljs-comment">//设置日期输出的格式  </span><br>    <span class="hljs-type">SimpleDateFormat</span> df<span class="hljs-operator">=</span>new <span class="hljs-type">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);  <br>    <span class="hljs-comment">//格式化输出  </span><br>    <span class="hljs-type">String</span> nowTime <span class="hljs-operator">=</span> df.format(tasktime);<br>    <br>    <span class="hljs-type">PrintWriter</span> out <span class="hljs-operator">=</span> response.getWriter();<br>    <span class="hljs-type">String</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&quot;自动刷新 Header 设置&quot;</span>;<br>    <span class="hljs-type">String</span> docType <span class="hljs-operator">=</span><br>    <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;<span class="hljs-subst">\n</span>&quot;</span>;<br>    out.println(docType <span class="hljs-operator">+</span><br>      <span class="hljs-string">&quot;&lt;html&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>      <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;<span class="hljs-subst">\n</span>&quot;</span><span class="hljs-operator">+</span><br>      <span class="hljs-string">&quot;&lt;body bgcolor=<span class="hljs-subst">\&quot;</span>#f0f0f0<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>      <span class="hljs-string">&quot;&lt;h1 align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/h1&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>      <span class="hljs-string">&quot;&lt;p&gt;当前时间是：&quot;</span> <span class="hljs-operator">+</span> nowTime <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/p&gt;<span class="hljs-subst">\n</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/respon.png"></p><h5 id="1-5-3、HTTP状态码"><a href="#1-5-3、HTTP状态码" class="headerlink" title="1.5.3、HTTP状态码"></a>1.5.3、HTTP状态码</h5><table><thead><tr><th align="left">代码</th><th align="left">消息</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">服务器切换协议。</td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">该请求是完整的，并创建一个新的资源。</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">该请求被接受处理，但是该处理是不完整的。</td></tr><tr><td align="left">203</td><td align="left">Non-authoritative Information</td><td align="left"></td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left"></td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left"></td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">所请求的页面已经转移到一个新的 URL。</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">所请求的页面已经临时转移到一个新的 URL。</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">所请求的页面可以在另一个不同的 URL 下被找到。</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left"></td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left"></td></tr><tr><td align="left">306</td><td align="left"><em>Unused</em></td><td align="left">在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">所请求的页面已经临时转移到一个新的 URL。</td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">服务器不理解请求。</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">所请求的页面需要用户名和密码。</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left"><em>您还不能使用该代码。</em></td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">禁止访问所请求的页面。</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法找到所请求的页面。.</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">在请求中指定的方法是不允许的。</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器只生成一个不被客户端接受的响应。</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">在请求送达之前，您必须使用代理服务器的验证。</td></tr><tr><td align="left">408</td><td align="left">Request Timeout</td><td align="left">请求需要的时间比服务器能够等待的时间长，超时。</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">请求因为冲突无法完成。</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">所请求的页面不再可用。</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">“Content-Length” 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">请求中给出的先决条件被服务器评估为 false。</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">服务器不接受该请求，因为请求实体过大。</td></tr><tr><td align="left">414</td><td align="left">Request-url Too Long</td><td align="left">服务器不接受该请求，因为 URL 太长。当您转换一个 “post” 请求为一个带有长的查询信息的 “get” 请求时发生。</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器不接受该请求，因为媒体类型不被支持。</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">未完成的请求。服务器遇到了一个意外的情况。</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">未完成的请求。服务器不支持所需的功能。</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">未完成的请求。服务器从上游服务器收到无效响应。</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">未完成的请求。服务器暂时超载或死机。</td></tr><tr><td align="left">504</td><td align="left">Gateway Timeout</td><td align="left">网关超时。</td></tr><tr><td align="left">505</td><td align="left">HTTP Version Not Supported</td><td align="left">服务器不支持”HTTP协议”版本。</td></tr></tbody></table><h4 id="1-6、Servlet过滤器"><a href="#1-6、Servlet过滤器" class="headerlink" title="1.6、Servlet过滤器"></a>1.6、Servlet过滤器</h4><p>Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。</p><p>可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet，也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Servlet 过滤器。</p><p>过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。</p><p>当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例。</p><p>Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。</p><h5 id="1-6-1、Servlet-过滤器目的"><a href="#1-6-1、Servlet-过滤器目的" class="headerlink" title="1.6.1、Servlet 过滤器目的"></a>1.6.1、Servlet 过滤器目的</h5><p>Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：</p><ul><li>在客户端的请求访问后端资源之前，拦截这些请求。</li><li>在服务器的响应发送回客户端之前，处理这些响应。</li></ul><h5 id="1-6-2、根据规范建议的各种类型的过滤器"><a href="#1-6-2、根据规范建议的各种类型的过滤器" class="headerlink" title="1.6.2、根据规范建议的各种类型的过滤器"></a>1.6.2、根据规范建议的各种类型的过滤器</h5><ul><li>身份验证过滤器（Authentication Filters）。</li><li>数据压缩过滤器（Data compression Filters）。</li><li>加密过滤器（Encryption Filters）。</li><li>触发资源访问事件过滤器。</li><li>图像转换过滤器（Image Conversion Filters）。</li><li>日志记录和审核过滤器（Logging and Auditing Filters）。</li><li>MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。</li><li>标记化过滤器（Tokenizing Filters）。</li><li>XSL/T 过滤器（XSL/T Filters），转换 XML 内容。</li></ul><h5 id="1-6-3、Servlet-过滤器方法"><a href="#1-6-3、Servlet-过滤器方法" class="headerlink" title="1.6.3、Servlet 过滤器方法"></a><strong>1.6.3、Servlet 过滤器方法</strong></h5><p>过滤器是一个实现了 <code>javax.servlet.Filter</code> 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public void doFilter (ServletRequest, ServletResponse, FilterChain)</strong> <br>该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。</td></tr><tr><td align="left">2</td><td align="left"><strong>public void init(FilterConfig filterConfig)</strong> <br>web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</td></tr><tr><td align="left">3</td><td align="left"><strong>public void destroy()</strong> <br>Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</td></tr></tbody></table><h5 id="1-6-4、FilterConfig-使用"><a href="#1-6-4、FilterConfig-使用" class="headerlink" title="1.6.4、FilterConfig 使用"></a><strong>1.6.4、FilterConfig 使用</strong></h5><p>Filter 的 init 方法中提供了一个 FilterConfig 对象。</p><p>如 web.xml 文件配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.ant_nest.test.LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>Site<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>Ant Nest<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;<span class="hljs-name">f</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 init 方法使用 FilterConfig 对象获取参数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig <span class="hljs-built_in">config</span>)</span> throws ServletException </span>&#123;<br>    <span class="hljs-comment">// 获取初始化参数</span><br>    <span class="hljs-keyword">String</span> site = <span class="hljs-built_in">config</span>.getInitParameter(<span class="hljs-string">&quot;Site&quot;</span>); <br>    <span class="hljs-comment">// 输出初始化参数</span><br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;网站名称: &quot;</span> + site); <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-6-5、Servlet过滤器案例"><a href="#1-6-5、Servlet过滤器案例" class="headerlink" title="1.6.5、Servlet过滤器案例"></a>1.6.5、Servlet过滤器案例</h5><p><strong>1）、DisplayHeader.java</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//导入必需的 java 库</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.Enumeration;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/DisplayHeader&quot;</span>)<br><br><span class="hljs-comment">//扩展 HttpServlet 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisplayHeader</span> <span class="hljs-title">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-comment">// 处理 GET 方法请求的方法</span><br>    <span class="hljs-keyword">public</span> void doGet(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span><br>    &#123;<br>        <span class="hljs-comment">// 设置响应内容类型</span><br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><br>        <span class="hljs-type">PrintWriter</span> out <span class="hljs-operator">=</span> response.getWriter();<br>        <span class="hljs-type">String</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP Header 请求实例&quot;</span>;<br>        <span class="hljs-type">String</span> docType <span class="hljs-operator">=</span><br>                <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; <span class="hljs-subst">\n</span>&quot;</span>;<br>        out.println(docType <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;html&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;head&gt;&lt;meta charset=<span class="hljs-subst">\&quot;</span>utf-8<span class="hljs-subst">\&quot;</span>&gt;&lt;title&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;<span class="hljs-subst">\n</span>&quot;</span><span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;body bgcolor=<span class="hljs-subst">\&quot;</span>#f0f0f0<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;h1 align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/h1&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;table width=<span class="hljs-subst">\&quot;</span>100%<span class="hljs-subst">\&quot;</span> border=<span class="hljs-subst">\&quot;</span>1<span class="hljs-subst">\&quot;</span> align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;tr bgcolor=<span class="hljs-subst">\&quot;</span>#949494<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;th&gt;Header 名称&lt;/th&gt;&lt;th&gt;Header 值&lt;/th&gt;<span class="hljs-subst">\n</span>&quot;</span><span class="hljs-operator">+</span><br>                <span class="hljs-string">&quot;&lt;/tr&gt;<span class="hljs-subst">\n</span>&quot;</span>);<br><br>        <span class="hljs-type">Enumeration</span> headerNames <span class="hljs-operator">=</span> request.getHeaderNames();<br><br>        <span class="hljs-keyword">while</span>(headerNames.hasMoreElements()) &#123;<br>            <span class="hljs-type">String</span> paramName <span class="hljs-operator">=</span> (<span class="hljs-type">String</span>)headerNames.nextElement();<br>            out.print(<span class="hljs-string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> <span class="hljs-operator">+</span> paramName <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/td&gt;<span class="hljs-subst">\n</span>&quot;</span>);<br>            <span class="hljs-type">String</span> paramValue <span class="hljs-operator">=</span> request.getHeader(paramName);<br>            out.println(<span class="hljs-string">&quot;&lt;td&gt; &quot;</span> <span class="hljs-operator">+</span> paramValue <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/td&gt;&lt;/tr&gt;<span class="hljs-subst">\n</span>&quot;</span>);<br>        &#125;<br>        out.println(<span class="hljs-string">&quot;&lt;/table&gt;<span class="hljs-subst">\n</span>&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 处理 POST 方法请求的方法</span><br>    <span class="hljs-keyword">public</span> void doPost(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br>        doGet(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）、index.jsp</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;%<span class="hljs-comment">-- Created by IntelliJ IDEA. --%&gt;</span><br>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; <span class="hljs-keyword">language</span>=&quot;java&quot; %&gt;<br>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;form action=&quot;DisplayHeader&quot; <span class="hljs-keyword">method</span>=&quot;get&quot;&gt;<br>        网址名：&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;text&quot; <span class="hljs-type">name</span>=&quot;name&quot;&gt;<br>        &lt;br /&gt;<br>        网址：&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;text&quot; <span class="hljs-type">name</span>=&quot;url&quot; /&gt;<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-type">name</span>=&quot;baidu&quot; checked=&quot;checked&quot; /&gt; 百度<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-type">name</span>=&quot;google&quot;  /&gt; Google<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-type">name</span>=&quot;taobao&quot; checked=&quot;checked&quot; /&gt; 淘宝<br>        &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;submit&quot; <span class="hljs-keyword">value</span>=&quot;提交&quot; /&gt;<br>    &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>3）、LogFilter.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.ant_nest.Filter;<br><br><span class="hljs-comment">//导入必需的 java 库</span><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">//实现 Filter 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span>  </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig config)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        <span class="hljs-comment">// 获取初始化参数</span><br>        String site = config.getInitParameter(<span class="hljs-string">&quot;Site&quot;</span>);<br><br>        <span class="hljs-comment">// 输出初始化参数</span><br>        System.out.println(<span class="hljs-string">&quot;网站名称: &quot;</span> + site);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> java.io.IOException, ServletException </span>&#123;<br><br>        <span class="hljs-comment">// 输出站点名称</span><br>        System.out.println(<span class="hljs-string">&quot;站点网址：http://Kongwei-Liao.cn&quot;</span>);<br><br>        <span class="hljs-comment">// 把请求传回过滤链</span><br>        chain.doFilter(request,response);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">( )</span></span>&#123;<br>        <span class="hljs-comment">/* 在 Filter 实例被 Web 容器从服务移除之前调用 */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4）、配置web.xml</strong></p><p>上述过滤器适用于所有的 Servlet，因为我们在配置中指定 <strong>/*</strong> 。如果您只想在少数的 Servlet 上应用过滤器，您可以指定一个具体的 Servlet 路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>cn.ant_nest.Filter.LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>Site<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>练习使用过滤器<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/filt.png"></p><h5 id="1-6-6、使用多个过滤器"><a href="#1-6-6、使用多个过滤器" class="headerlink" title="1.6.6、使用多个过滤器"></a>1.6.6、使用多个过滤器</h5><p>Web 应用程序可以根据特定的目的定义若干个不同的过滤器。假设您定义了两个过滤器 <em>AuthenFilter</em> 和 <em>LogFilter</em>。您需要创建一个如下所述的不同的映射，其余的处理与上述所讲解的大致相同：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>cn.ant_nest.Filter.LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>test-param<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>Initialization Paramter<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AuthenFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>cn.ant_nest.Filter.AuthenFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>test-param<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>Initialization Paramter<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AuthenFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-6-7、多个过滤器的顺序"><a href="#1-6-7、多个过滤器的顺序" class="headerlink" title="1.6.7、多个过滤器的顺序"></a>1.6.7、多个过滤器的顺序</h5><p>web.xml 中的 filter-mapping 元素的顺序决定了 Web 容器应用过滤器到 Servlet 的顺序。若要反转过滤器的顺序，您只需要在 web.xml 文件中反转 filter-mapping 元素即可。</p><p>例如，上面的实例将先应用 LogFilter，然后再应用 AuthenFilter，但是下面的实例将颠倒这个顺序：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>AuthenFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>LogFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-6-8、web-xml配置各个结点说明"><a href="#1-6-8、web-xml配置各个结点说明" class="headerlink" title="1.6.8、web.xml配置各个结点说明"></a>1.6.8、web.xml配置各个结点说明</h5><ul><li><p><filter>指定一个过滤器。 </filter></p><ul><li><filter-name>用于为过滤器指定一个名字，该元素的内容不能为空。</filter-name></li><li><filter-class>元素用于指定过滤器的完整的限定类名。</filter-class></li><li><init-param>元素用于为过滤器指定初始化参数，它的子元素<param-name>指定参数的名字，<param-value>指定参数的值。</param-value></param-name></init-param></li><li>在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。</li></ul></li><li><p><filter-mapping>元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径 </filter-mapping></p><ul><li><filter-name>子元素用于设置filter的注册名称。该值必须是在<filter>元素中声明过的过滤器的名字</filter></filter-name></li><li><url-pattern>设置 filter 所拦截的请求路径(过滤器关联的URL样式)</url-pattern></li></ul></li><li><p><servlet-name>指定过滤器所拦截的Servlet名称。</servlet-name></p></li><li><p><dispatcher>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个<dispatcher>子元素用来指定 Filter 对资源的多种调用方式进行拦截。</dispatcher></dispatcher></p></li><li><p><dispatcher>子元素可以设置的值及其意义 </dispatcher></p><ul><li>REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过</li><li>RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li><li>INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li><li>FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li><li>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li></ul></li></ul><h4 id="1-7、Servlet异常处理"><a href="#1-7、Servlet异常处理" class="headerlink" title="1.7、Servlet异常处理"></a><a href="https://www.runoob.com/servlet/servlet-exception-handling.html">1.7、Servlet异常处理</a></h4><p>当一个 Servlet 抛出一个异常时，Web 容器在使用了 exception-type 元素的 <strong>web.xml</strong> 中搜索与抛出异常类型相匹配的配置。</p><p>您必须在 web.xml 中使用 <strong>error-page</strong> 元素来指定对特定<strong>异常</strong> 或 HTTP <strong>状态码</strong> 作出相应的 Servlet 调用。</p><h5 id="1-7-1、web-xml配置"><a href="#1-7-1、web-xml配置" class="headerlink" title="1.7.1、web.xml配置"></a>1.7.1、web.xml配置</h5><p>假设，有一个 <em>ErrorHandler</em> 的 Servlet 在任何已定义的异常或错误出现时被调用。以下将是在 web.xml 中创建的项。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- servlet 定义 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ErrorHandler<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>ErrorHandler<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!-- servlet 映射 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ErrorHandler<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/ErrorHandler<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- error-code 相关的错误页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/ErrorHandler<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>403<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/ErrorHandler<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- exception-type 相关的错误页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exception-type</span>&gt;</span><br>          javax.servlet.ServletException<br>    &lt;/exception-type &gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/ErrorHandler<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exception-type</span>&gt;</span><br>    java.io.IOException<br>    &lt;/exception-type &gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/ErrorHandler<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果您想对所有的异常有一个通用的错误处理程序，那么应该定义下面<code>java.lang.Throwable</code>的 error-page，而不是为每个异常定义单独的 error-page 元素：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;error-page&gt;</span><br>    <span class="hljs-attribute">&lt;exception-type&gt;</span>java.lang.Throwable<span class="hljs-attribute">&lt;/exception-type &gt;</span><br>    <span class="hljs-attribute">&lt;location&gt;</span>/ErrorHandler<span class="hljs-attribute">&lt;/location&gt;</span><br><span class="hljs-attribute">&lt;/error-page&gt;</span><br></code></pre></td></tr></table></figure><p>以下是关于上面的 web.xml 异常处理要注意的点：</p><ul><li>Servlet ErrorHandler 与其他的 Servlet 的定义方式一样，且在 web.xml 中进行配置。</li><li>如果有错误状态代码出现，不管为 404（Not Found 未找到）或 403（Forbidden 禁止），则会调用 ErrorHandler 的 Servlet。</li><li>如果 Web 应用程序抛出 <em>ServletException</em> 或 <em>IOException</em>，那么 Web 容器会调用 ErrorHandler 的 Servlet。</li><li>您可以定义不同的错误处理程序来处理不同类型的错误或异常。上面的实例是非常通用的，希望您能通过实例理解基本的概念。</li></ul><h5 id="1-7-2、请求属性-错误-异常"><a href="#1-7-2、请求属性-错误-异常" class="headerlink" title="1.7.2、请求属性-错误/异常"></a>1.7.2、<code>请求属性</code>-错误/异常</h5><p>以下是错误处理的 Servlet 可以访问的请求属性列表，用来分析错误/异常的性质。</p><table><thead><tr><th align="left">序号</th><th align="left"><code>属性</code> &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>javax.servlet.error.status_code</strong> 该属性给出状态码，状态码可被存储，并在存储为 java.lang.Integer 数据类型后可被分析。</td></tr><tr><td align="left">2</td><td align="left"><strong>javax.servlet.error.exception_type</strong> 该属性给出异常类型的信息，异常类型可被存储，并在存储为 java.lang.Class 数据类型后可被分析。</td></tr><tr><td align="left">3</td><td align="left"><strong>javax.servlet.error.message</strong> 该属性给出确切错误消息的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr><tr><td align="left">4</td><td align="left"><strong>javax.servlet.error.request_uri</strong> 该属性给出有关 URL 调用 Servlet 的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr><tr><td align="left">5</td><td align="left"><strong>javax.servlet.error.exception</strong> 该属性给出异常产生的信息，信息可被存储，并在存储为 java.lang.Throwable 数据类型后可被分析。</td></tr><tr><td align="left">6</td><td align="left"><strong>javax.servlet.error.servlet_name</strong> 该属性给出 Servlet 的名称，名称可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr></tbody></table><h5 id="1-7-3、Servlet错误处理程序"><a href="#1-7-3、Servlet错误处理程序" class="headerlink" title="1.7.3、Servlet错误处理程序"></a>1.7.3、Servlet错误处理程序</h5><p>以下是 Servlet 实例，将应对任何您所定义的错误或异常发生时的错误处理程序。</p><p>本实例让您对 Servlet 中的异常处理有基本的了解，您可以使用相同的概念编写更复杂的异常处理应用程序：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//扩展 HttpServlet 类</span><br><span class="hljs-keyword">public</span> class ErrorHandler extends HttpServlet &#123;<br><br>    <span class="hljs-comment">// 处理 GET 方法请求的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> doGet(HttpServletRequest request, HttpServletResponse response) <span class="hljs-keyword">throws</span> ServletException, IOException<br>    &#123;<br>        Throwable throwable = (Throwable)<br>        request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.exception&quot;</span>);<span class="hljs-comment">//1.7.2的请求属性</span><br>        Integer statusCode = (Integer)<br>        request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.status_code&quot;</span>);<br>        <span class="hljs-keyword">String</span> servletName = (<span class="hljs-keyword">String</span>)<br>        request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.servlet_name&quot;</span>);<br>        <span class="hljs-keyword">if</span> (servletName == <span class="hljs-keyword">null</span>)&#123;<br>            servletName = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">String</span> requestUri = (<span class="hljs-keyword">String</span>)<br>        request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.request_uri&quot;</span>);<br>        <span class="hljs-keyword">if</span> (requestUri == <span class="hljs-keyword">null</span>)&#123;<br>            requestUri = <span class="hljs-string">&quot;Unknown&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 设置响应内容类型</span><br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>    <br>        PrintWriter out = response.getWriter();<br>        <span class="hljs-keyword">String</span> title = <span class="hljs-string">&quot;Error/Exception 信息&quot;</span>;<br>       <br>        <span class="hljs-keyword">String</span> docType = <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>;<br>        out.<span class="hljs-built_in">println</span>(docType +<br>            <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>             <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span> +<br>             <span class="hljs-string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span>);<br>           out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&lt;h1&gt;异常信息实例演示&lt;/h1&gt;&quot;</span>);<br>           <span class="hljs-keyword">if</span> (throwable == <span class="hljs-keyword">null</span> &amp;&amp; statusCode == <span class="hljs-keyword">null</span>)&#123;<br>              out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&lt;h2&gt;错误信息丢失&lt;/h2&gt;&quot;</span>);<br>              out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;请返回 &lt;a href=\&quot;&quot;</span> + <br>            response.encodeURL(<span class="hljs-string">&quot;http://localhost:8080/&quot;</span>) + <br>                <span class="hljs-string">&quot;\&quot;&gt;主页&lt;/a&gt;。&quot;</span>);<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusCode != <span class="hljs-keyword">null</span>) &#123;<br>              out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;错误代码 : &quot;</span> + statusCode);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>               out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&lt;h2&gt;错误信息&lt;/h2&gt;&quot;</span>);<br>              out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Servlet Name : &quot;</span> + servletName + <br>                              <span class="hljs-string">&quot;&lt;/br&gt;&lt;/br&gt;&quot;</span>);<br>              out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;异常类型 : &quot;</span> + <br>                              throwable.getClass( ).getName( ) + <br>                              <span class="hljs-string">&quot;&lt;/br&gt;&lt;/br&gt;&quot;</span>);<br>              out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;请求 URI: &quot;</span> + requestUri + <br>                              <span class="hljs-string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>);<br>              out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;异常信息: &quot;</span> + <br>                                  throwable.getMessage( ));<br>           &#125;<br>           out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&lt;/body&gt;&quot;</span>);<br>           out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 处理 POST 方法请求的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> doPost(HttpServletRequest request,<br>                      HttpServletResponse response)<br>       <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-8、Servlet-Cookies处理"><a href="#1-8、Servlet-Cookies处理" class="headerlink" title="1.8、Servlet Cookies处理"></a>1.8、Servlet Cookies处理</h4><p>Cookie 是存储在客户端计算机上的文本文件，并保留了各种跟踪信息。Java Servlet 显然支持 HTTP Cookie。</p><p>识别返回用户包括三个步骤：</p><ul><li>服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。</li><li>浏览器将这些信息存储在本地计算机上，以备将来使用。</li><li>当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户。</li></ul><p>Cookie 通常设置在 HTTP 头信息中（虽然 JavaScript 也可以直接在浏览器上设置一个 Cookie）。设置 Cookie 的 Servlet 会发送如下的头信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span>: Fri, <span class="hljs-number">04</span> Feb <span class="hljs-number">2000</span> <span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">38</span> GMT<br><span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">9</span> (UNIX) PHP/<span class="hljs-number">4</span>.<span class="hljs-number">0</span>b<span class="hljs-number">3</span><br><span class="hljs-attribute">Set</span>-Cookie: name=xyz; expires=Friday, <span class="hljs-number">04</span>-Feb-<span class="hljs-number">07</span> <span class="hljs-number">22</span>:<span class="hljs-number">03</span>:<span class="hljs-number">38</span> GMT; <br>                 <span class="hljs-attribute">path</span>=/; domain=Kongwei-Liao.cn<br><span class="hljs-attribute">Connection</span>: close<br><span class="hljs-attribute">Content</span>-Type: text/html<br></code></pre></td></tr></table></figure><p>正如您所看到的，Set-Cookie 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。expires 字段是一个指令，告诉浏览器在给定的时间和日期之后”忘记”该 Cookie。</p><p>如果浏览器被配置为存储 Cookie，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器。浏览器的头信息可能如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.0</span><br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>zink.demon.co.uk:1126<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>image/gif, */*<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en<br><span class="hljs-attribute">Accept-Charset</span><span class="hljs-punctuation">: </span>iso-8859-1,*,utf-8<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>name=xyz<br></code></pre></td></tr></table></figure><p>Servlet 就能够通过请求方法 <code>request.getCookies()</code> 访问 Cookie，该方法将返回一个 <em>Cookie</em> 对象的数组。</p><p>以下是在 Servlet 中操作 Cookie 时可使用的有用的方法列表。</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public void setDomain(String pattern)</strong> 该方法设置 cookie 适用的域，例如 runoob.com。</td></tr><tr><td align="left">2</td><td align="left"><strong>public String getDomain()</strong> 该方法获取 cookie 适用的域，例如 runoob.com。</td></tr><tr><td align="left">3</td><td align="left"><strong>public void setMaxAge(int expiry)</strong> 该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td></tr><tr><td align="left">4</td><td align="left"><strong>public int getMaxAge()</strong> 该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td></tr><tr><td align="left">5</td><td align="left"><strong>public String getName()</strong> 该方法返回 cookie 的名称。名称在创建后不能改变。</td></tr><tr><td align="left">6</td><td align="left"><strong>public void setValue(String newValue)</strong> 该方法设置与 cookie 关联的值。</td></tr><tr><td align="left">7</td><td align="left"><strong>public String getValue()</strong> 该方法获取与 cookie 关联的值。</td></tr><tr><td align="left">8</td><td align="left"><strong>public void setPath(String uri)</strong> 该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td></tr><tr><td align="left">9</td><td align="left"><strong>public String getPath()</strong> 该方法获取 cookie 适用的路径。</td></tr><tr><td align="left">10</td><td align="left"><strong>public void setSecure(boolean flag)</strong> 该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td></tr><tr><td align="left">11</td><td align="left"><strong>public void setComment(String purpose)</strong> 设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td></tr><tr><td align="left">12</td><td align="left"><strong>public String getComment()</strong> 获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td></tr></tbody></table><p>通过 Servlet 设置 Cookie 的步骤：</p><h5 id="1-8-1、创建一个-Cookie-对象："><a href="#1-8-1、创建一个-Cookie-对象：" class="headerlink" title="1.8.1、创建一个 Cookie 对象："></a><strong>1.8.1、创建一个 Cookie 对象：</strong></h5><p>您可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Cookie cookie</span> = new Cookie(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<br></code></pre></td></tr></table></figure><p>请记住，无论是名字还是值，都不应该包含空格或以下任何字符：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">[ ] ( ) = , <span class="hljs-string">&quot; / ? @ : ;</span><br></code></pre></td></tr></table></figure><h5 id="1-8-2、-设置最大生存周期："><a href="#1-8-2、-设置最大生存周期：" class="headerlink" title="1.8.2、 设置最大生存周期："></a><strong>1.8.2、 设置最大生存周期：</strong></h5><p>您可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）。下面将设置一个最长有效期为 24 小时的 cookie。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cookie</span>.setMaxAge(<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span>); <br></code></pre></td></tr></table></figure><h5 id="1-8-3、-发送-Cookie-到-HTTP-响应头："><a href="#1-8-3、-发送-Cookie-到-HTTP-响应头：" class="headerlink" title="1.8.3、 发送 Cookie 到 HTTP 响应头："></a><strong>1.8.3、 发送 Cookie 到 HTTP 响应头：</strong></h5><p>您可以使用 <strong>response.addCookie</strong> 来添加 HTTP 响应头中的 Cookie，如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">response.add<span class="hljs-constructor">Cookie(<span class="hljs-params">cookie</span>)</span>;<br></code></pre></td></tr></table></figure><h5 id="1-8-4、要读取-Cookie"><a href="#1-8-4、要读取-Cookie" class="headerlink" title="1.8.4、要读取 Cookie"></a><strong>1.8.4、要读取 Cookie</strong></h5><p>您需要通过调用 <em>HttpServletRequest</em> 的 <strong>getCookies( )</strong> 方法创建一个 <em>javax.servlet.http.Cookie</em> 对象的数组。然后循环遍历数组，并使用 getName() 和 getValue() 方法来访问每个 cookie 和关联的值。</p><h5 id="1-8-5、删除Cookie："><a href="#1-8-5、删除Cookie：" class="headerlink" title="1.8.5、删除Cookie："></a><strong>1.8.5、删除Cookie：</strong></h5><p>1、读取一个现有的 cookie；</p><p>2、使用 <strong>setMaxAge()</strong> 方法设置 cookie 的年龄为零</p><p>3、把这个 cookie 添加到响应头。</p><h4 id="1-9、Servlet-Session跟踪"><a href="#1-9、Servlet-Session跟踪" class="headerlink" title="1.9、Servlet Session跟踪"></a>1.9、Servlet Session跟踪</h4><p>HTTP 是一种”无状态”协议，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web 服务器，服务器会自动不保留之前客户端请求的任何记录。</p><p>Servlet 提供了 HttpSession 接口，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。</p><p>Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。</p><h5 id="1-9-1、Session对象获取"><a href="#1-9-1、Session对象获取" class="headerlink" title="1.9.1、Session对象获取"></a>1.9.1、Session对象获取</h5><p>通过调用 HttpServletRequest 的公共方法 <strong>getSession()</strong> 来获取 HttpSession 对象，如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">HttpSession session = request.getSession()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>注：你需要在向客户端发送任何文档内容之前调用 <em>request.getSession()<em>。</em></em>？？？**</p><h5 id="1-9-2、HttpSession-对象中可用的几个重要的方法"><a href="#1-9-2、HttpSession-对象中可用的几个重要的方法" class="headerlink" title="1.9.2、HttpSession 对象中可用的几个重要的方法"></a>1.9.2、HttpSession 对象中可用的几个重要的方法</h5><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public Object getAttribute(String name)</strong> 该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td></tr><tr><td align="left">2</td><td align="left"><strong>public Enumeration getAttributeNames()</strong> 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td></tr><tr><td align="left">3</td><td align="left"><strong>public long getCreationTime()</strong> 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr><tr><td align="left">4</td><td align="left"><strong>public String getId()</strong> 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td></tr><tr><td align="left">5</td><td align="left"><strong>public long getLastAccessedTime()</strong> 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr><tr><td align="left">6</td><td align="left"><strong>public int getMaxInactiveInterval()</strong> 该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td></tr><tr><td align="left">7</td><td align="left"><strong>public void invalidate()</strong> 该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td></tr><tr><td align="left">8</td><td align="left"><strong>public boolean isNew()</strong> 如果<strong>客户端还不知道该 session 会话</strong>，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td></tr><tr><td align="left">9</td><td align="left"><strong>public void removeAttribute(String name)</strong> 该方法将从该 session 会话移除指定名称的对象。</td></tr><tr><td align="left">10</td><td align="left"><strong>public void setAttribute(String name, Object value)</strong>  该方法使用指定的名称绑定一个对象到该 session 会话。</td></tr><tr><td align="left">11</td><td align="left"><strong>public void setMaxInactiveInterval(int interval)</strong> 该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td></tr></tbody></table><h5 id="1-9-3、删除Session会话数据"><a href="#1-9-3、删除Session会话数据" class="headerlink" title="1.9.3、删除Session会话数据"></a>1.9.3、删除Session会话数据</h5><p>当您完成了一个用户的 session 会话数据，您有以下几种选择：</p><ul><li><strong>移除一个特定的属性：</strong>您可以调用 <em>public void removeAttribute(String name)</em> 方法来删除与特定的键相关联的值。</li><li><strong>删除整个 session 会话：</strong>您可以调用 <em>public void invalidate()</em> 方法来丢弃整个 session 会话。</li><li><strong>设置 session 会话过期时间：</strong>您可以调用 <em>public void setMaxInactiveInterval(int interval)</em> 方法来单独设置 session 会话超时。</li><li><strong>注销用户：</strong>如果使用的是支持 servlet 2.4 的服务器，您可以调用 <strong>logout</strong> 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。</li><li><strong>web.xml 配置：</strong>如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面实例中的超时时间是<strong>以分钟为单位</strong>，将覆盖 Tomcat 中默认的 30 分钟超时时间。</p><p>在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，<strong>以秒为单位</strong>。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">WebServlet(<span class="hljs-string">&quot;/SessionTrack&quot;</span>)</span><br>public <span class="hljs-keyword">class</span> SessionTrack extends HttpServlet &#123;<br>    <span class="hljs-keyword">private</span> static final long serialVersionUID = <span class="hljs-number">1L</span>;<br><br>    public void <span class="hljs-keyword">do</span><span class="hljs-constructor">Get(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span> throws ServletException, IOException<br>    &#123;<br>        <span class="hljs-comment">// 如果不存在 session 会话，则创建一个 session 对象</span><br>        HttpSession session = request.get<span class="hljs-constructor">Session(<span class="hljs-params">true</span>)</span>;<br>        <span class="hljs-comment">// 获取 session 创建时间</span><br>        Date createTime = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(<span class="hljs-params">session</span>.<span class="hljs-params">getCreationTime</span>()</span>);<br>        <span class="hljs-comment">// 获取该网页的最后一次访问时间</span><br>        Date lastAccessTime = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(<span class="hljs-params">session</span>.<span class="hljs-params">getLastAccessedTime</span>()</span>);<br><br>        <span class="hljs-comment">//设置日期输出的格式  </span><br>        SimpleDateFormat df=<span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span>;<br><br>        String title = <span class="hljs-string">&quot;Servlet Session 实例 - 菜鸟教程&quot;</span>;<br>        Integer visitCount = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Integer(0)</span>;<br>        String visitCountKey = <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-string">&quot;visitCount&quot;</span>)</span>;<br>        String userIDKey = <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-string">&quot;userID&quot;</span>)</span>;<br>        String userID = <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-string">&quot;Runoob&quot;</span>)</span>;<br>        <span class="hljs-keyword">if</span>(session.get<span class="hljs-constructor">Attribute(<span class="hljs-params">visitCountKey</span>)</span><span class="hljs-operator"> == </span>null) &#123;<br>            session.set<span class="hljs-constructor">Attribute(<span class="hljs-params">visitCountKey</span>, <span class="hljs-params">new</span> Integer(0)</span>);<br>        &#125;<br><br><br>        <span class="hljs-comment">// 检查网页上是否有新的访问者</span><br>        <span class="hljs-keyword">if</span> (session.is<span class="hljs-constructor">New()</span>)&#123;<br>            title = <span class="hljs-string">&quot;Servlet Session 实例 - 菜鸟教程&quot;</span>;<br>            session.set<span class="hljs-constructor">Attribute(<span class="hljs-params">userIDKey</span>, <span class="hljs-params">userID</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            visitCount = (Integer)session.get<span class="hljs-constructor">Attribute(<span class="hljs-params">visitCountKey</span>)</span>;<br>            visitCount = visitCount + <span class="hljs-number">1</span>;<br>            userID = (String)session.get<span class="hljs-constructor">Attribute(<span class="hljs-params">userIDKey</span>)</span>;<br>        &#125;<br>        session.set<span class="hljs-constructor">Attribute(<span class="hljs-params">visitCountKey</span>,  <span class="hljs-params">visitCount</span>)</span>;<br><br>        <span class="hljs-comment">// 设置响应内容类型</span><br>        response.set<span class="hljs-constructor">ContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>)</span>;<br>        PrintWriter out = response.get<span class="hljs-constructor">Writer()</span>;<br><br>        String docType = <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>;<br>        out.println(docType +<br>                <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;h2 align=\&quot;center\&quot;&gt;Session 信息&lt;/h2&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;table border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;id&lt;/td&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;&quot;</span> + session.get<span class="hljs-constructor">Id()</span> + <span class="hljs-string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;创建时间&lt;/td&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;&quot;</span> +  df.format(createTime) +<br>                <span class="hljs-string">&quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;最后访问时间&lt;/td&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;&quot;</span> + df.format(lastAccessTime) +<br>                <span class="hljs-string">&quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;用户 ID&lt;/td&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;&quot;</span> + userID +<br>                <span class="hljs-string">&quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;访问统计：&lt;/td&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;  &lt;td&gt;&quot;</span> + visitCount + <span class="hljs-string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;/table&gt;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-10、Servlet数据库访问"><a href="#1-10、Servlet数据库访问" class="headerlink" title="1.10、Servlet数据库访问"></a>1.10、Servlet数据库访问</h4><p>在 java 项目中，只需要在 Eclipse 中引入 mysql-connector-java-5.1.39-bin.jar 就可以运行java项目。 但是在 Eclipse web 项目中，当执行 Class.forName(“com.mysql.jdbc.Driver”);时不会去查找驱动的。所以本实例中我们需要把 mysql-connector-java-5.1.39-bin.jar 拷贝到<code> tomcat下lib目录</code>。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs processing">@WebServlet(<span class="hljs-string">&quot;/DatabaseAccess&quot;</span>)<br><span class="hljs-keyword">public</span> class DatabaseAccess extends HttpServlet &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1</span>L;<br>    <span class="hljs-comment">// JDBC 驱动名及数据库 URL</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> JDBC_DRIVER = <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> DB_URL = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/Train&quot;</span>;<br>    <br>    <span class="hljs-comment">// 数据库的用户名与密码，需要根据自己的设置</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> USER = <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> PASS = <span class="hljs-string">&quot;123456&quot;</span>; <br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> doGet(HttpServletRequest request, HttpServletResponse response) <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        Statement stmt = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 设置响应内容类型</span><br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        PrintWriter out = response.getWriter();<br>        <span class="hljs-keyword">String</span> title = <span class="hljs-string">&quot;Servlet Mysql 测试&quot;</span>;<br>        <span class="hljs-keyword">String</span> docType = <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>;<br>        out.<span class="hljs-built_in">println</span>(docType +<br>        <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 注册 JDBC 驱动器</span><br>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>            <br>            <span class="hljs-comment">// 打开一个连接</span><br>            conn = DriverManager.getConnection(DB_URL,USER,PASS);<br><br>            <span class="hljs-comment">// 执行 SQL 查询</span><br>            stmt = conn.createStatement();<br>            <span class="hljs-keyword">String</span> sql;<br>            sql = <span class="hljs-string">&quot;SELECT id, name, url FROM websites&quot;</span>;<br>            ResultSet rs = stmt.executeQuery(sql);<br><br>            <span class="hljs-comment">// 展开结果集数据库</span><br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                <span class="hljs-comment">// 通过字段检索</span><br>                <span class="hljs-built_in">int</span> id  = rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                <span class="hljs-keyword">String</span> name = rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>                <span class="hljs-keyword">String</span> url = rs.getString(<span class="hljs-string">&quot;url&quot;</span>);<br>    <br>                <span class="hljs-comment">// 输出数据</span><br>                out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;ID: &quot;</span> + id);<br>                out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;, 站点名称: &quot;</span> + name);<br>                out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;, 站点 URL: &quot;</span> + url);<br>                out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&lt;br /&gt;&quot;</span>);<br>            &#125;<br>            out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br><br>            <span class="hljs-comment">// 完成后关闭</span><br>            rs.close();<br>            stmt.close();<br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span>(SQLException se) &#123;<br>            <span class="hljs-comment">// 处理 JDBC 错误</span><br>            se.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            <span class="hljs-comment">// 处理 Class.forName 错误</span><br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">// 最后是用于关闭资源的块</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">if</span>(stmt!=<span class="hljs-keyword">null</span>)<br>                stmt.close();<br>            &#125;<span class="hljs-keyword">catch</span>(SQLException se2)&#123;<br>            &#125;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)<br>                conn.close();<br>            &#125;<span class="hljs-keyword">catch</span>(SQLException se)&#123;<br>                se.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-11、Servlet文件上传"><a href="#1-11、Servlet文件上传" class="headerlink" title="1.11、Servlet文件上传"></a>1.11、Servlet文件上传</h4><p>Servlet 可以与 HTML form 标签一起使用，来允许用户上传文件到服务器。上传的文件可以是文本文件或图像文件或任何文档。</p><p>需要引入的 jar 文件：commons-fileupload-1.3.2、commons-io-2.5.jar。</p><p><strong>注意：</strong>Servlet3.0 已经内置了文件上传这一特性，开发者不再需要将 Commons FileUpload 组件导入到工程中去。</p><p>案例：</p><h5 id="第一步创建一个文件上传表单"><a href="#第一步创建一个文件上传表单" class="headerlink" title="第一步创建一个文件上传表单"></a>第一步创建一个文件上传表单</h5><ul><li>表单 <strong>method</strong> 属性应该设置为 <strong>POST</strong> 方法，不能使用 GET 方法。</li><li>表单 <strong>enctype</strong> 属性应该设置为 <strong>multipart/form-data</strong>.</li><li>表单 <strong>action</strong> 属性应该设置为在后端服务器上处理文件上传的 Servlet 文件。下面的实例使用了 <strong>UploadServlet</strong> Servlet 来上传文件。</li><li>上传单个文件，您应该使用单个带有属性 type=”file” 的 &lt;input …/&gt; 标签。为了允许多个文件上传，请包含多个 name 属性值不同的 input 标签。输入标签具有不同的名称属性的值。浏览器会为每个 input 标签关联一个浏览按钮。</li></ul><p>upload.jsp代码</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">form</span> method=<span class="hljs-string">&quot;post&quot;</span> action=<span class="hljs-string">&quot;/TomcatTest/UploadServlet&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>    选择一个文件:<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;uploadFile&quot;</span> /&gt;<br>    &lt;<span class="hljs-keyword">br</span>/&gt;&lt;<span class="hljs-keyword">br</span>/&gt;<br>    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;上传&quot;</span> /&gt;<br>&lt;/<span class="hljs-keyword">form</span>&gt;<br></code></pre></td></tr></table></figure><h5 id="第二步编写后台Servlet"><a href="#第二步编写后台Servlet" class="headerlink" title="第二步编写后台Servlet"></a>第二步编写后台Servlet</h5><p>以下是 UploadServlet 的源代码，同于处理文件上传，在这之前我们先确保依赖包已经引入到项目的 WEB-INF/lib 目录下： </p><ul><li>下面的实例依赖于 FileUpload，所以一定要确保在您的 classpath 中有最新版本的 <strong>commons-fileupload.x.x.jar</strong> 文件。可以从 <a href="http://commons.apache.org/proper/commons-fileupload/">http://commons.apache.org/proper/commons-fileupload/</a> 下载。</li><li>FileUpload 依赖于 Commons IO，所以一定要确保在您的 classpath 中有最新版本的 <strong>commons-io-x.x.jar</strong> 文件。可以从 <a href="http://commons.apache.org/proper/commons-io/">http://commons.apache.org/proper/commons-io/</a> 下载。</li></ul><p>你可以直接下载本站提供的两个依赖包：</p><ul><li><a href="http://static.runoob.com/download/commons-fileupload-1.3.2.jar">commons-fileupload-1.3.2.jar</a></li><li><a href="http://static.runoob.com/download/commons-io-2.5.jar">commons-io-2.5.jar</a></li></ul><p>UploadServlet 的源代码 如下所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs gradle">@WebServlet(<span class="hljs-string">&quot;/UploadServlet&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> UploadServlet <span class="hljs-keyword">extends</span> HttpServlet &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1</span>L;<br>     <br>    <span class="hljs-comment">// 上传文件存储目录</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String UPLOAD_DIRECTORY = <span class="hljs-string">&quot;upload&quot;</span>;<br> <br>    <span class="hljs-comment">// 上传配置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MEMORY_THRESHOLD   = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">3</span>;  <span class="hljs-comment">// 3MB</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_FILE_SIZE      = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">40</span>; <span class="hljs-comment">// 40MB</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_REQUEST_SIZE   = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">50</span>; <span class="hljs-comment">// 50MB</span><br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上传数据及保存文件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> doPost(HttpServletRequest request,<br>        HttpServletResponse response) <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 检测是否为多媒体上传</span><br>        <span class="hljs-keyword">if</span> (!ServletFileUpload.isMultipartContent(request)) &#123;<br>            <span class="hljs-comment">// 如果不是则停止</span><br>            PrintWriter writer = response.getWriter();<br>            writer.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;Error: 表单必须包含 enctype=multipart/form-data&quot;</span>);<br>            writer.flush();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br> <br>        <span class="hljs-comment">// 配置上传参数</span><br>        DiskFileItemFactory factory = <span class="hljs-keyword">new</span> DiskFileItemFactory();<br>        <span class="hljs-comment">// 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中</span><br>        factory.setSizeThreshold(MEMORY_THRESHOLD);<br>        <span class="hljs-comment">// 设置临时存储目录</span><br>        factory.setRepository(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(System.getProperty(<span class="hljs-string">&quot;java.io.tmpdir&quot;</span>)));<br> <br>        ServletFileUpload upload = <span class="hljs-keyword">new</span> ServletFileUpload(factory);<br>         <br>        <span class="hljs-comment">// 设置最大文件上传值</span><br>        upload.setFileSizeMax(MAX_FILE_SIZE);<br>         <br>        <span class="hljs-comment">// 设置最大请求值 (包含文件和表单数据)</span><br>        upload.setSizeMax(MAX_REQUEST_SIZE);<br><br>        <span class="hljs-comment">// 中文处理</span><br>        upload.setHeaderEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>); <br><br>        <span class="hljs-comment">// 构造临时路径来存储上传的文件</span><br>        <span class="hljs-comment">// 这个路径相对当前应用的目录</span><br>        String uploadPath = request.getServletContext().getRealPath(<span class="hljs-string">&quot;./&quot;</span>) + <span class="hljs-keyword">File</span>.separator + UPLOAD_DIRECTORY;<br>       <br>         <br>        <span class="hljs-comment">// 如果目录不存在则创建</span><br>        <span class="hljs-keyword">File</span> uploadDir = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(uploadPath);<br>        <span class="hljs-keyword">if</span> (!uploadDir.exists()) &#123;<br>            uploadDir.mkdir();<br>        &#125;<br> <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 解析请求的内容提取文件数据</span><br>            @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>            List&lt;FileItem&gt; formItems = upload.parseRequest(request);<br> <br>            <span class="hljs-keyword">if</span> (formItems != <span class="hljs-keyword">null</span> &amp;&amp; formItems.<span class="hljs-keyword">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 迭代表单数据</span><br>                <span class="hljs-keyword">for</span> (FileItem item : formItems) &#123;<br>                    <span class="hljs-comment">// 处理不在表单中的字段</span><br>                    <span class="hljs-keyword">if</span> (!item.isFormField()) &#123;<br>                        String fileName = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(item.getName()).getName();<br>                        String filePath = uploadPath + <span class="hljs-keyword">File</span>.separator + fileName;<br>                        <span class="hljs-keyword">File</span> storeFile = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(filePath);<br>                        <span class="hljs-comment">// 在控制台输出文件的上传路径</span><br>                        System.out.<span class="hljs-keyword">println</span>(filePath);<br>                        <span class="hljs-comment">// 保存文件到硬盘</span><br>                        item.<span class="hljs-keyword">write</span>(storeFile);<br>                        request.setAttribute(<span class="hljs-string">&quot;message&quot;</span>,<br>                            <span class="hljs-string">&quot;文件上传成功!&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            request.setAttribute(<span class="hljs-string">&quot;message&quot;</span>,<br>                    <span class="hljs-string">&quot;错误信息: &quot;</span> + ex.getMessage());<br>        &#125;<br>        <span class="hljs-comment">// 跳转到 message.jsp</span><br>        request.getServletContext().getRequestDispatcher(<span class="hljs-string">&quot;/message.jsp&quot;</span>).forward(<br>                request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>message.jsp 文件代码如下：</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erb"><span class="xml">&lt;%</span><span class="ruby">@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="ruby">    pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span></span><span class="xml">%&gt;</span><br><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span></span><br><span class="xml">    &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>文件上传结果<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>$&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="1-12、Servlet处理时间"><a href="#1-12、Servlet处理时间" class="headerlink" title="1.12、Servlet处理时间"></a>1.12、Servlet处理时间</h4><p>使用 Servlet 的最重要的优势之一是，可以使用核心 Java 中的大多数可用的方法， Java 提供的 <strong>java.util</strong> 包中的 <strong>Date</strong> 类，这个类封装了当前的日期和时间。</p><h5 id="1-12-1、Date类"><a href="#1-12-1、Date类" class="headerlink" title="1.12.1、Date类"></a>1.12.1、Date类</h5><p>Date 类支持两个构造函数。第一个构造函数初始化当前日期和时间的对象。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Date</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>下面的构造函数接受一个参数，该参数等于 1970 年 1 月 1 日午夜以来经过的毫秒数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Date(<span class="hljs-params">long</span> <span class="hljs-params">millisec</span>)</span><br></code></pre></td></tr></table></figure><p>一旦您有一个可用的 Date 对象，您可以调用下列任意支持的方法来使用日期：</p><h5 id="1-12-2、Date-对象的方法"><a href="#1-12-2、Date-对象的方法" class="headerlink" title="1.12.2、Date 对象的方法"></a>1.12.2、Date 对象的方法</h5><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>boolean after(Date date)</strong> 如果调用的 Date 对象中包含的日期在 date 指定的日期之后，则返回 true，否则返回 false。</td></tr><tr><td align="left">2</td><td align="left"><strong>boolean before(Date date)</strong> 如果调用的 Date 对象中包含的日期在 date 指定的日期之前，则返回 true，否则返回 false。</td></tr><tr><td align="left">3</td><td align="left"><strong>Object clone( )</strong> 重复调用 Date 对象。</td></tr><tr><td align="left">4</td><td align="left"><strong>int compareTo(Date date)</strong> 把调用对象的值与 date 的值进行比较。如果两个值是相等的，则返回 0。如果调用对象在 date 之前，则返回一个负值。如果调用对象在 date 之后，则返回一个正值。</td></tr><tr><td align="left">5</td><td align="left"><strong>int compareTo(Object obj)</strong> 如果 obj 是 Date 类，则操作等同于 compareTo(Date)。否则，它会抛出一个 ClassCastException。</td></tr><tr><td align="left">6</td><td align="left"><strong>boolean equals(Object date)</strong> 如果调用的 Date 对象中包含的时间和日期与 date 指定的相同，则返回 true，否则返回 false。</td></tr><tr><td align="left">7</td><td align="left"><strong>long getTime( )</strong> 返回 1970 年 1 月 1 日以来经过的毫秒数。</td></tr><tr><td align="left">8</td><td align="left"><strong>int hashCode( )</strong> 为调用对象返回哈希代码。</td></tr><tr><td align="left">9</td><td align="left"><strong>void setTime(long time)</strong> 设置 time 指定的时间和日期，这表示从 1970 年 1 月 1 日午夜以来经过的时间（以毫秒为单位）。</td></tr><tr><td align="left">10</td><td align="left"><strong>String toString( )</strong> 转换调用的 Date 对象为一个字符串，并返回结果。</td></tr></tbody></table><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/CurrentDate&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrentDate</span> <span class="hljs-title">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> long serialVersionUID <span class="hljs-operator">=</span> 1L;<br><br>    protected void doGet(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br><br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> out <span class="hljs-operator">=</span> response.getWriter();<br>          <span class="hljs-type">String</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&quot;显示当前的日期和时间&quot;</span>;<br>        <span class="hljs-type">Date</span> date <span class="hljs-operator">=</span> new <span class="hljs-type">Date</span>();<br>        <span class="hljs-type">String</span> docType <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; <span class="hljs-subst">\n</span>&quot;</span>;<br>          out.println(docType <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&lt;html&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&lt;body bgcolor=<span class="hljs-subst">\&quot;</span>#f0f0f0<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&lt;h1 align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/h1&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&lt;h2 align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;&quot;</span> <span class="hljs-operator">+</span> date.toString() <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/h2&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/date" alt="img" style="zoom: 80%;"><h5 id="1-12-3、日期比较"><a href="#1-12-3、日期比较" class="headerlink" title="1.12.3、日期比较"></a>1.12.3、日期比较</h5><ul><li>您可以使用 getTime() 来获取两个对象自 1970 年 1 月 1 日午夜以来经过的时间（以毫秒为单位），然后对这两个值进行比较。</li><li>您可以使用方法 before( )、after( ) 和 equals( )。由于一个月里 12 号在 18 号之前，例如，new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回 true。</li><li>您可以使用 compareTo( ) 方法，该方法由 Comparable 接口定义，由 Date 实现。</li></ul><h5 id="1-12-4、使用SimpleDateFormat格式化日期"><a href="#1-12-4、使用SimpleDateFormat格式化日期" class="headerlink" title="1.12.4、使用SimpleDateFormat格式化日期"></a>1.12.4、使用SimpleDateFormat格式化日期</h5><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和解析日期的具体类。 SimpleDateFormat 允许您选择任何用户定义的日期时间格式化的模式。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Date</span> dNow = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>();<br>SimpleDateFormat ft = <span class="hljs-built_in">new</span> SimpleDateFormat (&quot;yyyy.MM.dd  hh:mm:ss E a &quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(ft.format(dNow));<br></code></pre></td></tr></table></figure><p>使用事件模式字符串来指定时间格式。在这种模式下，所有的 ASCII 字母被保留为模式字母，这些字母定义如下：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">G</td><td align="left">Era 指示器</td><td align="left">AD</td></tr><tr><td align="left">y</td><td align="left">四位数表示的年</td><td align="left">2001</td></tr><tr><td align="left">M</td><td align="left">一年中的月</td><td align="left">July 或 07</td></tr><tr><td align="left">d</td><td align="left">一月中的第几天</td><td align="left">10</td></tr><tr><td align="left">h</td><td align="left">带有 A.M./P.M. 的小时（1~12）</td><td align="left">12</td></tr><tr><td align="left">H</td><td align="left">一天中的第几小时（0~23）</td><td align="left">22</td></tr><tr><td align="left">m</td><td align="left">一小时中的第几分</td><td align="left">30</td></tr><tr><td align="left">s</td><td align="left">一分中的第几秒</td><td align="left">55</td></tr><tr><td align="left">S</td><td align="left">毫秒</td><td align="left">234</td></tr><tr><td align="left">E</td><td align="left">一周中的星期几</td><td align="left">Tuesday</td></tr><tr><td align="left">D</td><td align="left">一年中的第几天</td><td align="left">360</td></tr><tr><td align="left">F</td><td align="left">所在的周是这个月的第几周</td><td align="left">2 (second Wed. in July)</td></tr><tr><td align="left">w</td><td align="left">一年中的第几周</td><td align="left">40</td></tr><tr><td align="left">W</td><td align="left">一月中的第几周</td><td align="left">1</td></tr><tr><td align="left">a</td><td align="left">A.M./P.M. 标记</td><td align="left">PM</td></tr><tr><td align="left">k</td><td align="left">一天中的第几小时（1~24）</td><td align="left">24</td></tr><tr><td align="left">K</td><td align="left">带有 A.M./P.M. 的小时（0~11）</td><td align="left">10</td></tr><tr><td align="left">z</td><td align="left">时区</td><td align="left">Eastern Standard Time</td></tr><tr><td align="left">‘</td><td align="left">Escape for text</td><td align="left">Delimiter</td></tr><tr><td align="left">“</td><td align="left">单引号</td><td align="left">`</td></tr></tbody></table><p>如需查看可用的处理日期方法的完整列表，您可以参考标准的 Java 文档。</p><h4 id="1-13、Servlet网页重定向"><a href="#1-13、Servlet网页重定向" class="headerlink" title="1.13、Servlet网页重定向"></a>1.13、Servlet网页重定向</h4><p>当文档移动到新的位置，我们需要向客户端发送这个新位置时，我们需要用到网页重定向。当然，也可能是为了负载均衡，或者只是为了简单的随机，这些情况都有可能用到网页重定向。</p><h5 id="1-13-1、使用-response-对象的-sendRedirect-方法"><a href="#1-13-1、使用-response-对象的-sendRedirect-方法" class="headerlink" title="1.13.1、使用 response 对象的 sendRedirect() 方法"></a>1.13.1、使用 response 对象的 sendRedirect() 方法</h5><p>重定向请求到另一个网页的最简单的方式是使用 response 对象的 sendRedirect() 方法。下面是该方法的定义：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> HttpServletResponse.sendRedirect(<span class="hljs-keyword">String</span> location)<br><span class="hljs-keyword">throws</span> IOException<br></code></pre></td></tr></table></figure><h5 id="1-13-2、setStatus-和-setHeader-方法一起"><a href="#1-13-2、setStatus-和-setHeader-方法一起" class="headerlink" title="1.13.2、setStatus() 和 setHeader() 方法一起"></a>1.13.2、setStatus() 和 setHeader() 方法一起</h5><p>该方法把响应连同状态码和新的网页位置发送回浏览器。您也可以通过把 setStatus() 和 setHeader() 方法一起使用来达到同样的效果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">....<br>String site = &quot;http://www.baidu.com&quot; ;<br>response.setStatus(response.SC_MOVED_TEMPORARILY);<br>response.setHeader(&quot;Location&quot;, site); <br>....<br></code></pre></td></tr></table></figure><p>本实例显示了 Servlet 如何进行页面重定向到另一个位置：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/PageRedirect&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageRedirect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <br>  public void doGet(<span class="hljs-type">HttpServletRequest</span> request,<br>                    <span class="hljs-type">HttpServletResponse</span> response)<br>            <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span><br>  &#123;<br>      <span class="hljs-comment">// 设置响应内容类型</span><br>      response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><br>      <span class="hljs-comment">// 要重定向的新位置</span><br>      <span class="hljs-type">String</span> site = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">&quot;http://www.runoob.com&quot;</span>);<br><br>      response.setStatus(response.<span class="hljs-type">SC_MOVED_TEMPORARILY</span>);<br>      response.setHeader(<span class="hljs-string">&quot;Location&quot;</span>, site);    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-14、Servlet点击计数器"><a href="#1-14、Servlet点击计数器" class="headerlink" title="1.14、Servlet点击计数器"></a>1.14、Servlet点击计数器</h4><h5 id="1-14-1网页点击计数器："><a href="#1-14-1网页点击计数器：" class="headerlink" title="1.14.1网页点击计数器："></a><strong>1.14.1网页点击计数器：</strong></h5><p>很多时候，您可能有兴趣知道网站的某个特定页面上的总点击量。使用 Servlet 来计算这些点击量是非常简单的，因为一个 Servlet 的生命周期是由它运行所在的容器控制的。</p><p>以下是实现一个简单的基于 Servlet 生命周期的网页点击计数器需要采取的步骤：</p><ul><li>在 init() 方法中初始化一个全局变量。</li><li>每次调用 doGet() 或 doPost() 方法时，都增加全局变量。</li><li>如果需要，您可以使用一个数据库表来存储全局变量的值在 destroy() 中。在下次初始化 Servlet 时，该值可在 init() 方法内被读取。这一步是可选的。</li><li>如果您只想对一个 session 会话计数一次页面点击，那么请使用 isNew() 方法来检查该 session 会话是否已点击过相同页面。这一步是可选的。</li><li>您可以通过显示全局计数器的值，来在网站上展示页面的总点击量。这一步是可选的。</li></ul><p>在这里，我们假设 Web 容器将无法重新启动。如果是重新启动或 Servlet 被销毁，计数器将被重置。</p><h5 id="1-14-2、网站点击计数器："><a href="#1-14-2、网站点击计数器：" class="headerlink" title="1.14.2、网站点击计数器："></a><strong>1.14.2、网站点击计数器</strong>：</h5><p>很多时候，您可能有兴趣知道整个网站的总点击量。在 Servlet 中，这也是非常简单的，我们可以使用过滤器做到这一点。</p><p>以下是实现一个简单的基于过滤器生命周期的网站点击计数器需要采取的步骤：</p><ul><li>在过滤器的 init() 方法中初始化一个全局变量。</li><li>每次调用 doFilter 方法时，都增加全局变量。</li><li>如果需要，您可以在过滤器的 destroy() 中使用一个数据库表来存储全局变量的值。在下次初始化过滤器时，该值可在 init() 方法内被读取, 这一步是可选的。</li></ul><p>在这里，我们假设 Web 容器将无法重新启动。如果是重新启动或 Servlet 被销毁，点击计数器将被重置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SiteHitCounter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hitCount; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig config)</span> </span><br><span class="hljs-function">                    <span class="hljs-keyword">throws</span> ServletException</span>&#123;<br>     <span class="hljs-comment">// 重置点ss击计数器</span><br>     hitCount = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, </span></span><br><span class="hljs-function"><span class="hljs-params">              ServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">              FilterChain chain)</span> </span><br><span class="hljs-function">              <span class="hljs-keyword">throws</span> java.io.IOException, ServletException </span>&#123;<br>      <span class="hljs-comment">// 把计数器的值增加 1</span><br>      hitCount++;<br>      <span class="hljs-comment">// 输出计数器</span><br>      System.out.println(<span class="hljs-string">&quot;网站访问统计：&quot;</span>+ hitCount );<br>      <span class="hljs-comment">// 把请求传回到过滤器链???</span><br>      chain.doFilter(request,response);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">  </span>&#123; <br>      <span class="hljs-comment">// 这一步是可选的，但是如果需要，您可以把 hitCount 的值写入到数据库</span><br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-15、Servlet包"><a href="#1-15、Servlet包" class="headerlink" title="1.15、Servlet包"></a>1.15、Servlet包</h4><p>涉及到 WEB-INF 子目录的 Web 应用程序结构是所有的 Java web 应用程序的标准，并由 Servlet API 规范指定。给定一个顶级目录名 myapp，目录结构如下所示：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/myapp</span><br>    <span class="hljs-string">/images</span><br>    <span class="hljs-string">/WEB-INF</span><br>        <span class="hljs-string">/classes</span><br>        <span class="hljs-string">/lib</span><br></code></pre></td></tr></table></figure><p>WEB-INF 子目录中包含应用程序的部署描述符，名为 web.xml。所有的 HTML 文件都位于顶级目录 <em>myapp</em> 下。对于 admin 用户，您会发现 ROOT 目录是 myApp 的父目录。</p><h5 id="1-15-1、创建包中的-Servlet"><a href="#1-15-1、创建包中的-Servlet" class="headerlink" title="1.15.1、创建包中的 Servlet"></a>1.15.1、创建包中的 Servlet</h5><p>WEB-INF/classes 目录包含了所有的 Servlet 类和其他类文件，类文件所在的目录结构与他们的包名称匹配。例如，如果您有一个完全合格的类名称 <strong>com.myorg.MyServlet</strong>，那么这个 Servlet 类必须位于以下目录中：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/myapp/</span>WEB-INF<span class="hljs-regexp">/classes/</span>com<span class="hljs-regexp">/myorg/My</span>Servlet.<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><h5 id="1-15-2、编译包中的-Servlet"><a href="#1-15-2、编译包中的-Servlet" class="headerlink" title="1.15.2、编译包中的 Servlet"></a>1.15.2、编译包中的 Servlet</h5><p>编译包中的类与编译其他的类没有什么大的不同。最简单的方法是让您的 java 文件保留完全限定路径，如上面提到的类，将被保留在 com.myorg 中。您还需要在 CLASSPATH 中添加该目录。 </p><p>假设您的环境已正确设置，进入 <strong>/webapps/ROOT/WEB-INF/classes</strong> 目录，并编译 MyServlet.java，如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">$ javac <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyServlet</span>.</span></span>java<br></code></pre></td></tr></table></figure><p>如果 Servlet 依赖于其他库，那么您必须在 CLASSPATH 中也要引用那些 JAR 文件。这里我只引用了 servlet-api.jar JAR 文件，因为我在 Hello World 程序中并没有使用任何其他库。</p><p>该命令行使用内置的 javac 编译器，它是 Sun Microsystems Java 软件开发工具包（JDK，全称 Java Software Development Kit）附带的。 Microsystems的Java软件开发工具包（JDK）。为了让该命令正常工作，必须包括您在 PATH 环境变量中所使用的 Java SDK 的位置。</p><p>如果一切顺利，上述编译会在同一目录下生成 <strong>MyServlet.class</strong> 文件。下一节将解释如何把一个已编译的 Servlet 部署到生产中。</p><h5 id="1-15-3、Servlet-打包部署"><a href="#1-15-3、Servlet-打包部署" class="headerlink" title="1.15.3、Servlet 打包部署"></a>1.15.3、Servlet 打包部署</h5><p>默认情况下，Servlet 应用程序位于路径 &lt;Tomcat-installation-directory&gt;/webapps/ROOT 下，且类文件放在 &lt;Tomcat-installation-directory&gt;/webapps/ROOT/WEB-INF/classes 中。</p><p>如果您有一个完全合格的类名称 <strong>com.myorg.MyServlet</strong>，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中，您需要在位于 &lt;Tomcat-installation-directory&gt;/webapps/ROOT/WEB-INF/ 的 web.xml 文件中创建以下条目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.myorg.MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的条目要被创建在 web.xml 文件中的 &lt;web-app&gt;…&lt;/web-app&gt; 标签内。在该文件中可能已经有各种可用的条目，但不要在意。</p><p>到这里，您基本上已经完成了，现在让我们使用 &lt;Tomcat-installation-directory&gt;\bin\startup.bat（在 Windows 上）或 &lt;Tomcat-installation-directory&gt;/bin/startup.sh（在 Linux/Solaris 等上）启动 tomcat 服务器，最后在浏览器的地址栏中输入 <strong><a href="http://localhost:8080/MyServlet">http://localhost:8080/MyServlet</a></strong>。如果一切顺利，浏览器页面显示“Hello World“。</p><h4 id="1-16、Servlet调试"><a href="#1-16、Servlet调试" class="headerlink" title="1.16、Servlet调试"></a>1.16、Servlet调试</h4><p>测试/调试 Servlet 始终是开发使用过程中的难点。Servlet 往往涉及大量的客户端/服务器交互，可能会出现错误但又难以重现。</p><h5 id="1-16-1、一些提示和建议，帮助调试"><a href="#1-16-1、一些提示和建议，帮助调试" class="headerlink" title="1.16.1、一些提示和建议，帮助调试"></a>1.16.1、一些提示和建议，帮助调试</h5><ul><li><p>System.out.println()</p></li><li><p>消息日志：使用适当的日志记录方法来记录所有调试、警告和错误消息，推荐使用 <a href="https://logging.apache.org/log4j/2.0/download.html">log4J</a> 来记录所有的消息。</p></li><li><p>使用JDB调试器：使用调试 applet 或应用程序的 jdb 命令来调试 Servlet。</p></li><li><p>使用注释：代码中的注释有助于以各种方式进行调试。</p></li><li><p>客户端和服务器端头信息：当一个 Servlet 并没有像预期那样时，查看原始的 HTTP 请求和响应是非常有用的。</p></li></ul><h5 id="1-16-2、一些-Servlet-调试的技巧："><a href="#1-16-2、一些-Servlet-调试的技巧：" class="headerlink" title="1.16.2、一些 Servlet 调试的技巧："></a>1.16.2、一些 Servlet 调试的技巧：</h5><ul><li>请注意，server_root/classes 不会重载，而 server_root/servlets 可能会。</li><li>要求浏览器显示它所显示的页面的原始内容。这有助于识别格式的问题。它通常是”视图”菜单下的一个选项。</li><li>通过强制执行完全重新加载页面来确保浏览器还没有缓存前一个请求的输出。在 Netscape Navigator 中，请使用 Shift-Reload，在 Internet Explorer 中，请使用 Shift-Refresh。</li><li>请确认 servlet 的 init() 方法接受一个 ServletConfig 参数，并调用 super.init(config)。</li></ul><h4 id="1-17、Servlet国际化"><a href="#1-17、Servlet国际化" class="headerlink" title="1.17、Servlet国际化"></a>1.17、Servlet国际化</h4><p>当建立一个全球性的网站时有一些注意事项。本教程不会讲解这些注意事项的完整细节，但它会通过一个很好的实例向您演示如何通过差异化定位（即区域设置）来让网页以不同语言呈现。</p><p>在我们开始之前，先来看看三个重要术语：</p><ul><li><strong>国际化（i18n）：</strong>这意味着一个网站提供了不同版本的翻译成访问者的语言或国籍的内容。</li><li><strong>本地化（l10n）：</strong>这意味着向网站添加资源，以使其适应特定的地理或文化区域，例如网站翻译成印地文（Hindi）。</li><li><strong>区域设置（locale）：</strong>这是一个特殊的文化或地理区域。它通常指语言符号后跟一个下划线和一个国家符号。例如 “en_US” 表示针对 US 的英语区域设置。</li></ul><p>Servlet 可以根据请求者的区域设置拾取相应版本的网站，并根据当地的语言、文化和需求提供相应的网站版本。以下是 request 对象中返回 Locale 对象的方法。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Locale</span> request<span class="hljs-selector-class">.getLocale</span>() <br></code></pre></td></tr></table></figure><h5 id="1-17-1、检测区域设置"><a href="#1-17-1、检测区域设置" class="headerlink" title="1.17.1、检测区域设置"></a>1.17.1、检测区域设置</h5><p>下面列出了重要的区域设置方法，您可以使用它们来检测请求者的地理位置、语言和区域设置。下面所有的方法都显示了请求者浏览器中设置的国家名称和语言名称。</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>String getCountry()</strong> 该方法以 2 个大写字母形式的 ISO 3166 格式返回该区域设置的国家/地区代码。</td></tr><tr><td align="left">2</td><td align="left"><strong>String getDisplayCountry()</strong> 该方法返回适合向用户显示的区域设置的国家的名称。</td></tr><tr><td align="left">3</td><td align="left"><strong>String getLanguage()</strong> 该方法以小写字母形式的 ISO 639 格式返回该区域设置的语言代码。</td></tr><tr><td align="left">4</td><td align="left"><strong>String getDisplayLanguage()</strong> 该方法返回适合向用户显示的区域设置的语言的名称。</td></tr><tr><td align="left">5</td><td align="left"><strong>String getISO3Country()</strong> 该方法返回该区域设置的国家的三个字母缩写。</td></tr><tr><td align="left">6</td><td align="left"><strong>String getISO3Language()</strong> 该方法返回该区域设置的语言的三个字母的缩写。</td></tr></tbody></table><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetLocale</span> <span class="hljs-title">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>  <span class="hljs-keyword">public</span> void doGet(<span class="hljs-type">HttpServletRequest</span> request,<br>                    <span class="hljs-type">HttpServletResponse</span> response)<br>            <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span><br>  &#123;<br>      <span class="hljs-comment">// 获取客户端的区域设置</span><br>      <span class="hljs-type">Locale</span> locale <span class="hljs-operator">=</span> request.getLocale();<br>      <span class="hljs-type">String</span> language <span class="hljs-operator">=</span> locale.getLanguage();<br>      <span class="hljs-type">String</span> country <span class="hljs-operator">=</span> locale.getCountry();<br><br>      <span class="hljs-comment">// 设置响应内容类型</span><br>      response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>      <span class="hljs-type">PrintWriter</span> out <span class="hljs-operator">=</span> response.getWriter();<br><br>      <span class="hljs-type">String</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&quot;检测区域设置&quot;</span>;<br>      <span class="hljs-type">String</span> docType <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; <span class="hljs-subst">\n</span>&quot;</span>;<br>      out.println(docType <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;html&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> <span class="hljs-operator">+</span> title <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;body bgcolor=<span class="hljs-subst">\&quot;</span>#f0f0f0<span class="hljs-subst">\&quot;</span>&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;h1 align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;&quot;</span> <span class="hljs-operator">+</span> language <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/h1&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;h2 align=<span class="hljs-subst">\&quot;</span>center<span class="hljs-subst">\&quot;</span>&gt;&quot;</span> <span class="hljs-operator">+</span> country <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&lt;/h2&gt;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>        <span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-17-2、语言设置"><a href="#1-17-2、语言设置" class="headerlink" title="1.17.2、语言设置"></a>1.17.2、语言设置</h5><p>Servlet 可以输出以西欧语言（如英语、西班牙语、德语、法语、意大利语、荷兰语等）编写的页面。在这里，为了能正确显示所有的字符，设置 Content-Language 头是非常重要的。</p><p>第二点是使用 HTML 实体显示所有的特殊字符，例如，”&amp;#241;” 表示 “ñ”，”&amp;#161;” 表示 “¡”，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisplaySpanish</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>  public void doGet(<span class="hljs-type">HttpServletRequest</span> request,<br>                    <span class="hljs-type">HttpServletResponse</span> response)<br>            <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span><br>  &#123;<br>    <span class="hljs-comment">// 设置响应内容类型</span><br>    response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>    <span class="hljs-type">PrintWriter</span> out = response.getWriter();<br>    <span class="hljs-comment">// 设置西班牙语言代码</span><br>    response.setHeader(<span class="hljs-string">&quot;Content-Language&quot;</span>, <span class="hljs-string">&quot;es&quot;</span>);<br><br>    <span class="hljs-type">String</span> title = <span class="hljs-string">&quot;En Espa&amp;ntilde;ol&quot;</span>;<br>    <span class="hljs-type">String</span> docType = <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; \n&quot;</span>;<br>     out.println(docType +<br>     <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>     <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span> +<br>     <span class="hljs-string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span> +<br>     <span class="hljs-string">&quot;&lt;h1&gt;&quot;</span> + <span class="hljs-string">&quot;En Espa&amp;ntilde;ol:&quot;</span> + <span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span> +<br>     <span class="hljs-string">&quot;&lt;h1&gt;&quot;</span> + <span class="hljs-string">&quot;&amp;iexcl;Hola Mundo!&quot;</span> + <span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span> +<br>     <span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-17-3、特定于区域设置的日期"><a href="#1-17-3、特定于区域设置的日期" class="headerlink" title="1.17.3、特定于区域设置的日期"></a>1.17.3、特定于区域设置的日期</h5><p>您可以使用 java.text.DateFormat 类及其静态方法 getDateTimeInstance() 来格式化特定于区域设置的日期和时间。下面的实例演示了如何格式化特定于某个给定的区域设置的日期：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> class DateLocale extends HttpServlet&#123;<br>    <br>  <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> doGet(HttpServletRequest request,<br>                    HttpServletResponse response)<br>            throws ServletException, IOException<br>  &#123;<br>    <span class="hljs-comment">// 设置响应内容类型</span><br>    response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>    PrintWriter out = response.getWriter();<br>    <span class="hljs-comment">// 获取客户端的区域设置</span><br>    <span class="hljs-built_in">Locale</span> <span class="hljs-built_in">locale</span> = request.getLocale( );<br>    <span class="hljs-built_in">String</span> <span class="hljs-built_in">date</span> = DateFormat.getDateTimeInstance(<br>                                  DateFormat.<span class="hljs-literal">FULL</span>, <br>                                  DateFormat.SHORT, <br>                                  <span class="hljs-built_in">locale</span>).format(<span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>( ));<br><br>    <span class="hljs-built_in">String</span> title = <span class="hljs-string">&quot;特定于区域设置的日期&quot;</span>;<br>    <span class="hljs-built_in">String</span> docType = <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; \n&quot;</span>;<br>      out.println(docType +<br>      <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot;</span> + <span class="hljs-built_in">date</span> + <span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-17-4、特定于区域设置的货币"><a href="#1-17-4、特定于区域设置的货币" class="headerlink" title="1.17.4、特定于区域设置的货币"></a>1.17.4、特定于区域设置的货币</h5><p>您可以使用 java.text.NumberFormat 类及其静态方法 getCurrencyInstance() 来格式化数字（比如 long 类型或 double 类型）为特定于区域设置的货币。下面的实例演示了如何格式化特定于某个给定的区域设置的货币：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrencyLocale</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <br>  public void doGet(<span class="hljs-type">HttpServletRequest</span> request,<br>                    <span class="hljs-type">HttpServletResponse</span> response)<br>            <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span><br>  &#123;<br>    <span class="hljs-comment">// 设置响应内容类型</span><br>    response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>    <span class="hljs-type">PrintWriter</span> out = response.getWriter();<br>    <span class="hljs-comment">// 获取客户端的区域设置</span><br>    <span class="hljs-type">Locale</span> locale = request.getLocale( );<br>    <span class="hljs-type">NumberFormat</span> nft = <span class="hljs-type">NumberFormat</span>.getCurrencyInstance(locale);<br>    <span class="hljs-type">String</span> formattedCurr = nft.format(<span class="hljs-number">1000000</span>);<br><br>    <span class="hljs-type">String</span> title = <span class="hljs-string">&quot;特定于区域设置的货币&quot;</span>;<br>    <span class="hljs-type">String</span> docType = <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; \n&quot;</span>;<br>      out.println(docType +<br>      <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot;</span> + formattedCurr + <span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-17-5、特定于区域设置的百分比"><a href="#1-17-5、特定于区域设置的百分比" class="headerlink" title="1.17.5、特定于区域设置的百分比"></a>1.17.5、特定于区域设置的百分比</h5><p>您可以使用 java.text.NumberFormat 类及其静态方法 getPercentInstance() 来格式化特定于区域设置的百分比。下面的实例演示了如何格式化特定于某个给定的区域设置的百分比：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PercentageLocale</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <br>  public void doGet(<span class="hljs-type">HttpServletRequest</span> request,<br>                    <span class="hljs-type">HttpServletResponse</span> response)<br>            <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span><br>  &#123;<br>    <span class="hljs-comment">// 设置响应内容类型</span><br>    response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>    <span class="hljs-type">PrintWriter</span> out = response.getWriter();<br>    <span class="hljs-comment">// 获取客户端的区域设置</span><br>    <span class="hljs-type">Locale</span> locale = request.getLocale( );<br>    <span class="hljs-type">NumberFormat</span> nft = <span class="hljs-type">NumberFormat</span>.getPercentInstance(locale);<br>    <span class="hljs-type">String</span> formattedPerc = nft.format(<span class="hljs-number">0.51</span>);<br><br>    <span class="hljs-type">String</span> title = <span class="hljs-string">&quot;特定于区域设置的百分比&quot;</span>;<br>    <span class="hljs-type">String</span> docType = <span class="hljs-string">&quot;&lt;!DOCTYPE html&gt; \n&quot;</span>;<br>      out.println(docType +<br>      <span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot;</span> + formattedPerc + <span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span> +<br>      <span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-18、需要共享信息与页面跳转的原因"><a href="#1-18、需要共享信息与页面跳转的原因" class="headerlink" title="1.18、需要共享信息与页面跳转的原因"></a>1.18、需要共享信息与页面跳转的原因</h4><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/servlet.png"></p><h5 id="1-18-1、为什么需要跳转和数据共享？"><a href="#1-18-1、为什么需要跳转和数据共享？" class="headerlink" title="1.18.1、为什么需要跳转和数据共享？"></a>1.18.1、为什么需要跳转和数据共享？</h5><p>跳转：需要做责任分离（Servlet擅长写代码，jsp擅长展示页面）</p><p>共享：Http是无状态的，我们跳转的时候数据无法传递，因此需要做数据共享</p><h5 id="1-18-2、页面跳转可以怎么跳"><a href="#1-18-2、页面跳转可以怎么跳" class="headerlink" title="1.18.2、页面跳转可以怎么跳?"></a>1.18.2、页面跳转可以怎么跳?</h5><p>Servlet 跳转 其它资源(jsp,html)</p><p>Serlvet 跳转 Servlet </p><p>一般来说: 最后都会跳转到JSP页面(我们需要JSP页面来做展示)</p><h5 id="1-18-3、页面跳转的三种方式"><a href="#1-18-3、页面跳转的三种方式" class="headerlink" title="1.18.3、页面跳转的三种方式"></a>1.18.3、页面跳转的三种方式</h5><p>①请求转发、②重定向、③请求包含</p><h5 id="1-18-4、页面跳转：请求转发-Forward"><a href="#1-18-4、页面跳转：请求转发-Forward" class="headerlink" title="1.18.4、页面跳转：请求转发 Forward"></a>1.18.4、页面跳转：请求转发 Forward</h5><p>创建两个Servlet，分别是AServlet与BServlet，然后我访问AServlet，从AServlet跳转到BServlet；（分别使用3种方式）</p><p>转发的方式: <code>req.getRequestDispatcher(&quot;路径&quot;).forward(request, response);</code></p><p>注意:千万不要忘了forward</p><p><strong>案例代码：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/forward/a&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req,<span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;现在AServlet中。。。&quot;</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * req.getRequestDispatcher(String path)</span><br><span class="hljs-comment">         * 拿到分发器/确认跳转的地址</span><br><span class="hljs-comment">         * forward：进行跳转</span><br><span class="hljs-comment">         */</span><br>        req.getRequestDispatcher(<span class="hljs-string">&quot;/forward/b&quot;</span>).forward(req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/forward/b&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;现在BServlet&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/jsp2.png"></p><p><strong>forward转发的特点：</strong></p><ul><li><p>地址栏地址不发生变化</p></li><li><p>浏览器只发送了一次请求（请求对象只有 <code>HTTPServletRequest req</code> 一个），forward是作为参数传递。</p></li><li><p>AServlet收到的浏览器的请求req和forward传给BServlet的req是同一个对象。里边的内容是相同的。</p></li><li><p>请求的顺序中，只最后一个response才起最用</p></li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/response.png"></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/jsp3.png"></p><ul><li><p>在AServlet 里面 跳转之后，resp.getWriter().println(i am aservlet”);不会显示在页面上，因为这个resp 不会转发之后，在回AServlet里面来;</p></li><li><p>forward不可跨域访问</p></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.getRequestDispatcher</span>(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<span class="hljs-selector-class">.forward</span>(req,resp);<br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/jsp4.png"></p><ul><li>可以访问web-inf中的资源，但是不能直接通过/locolhost/WEB-INF/haha.html进行访问，可以通过转发访问到WEB-INF里面的内容。</li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/jsp5.png"></p><h5 id="1-18-5、页面跳转：重定向Redirect"><a href="#1-18-5、页面跳转：重定向Redirect" class="headerlink" title="1.18.5、页面跳转：重定向Redirect"></a>1.18.5、页面跳转：重定向Redirect</h5><p>跳转的方式: resp.sendRedirect(“路径”);//直接跳转</p><p><strong>转发特点:</strong></p><ul><li><p> 地址会发生变化</p></li><li><p> 发送了多次请求(每跳转一次就会发送一次请求)</p></li><li><p> 请求不一样的（请求头不共享）</p></li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/redirect.png"></p><ul><li> 请求的顺序, 显示的依然是最后一个</li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/redirect3.png"></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/redirect1.png"></p><ul><li> 可以跨域访问</li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/redirect4.png"></p><ul><li> 不能访问到WEB-INF下面的内容</li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/redirect5.png"></p><h5 id="1-18-6、页面跳转：请求包含include"><a href="#1-18-6、页面跳转：请求包含include" class="headerlink" title="1.18.6、页面跳转：请求包含include"></a><strong>1.18.6、页面跳转：请求包含include</strong></h5><p>一般不会在Servlet中使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.getRequestDispatcher</span>(<span class="hljs-string">&quot;/include/b&quot;</span>)<span class="hljs-selector-class">.include</span>(req, resp);<br></code></pre></td></tr></table></figure><p>这个两个结果会包含在一起（我们一般不使用）：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/include.png"></p><h4 id="1-19、四大作用域对象"><a href="#1-19、四大作用域对象" class="headerlink" title="1.19、四大作用域对象"></a>1.19、四大作用域对象</h4><p>引入：我们在做数据共享的时候，把数据放到不同的地方，这个不同的地方就是放到不同的作用域里面，作用域对象有4个；</p><table><thead><tr><th>类</th><th>对象(叫法)</th><th>范围</th></tr></thead><tbody><tr><td>PageContext</td><td>pageContext</td><td>当前页面(作用不大)  当前页，直接使用就是，根本不需要在放到对象里面</td></tr><tr><td>HttpServletRequest</td><td>Request</td><td>一次请求(必需请求转发)</td></tr><tr><td>HttpSession</td><td>Session（多个对象）</td><td>一次会话</td></tr><tr><td>ServletContext</td><td>application</td><td>整个应用(有且只有一个对象)</td></tr></tbody></table><p>pageContext：每次访问的时候创建，可以有多个；</p><p>Request：每次请求的时候创建，可以有多个；</p><p>Session：每次会话的时候创建，不同人打开不同的浏览器，就创建多个，可以有个多个；</p><p>Application：整个应用有且只有一个对象，tomcat启动的创建，关闭的时候销毁；</p><h5 id="1-19-1、作用域对象的操作"><a href="#1-19-1、作用域对象的操作" class="headerlink" title="1.19.1、作用域对象的操作"></a>1.19.1、作用域对象的操作</h5><p><code>service方法</code>中拿到相应的作用域对象</p><blockquote><p>request:req</p><p>session:req.getSession()</p><p>application:super.getServletContext()</p></blockquote><p><strong>1)、向作用域对象中添加数据</strong></p><p>作用域对象.setAttribute(key, value);</p><p>修改（在设置一个相同的key，覆盖原有的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">protect <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException</span>&#123;<br>        req.setAttribute(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-comment">//添加到request对象</span><br>        req.getSession().setAttribute(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-comment">//添加到Session对象中</span><br>        <span class="hljs-keyword">super</span>.getServletContext().setAttribute(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-comment">//添加到Applicatoin</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）、作用域对象中获取数据</strong></p><p>作用域对象.getAttribute(key);</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    protect void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>&#123;<br>        req.getAttribute(<span class="hljs-string">&quot;key&quot;</span>);<span class="hljs-comment">//从request对象获取数据</span><br>        req.getSession().getAttribute(<span class="hljs-string">&quot;key&quot;</span>);<span class="hljs-comment">//从Session对象中获取</span><br>        <span class="hljs-keyword">super</span>.getServletContext().getAttribute(<span class="hljs-string">&quot;key&quot;</span>);<span class="hljs-comment">//从Applicatoin获取</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3）、删除作用域对象中的数据</strong></p><p>作用域对象.removeAttribute(“key”);</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    protect void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>&#123;<br>        req.removeAttribute(<span class="hljs-string">&quot;key&quot;</span>);<br>        req.getSession().removeAttribute(<span class="hljs-string">&quot;key&quot;</span>);<br>        <span class="hljs-keyword">super</span>.getServletContext().removeAttribute(<span class="hljs-string">&quot;key&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用域有大小，存在哪个作用域对象里，就需要在哪个作用域对象里获取</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/domain.png"></p><h5 id="1-19-2、各个作用域使用"><a href="#1-19-2、各个作用域使用" class="headerlink" title="1.19.2、各个作用域使用"></a>1.19.2、各个作用域使用</h5><p>①Session只用于登录，保存当前登录的用户</p><p>②Request我们平时从数据库拿到数据的展示都全部Request</p><p>③Application一般用于统计当前登录用户的数量上</p><h5 id="1-19-3、作用域经典案例"><a href="#1-19-3、作用域经典案例" class="headerlink" title="1.19.3、作用域经典案例"></a>1.19.3、作用域经典案例</h5><p>创建一个CountServlet.java</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 我们去作用域对象里面去拿到一个计数器</span><br><span class="hljs-comment"> *   如果有这个计数器,就直接拿到</span><br><span class="hljs-comment"> *   如果没有,创建一个,再拿到</span><br><span class="hljs-comment"> * 对计数器进行加1</span><br><span class="hljs-comment"> * 将新计数器再重新放到作用域中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> javax.servlet.<span class="hljs-type">ServletException</span>;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.<span class="hljs-type">WebServlet</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServlet</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServletRequest</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServletResponse</span>;<br><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">IOException</span>;<br><br><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/scope/count&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-comment">//request作用域</span><br>        <span class="hljs-type">Integer</span> reqCount=(<span class="hljs-type">Integer</span>)req.getAttribute(<span class="hljs-string">&quot;REQ_IN_COUNT&quot;</span>);<br>        <span class="hljs-keyword">if</span>(reqCount==<span class="hljs-literal">null</span>)&#123;<br>            reqCount=<span class="hljs-number">0</span>;<br>        &#125;<br>        reqCount=reqCount+<span class="hljs-number">1</span>;<br>        req.setAttribute(<span class="hljs-string">&quot;REQ_IN_COUNT&quot;</span>,reqCount);<br>        <span class="hljs-comment">//session作用域</span><br>        <span class="hljs-type">Integer</span> sessionCount=(<span class="hljs-type">Integer</span>)req.getSession().getAttribute(<span class="hljs-string">&quot;SESSION_IN_COUNT&quot;</span>);<br>        <span class="hljs-keyword">if</span>(sessionCount==<span class="hljs-literal">null</span>)&#123;<br>            sessionCount=<span class="hljs-number">0</span>;<br>        &#125;<br>        sessionCount=sessionCount+<span class="hljs-number">1</span>;<br>        req.getSession().setAttribute(<span class="hljs-string">&quot;SESSION_IN_COUNT&quot;</span>,sessionCount);<br><br>        <span class="hljs-comment">//application作用域</span><br>        <span class="hljs-type">Integer</span> appCount=(<span class="hljs-type">Integer</span>)<span class="hljs-keyword">super</span>.getServletContext().getAttribute(<span class="hljs-string">&quot;APP_IN_COUNT&quot;</span>);<br>        <span class="hljs-keyword">if</span>(appCount==<span class="hljs-literal">null</span>)&#123;<br>            appCount=<span class="hljs-number">0</span>;<br>        &#125;<br>        appCount=appCount+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">super</span>.getServletContext().setAttribute(<span class="hljs-string">&quot;APP_IN_COUNT&quot;</span>,appCount);<br><br>        req.getRequestDispatcher(<span class="hljs-string">&quot;/scope/result&quot;</span>).forward(req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个ScopeServlet.java拿到计数器的值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> javax.servlet.annotation.<span class="hljs-type">WebServlet</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServlet</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServletRequest</span>;<br><span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServletResponse</span>;<br><span class="hljs-keyword">import</span> java.io.<span class="hljs-type">IOException</span>;<br><br><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/scope/result&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void service(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-type">Integer</span> reqCount=(<span class="hljs-type">Integer</span>)req.getAttribute(<span class="hljs-string">&quot;REQ_IN_COUNT&quot;</span>);<br>        resp.getWriter().println(<span class="hljs-string">&quot;request:&quot;</span>+reqCount);<br><br>        <span class="hljs-type">Integer</span> sessionCount=(<span class="hljs-type">Integer</span>)req.getSession().getAttribute(<span class="hljs-string">&quot;SESSION_IN_COUNT&quot;</span>);<br>        resp.getWriter().println(<span class="hljs-string">&quot;session:&quot;</span>+sessionCount);<br><br>        <span class="hljs-type">Integer</span> appCount=(<span class="hljs-type">Integer</span>)<span class="hljs-keyword">super</span>.getServletContext().getAttribute(<span class="hljs-string">&quot;APP_IN_COUNT&quot;</span>);<br>        resp.getWriter().println(<span class="hljs-string">&quot;application:&quot;</span>+appCount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/Scope.png"></p><p>注：有的浏览器如Chrome，因受浏览器后台驻留影响，重新打开浏览器不会创建新的session会话，而是使用原有的session，给我们一种重启浏览器session不会重新计数的印象。</p><h5 id="1-19-4、ServletContext对象介绍"><a href="#1-19-4、ServletContext对象介绍" class="headerlink" title="1.19.4、ServletContext对象介绍"></a>1.19.4、ServletContext对象介绍</h5><p><strong>1）、获取ServletContext 上下文对象</strong></p><p>ServletContext 表示上下文对象，得到上下文对象ServletContext对象的四种方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ServletContext <span class="hljs-attribute">app1</span>=super.getServletContext();<br>ServletContext <span class="hljs-attribute">app2</span>=super.getServletConfig().getServletContext();<br>ServletContext <span class="hljs-attribute">app3</span>=req.getServletContext();<br>ServletContext <span class="hljs-attribute">app4</span>=re1.getSession().getServletContext();<br></code></pre></td></tr></table></figure><p>它们拿到的对象都是同一个对象，那我们选择哪种方式呢？</p><blockquote><p>第①和第②种我们肯定选择①</p><p>第③和和第④种我们肯定选择③（简单）</p><p>第①和第③种选择哪种？</p><ul><li>如果在servlet里面 有super，使用第一种①；</li><li>如果没有在servlet，普通类里面 ，可以通过传递req，选择③</li></ul><p>第③种更简单,不兼容低版本，不兼容tomcat7以前的版本</p><p>第④种麻烦一点,兼容性好</p></blockquote><p><strong>2）、ServletContext的常用方法</strong></p><p>获取到ServletContext 上下文对象后，怎么用？有什么用？</p><p>主要看里面的一些方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">getContextPath</span>();<span class="hljs-comment">//拿到上下文路径</span><br><span class="hljs-selector-tag">getRealPath</span>(“/”);拿到真实路径<span class="hljs-selector-tag">--</span>(以后做上传下载可以使用)<br><span class="hljs-selector-tag">getInitParameter</span>(“encoding”);<span class="hljs-comment">//拿到初始化参数（只能拿到全局里面的参数信息）</span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/%E4%B8%8A%E4%B8%8B%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.png"></p><p>①<strong>以前</strong>取到servlet里面配置的参数信息，</p><p> 通过super.getServletConfig().getInitParameter(“encoding”)拿到</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/se.png"></p><p>②<strong>现在</strong>web.xml配置全局的信息，通过super.getServletContext().getInitParameter(“encoding”) 拿到：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/webxml.png"></p><p>注意：super.getServletContext().getInitParameter(“encoding”); 只能拿到context-param里面配置，不能拿到Servlet里面配置的参数；</p><h5 id="1-19-5、补充内容"><a href="#1-19-5、补充内容" class="headerlink" title="1.19.5、补充内容"></a>1.19.5、补充内容</h5><p><strong>1）、req.getParameter(“”)和req.getAttribute(“”)的区别?</strong></p><blockquote><p>req.getParameter :用户传过来的</p><p>req.getAttribute :从作用域里拿的(必需是放到作用域里的)</p></blockquote><p><strong>2）、ServletConfig.getInitParameter和application.getInitParameter 有什么区别?</strong></p><blockquote><p>ServletConfig.getInitParameter 只作为于一个Servlet</p><p>application.getInitParameter 整个应用都可以拿到</p></blockquote><h4 id="1-20、Servlet配置部署"><a href="#1-20、Servlet配置部署" class="headerlink" title="1.20、Servlet配置部署"></a>1.20、Servlet配置部署</h4><p>在Servlet2.5规范之前，Java Web应用的绝大部分组件都通过web.xml文件来配置管理，Servlet3.0规范可通过Annotation来配置管理Web组件，因此web.xml文件可以变得更加简洁，这也是Servlet3.0的重要简化。</p><p>两种方式：</p><h5 id="（1），通过web-xml配置"><a href="#（1），通过web-xml配置" class="headerlink" title="（1），通过web.xml配置"></a>（1），通过<strong>web.xml</strong>配置</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>GetApplication<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.fpp.GetApplication<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 通过servletConfig getInitParameter()取出参数 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>GetApplication<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/GetApplication<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="（2），使用-WebServlet-Annotation-进行配置"><a href="#（2），使用-WebServlet-Annotation-进行配置" class="headerlink" title="（2），使用**@WebServlet Annotation**进行配置"></a>（2），使用**@WebServlet Annotation**进行配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;AdminAddServlet&quot;,urlPatterns=&quot;/adminAddServlet&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminAddServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span>  </span><br></code></pre></td></tr></table></figure><p> @WebServlet支持的常用属性：</p><blockquote><p>displayName,initParams,loadOnStartup,name,urlPatterns/value,asyncSupported</p></blockquote><p>如果打算使用Annotation来配置Servlet，需要注意以下几点：</p><ul><li>不要在web.xml文件的根元素（&lt;web-app—/&gt;）中指定metadata-complete=“true”；</li><li>不要在web.xml文件中配置该Servlet</li></ul><h3 id="2、JSP"><a href="#2、JSP" class="headerlink" title="2、JSP"></a>2、JSP</h3><h4 id="2-1、JSP简介"><a href="#2-1、JSP简介" class="headerlink" title="2.1、JSP简介"></a>2.1、JSP简介</h4><p>JSP 与 PHP、ASP、ASP.NET 等语言类似，运行在服务端的语言。</p><p>JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准。</p><p>JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于HTTP的应用程序。</p><p><strong>Servlet也是Java用来做动态网页的技术，因为JSP就是Servlet；</strong></p><p>Servlet:         <strong>Java代码(主)</strong> + HTML代码</p><p>Jsp:                Java代码 + <strong>HTML代码(主)</strong></p><p>JSP就是Servlet ( 我们开发需要把 jsp 和 Servlet 结合使用)</p><p>Servlet更擅长写java业务代码，Jsp更擅长于显示的HTML页面；</p><p>开发目标：<strong>servlet里面不要写HTML代码，jsp里面不要写java代码。</strong></p><p>一个基本的JSP代码结构：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/JSPS.png"></p><p>注意：JSP页面不能直接拖到浏览器上面运行，它只能在服务器上面使用，服务器对它作了编译的返回给浏览器HTML格式的页面。</p><h4 id="2-2、JSP原理分析"><a href="#2-2、JSP原理分析" class="headerlink" title="2.2、JSP原理分析"></a>2.2、JSP原理分析</h4><h5 id="2-2-1、JSP结构"><a href="#2-2-1、JSP结构" class="headerlink" title="2.2.1、JSP结构"></a>2.2.1、JSP结构</h5><p>网络服务器需要一个 JSP 引擎，也就是一个容器来处理 JSP 页面。容器负责截获对 JSP 页面的请求。本教程使用内嵌 JSP 容器的 Apache 来支持 JSP 开发。 </p><p> JSP 容器与 Web 服务器协同合作，为JSP的正常运行提供必要的运行环境和其他服务，并且能够正确识别专属于 JSP 网页的特殊元素。 </p><p>下图显示了 JSP 容器和 JSP 文件在 Web 应用中所处的位置。 </p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/StructJSP.png"></p><h5 id="2-2-2、JSP处理"><a href="#2-2-2、JSP处理" class="headerlink" title="2.2.2、JSP处理"></a>2.2.2、JSP处理</h5><p>以下步骤表明了 Web 服务器是如何使用JSP来创建网页的： </p><ul><li><p>就像其他普通的网页一样，您的浏览器发送一个 HTTP 请求给服务器。</p></li><li><p>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用  URL或者 .jsp 文件来完成。</p></li><li><p>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。</p></li><li><p>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。</p></li><li><p>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</p></li><li><p>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</p></li><li><p>最终，Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。</p><p>以上提及到的步骤可以用下图来表示： </p></li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/jsp-processing.jpg"></p><p>一般情况下，JSP 引擎会检查 JSP 文件对应的 Servlet 是否已经存在，并且检查 JSP 文件的修改日期是否早于 Servlet。如果 JSP 文件的修改日期早于对应的 Servlet，那么容器就可以确定 JSP 文件没有被修改过并且 Servlet 有效。这使得整个流程与其他脚本语言（比如 PHP）相比要高效快捷一些。 </p><p> 总的来说，JSP 网页就是用另一种方式来编写 Servlet 而不用成为 Java 编程高手。除了解释阶段外，JSP 网页几乎可以被当成一个普通的 Servlet 来对待。 </p><h5 id="2-2-3、JSP生命周期"><a href="#2-2-3、JSP生命周期" class="headerlink" title="2.2.3、JSP生命周期"></a>2.2.3、JSP生命周期</h5><p>JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。 </p><ul><li><p><strong>编译阶段：</strong></p><p>解析JSP文件，转换为Servlet，servlet容器编译servlet源文件，生成servlet类</p></li><li><p>初始化阶段：</p><p>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p></li><li><p>执行阶段：</p><p>调用与JSP对应的servlet实例的服务方法</p></li><li><p>销毁阶段：</p><p>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p></li></ul><p>很明显，JSP生命周期的四个主要阶段和servlet生命周期非常相似，下面给出图示： </p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/jsp_life_cycle.jpg"></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/Snip.png"></p><h5 id="2-2-4、代码分析"><a href="#2-2-4、代码分析" class="headerlink" title="2.2.4、代码分析"></a>2.2.4、代码分析</h5><p>Jsp页面上面的代码如下所示，怎么运行之后，就变成右边的时间呢？</p><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vbscript-html"><span class="vbscript">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;</span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">    HelloWorld！</span><span class="vbscript">&lt;%= <span class="hljs-keyword">new</span> java.util.<span class="hljs-built_in">Date</span>().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>()%&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/fenxi.png"></p><p>当我们访问 20191120.jsp时，会先去找到web.xml里面&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;，在会找到 JspServlet，如下图：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/procedure.png"></p><p>JspServlet：在这里面，把我们自己写的JSP页面给翻译成一个JAVA文件，翻译好的文件放在         apache-tomcat-7.0.57\work\Catalina文件夹下面  </p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/compile.png"></p><p>记事本打开这个生成的Java文件：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/shengcheng.png"></p><p>翻译过程：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/procedure1.png"></p><h4 id="2-3、JSP语法"><a href="#2-3、JSP语法" class="headerlink" title="2.3、JSP语法"></a>2.3、JSP语法</h4><p>请大家记住一句话:</p><blockquote><p>在JSP里面最好不要写JAVA代码，在Servlet里面也不要写HTML代码；</p><p>到目前，初学者可能还不能完全做到，后面内容学完，才能消除二者代码的杂糅。</p></blockquote><h5 id="2-3-1、JSP页面上面注释"><a href="#2-3-1、JSP页面上面注释" class="headerlink" title="2.3.1、JSP页面上面注释"></a>2.3.1、JSP页面上面注释</h5><p>   ①语法：&lt;%–这是注释–%&gt; 在jsp翻译成Servlet的时候这个注释就没有了(浏览器查看页面源代码看不到)；</p><p>   ②我们还可以用html的注释（<!--我是一个注释-->）,在页面上看源代码可以看到；</p><h5 id="2-3-2、-lt-表达式-gt"><a href="#2-3-2、-lt-表达式-gt" class="headerlink" title="2.3.2、&lt;%=表达式%&gt;"></a>2.3.2、&lt;%=表达式%&gt;</h5><p>实际上就是调用输出流打印到页面上，其对应servlet里的out.print(表达式);</p><p>作用：输出数据到页面上</p><p>例: &lt;%=**new** java.util.Date().toLocaleString() %&gt;</p><p>翻译到Servlet中的代码:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">out.print(<span class="hljs-keyword">new</span> java.util.<span class="hljs-constructor">Date()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span>);<br></code></pre></td></tr></table></figure><h5 id="2-3-3、-lt-…-gt"><a href="#2-3-3、-lt-…-gt" class="headerlink" title="2.3.3、&lt;% … %&gt;"></a>2.3.3、&lt;% … %&gt;</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;%<br> Java语句<span class="hljs-number">1</span><span class="hljs-comment">;</span><br> Java语句<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>%&gt;<br></code></pre></td></tr></table></figure><p>JSP中的Java脚本片段：(实际开发中，应做到JSP中不能出现一行Java脚本片段)</p><p>作用：书写Java代码逻辑</p><p>原理：其中的语句会原封不动的被服务器翻译到对应的<code>Servlet的_jspService</code>方法中。</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/jspservice.png"></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/fanyi.png"></p><h5 id="2-3-4、-lt-…-gt"><a href="#2-3-4、-lt-…-gt" class="headerlink" title="2.3.4、&lt;%!  … %&gt;"></a>2.3.4、&lt;%!  … %&gt;</h5><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">&lt;<span class="hljs-comment">%!</span><br>  Java代码<br><span class="hljs-comment">%&gt;</span><br></code></pre></td></tr></table></figure><p>作用：定义类的成员</p><p>原理: 把其中的代码,原封不动翻译到Servlet类中。</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/chengyuan.png"></p><h4 id="2-4、JSP三大指令"><a href="#2-4、JSP三大指令" class="headerlink" title="2.4、JSP三大指令"></a>2.4、JSP三大指令</h4><p>JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">&lt;%@ page … %&gt;</td><td align="left">定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td align="left">&lt;%@ include … %&gt;</td><td align="left">包含其他文件</td></tr><tr><td align="left">&lt;%@ taglib … %&gt;</td><td align="left">引入标签库的定义，可以是自定义标签</td></tr></tbody></table><h5 id="2-4-1、Page指令"><a href="#2-4-1、Page指令" class="headerlink" title="2.4.1、Page指令"></a>2.4.1、Page指令</h5><p>Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。</p><p>Page指令的语法格式：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;<span class="hljs-meta">%</span>@ page attribute=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-meta">%</span>&gt;<br></code></pre></td></tr></table></figure><p> 等价的XML格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp:directive.page</span> <span class="hljs-attr">attribute</span>=<span class="hljs-string">&quot;value&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>Page指令相关的属性：</p><table><thead><tr><th align="left"><strong>属性</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">buffer</td><td align="left">指定out对象使用缓冲区的大小</td></tr><tr><td align="left">autoFlush</td><td align="left">控制out对象的 缓存区</td></tr><tr><td align="left">contentType</td><td align="left">指定当前JSP页面的MIME类型和字符编码</td></tr><tr><td align="left">errorPage</td><td align="left">指定当JSP页面发生异常时需要转向的错误处理页面</td></tr><tr><td align="left">isErrorPage</td><td align="left">指定当前页面是否可以作为另一个JSP页面的错误处理页面</td></tr><tr><td align="left">extends</td><td align="left">指定servlet从哪一个类继承</td></tr><tr><td align="left">import</td><td align="left">导入要使用的Java类</td></tr><tr><td align="left">info</td><td align="left">定义JSP页面的描述信息</td></tr><tr><td align="left">isThreadSafe</td><td align="left">指定对JSP页面的访问是否为线程安全</td></tr><tr><td align="left">language</td><td align="left">定义JSP页面所用的脚本语言，默认是Java</td></tr><tr><td align="left">session</td><td align="left">指定JSP页面是否使用session</td></tr><tr><td align="left">isELIgnored</td><td align="left">指定是否执行EL表达式</td></tr><tr><td align="left">isScriptingEnabled</td><td align="left">确定脚本元素能否被使用</td></tr></tbody></table><p>①、language=”java” *–&gt;*语言只有java，意义不大 </p><p>②、contentType=”text/html; charset=UTF-8” *–&gt;*输出的页面类型,以后的servlet里面不用写（resp.setContentType(“text/html;charset=utf-8”)）</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/setcontenttype.png"></p><p>③、pageEncoding=”UTF-8”</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/page.png"></p><p>④、errorPage=”/myerror.jsp”:如果当前页面出错,就跳转到对应的页面</p><p>和isErrorPage=”true”:这个页面是否是错误页面(当我们要在页面上直接使用exception的时候就可以加上它)</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/errorPage.png"></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/iserrorpage.png"></p><p>效果：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/error.png"></p><p>在web.xml里面也可以配置错误页面：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/errorxml.png"></p><h5 id="2-4-2、Include指令"><a href="#2-4-2、Include指令" class="headerlink" title="2.4.2、Include指令"></a>2.4.2、Include指令</h5><p>JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。</p><p> Include指令的语法格式如下：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">&lt;%@ include <span class="hljs-keyword">file</span>=<span class="hljs-string">&quot;文件相对 url 地址&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><p> <strong>include</strong> 指令中的文件名实际上是一个相对的 URL 地址。</p><p>如果您没有给文件关联一个路径，JSP编译器默认在当前路径下寻找。</p><p> 等价的XML语法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">&lt;jsp:directive.<span class="hljs-keyword">include</span> <span class="hljs-keyword">file</span>=<span class="hljs-string">&quot;文件相对 url 地址&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>当每个页面都有导航的时候，我们只需要使用一个，这个时候就可以使用包含指令：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/include1.png"></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/baohan.png"></p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/baohan1.png"></p><p>一般被包含的jsp文件我们会取名为 jspf(jsp片断)：</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/pianduan.png"></p><h5 id="2-4-3、taglib指令"><a href="#2-4-3、taglib指令" class="headerlink" title="2.4.3、taglib指令"></a>2.4.3、taglib指令</h5><p>JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。</p><p> Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。</p><p> Taglib指令的语法：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;<span class="hljs-meta">%</span>@ taglib uri=<span class="hljs-string">&quot;uri&quot;</span> prefix=<span class="hljs-string">&quot;prefixOfTag&quot;</span> <span class="hljs-meta">%</span>&gt;<br></code></pre></td></tr></table></figure><p> uri属性确定标签库的位置，prefix属性指定标签库的前缀。</p><p> 等价的XML语法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;jsp:directive.taglib <span class="hljs-attribute">uri</span>=<span class="hljs-string">&quot;uri&quot;</span> <span class="hljs-attribute">prefix</span>=<span class="hljs-string">&quot;prefixOfTag&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="2-5、JSP动作元素"><a href="#2-5、JSP动作元素" class="headerlink" title="2.5、JSP动作元素"></a><a href="https://www.runoob.com/jsp/jsp-actions.html">2.5、JSP动作元素</a></h4><p>JSP行为标签使用XML语法结构来控制servlet引擎。它能够<code>动态</code>插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。</p><p> 行为标签只有一种语法格式，它严格遵守XML标准：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp:action_name</span> <span class="hljs-attr">attribute</span>=<span class="hljs-string">&quot;value&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p> 行为标签基本上是一些预先就定义好的函数，下表罗列出了一些可用的</p><h5 id="2-5-1、JSP动作标签：："><a href="#2-5-1、JSP动作标签：：" class="headerlink" title="2.5.1、JSP动作标签：："></a>2.5.1、JSP动作标签：：</h5><table><thead><tr><th align="left"><strong>语法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">jsp:include</td><td align="left">用于在当前页面中包含静态或动态资源</td></tr><tr><td align="left">jsp:useBean</td><td align="left">寻找和初始化一个JavaBean组件</td></tr><tr><td align="left">jsp:setProperty</td><td align="left">设置 JavaBean组件的值</td></tr><tr><td align="left">jsp:getProperty</td><td align="left">将 JavaBean组件的值插入到 output中</td></tr><tr><td align="left">jsp:forward</td><td align="left">从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td align="left">jsp:plugin</td><td align="left">用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td align="left">jsp:element</td><td align="left">动态创建一个XML元素</td></tr><tr><td align="left">jsp:attribute</td><td align="left">定义动态创建的XML元素的属性</td></tr><tr><td align="left">jsp:body</td><td align="left">定义动态创建的XML元素的主体</td></tr><tr><td align="left">jsp:text</td><td align="left">用于封装模板数据</td></tr></tbody></table><h5 id="2-5-2、所有的动作要素都有两个属性"><a href="#2-5-2、所有的动作要素都有两个属性" class="headerlink" title="2.5.2、所有的动作要素都有两个属性"></a>2.5.2、所有的动作要素都有两个属性</h5><ul><li><p>id属性：</p><p>id属性是动作元素的唯一标识，可以在JSP页面中引用。动作元素创建的id值可以通过PageContext来调用。 </p></li><li><p>scope属性：</p><p>该属性用于识别动作元素的生命周期。 id属性和scope属性有直接关系，scope属性定义了相关联id对象的寿命。 scope属性有四个可能的值： (a) page, (b)request, (c)session, 和 (d) application。 </p></li></ul><h5 id="2-5-3、-lt-jsp-include-gt-动作元素"><a href="#2-5-3、-lt-jsp-include-gt-动作元素" class="headerlink" title="2.5.3、**&lt;jsp:include&gt;**动作元素"></a>2.5.3、**&lt;jsp:include&gt;**动作元素</h5><p>用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;jsp:include <span class="hljs-attribute">page</span>=<span class="hljs-string">&quot;相对 URL 地址&quot;</span> <span class="hljs-attribute">flush</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p> 前面已经介绍过include指令，它是在JSP文件被转换成Servlet的时候引入文件，而这里的</p><p>&lt;jsp:include&gt;动作不同，插入文件的时间是在页面被请求的时候。 </p><p>以下是include动作相关的属性列表。</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">page</td><td align="left">包含在页面中的相对URL地址。</td></tr><tr><td align="left">flush</td><td align="left">布尔属性，定义在包含资源前是否刷新缓存区。</td></tr></tbody></table><h5 id="2-5-4、-lt-jsp-forward-gt-动作"><a href="#2-5-4、-lt-jsp-forward-gt-动作" class="headerlink" title="**2.5.4、&lt;jsp:forward&gt;**动作"></a>**2.5.4、&lt;jsp:forward&gt;**动作</h5><p>把请求转到另外的页面。jsp:forward标记只有一个属性page。语法格式如下所示：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp:forward</span> <span class="hljs-attr">page</span>=<span class="hljs-string">&quot;相对 URL 地址&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>以下是foward相关联的属性：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">page</td><td align="left">page属性包含的是一个相对URL。page的值既可以直接给出，也可以在请求的时候动态计算，可以是一个JSP页面或者一个 Java Servlet.</td></tr></tbody></table><h5 id="2-5-5、-lt-jsp-useBean-gt-动作用来加载一个将在JSP页面中使用的JavaBean。"><a href="#2-5-5、-lt-jsp-useBean-gt-动作用来加载一个将在JSP页面中使用的JavaBean。" class="headerlink" title="2.5.5、&lt;jsp:useBean&gt; 动作用来加载一个将在JSP页面中使用的JavaBean。"></a><strong>2.5.5、&lt;jsp:useBean&gt;</strong> 动作用来加载一个将在JSP页面中使用的JavaBean。</h5><p>这个功能非常有用，因为它使得我们可以发挥 Java 组件复用的优势。</p><p>jsp:useBean动作最简单的语法为：  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;jsp:useBean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;package.class&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p> 在类载入后，我们既可以通过 jsp:setProperty 和 jsp:getProperty 动作来修改和检索bean的属性。  </p><p>以下是useBean动作相关的属性列表。</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">class</td><td align="left">指定Bean的完整包名。</td></tr><tr><td align="left">type</td><td align="left">指定将引用该对象变量的类型。</td></tr><tr><td align="left">beanName</td><td align="left">通过 java.beans.Beans 的 instantiate() 方法指定Bean的名字。</td></tr></tbody></table><p>**&lt;jsp:setProperty&gt;**用来设置已经实例化的Bean对象的属性，有两种用法。首先，你可以在jsp:useBean元素的外面（后面）使用jsp:setProperty，如下所示：  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;jsp:useBean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;myName&quot;</span> ... /&gt;<br>...<br>&lt;jsp:setProperty <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;myName&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;someProperty&quot;</span> .../&gt;<br></code></pre></td></tr></table></figure><p>此时，不管jsp:useBean是找到了一个现有的Bean，还是新创建了一个Bean实例，jsp:setProperty都会执行。第二种用法是把jsp:setProperty放入jsp:useBean元素的内部，如下所示：  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&lt;jsp<span class="hljs-function">:useBean</span> id=<span class="hljs-string">&quot;myName&quot;</span> <span class="hljs-string">...</span> &gt;<br><span class="hljs-string">...</span><br>   &lt;jsp<span class="hljs-function">:setProperty</span> name=<span class="hljs-string">&quot;myName&quot;</span> property=<span class="hljs-string">&quot;someProperty&quot;</span> <span class="hljs-string">.../</span>&gt;<br>&lt;<span class="hljs-string">/jsp</span><span class="hljs-function">:useBean</span>&gt;<br></code></pre></td></tr></table></figure><p>此时，jsp:setProperty只有在新建Bean实例时才会执行，如果是使用现有实例则不执行jsp:setProperty。  </p><p>jsp:setProperty动作有下面四个属性,如下表：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">name属性是必需的。它表示要设置属性的是哪个Bean。</td></tr><tr><td align="left">property</td><td align="left">property属性是必需的。它表示要设置哪个属性。有一个特殊用法：如果property的值是”*”，表示所有名字和Bean属性名字匹配的请求参数都将被传递给相应的属性set方法。</td></tr><tr><td align="left">value</td><td align="left">value 属性是可选的。该属性用来指定Bean属性的值。字符串数据会在目标类中通过标准的valueOf方法自动转换成数字、boolean、Boolean、 byte、Byte、char、Character。例如，boolean和Boolean类型的属性值（比如”true”）通过 Boolean.valueOf转换，int和Integer类型的属性值（比如”42”）通过Integer.valueOf转换。  　value和param不能同时使用，但可以使用其中任意一个。</td></tr><tr><td align="left">param</td><td align="left">param 是可选的。它指定用哪个请求参数作为Bean属性的值。如果当前请求没有参数，则什么事情也不做，系统不会把null传递给Bean属性的set方法。因此，你可以让Bean自己提供默认属性值，只有当请求参数明确指定了新值时才修改默认属性值。</td></tr></tbody></table><p>**&lt;jsp:getProperty&gt;**动作提取指定Bean属性的值，转换成字符串，然后输出。语法格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;jsp:useBean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;myName&quot;</span> ... /&gt;<br>...<br>&lt;jsp:getProperty <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;myName&quot;</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;someProperty&quot;</span> .../&gt;<br></code></pre></td></tr></table></figure><p>下表是与getProperty相关联的属性：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">要检索的Bean属性名称。Bean必须已定义。</td></tr><tr><td align="left">property</td><td align="left">表示要提取Bean属性的值</td></tr></tbody></table><h4 id="2-6、JSP九大内置对象"><a href="#2-6、JSP九大内置对象" class="headerlink" title="2.6、JSP九大内置对象"></a>2.6、JSP九大内置对象</h4><p>引入：在jsp页面里面 ，可以直接使用request和session，为什么可以直接使用？</p><p>这里request和session 就是别人已经帮我们定义好9个内置对象中的其中两个，我们直接</p><p>拿到使用就是。</p><table><thead><tr><th align="left"><strong>对象</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">request</td><td align="left"><strong>HttpServletRequest</strong>类的实例</td></tr><tr><td align="left">response</td><td align="left"><strong>HttpServletResponse</strong>类的实例</td></tr><tr><td align="left">out</td><td align="left"><strong>PrintWriter</strong>类的实例，用于把结果输出至网页上，<strong>JSPWriter</strong></td></tr><tr><td align="left">session</td><td align="left"><strong>HttpSession</strong>类的实例</td></tr><tr><td align="left">application</td><td align="left"><strong>ServletContext</strong>类的实例，与应用上下文有关</td></tr><tr><td align="left">config</td><td align="left"><strong>ServletConfig</strong>类的实例</td></tr><tr><td align="left">pageContext</td><td align="left"><strong>PageContext</strong>类的实例，提供对JSP页面所有对象以及命名空间的访问</td></tr><tr><td align="left">page</td><td align="left">类似于Java类中的this关键字</td></tr><tr><td align="left">Exception</td><td align="left"><strong>Exception</strong>类的对象，代表发生错误的JSP页面中对应的异常对象</td></tr></tbody></table><h4 id="2-6、JSP四大作用域对象"><a href="#2-6、JSP四大作用域对象" class="headerlink" title="2.6、JSP四大作用域对象"></a>2.6、JSP四大作用域对象</h4><table><thead><tr><th>作用域对象</th><th>类</th><th></th></tr></thead><tbody><tr><td>application</td><td>ServletContext</td><td>整个应用</td></tr><tr><td>session</td><td>HttpSession</td><td>一次会话</td></tr><tr><td>request</td><td>HttpServletRequest</td><td>一次请求</td></tr><tr><td>pageContext</td><td>PageContext</td><td>当前页</td></tr></tbody></table><p>JSP四大作用域对象属于9大内置对象</p><h4 id="2-7、补充内容"><a href="#2-7、补充内容" class="headerlink" title="2.7、补充内容"></a>2.7、补充内容</h4><p>在JSP动作元素中，我们只了解 jsp:include这个动作元素</p><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/jspinclude.png"></p><p>我们要用 jsp:include 来做包含页面的时候，就不能再使用<strong>片段</strong>（<code>2.4.2</code>）</p><p>面试题:动态包含(动作jsp:include)与静态包含(指令include)的区别? </p><p>什么时候用动态包含，什么时候用静态包含?</p><ul><li>静态包含先把页面包含进来,再翻译成java代码!!  (只有一个文件)</li><li>动态包含先都编译成java代码,再将内容进行包含!!  (有多个文件)</li></ul><p>有个说法：</p><ul><li>如果包含的是静态页面(html),那么使用静态包含</li><li>如果包含的是动态网页(jsp),那么使用动态包含</li></ul><p>编译的文件（\apache-tomcat-7.0.57\work\Catalina\路径下面）</p><ul><li>静态包含&lt;%@ include file=”/include/b.jsp” %&gt;</li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/clip_image001.png" alt="img"></p><ul><li>动态包含&lt;jsp:include page=”/include2/b.jsp”&gt;&lt;/ jsp:include&gt;</li></ul><p><img src="/2019/11/21/Servlet%E4%BA%A4%E4%BA%92%E4%B8%8EJSP/clip_image002.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSP</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库练习（一）</title>
    <link href="/2019/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>1、 部门表：DEPT</p><table><thead><tr><th><strong>No.</strong></th><th><strong>字段名称</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1</strong></td><td>DEPTNO</td><td>BIGINT</td><td>部门编号，由两位数字所组成(主键)</td></tr><tr><td>2</td><td>DNAME</td><td>VARCHAR(20)</td><td>部门名称，由 14 位字符所组成</td></tr><tr><td>3</td><td>LOC</td><td>VARCHAR(20)</td><td>部门位置</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> DEPT ( <br>DEPTNO <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY</span> KEY COMMENT &quot;部门编号，有两位数据组成主键&quot;, <br>DNAME <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ), <br>LOC <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <br>);<br></code></pre></td></tr></table></figure><p>2、 雇员表：EMP</p><table><thead><tr><th><strong>No.</strong></th><th><strong>字段名称</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1</td><td>EMPNO</td><td>BIGINT</td><td>雇员编号，由四位数字所组成(主键)</td></tr><tr><td>2</td><td>ENAME</td><td>VARCHAR(20)</td><td>雇员姓名</td></tr><tr><td>3</td><td>JOB</td><td>VARCHAR(20)</td><td>职位</td></tr><tr><td>4</td><td>MGR</td><td>BIGINT</td><td>一个雇员对应的领导编号（雇员编号）</td></tr><tr><td>5</td><td>HIREDATE</td><td>DATE</td><td>雇员的雇佣日期</td></tr><tr><td>6</td><td>SAL</td><td>DOUBLE(7,2)</td><td>基本工资，由两位小数和五位整数所组成</td></tr><tr><td>7</td><td>COMM</td><td>DOUBLE(7,2)</td><td>奖金/奖金</td></tr><tr><td>8</td><td>DEPTNO</td><td>BIGINT</td><td>一个雇员所在的部门编号，与dept 表的对应</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> EMP (<br>EMPNO <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY</span> KEY COMMENT &quot;GUYUANBIANHAO &quot;,<br>ENAME <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ),<br>JOB <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ),<br>MGR <span class="hljs-type">BIGINT</span>,<br>HIREDATE <span class="hljs-type">DATE</span>,<br>SAL <span class="hljs-keyword">DOUBLE</span> ( <span class="hljs-number">7</span>, <span class="hljs-number">2</span> ),<br>COMM <span class="hljs-keyword">DOUBLE</span> ( <span class="hljs-number">7</span>, <span class="hljs-number">2</span> ),<br>DEPTNO <span class="hljs-type">BIGINT</span>,<br><span class="hljs-keyword">FOREIGN</span> KEY EMP ( DEPTNO ) <span class="hljs-keyword">REFERENCES</span> DEPT ( DEPTNO ) <br>);<br></code></pre></td></tr></table></figure><p>3、在上述两表中插入数据<br>DEPT 表数据:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`DEPT`</span> <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;ACCOUNTING&#x27;</span>, <span class="hljs-string">&#x27;NEW YORK&#x27;</span> );<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`DEPT`</span> <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;RESEARCH&#x27;</span>, <span class="hljs-string">&#x27;DALLAS&#x27;</span> );<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`DEPT`</span> <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;SALES&#x27;</span>, <span class="hljs-string">&#x27;CHICAGO&#x27;</span> );<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`DEPT`</span> <span class="hljs-keyword">VALUES</span> ( <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;OPERATIONS&#x27;</span>, <span class="hljs-string">&#x27;BOSTON&#x27;</span> );<br></code></pre></td></tr></table></figure><p>EMP 表数据:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7369</span>, <span class="hljs-string">&#x27;SMITH&#x27;</span>, <span class="hljs-string">&#x27;CLERK&#x27;</span>, <span class="hljs-number">7902</span>, <span class="hljs-string">&#x27;1980-12-17&#x27;</span>, <span class="hljs-number">800</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7499</span>, <span class="hljs-string">&#x27;ALLEN&#x27;</span>, <span class="hljs-string">&#x27;SALESMAN&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-02-20&#x27;</span>, <span class="hljs-number">1600</span>, <span class="hljs-number">300</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7521</span>, <span class="hljs-string">&#x27;WARD&#x27;</span>, <span class="hljs-string">&#x27;SALESMAN&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-02-22&#x27;</span>, <span class="hljs-number">1250</span>, <span class="hljs-number">500</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7566</span>, <span class="hljs-string">&#x27;JONES&#x27;</span>, <span class="hljs-string">&#x27;MANAGER&#x27;</span>, <span class="hljs-number">7839</span>, <span class="hljs-string">&#x27;1981-04-02&#x27;</span>, <span class="hljs-number">2975</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7654</span>, <span class="hljs-string">&#x27;MARTIN&#x27;</span>, <span class="hljs-string">&#x27;SALESMAN&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-09-28&#x27;</span>, <span class="hljs-number">1250</span>,  <span class="hljs-number">1400</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7698</span>,  <span class="hljs-string">&#x27;BLAKE&#x27;</span>, <span class="hljs-string">&#x27;MANAGER&#x27;</span>, <span class="hljs-number">7839</span>,  <span class="hljs-string">&#x27;1981-05-01&#x27;</span>, <span class="hljs-number">2850</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7782</span>,  <span class="hljs-string">&#x27;CLARK&#x27;</span>, <span class="hljs-string">&#x27;MANAGER&#x27;</span>, <span class="hljs-number">7839</span>,  <span class="hljs-string">&#x27;1981-06-09&#x27;</span>, <span class="hljs-number">2450</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7788</span>, <span class="hljs-string">&#x27;SCOTT&#x27;</span>, <span class="hljs-string">&#x27;ANALYST&#x27;</span>, <span class="hljs-number">7566</span>, <span class="hljs-string">&#x27;1987-04-19&#x27;</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7839</span>, <span class="hljs-string">&#x27;KING&#x27;</span>, <span class="hljs-string">&#x27;PRESIDENT&#x27;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;1981-11-17&#x27;</span>, <span class="hljs-number">5000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7844</span>, <span class="hljs-string">&#x27;TURNER&#x27;</span>, <span class="hljs-string">&#x27;SALESMAN&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-09-08&#x27;</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7876</span>, <span class="hljs-string">&#x27;ADAMS&#x27;</span>, <span class="hljs-string">&#x27;CLERK&#x27;</span>, <span class="hljs-number">7788</span>, <span class="hljs-string">&#x27;1987-05-23&#x27;</span>, <span class="hljs-number">1100</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7900</span>,  <span class="hljs-string">&#x27;JAMES&#x27;</span>, <span class="hljs-string">&#x27;CLERK&#x27;</span>, <span class="hljs-number">7698</span>, <span class="hljs-string">&#x27;1981-12-03&#x27;</span>, <span class="hljs-number">950</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7902</span>, <span class="hljs-string">&#x27;FORD&#x27;</span>, <span class="hljs-string">&#x27;ANALYST&#x27;</span>, <span class="hljs-number">7566</span>, <span class="hljs-string">&#x27;1981-12-03&#x27;</span>, <span class="hljs-number">3000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-symbol">`EMP`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7934</span>, <span class="hljs-string">&#x27;MILLER&#x27;</span>, <span class="hljs-string">&#x27;CLERK&#x27;</span>, <span class="hljs-number">7782</span>, <span class="hljs-string">&#x27;1982-01-23&#x27;</span>, <span class="hljs-number">1300</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>4、练习下面内容：</p><table><thead><tr><th>练习下面内容：</th></tr></thead><tbody><tr><td>01.查询每个雇员的编号、姓名、职位。<br>SELECT EMPNO,ename,job FROM emp;#SQL语句所有（关键字，表，字段）大小写不敏感</td></tr><tr><td>02.查询每个雇员的职位，使用 DISTINCT消除掉显示的重复行记录。<br>SELECT DISTINCT JOB FROM EMP;</td></tr><tr><td>03.计算每个雇员的编号、姓名、基本年薪。年薪=(工资+奖金)*12，(使用  IFNULL 函数判断  NULL）<br>SELECT EMPNO,ENAME,(SAL+IFNULL(COMM,0)) *12 FROM EMP;</td></tr><tr><td>04.每个雇员每个月公司会补贴饭食  200 元，交通补助 300 元，计算年薪。<br>SELECT (SAL+IFNULL(COMM,0)+500) *12 FROM EMP;</td></tr><tr><td>05.查询基本工资高于 2000 的全部雇员信息。<br>SELECT * FROM EMP WHERE SAL&gt;2000;</td></tr><tr><td>06.查询出 smith 的信息。<br>SELECT * FROM EMP WHERE ENAME=’SMITH’;#这个SMITH需要引起来</td></tr><tr><td>07.查询出所有不是 CLERK 的详细信息。<br>SELECT * FROM EMP WHERE JOB!=’CLERK’;</td></tr><tr><td>08.查询出所有销售人员(SALESMAN)的基本信息，并且要求销售人员的工资高于 1300。<br>SELECT * FROM EMP WHERE JOB=’SALESMAN’ AND SAL&gt;1300;</td></tr><tr><td>09.查询出工资范围在 1500~3000 之间的全部雇员信息（包含 1500 和 3000）。<br>SELECT * FROM EMP WHERE SAL BETWEEN 1500 AND 3000;</td></tr><tr><td>10.查询出所有经理或者是销售人员的信息，并且要求这些人的基本工资高于  1500。<br>SELECT * FROM EMP WHERE JOB IN (‘SALESMAN’,’MANAGER’) AND SAL&gt;1500;</td></tr><tr><td>11.要求查询出所有在 1981 年雇佣的雇员信息。<br>SELECT * FROM emp where HIREDATE like ‘1981%’;</td></tr><tr><td>12.查询所有领取奖金的雇员信息（comm 不为空）。<br>SELECT * FROM EMP WHERE COMM IS NOT NULL;</td></tr><tr><td>13.查询所有领取奖金高于 100 的雇员信息。<br>SELECT * FROM EMP WHERE COMM IS NOT NULL AND COMM&gt;100;</td></tr><tr><td>14.查询出雇员编号是 7369、7566、9999 的雇员信息。<br>SELECT * FROM EMP WHERE EMPNO IN (7369,7566,9999);</td></tr><tr><td>15.查询出所有雇员姓名是以 A 开头的全部雇员信息。<br>SELECT * FROM EMP WHERE ENAME LIKE ‘A%’;</td></tr><tr><td>16.查询出雇员姓名第二个字母是 M 的全部雇员信息。<br>SELECT * FROM EMP WHERE ENAME LIKE ‘_M%’;</td></tr><tr><td>17.查询出雇员姓名任意位置上包含字母 A  的全部雇员信息。<br>SELECT * FROM EMP WHERE ENAME LIKE ‘%A%’;</td></tr><tr><td>18.查询出所有雇员的信息，要求按照工资排序。<br>SELECT * FROM EMP ORDER BY SAL;</td></tr><tr><td>19.要求查询所有雇员的信息，按照雇佣日期由先后排序。<br>SELECT * FROM EMP ORDER BY HIREDATE;</td></tr><tr><td>20.查询全部雇员信息，按照工资由高到低排序，如果工资相同，则按照雇佣日期由先后排序。<br>SELECT * FROM EMP ORDER BY SAL DESC,HIREDATE;</td></tr><tr><td>21.查询部门 30 中的所有员工。<br>SELECT * FROM EMP WHERE DEPTNO=30;</td></tr><tr><td>22.查询出所有办事员（CLERK）的姓名，编号和部门编号。<br>SELECT ENAME,EMPNO,DEPTNO FROM EMP WHERE JOB=’CLERK’;</td></tr><tr><td>23.查询出奖金高于薪金的员工。<br>SELECT * FROM EMP WHERE COMM&gt;SAL;</td></tr><tr><td>24.查询出奖金高于薪金的 60%的员工。<br>SELECT * FROM EMP WHERE COMM&gt;0.6*SAL;</td></tr><tr><td>25.查询出部门 10 中所有经理（MANAGER）和部门 20 中所有办事员（CLERK）的详细资料。<br>SELECT * FROM EMP WHERE DEPTNO=10 AND JOB=’MANAGER’ OR DEPTNO=20 AND JOB=’CLERK’;<br>SELECT * FROM EMP WHERE DEPTNO=10 AND JOB=’MANAGER’ UNION SELECT * FROM EMP WHERE DEPTNO=20 AND JOB=’CLERK’;</td></tr><tr><td>26.查询出部门 10 中所有经理，部门 20 中所有办事员，既不是经理又不是办事员但其薪金大于或等于 2000  的所有员工的信息。<br>SELECT * FROM emp where (JOB=’MANAGER’ and deptno=10) OR  (job=’CLERK’ and deptno=20 ) OR (JOB!=’MANAGER’ and job!=’CLERK’  and sal&gt;=2000)；</td></tr><tr><td>27.查询出收取奖金的员工的不同工作。<br>SELECT DISTINCT JOB FROM EMP WHERE COMM IS NOT NULL;</td></tr><tr><td>28.查询出不收取奖金或收取的奖金低于  100 的员工。<br>SELECT * FROM EMP WHERE COMM IS NULL OR COMM&lt;100;<br>#WHERE COMM&lt;100  会过先滤掉空值，在比较</td></tr><tr><td>29.查询出不带有“R”的员工的姓名。<br>SELECT * FROM EMP WHERE ENAME NOT LIKE ‘%R%’;</td></tr><tr><td>30.查询出每个雇员的姓名、职位、领导姓名。<br>SELECT A.ENAME,A.JOB,B.ENAME FROM EMP A,EMP B WHERE A.MGR=B.EMPNO;#老板没有领导，这样写会少一条老板的记录<br>SELECT A.ENAME,A.JOB,B.ENAME FROM EMP A LEFT JOIN EMP B ON A.MGR=B.EMPNO;</td></tr><tr><td>31.查询出所有员工的编号、姓名及其直接上级的编号、姓名，显示的结果按领导年工资的降序排列。<br>SELECT A.EMPNO,A.ENAME,A.JOB,A.MGR,B.ENAME FROM EMP A LEFT JOIN EMP B ON A.MGR=B.EMPNO ORDER BY B.SAL DESC;</td></tr><tr><td>32.查询出在销售部（SALES）工作的员工姓名、基本工资、雇佣日期、部门名称。（不知道销售部编号）。<br>SELECT A.ENAME,A.SAL,A.HIREDATE,B.DNAME FROM EMP A,DEPT B WHERE A.DEPTNO=B.DEPTNO AND B.DNAME=’SALES’;</td></tr><tr><td>33.查询出所有员工的姓名、部门名称和工资。<br>SELECT A.ENAME,A.SAL,A.HIREDATE,B.DNAME FROM EMP A,DEPT B WHERE A.DEPTNO=B.DEPTNO;</td></tr><tr><td>34.查询出所有员工的年工资，所在部门名称，按年薪从低到高排序。<br>SELECT (A.SAL+IFNULL(A.COMM,0)) * 12 年薪,B.DNAME FROM EMP A,DEPT B WHERE A.DEPTNO=B.DEPTNO ORDER BY 年薪 DESC;</td></tr><tr><td>35.查询出某个员工的上级主管及所在部门名称，并要求出这些主管中的薪水超过  3000。<br>SELECT A.ENAME,B.ENAME,C.DNAME FROM EMP A LEFT JOIN EMP B ON A.MGR=B.EMPNO LEFT JOIN DEPT C ON A.DEPTNO=C.DEPTNO WHERE B.SAL&gt;3000;</td></tr><tr><td>36.查询出公司的最高和最低工资。<br>SELECT MAX(SAL),MIN(SAL) FROM EMP;</td></tr><tr><td>37.查询出每个部门的人数、平均工资，只显示部门编号。<br>SELECT DEPTNO,COUNT(1),AVG(SAL) FROM EMP GROUP BY DEPTNO;</td></tr><tr><td>38.查询出每种职位的最高和最低工资。<br>SELECT JOB,MAX(SAL),MIN(SAL) FROM EMP GROUP BY JOB;</td></tr><tr><td>39.查询平均工资高于 2000 的职位信息，以及从事此职位的雇员人数、平均工资。<br>SELECT JOB,COUNT(1),AVG(SAL) FROM EMP GROUP BY JOB HAVING AVG(SAL)&gt;2000;</td></tr><tr><td>40.查询员工编号大于其领导编号的每个员工的姓名、职位、领导名称。<br>SELECT A.ENAME,A.JOB,B.ENAME FROM EMP A LEFT JOIN EMP B ON A.MGR=B.EMPNO WHERE A.EMPNO&gt;A.MGR;<br>SELECT e.ename,e.job,p.ename,e.empno,p.empno FROM  emp AS e LEFT JOIN emp AS p ON e.mgr = p.empno  where  e.empno&gt;p.empno</td></tr><tr><td>*41 查询出至少有一个员工的所有部门编号、名称，并统计出这些部门的平均工资、最低工资、最高工资。<br>SELECT d.deptno,d.dname,avg(p.sal),min(p.sal),max(p.sal) FROM emp AS p join dept AS d ON p.deptno = d.deptno  GROUP BY d.deptno HAVING count(p.deptno)&gt;=1</td></tr><tr><td>*42.查询出部门名称和这些部门的员工信息（数量、平均工资），同时列出那些没有员工的部门。<br>SELECT d.dname,e.ename,count(e.empno),avg(e.sal) FROM dept AS d left JOIN emp AS e on d.deptno=e.deptno GROUP BY  d.deptno</td></tr><tr><td>43.查询工资比smith 更高的全部员工信息。<br>SELECT * FROM EMP WHERE SAL&gt;(SELECT SAL FROM EMP WHERE ENAME=’SMITH’);</td></tr><tr><td>44.查询工资和职位和smith 相同的所有员工信息。<br>select * from emp where (sal,job)=(select sal,job from emp where ename=’SMITH’);</td></tr><tr><td>*45.查询各部门的部门编号，部门名词，部门地址，员工人数和平均工资。<br>select d.deptno,d.dname,d.loc,count(e.empno),IFNULL(avg(e.sal),0) from dept AS d  left JOIN emp  AS e ON d.deptno=e.deptno GROUP BY d.deptno;</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
      <tag>数据库练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试</title>
    <link href="/2019/11/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <url>/2019/11/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1、软件测试一些概念"><a href="#1、软件测试一些概念" class="headerlink" title="1、软件测试一些概念"></a>1、软件测试一些概念</h3><p><strong>按是否查看程序内部结构分为</strong></p><p>黑盒测试（black-box testing）：只关心输入和输出的结果，黑盒测试分为功能测试和性能测试<br>白盒测试（white-box testing）：去研究里面的源代码和程序结构</p><p><strong>按是否运行程序分为：静态测试、动态测试</strong></p><p>静态测试（static testing）</p><p>是指不实际运行被测软件，而只是静态地检查程序代码、界面或文档可能存在的错误的过程。包括：</p><ul><li>对于代码测试，主要是测试代码是否符合相应的标准和规范。</li><li>对于界面测试，主要测试软件的实际界面与需求中的说明是否相符。</li><li>对于文档测试，主要测试用户手册和需求说明是否真正符合用户的实际需求。</li></ul><p>动态测试（dynamic testing）</p><p>是指实际运行被测程序，输入相应的测试数据，检查输出结果和预期结果是否相符的过程</p><p><strong>UT是单元测试，Unit Test；</strong></p><p>单元测试任务包括：1 模块接口测试；2 模块局部数据结构测试；3 模块边界条件测试；4 模块中所有独立执行通路测试；5 模块的各条错误处理通路测试。；</p><p><strong>IT是集成测试，Integration Test；</strong></p><p>集成测试阶段是以黑盒法为主，在自底向上集成的早期，白盒法测试占一定的比例，随着集成测试的不断深入，这种比例在测试过程中将越来越少，渐渐地，黑盒法测试占据主导地位。</p><p><strong>ST是系统测试，System Test；</strong></p><p>从技术角度看，系统测试是整个测试阶段的最后一步，所有的开发和测试在这一点上集中表现为生成一个具有一定功能的软件系统。该阶段主要对系统的准确性及完整性等方面进行测试。主要进行：功能确认测试、运行测试、强度测试、恢复测试、安全性测试等。系统测试的测试人员由测试组成员（或质量保证人员）或测试组成员与用户共同测试。在整个系统开发完成，即将交付用户使用前进行。在这一阶段，完全采用黑盒法对整个系统进行测试。</p><p><strong>UAT是验收测试，User Acceptance Test；</strong></p><p>验收测试是向未来的用户表明系统能够像预定要求那样工作。经集成测试后，已经按照设计把所有的模块组装成一个完整的软件系统，接口错误也已经基本排除了，接着就应该进一步验证软件的有效性，这就是验收测试的任务，即软件的功能和性能如同用户所合理期待的那样。 </p><p><strong>功能测试</strong></p><p>功能测试分三个阶段，第一个阶段自测，第二个阶段交叉测试，最后回归测试。交叉测试按字面意思理解就是把测试人员所测试的模块交换测试。回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。回归测试是指重复以前的全部或部分的相同测试，回归测试的重心，以关键性模组为核心。</p><h3 id="2、单元测试"><a href="#2、单元测试" class="headerlink" title="2、单元测试"></a>2、单元测试</h3><p>写了个类，要给别人用，会不会有bug？测试一下。</p><p>程序单元是应用的最小可测试部件。一个单元可能是单个程序、类、对象、方法等。</p><p>单元测试是保障业务代码质量的非常有效工具，也是提高代码可靠性的必要手段。单元测试是编写测试代码，应该准确、快速地保证程序基本模块的正确性。<br>用main方法测试的问题：不能一起运行，大多数情况下需要人为的观察输出确定是否正确。</p><p>减少Bug、快速定位Bug减少调试时间、提高代码质量、性能测试、放心重构</p><h4 id="2-1、Junit4入门"><a href="#2-1、Junit4入门" class="headerlink" title="2.1、Junit4入门"></a>2.1、Junit4入门</h4><p>JUnit是一个单元测试框架，我们可以基于它编写用来测试代码的代码，从而更方便地进行回归测试。</p><h5 id="2-1-1、导包"><a href="#2-1-1、导包" class="headerlink" title="2.1.1、导包"></a>2.1.1、导包</h5><p><strong>Eclipse</strong>自带junit包，也可导入最新的Junit包，最好是自己导入的最新的包。<a href="https://github.com/junit-team/junit4/wiki/Download-and-Install">junit4传送门</a></p><p><strong>IntelliJ IDEA</strong>创建Maven项目，添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-1-2、新建一个Test类"><a href="#2-1-2、新建一个Test类" class="headerlink" title="2.1.2、新建一个Test类"></a>2.1.2、新建一个Test类</h5><p><strong>Eclipse：</strong>New–&gt;JunitTest Case–&gt;在Junit Test Case界面中，选New Junit 4 test , Name一般为要被测试的类名+Test,Class under test可以选对哪个类进行测试、对这个类的哪些方法测试。–&gt;Finish</p><p><strong>IntelliJ IDEA</strong>：</p><p>写一个方法类，定义两个方法实现两个数的相加和相减运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JunitDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>  b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>  b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a-b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下写我们的测试类：</p><p><code>assertEquals</code>方法第一个参数是预期的值，第二个参数就是调用类的方法。如果调用结果和预期不一样就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Assert;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JunitTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><span class="hljs-comment">//测试方法必须用@Test修饰</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//测试方法必须用public void修饰，不能带参数</span><br>        assertEquals(<span class="hljs-number">6</span>, <span class="hljs-keyword">new</span> JunitDemo().add(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>));<br>    &#125;<br>    <span class="hljs-meta">@Test</span><span class="hljs-comment">//测试方法必须用@Test修饰</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSubtract</span><span class="hljs-params">()</span></span>&#123;<br>        assertEquals(<span class="hljs-number">20</span>, <span class="hljs-keyword">new</span> JunitDemo().subtract(<span class="hljs-number">30</span>, <span class="hljs-number">10</span>));<br>    &#125;<br>    <span class="hljs-comment">//每个测试方法必须可以单独测试，各方法间不要有依赖。</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-1-3、测试的类和开发的类分开放"><a href="#2-1-3、测试的类和开发的类分开放" class="headerlink" title="2.1.3、测试的类和开发的类分开放"></a>2.1.3、测试的类和开发的类分开放</h5><p>测试类应有单独源代码目录，不要和业务代码放在一起。</p><p>建议测试类放在test包中，使用<code>Test作为类名的后缀</code>,测试方法使用<code>test作为方法名的前缀</code>，如测试类JunitTest和测试方法testAdd。</p><p><img src="/2019/11/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/junitdemo.png"></p><h5 id="2-1-4、静态引入"><a href="#2-1-4、静态引入" class="headerlink" title="2.1.4、静态引入"></a>2.1.4、静态引入</h5><p>比如import static org.junit.Assert.*; 静态引入一个类，类里面有很多静态方法，可以直接调用这个类里面的静态方法，而不用在其前面加 ‘类名.’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.assertEquals;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JunitTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><span class="hljs-comment">//测试方法必须用@Test修饰</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//测试方法必须用public void修饰，不能带参数</span><br>        assertEquals(<span class="hljs-number">6</span>, <span class="hljs-keyword">new</span> JunitDemo().add(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>));<br>    &#125;<br>    <span class="hljs-meta">@Test</span><span class="hljs-comment">//测试方法必须用@Test修饰</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSubtract</span><span class="hljs-params">()</span></span>&#123;<br>        assertEquals(<span class="hljs-number">20</span>, <span class="hljs-keyword">new</span> JunitDemo().subtract(<span class="hljs-number">30</span>, <span class="hljs-number">10</span>));<br>    &#125;<br>    <span class="hljs-comment">//每个测试方法必须可以单独测试，各方法间不要有依赖。</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-1-5、运行测试"><a href="#2-1-5、运行测试" class="headerlink" title="2.1.5、运行测试"></a>2.1.5、运行测试</h5><p><strong>Eclipse：</strong>可以在测试类上或测试方法–&gt;右键–&gt;Run As–&gt;Junit Test</p><p><strong>IntelliJ IDEA：</strong>详见2.1.3图</p><h5 id="2-1-6、测试结果"><a href="#2-1-6、测试结果" class="headerlink" title="2.1.6、测试结果"></a>2.1.6、测试结果</h5><p><strong>Eclipse：</strong></p><p><code>测试通过</code></p><p><img src="/2019/11/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/junits.png"></p><p><code>测试失败</code></p><p><img src="/2019/11/19/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/junitf.png"></p><p><strong>IntelliJ IDEA：</strong>详见2.1.3图。</p><p>JUnit 将测试失败的情况分为两种：<code>failure</code>和 <code>error</code>。Failure 一般由单元测试使用的<code>断言方法判断失败引起</code>，它表示在测试点发现了问题；而 error 则是由<code>代码异常引起</code>，这是测试目的之外的发现，它可能产生于<code>测试代码本身</code>的错误，也可能是<code>被测试代码</code>中的一个隐藏的 bug。</p><h5 id="2-1-7、Assert断言"><a href="#2-1-7、Assert断言" class="headerlink" title="2.1.7、Assert断言"></a>2.1.7、Assert断言</h5><p>①Assert类里面有很多静态方法，查阅相关文档：<a href="https://junit.org/junit4/javadoc/latest/org/junit/Assert.html">https://junit.org/junit4/javadoc/latest/org/junit/Assert.html</a></p><p>②有的函数的第一个参数String message在断言没有通过，会显示出来，用来自定义提示错误。</p><p>列如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">assert</span><span class="hljs-constructor">Equals(String <span class="hljs-params">message</span>, <span class="hljs-params">double</span> <span class="hljs-params">expected</span>, <span class="hljs-params">double</span> <span class="hljs-params">actual</span>)</span><br></code></pre></td></tr></table></figure><p><code>③assertThat可以替代其他所有的assert</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">assert</span><span class="hljs-constructor">That(T <span class="hljs-params">actual</span>,<span class="hljs-params">org</span>.<span class="hljs-params">hamcrest</span>.Matcher&lt;T&gt; <span class="hljs-params">matcher</span>)</span>    <br><span class="hljs-keyword">assert</span><span class="hljs-constructor">That(String <span class="hljs-params">reason</span>,T <span class="hljs-params">actual</span>,<span class="hljs-params">org</span>.<span class="hljs-params">hamcrest</span>.Matcher&lt;T&gt; <span class="hljs-params">matcher</span>)</span>    <br></code></pre></td></tr></table></figure><p>需要hamcrest-cose-x.jar和hamcrest-library-x.jar，使用了这两个包后，junit包最好不要用eclipse自带的，会出错。包的下载地址：[hamcrest传送门](<a href="http://search.maven.org/#search|ga|1|g%3Aorg.hamcrest">http://search.maven.org/#search|ga|1|g%3Aorg.hamcrest</a>    hamcrest)</p><p>hamcrest帮助文档<a href="http://hamcrest.org/JavaHamcrest/javadoc/2.0.0.0/">http://hamcrest.org/JavaHamcrest/javadoc/2.0.0.0/</a>    </p><p>Matcher常用的方法见文章第四大点</p><h4 id="2-2、Junit4注解"><a href="#2-2、Junit4注解" class="headerlink" title="2.2、Junit4注解"></a>2.2、Junit4注解</h4><blockquote><p>@Test：讲一个普通方法修饰为测试方法<br>@BeforeClass：在所有方法执行前执行一次<br>@Before：在每一个方法执行前执行一次<br>@After：在每一个方法执行后执行一次<br>@AfterClass：在所有方法执行后执行一次。<br>@Ignore：修饰的方法会在测试运行时被忽略<br>@RunWith：修改测试运行器</p></blockquote><h5 id="2-2-1、-Test：测试方法"><a href="#2-2-1、-Test：测试方法" class="headerlink" title="2.2.1、@Test：测试方法"></a>2.2.1、@Test：测试方法</h5><p>@Test表示是测试方法，测试方法必须使用注解 <code>org.junit.Test </code>修饰。测试方法必须使用 public void 修饰，而且不能带有任何参数。</p><p><strong>异常以及时间测试</strong></p><p>注解<code>org.junit.Test</code>中有两个非常有用的参数：<code>expected</code> 和 <code>timeout</code>。</p><p>参数 <strong>expected</strong> 代表测试方法期望抛出指定的异常，如果运行测试并没有抛出这个异常，则JUnit 会认为这个测试没有通过。这为验证被测试方法在错误的情况下是否会抛出预定的异常提供了便利。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//当测试方法抛出NullPointerException时测试成功  </span><br><span class="hljs-variable">@Test</span>(expected = NullPointerException.class) <br><br><span class="hljs-comment">//如果代码里抛出了不止一处错误，不好区分，可以使用JUnit的ExpectedException Rule来解决</span><br><span class="hljs-variable">@Rule</span>  <br>public ExpectedException expectedException = ExpectedException.none();  <br></code></pre></td></tr></table></figure><p>另一个参数 <strong>timeout</strong>，指定被测试方法被允许运行的最长时间应该是多少，如果测试方法运行时间超过了指定的毫秒数，则 JUnit 认为测试失败。这个参数对于性能测试有一定的帮助。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//设置1000ms的超时时间，当超过这个时间测试还没执行完毕则失败  </span><br><span class="hljs-variable">@Test</span>(timeout = <span class="hljs-number">1000</span>) <br><br><span class="hljs-comment">//使用Timeout Rule设定全局的超时时间</span><br><span class="hljs-variable">@Rule</span>  <br>public Timeout timeout = new Timeout(<span class="hljs-number">1000</span>);  <br></code></pre></td></tr></table></figure><h5 id="2-2-3、忽略测试方法"><a href="#2-2-3、忽略测试方法" class="headerlink" title="2.2.3、忽略测试方法"></a>2.2.3、忽略测试方法</h5><p>注解 <code>org.junit.Ignore</code> 用于暂时忽略某个测试方法，因为有时候由于测试环境受限，并不能保证每一个测试方法都能正确运行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//忽略该测试，参数为输出信息  </span><br><span class="hljs-meta">@Ignore(<span class="hljs-meta-string">&quot;Temporary ignored as no changes.&quot;</span>)</span>  <br></code></pre></td></tr></table></figure><p>执行类里的所有测试，会输出以下信息，表示该测试被忽略了。</p><blockquote><p>…… ,ignored (Temporary ignored as no changes.)</p></blockquote><h5 id="2-2-4、Fixture"><a href="#2-2-4、Fixture" class="headerlink" title="2.2.4、Fixture"></a>2.2.4、Fixture</h5><p>Fixture是指在执行一个或者多个测试方法时需要的一系列公共资源或者数据，例如测试环境，测试数据等等。JUnit 专门提供了设置公共 Fixture 的方法，同一测试类中的所有测试方法都可以共用它来初始化 Fixture 和注销 Fixture。</p><p>①方法级别的Fixture：</p><p>使用注解<code> org,junit.Before</code> 修饰用于<code>初始化 Fixture 的方法</code>。每一个测试方法之前运行使用注解 <code>org.junit.After </code>修饰用于<code>注销 Fixture 的方法</code>。每一个测试方法之后运行保证这两种方法都使用 public void 修饰，而且不能带有任何参数。</p><p>②类级别的 Fixture</p><p>使用注解<code>org,junit.BeforeClass</code>修饰用于初始Fixture 的方法。所有测试方法开始之前运行，它比较适合加载配置文件,进行初始化等等使用注解<code>org.junit.AfterClass</code>修饰用于注销 Fixture 的方法。所有测试方法开始之后运行，通常用来对资源的清理,如关闭数据库的连接保证这两种方法都使用 public static void 修饰，而且不能带有任何参数。</p><h5 id="2-2-5、测试运行器"><a href="#2-2-5、测试运行器" class="headerlink" title="2.2.5、测试运行器"></a>2.2.5、测试运行器</h5><p>可以定制自己的运行器（所有的运行器都继承自<code>org.junit.runner.Runner</code>）使用注解 <code>org.junit.runner.RunWith</code> 在测试类上显式的声明要使用的运行器</p><h5 id="2-2-6、测试套件"><a href="#2-2-6、测试套件" class="headerlink" title="2.2.6、测试套件"></a>2.2.6、测试套件</h5><p>Unit 提供的一种批量（一次执行多个测试类）运行测试类的方法，测试套件的写法遵循以下规则：</p><p>​    ①创建一个空类作为测试套件的入口。</p><p>​    ②使用注解<code>org.junit.runner.RunWith</code>和<code>org.junit.runners.Suite.SuiteClasses</code>修饰这个空类。</p><p>​    ③将<code>org.junit.runners.Suite</code>作为参数传入注解 RunWith，以提示 JUnit 为此类使用套件运行器执行。</p><p>​    ④将需要放入此测试套件的测试类组成数组作为注解 SuiteClasses 的参数。</p><p>​    ⑤保证这个空类使用 public 修饰，而且存在公开的不带有任何参数的构造函数。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.junit.runners.Suite;<br><br><span class="hljs-keyword">@RunWith</span>(Suite.<span class="hljs-keyword">class</span>)  <br><span class="hljs-keyword">@Suite</span>.SuiteClasses(&#123;TaskTest1.<span class="hljs-keyword">class</span>,TaskTest2.<span class="hljs-keyword">class</span>,...&#125;)  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SuiteTest &#123; ... &#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-7、多个测试类同时运行"><a href="#2-2-7、多个测试类同时运行" class="headerlink" title="2.2.7、多个测试类同时运行"></a>2.2.7、多个测试类同时运行</h5><p>选择任意一个测试类–&gt;Run As–&gt;RunConfigurations–&gt;选择Run all tests in the selected project, package or source folder–&gt;Run</p><h5 id="2-2-8、参数化测试"><a href="#2-2-8、参数化测试" class="headerlink" title="2.2.8、参数化测试"></a>2.2.8、参数化测试</h5><p>参数化测试将测试方法中相同的代码结构提取出来，提高代码的重用度。参数化测试的编写：</p><p>​    ①为准备使用参数化测试的测试类指定特殊的运行器 <code>org.junit.runners.Parameterized</code>。</p><p>​    ②为测试类声明几个变量，分别用于存放期望值和测试所用数据。</p><p>​    ③为测试类声明一个使用注解<code>org.junit.runners.Parameterized.Parameters</code>修饰的，返回值为<code>java.util.Collection</code>的公共静态方法，并在此方法中初始化所有需要测试的参数对。</p><p>​    ④为测试类声明一个带有参数的公共构造函数，并在其中为第二个环节中声明的几个变量赋值。        ⑤编写测试方法，使用定义的变量作为参数进行测试。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 第一步</span><br><span class="hljs-meta">@RunWith</span>(Parameterized.class)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWordDealUtilWithParam</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-comment">// 第二步</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> expected;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> target;<br><span class="hljs-comment">// 第三步</span><br><span class="hljs-meta">@Parameters</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collection words()<br>&#123;<br><span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[][]<br>&#123;<br>&#123; <span class="hljs-string">&quot;employee_info&quot;</span>, <span class="hljs-string">&quot;employeeInfo&quot;</span> &#125;, <span class="hljs-comment">// 测试一般的处理情况</span><br>&#123; <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span> &#125;, <span class="hljs-comment">// 测试 null 时的处理情况</span><br>&#125;);<br>&#125;<br><span class="hljs-comment">// 第四步</span><br><span class="hljs-keyword">public</span> TestWordDealUtilWithParam(<span class="hljs-built_in">String</span> expected, <span class="hljs-built_in">String</span> target)<br>&#123;<br><span class="hljs-built_in">this</span>.expected = expected;<br><span class="hljs-built_in">this</span>.target = target;<br>&#125;<br><span class="hljs-comment">// 第五步</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> wordFormat4DB()<br>&#123;<br>assertEquals(expected, WordDealUtil.wordFormat4DB(target));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3、assertThat"><a href="#2-3、assertThat" class="headerlink" title="2.3、assertThat"></a>2.3、assertThat</h4><h5 id="2-3-1、一般匹配符"><a href="#2-3-1、一般匹配符" class="headerlink" title="2.3.1、一般匹配符"></a>2.3.1、一般匹配符</h5><p>1、assertThat( testedNumber, allOf( greaterThan(8), lessThan(16) ) );</p><p>注释： allOf匹配符表明如果接下来的所有条件必须都成立测试才通过，相当于“与”（&amp;&amp;）</p><p>2、assertThat( testedNumber, anyOf( greaterThan(16), lessThan(8) ) );</p><p>注释：anyOf匹配符表明如果接下来的所有条件只要有一个成立则测试通过，相当于“或”（||）</p><p>3、assertThat( testedNumber, anything() );</p><p>注释：anything匹配符表明无论什么条件，永远为true</p><p>4、assertThat( testedString, is( “developerWorks” ) );</p><p>注释： is匹配符表明如果前面待测的object等于后面给出的object，则测试通过</p><p>5、assertThat( testedString, not( “developerWorks” ) );</p><p>注释：not匹配符和is匹配符正好相反，表明如果前面待测的object不等于后面给出的object，则测试通过</p><h5 id="2-3-2、字符串相关匹配符"><a href="#2-3-2、字符串相关匹配符" class="headerlink" title="2.3.2、字符串相关匹配符"></a>2.3.2、字符串相关匹配符</h5><p>1、assertThat( testedString, containsString( “developerWorks” ) );</p><p>注释：containsString匹配符表明如果测试的字符串testedString包含子字符串”developerWorks”则测试通过</p><p>2、assertThat( testedString, endsWith( “developerWorks” ) ); </p><p>注释：endsWith匹配符表明如果测试的字符串testedString以子字符串”developerWorks”结尾则测试通过</p><p>3、assertThat( testedString, startsWith( “developerWorks” ) ); </p><p>注释：startsWith匹配符表明如果测试的字符串testedString以子字符串”developerWorks”开始则测试通过</p><p>4、assertThat( testedValue, equalTo( expectedValue ) ); </p><p>注释： equalTo匹配符表明如果测试的testedValue等于expectedValue则测试通过，equalTo可以测试数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法</p><p>5、assertThat( testedString, equalToIgnoringCase( “developerWorks” ) ); </p><p>注释：equalToIgnoringCase匹配符表明如果测试的字符串testedString在忽略大小写的情况下等于”developerWorks”则测试通过</p><p>6、assertThat( testedString, equalToIgnoringWhiteSpace( “developerWorks” ) );</p><p>注释：equalToIgnoringWhiteSpace匹配符表明如果测试的字符串testedString在忽略头尾的任意个空格的情况下等于”developerWorks”则测试通过，注意：字符串中的空格不能被忽略</p><h5 id="2-3-3、数值相关匹配符"><a href="#2-3-3、数值相关匹配符" class="headerlink" title="2.3.3、数值相关匹配符"></a>2.3.3、数值相关匹配符</h5><p>1、assertThat( testedDouble, closeTo( 20.0, 0.5 ) );</p><p>注释：closeTo匹配符表明如果所测试的浮点型数testedDouble在20.0±0.5范围之内则测试通过</p><p>2、assertThat( testedNumber, greaterThan(16.0) );</p><p>注释：greaterThan匹配符表明如果所测试的数值testedNumber大于16.0则测试通过</p><p>3、assertThat( testedNumber, lessThan (16.0) );</p><p>注释：lessThan匹配符表明如果所测试的数值testedNumber小于16.0则测试通过</p><p>4、assertThat( testedNumber, greaterThanOrEqualTo (16.0) );</p><p>注释： greaterThanOrEqualTo匹配符表明如果所测试的数值testedNumber大于等于16.0则测试通过</p><p>5、assertThat( testedNumber, lessThanOrEqualTo (16.0) );</p><p>注释：lessThanOrEqualTo匹配符表明如果所测试的数值testedNumber小于等于16.0则测试通过</p><h5 id="2-3-4、collection相关匹配符"><a href="#2-3-4、collection相关匹配符" class="headerlink" title="2.3.4、collection相关匹配符"></a>2.3.4、collection相关匹配符</h5><p>1、assertThat( mapObject, hasEntry( “key”, “value” ) );</p><p>注释：hasEntry匹配符表明如果测试的Map对象mapObject含有一个键值为”key”对应元素值为”value”的Entry项则测试通过</p><p>2、assertThat( iterableObject, hasItem ( “element” ) );</p><p>注释：hasItem匹配符表明如果测试的迭代对象iterableObject含有元素“element”项则测试通过</p><p>3、assertThat( mapObject, hasKey ( “key” ) );</p><p>注释： hasKey匹配符表明如果测试的Map对象mapObject含有键值“key”则测试通过</p><p>4、assertThat( mapObject, hasValue ( “key” ) );</p><p>注释：hasValue匹配符表明如果测试的Map对象mapObject含有元素值“value”则测试通过</p><p><a href="https://blog.csdn.net/qq_43520650/article/details/101308036">https://blog.csdn.net/qq_43520650/article/details/101308036</a></p>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub上传ssh-key</title>
    <link href="/2019/11/17/GitHub%E4%B8%8A%E4%BC%A0ssh-key/"/>
    <url>/2019/11/17/GitHub%E4%B8%8A%E4%BC%A0ssh-key/</url>
    
    <content type="html"><![CDATA[<h4 id="1、给git添加-ssh-key"><a href="#1、给git添加-ssh-key" class="headerlink" title="1、给git添加 ssh-key"></a>1、给git添加 ssh-key</h4><p><img src="/2019/11/17/GitHub%E4%B8%8A%E4%BC%A0ssh-key/yuanli.png" alt="1"></p><h5 id="1-1、查看是否C-Users-USERNAME-ssh目录，以及该目录下是否有生成的key"><a href="#1-1、查看是否C-Users-USERNAME-ssh目录，以及该目录下是否有生成的key" class="headerlink" title="1.1、查看是否C:\Users\USERNAME\.ssh目录，以及该目录下是否有生成的key"></a>1.1、查看是否<code>C:\Users\USERNAME\.ssh</code>目录，以及该目录下是否有生成的key</h5><p><img src="/2019/11/17/GitHub%E4%B8%8A%E4%BC%A0ssh-key/dirssh.png" alt="1"></p><p>若没有则生成一个ssh-key</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;email@mail.com&quot;</span><br></code></pre></td></tr></table></figure><h5 id="1-2、将-ssh-id-rsa-pub内容加入你的github中"><a href="#1-2、将-ssh-id-rsa-pub内容加入你的github中" class="headerlink" title="1.2、将.~/ssh/id_rsa.pub内容加入你的github中"></a>1.2、将.~/ssh/id_rsa.pub内容加入你的github中</h5><p><img src="/2019/11/17/GitHub%E4%B8%8A%E4%BC%A0ssh-key/githubssh.png" alt="1"></p><h5 id="1-3、设置你的git用户名及邮箱"><a href="#1-3、设置你的git用户名及邮箱" class="headerlink" title="1.3、设置你的git用户名及邮箱"></a>1.3、设置你的git用户名及邮箱</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;name&quot;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;email@mail.com&quot;</span><br></code></pre></td></tr></table></figure><h5 id="1-6、测试你的ssh-key"><a href="#1-6、测试你的ssh-key" class="headerlink" title="1.6、测试你的ssh-key"></a>1.6、测试你的ssh-key</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh -T <span class="hljs-symbol">git@</span>github.com<br></code></pre></td></tr></table></figure><p>输入yes后若显示以下内容，则代表成功</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Hi xxx! You’ve successfully authenticated, <span class="hljs-keyword">but</span> GitHub <span class="hljs-keyword">does</span> <span class="hljs-keyword">not</span> provide shell access. <br></code></pre></td></tr></table></figure><h4 id="2、解决github上传ssh-key后仍须输入密码的问题"><a href="#2、解决github上传ssh-key后仍须输入密码的问题" class="headerlink" title="2、解决github上传ssh-key后仍须输入密码的问题"></a>2、解决github上传ssh-key后仍须输入密码的问题</h4><p>这种情况绝大多数是因为用的是<code>https</code>而不是<code>ssh</code>，更新为<code>ssh</code>格式<br> <code>HTTPS</code>的格式为：<code>https://github.com/用户名/仓库名.git</code><br> <code>SSH</code>的格式为：<code>git@github.com:用户名/仓库名.git</code></p><p>2.1、这种事情通常发生在更换机器后克隆自己仓库的时候，通常我们会使用https方式克隆</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Name/</span>project.git<br></code></pre></td></tr></table></figure><p>2.2、这样便会在你git push时候要求输入用户名和密码<br>解决的方法是使用ssh方式克隆仓库</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:Name/project.git<br></code></pre></td></tr></table></figure><p>2.3、当如，如果你已经用https方式克隆了仓库，就不必删除仓库重新克隆，只需将本地仓库 .git/config文件中的 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">url = https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Name/</span>project.git <br></code></pre></td></tr></table></figure><p>一行改为 </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span> = git@github.com:Name/project.git <br></code></pre></td></tr></table></figure><p>即可。</p><p>来自苏生不惑问题及热心驻圈大佬的解答：<a href="https://segmentfault.com/q/1010000000599327">设置ssh key后push为什么还要输入用户名和密码</a></p><p><img src="/GitHub%E4%B8%8A%E4%BC%A0ssh-key/http_s.png" alt="1"></p><p><a href="https://blog.csdn.net/GreatTang/article/details/88431737">https://blog.csdn.net/GreatTang/article/details/88431737</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>ssh-key</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FTP服务搭建</title>
    <link href="/2019/11/15/FTP%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/11/15/FTP%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="FTP服务搭建"><a href="#FTP服务搭建" class="headerlink" title="FTP服务搭建"></a>FTP服务搭建</h2><p><a href="https://baike.baidu.com/item/FTP%E5%8D%8F%E8%AE%AE">FTP协议</a>（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。</p><p>FTP协议两部分组成，<code>FTP服务器</code>和<code>FTP客户端</code>。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。</p><p>在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。</p><p>默认情况下FTP协议使用TCP端口中的 <code>20[传输数据]</code>和<code>21[传输控制信息]</code>这两个端口。<strong>但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关</strong>。</p><p>FTP支持两种传输模式，如果采用<code>主动模式（Standard也就是 PORT方式）</code>，那么数据传输端口就是20；如果采用<code>被动模式 （Passive也就是PASV方式）</code>，则具体最终使用哪个端口要<code>服务器端和客户端协商决定</code>。</p><blockquote><p><strong>Standard模式：</strong>FTP 客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。 PORT命令包含了<code>客户端用什么端口接收数据</code>，在传送数据的时候，<code>服务器端通过自己的TCP 20端口</code>连接至客户端的指定端口发送数据， FTP server必须和客户端建立这样一个新的连接用来传送数据。</p><p><strong>Passive模式：</strong>在建立控制通道的时候和Standard模式类似，但建立连接后发送的不是Port命令，而是Pasv命令。FTP服务器收到Pasv命令后，随机打开一个高端端口（<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7">端口号</a>大于1024）并且通知客户端在这个端口上传送数据，客户端通过<code>三次握手</code>与FTP服务器指定的这个端口<code>建立数据通道</code>，FTP服务器将通过这个端口进行数据的传送。</p><p>很多<a href="https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99">防火墙</a>在设置的时候都是不允许接受外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口；而许多内网的客户端不能用PORT模式登陆FTP服务器，因为从服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作。</p></blockquote><p>同大多数Internet服务一样，FTP也是一个客户/服务器系统。依照 FTP 协议提供服务，进行文件传送的计算机就是 FTP服务器，而连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端。用户要连上FTP 服务器，就要用到 FTP 的客户端软件，通常 Windows自带“ftp”命令，这是一个命令行的 FTP客户程序，另外常用的 FTP 客户程序还有FileZilla、 CuteFTP、Ws_FTP、Flashfxp、LeapFTP等。</p><p>互联网中有很大一部分 FTP 服务器被称为<code>“匿名”（Anonymous）FTP 服务器</code>。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权。虽然目前使用WWW环境已取代匿名FTP成为最主要的信息查询方式，但是匿名FTP仍是 Internet上传输分发软件的一种基本方法。如red hat 、autodesk等公司的匿名站点。</p><p>FTP协议的任务是从一台计算机将文件传送到另一台计算机，它与这两台计算机所处的位置、联接的方式、甚至是是否使用相同的操作系统无关。假设两台计算机通过ftp协议对话，并且能访问Internet，你可以用ftp命令来传输文件。尽管每种操作系统使用上有某一些细微差别，但是每种协议基本的命令结构是相同的。</p><p>FTP的传输数据有两种方式：<code>ASCII传输模式</code>和<code>二进制数据传输模式</code>。注意传输二进制文件和文本文件所用的数据传输模式。 在大多数计算机上，ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。如果你传输二进制文件，所有的位都是重要的。 </p><h3 id="1、在CentOS上安装FTP服务"><a href="#1、在CentOS上安装FTP服务" class="headerlink" title="1、在CentOS上安装FTP服务"></a>1、在CentOS上安装FTP服务</h3><p>vsftpd(very secure FTP daemon),是一个UNIX类操作系统上运行FTP协议的服务器。</p><p>检测系统是否已安装过vsftpd：        <strong>rpm -q vsftpd</strong>或<strong>vsftpd -v</strong><br>安装：        <strong>yum -y install vsftpd</strong><br>查看安装位置：    <strong>whereis vsftpd</strong><br>开机自启动：    <strong>systemctl enable vsftpd.service</strong></p><blockquote><p>Created symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.<br>如果想让一个进程开机自启动，使用 systemctl enable XXXX.service 命令就是了<br>让这个程序自己的启动配置创建一个链接到系统的启动配置文件下，系统开机的时候就能运行 /usr/lib/systemd/system/ 文件下的配置文件对应的程序。</p></blockquote><p>服务启动/重启/停止：    <strong>systemctl start/restart/stop vsftpd</strong><br>查看服务状态：    <strong>systemctl status vsftpd</strong></p><h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><p>vim /etc/vsftpd/vsftpd.conf</p><p>vim编辑器:set number显示行号</p><p>注意：vsftpd 配置文件如果修改，需要重新启动 vsftpd ：systemctl restart vsftpd.service</p><h4 id="2-1、匿名权限控制"><a href="#2-1、匿名权限控制" class="headerlink" title="2.1、匿名权限控制"></a>2.1、匿名权限控制</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">anonymous_enable</span>=<span class="hljs-literal">NO</span><span class="hljs-comment">#是否允许匿名访问，NO禁用匿名登录</span><br><span class="hljs-attr">no_anon_password</span>=<span class="hljs-literal">YES</span><span class="hljs-comment">#匿名用户login时不询问口令</span><br></code></pre></td></tr></table></figure><p>下面这四个主要语句控制这文件和文件夹的上传、下载、创建、删除和重命名</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">anon_upload_enable</span>=<span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span><span class="hljs-comment">#控制匿名用户对文件（非目录）上传权限。</span><br><span class="hljs-attr">anon_world_readable_only</span>=<span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span> <span class="hljs-comment">#控制匿名用户对文件的下载权限</span><br><span class="hljs-attr">anon_mkdir_write_enable</span>=<span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span> <span class="hljs-comment">#控制匿名用户对文件夹的创建权限</span><br><span class="hljs-attr">anon_other_write_enable</span>=<span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span> <span class="hljs-comment">#控制匿名用户对文件和文件夹的删除和重命名</span><br></code></pre></td></tr></table></figure><p>注：匿名用户下载是使用的是nobody这个用户，所以相应的o这个位置要有r权限才能被下载。若想让匿名用户能上传和删除权限，必需设置。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">write_enable=YES<span class="hljs-comment">#全局设置，是否容许写入（无论是匿名还是本地用户，若要写入的话，就要开启）</span><br>anon_root=&#x27;dir&#x27;<span class="hljs-comment">#匿名用户主目录，默认/var/ftp/</span><br>anon_max_rate＝<span class="hljs-comment">#匿名用户速度限制，单位b/s</span><br>anon_umask＝077<span class="hljs-comment">#匿名用户上传文件的掩码(若使匿名用户上传的文件能直接被匿名下载，就设置这里为073)</span><br>chown_uploads=YES<span class="hljs-comment">#所有匿名上传的文件的所属用户将会被更改成chown_username</span><br>chown_username=whoever <span class="hljs-comment">#上传文件所属的用户</span><br></code></pre></td></tr></table></figure><h4 id="2-2、本地用户权限控制"><a href="#2-2、本地用户权限控制" class="headerlink" title="2.2、本地用户权限控制"></a>2.2、本地用户权限控制</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">write_enable=YES <span class="hljs-comment">#可以上传(全局控制) 删除，重命名</span><br>local_umask=022  <span class="hljs-comment">#设置本地用户上传文件默认文件掩码022</span><br><span class="hljs-comment">#FTP上本地的文件权限，默认是077，不过vsftpd安装后的配置文件里默认是022</span><br><br>local_root=  <span class="hljs-comment">#设置一个本地用户登录后进入到的目录</span><br>download_enable=  <span class="hljs-comment">#限制用户的下载权限</span><br><br>userlist_enable=YES <span class="hljs-comment">#限制了这里的用户不能访问</span><br>userlist_file=/etc/vsftpd/user_list <span class="hljs-comment">#在文件中指定限制的用户</span><br><span class="hljs-comment"># vsftpd userlist</span><br><span class="hljs-comment"># If userlist_deny=NO, only allow users in this file</span><br><span class="hljs-comment"># If userlist_deny=YES (default), never allow users in this file, and</span><br><span class="hljs-comment"># do not even prompt for a password.</span><br><span class="hljs-comment"># Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers</span><br><span class="hljs-comment"># for users that are denied.</span><br></code></pre></td></tr></table></figure><p>可以通过以下配置项来控制用户切换目录。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">chroot_list_enable</span>=<span class="hljs-literal">YES</span>　<span class="hljs-comment">#如果启动这项功能，则所有列在chroot_list_file之中的使用者不能更改根目录</span><br><span class="hljs-attr">chroot_list_file</span>=/etc/vsftpd/chroot_list <span class="hljs-comment">#指定限制的用户文件，指出被锁定在自家目录中的用户</span><br></code></pre></td></tr></table></figure><p>通过与chroot_local_user=YES|NO搭配能实现以下几种效果：<br>1、当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。<br>2、当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。<br>3、当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。<br>4、当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-attr">user_config_dir=</span> <span class="hljs-comment">#后面跟存放配置文件的目录</span><br><span class="hljs-comment">#在这个目录中，创建用户的单独配置文件，用哪个帐户登陆就用哪个帐户命名，用来实现不同用户不同权限。</span><br><br><span class="hljs-comment">#在每个用户单独的配置文件中，用下边的配置各用户的命令执行权限</span><br>cmds_allowed＝[ABOR,ACCT,APPE,CWD,CDUP,DELE,HELP,LIST,MODE,MDTM,MKD,NOOP,NLST,PASS,PASV,PORT,PWD,QUIT,REIN,RETR,RMD,RNFR,RNTO,SITE,SIZE,STOR,STAT,STOU,STRU,SYST,<span class="hljs-keyword">TYPE</span>,USER]<span class="hljs-comment">#指令权限设置</span><br></code></pre></td></tr></table></figure><p>1、不能下载、删除、重命名，只能上传</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">cmds_allowed＝FEAT,REST,CWD,<span class="hljs-keyword">LIST</span>,MDTM,MKD,NLST,PASS,PASV,PORT,<span class="hljs-keyword">PWD</span>,QUIT,RMD,SIZE,STOR,<span class="hljs-keyword">TYPE</span>,USER,ACCT,<span class="hljs-keyword">APPE</span>,CDUP,<span class="hljs-keyword">HELP</span>,MODE,NOOP,REIN,STAT,STOU,STRU,SYST<br></code></pre></td></tr></table></figure><p>2、不能上传、删除、重命名，只能下载</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">write_enable</span>=<span class="hljs-literal">NO</span><br></code></pre></td></tr></table></figure><p>3、只能上传、删除和重命名，不能下载</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">download_enable＝<span class="hljs-keyword">NO</span><br></code></pre></td></tr></table></figure><p>4、只能下载、删除和重命名，不能上传</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">cmds_allowed=FEAT,REST,CWD,<span class="hljs-keyword">LIST</span>,MDTM,MKD,NLST,PASS,PASV,PORT,<span class="hljs-keyword">PWD</span>,QUIT,RMD,RNFR,RNTO,RETR,DELE,SIZE,<span class="hljs-keyword">TYPE</span>,USER,ACCT,<span class="hljs-keyword">APPE</span>,CDUP,<span class="hljs-keyword">HELP</span>,MODE,NOOP,REIN,STAT,STOU,STRU,SYST<br></code></pre></td></tr></table></figure><blockquote><p>参数的详细解释：<br>ABOR - abort a file transfer 取消文件传输<br>CWD - change working directory 更改目录<br>DELE - delete a remote file 删除文件<br>LIST - list remote files 列目录<br>MDTM - return the modification time of a file 返回文件的更新时间<br>MKD - make a remote directory 新建文件夹<br>NLST - name list of remote directory<br>PASS - send password<br>PASV - enter passive mode<br>PORT - open a data port 打开一个传输端口<br>PWD - print working directory 显示当前工作目录<br>QUIT - terminate the connection 退出<br>RETR - retrieve a remote file 下载文件<br>RMD - remove a remote directory<br>RNFR - rename from<br>RNTO - rename to<br>SITE - site-specific commands<br>SIZE - return the size of a file 返回文件大小<br>STOR - store a file on the remote host 上传文件<br>TYPE - set transfer type<br>USER - send username<br> less common commands:<br>ACCT - send account information<br>APPE - append to a remote file<br>CDUP - CWD to the parent of the current directory<br>HELP - return help on using the server<br>MODE - set transfer mode<br>NOOP - do nothing<br>REIN - reinitialize the connection<br>STAT - return server status<br>STOU - store a file uniquely<br>STRU - set file transfer structure<br>SYST - return system type</p></blockquote><h4 id="2-3、虚拟用户设置"><a href="#2-3、虚拟用户设置" class="headerlink" title="2.3、虚拟用户设置"></a>2.3、虚拟用户设置</h4><p>虚拟用户使用PAM认证方式</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pam_service_name</span>=vsftpd<span class="hljs-comment">#设置PAM使用的名称，默认值为/etc/pam.d/vsftpd</span><br><span class="hljs-attr">check_shell</span>=<span class="hljs-literal">YES</span>   <span class="hljs-comment">#注意：仅在没有pam验证版本时有用,是否检查用户有一个有效的shell来登录</span><br><span class="hljs-attr">guest_enable</span>= <span class="hljs-literal">YES</span>|<span class="hljs-literal">NO</span>  <span class="hljs-comment">#启用虚拟用户，默认值为NO</span><br><span class="hljs-attr">guest_username</span>=ftp  <span class="hljs-comment">#映射虚拟用户，默认值为ftp；把虚拟用户映射到本地用户，虚拟用户=本地用户</span><br><br><span class="hljs-attr">virtual_use_local_privs</span>=<span class="hljs-literal">YES</span>|<span class="hljs-literal">NO</span> <br><span class="hljs-comment">#当该参数激活YES时，虚拟用户使用与本地用户相同的权限，当此参数关闭NO时，虚拟用户使用与匿名用户相同的权限，默认情况下此参数是关闭的（NO）。</span><br></code></pre></td></tr></table></figure><h4 id="2-4、访问控制设置"><a href="#2-4、访问控制设置" class="headerlink" title="2.4、访问控制设置"></a>2.4、访问控制设置</h4><p>两种控制方式：一种控制主机访问，另一种控制用户访问</p><h5 id="2-4-1、控制主机访问："><a href="#2-4-1、控制主机访问：" class="headerlink" title="2.4.1、控制主机访问："></a>2.4.1、控制主机访问：</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tcp_wrappers</span>=<span class="hljs-literal">YES</span>|<span class="hljs-literal">NO</span><br></code></pre></td></tr></table></figure><p>设置vsftpd是否与tcp wrapper相结合来进行主机的访问控制。默认值为YES。如果启用，则vsftpd服务器会检查/etc/hosts.allow 和/etc/hosts.deny 中的设置，来决定请求连接的主机，是否允许访问该FTP服务器。这两个文件可以起到简易的防火墙功能。</p><p>比如：若要仅允许192.168.10.1—192.168.10.254的用户可以连接FTP服务器，则在<br>/etc/hosts.allow<br>/etc/hosts.deny<br>文件中添加以下内容：</p><p>其格式: 限制的服务：ip(网段)<br>vsftpd:192.168.1.<br>vsftpd:192.168.1.12<br>vsftpd:192.168.1.0/255.255.255.0    #这里不能写成192.168.1.0/24</p><h5 id="2-4-2、控制用户访问："><a href="#2-4-2、控制用户访问：" class="headerlink" title="2.4.2、控制用户访问："></a>2.4.2、控制用户访问：</h5><p>/etc/vsftpd/下ftpusers和user_list文件    #用于保存不允许进行FTP登录的本地用户帐号，就是vsftp用户的黑名单</p><p>1、设置禁止user_list文件中的用户登录：要在主配置文件vsftpd.conf中修改如下两项，</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">userlist_enable</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">userlist_deny</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>说明：配置完以后，除了ftpusers文件和user_list文件中记录的ftp用户不能登录vsftp服务以外，其他的ftp用户都可以登录。</p><p>2、设置只允许user_list文件中的用户登录：同样的道理要把主配置文件vsftpd.conf 中的语句修改如下两项： </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">userlist_enable</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">userlist_deny</span>=<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><p>说明：配置完以后，只允许vsftpd.user_list文件中记录的ftp用户能登录vsftp服务，其他的ftp用户都不可以登录。</p><h4 id="2-5、超时设置"><a href="#2-5、超时设置" class="headerlink" title="2.5、超时设置"></a>2.5、超时设置</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">idle_session_timeout</span>=<span class="hljs-number">600</span> <span class="hljs-comment">#空闲连接超时</span><br><span class="hljs-attr">data_connection_timeout</span>=<span class="hljs-number">120</span> <span class="hljs-comment">#数据传输超时</span><br><span class="hljs-attr">ACCEPT_TIMEOUT</span>=<span class="hljs-number">60</span>  <span class="hljs-comment">#PAVS请求超时</span><br><span class="hljs-attr">connect_timeout</span>=<span class="hljs-number">60</span>  <span class="hljs-comment">#PROT模式连接超时</span><br></code></pre></td></tr></table></figure><h4 id="2-6、服务器功能选项"><a href="#2-6、服务器功能选项" class="headerlink" title="2.6、服务器功能选项"></a>2.6、服务器功能选项</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">xferlog_enable=YES<span class="hljs-comment">#开启日记功能</span><br>xferlog_std_format=YES<span class="hljs-comment">#使用标准格式</span><br>log_ftp_protocol=NO<span class="hljs-comment">#当xferlog_std_format关闭且本选项开启时,记录所有ftp请求和回复,常作调试用</span><br>pasv_enable=YES<span class="hljs-comment">#允许使用pasv模式</span><br>pasv_promiscuous=NO<span class="hljs-comment">#关闭安全检查，请慎重考虑</span><br>port_enable=YES<span class="hljs-comment">#允许使用port模式</span><br>tcp_wrappers=YES<span class="hljs-comment">#开启tcp_wrappers支持</span><br>pam_service_name=vsftpd<span class="hljs-comment">#定义PAM 所使用的名称，预设为vsftpd</span><br>nopriv_user=nobody<span class="hljs-comment">#当服务器运行于最底层时使用的用户名</span><br>pasv_address=<span class="hljs-comment">#使vsftpd在pasv命令回复时跳转到指定的IP地址。【服务器联接跳转？？？】</span><br></code></pre></td></tr></table></figure><h4 id="2-7、服务器性能选项"><a href="#2-7、服务器性能选项" class="headerlink" title="2.7、服务器性能选项"></a>2.7、服务器性能选项</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ls_recurse_enable=YES<span class="hljs-comment">#是否能使用ls -R命令以防止浪费大量的服务器资源</span><br>one_process_model<span class="hljs-comment">#是否使用单进程模式</span><br>listen=YES<span class="hljs-comment">#绑定到listen_port指定的端口,暨端口常都开,亦即standalone模式</span><br><br>text_userdb_names=NO<br><span class="hljs-comment">#当使用者登入后使用ls -al 之类的指令查询该档案的管理权时，预设会出现拥有者的UID，而不是该档案拥有者的名   #称。若是希望出现拥有者的名称，则将此功能开启。</span><br><br>use_localtime=NO<span class="hljs-comment">#显示目录清单时是用本地时间还是GMT时间,可以通过mdtm命令来达到一样的效果</span><br>use_sendfile=YES<span class="hljs-comment">#测试平台优化</span><br></code></pre></td></tr></table></figure><h4 id="2-8、信息类设置"><a href="#2-8、信息类设置" class="headerlink" title="2.8、信息类设置"></a>2.8、信息类设置</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ftpd_banner</span>=welcome to FTP<span class="hljs-comment">#login时显示欢迎信息.如果设置了banner_file则此设置无效</span><br><span class="hljs-attr">dirmessage_enable</span>=<span class="hljs-literal">YES</span><span class="hljs-comment">#允许为目录配置显示信息,显示每个目录下面的message_file文件的内容</span><br><span class="hljs-attr">setproctitle_enable</span>=<span class="hljs-literal">YES</span><span class="hljs-comment">#显示会话状态信息,默认关</span><br></code></pre></td></tr></table></figure><h4 id="2-9、文件定义"><a href="#2-9、文件定义" class="headerlink" title="2.9、文件定义"></a>2.9、文件定义</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">chroot_list_file</span>=/etc/vsftpd/vsftpd.chroot_list<span class="hljs-comment">#定义不能更改用户主目录的文件</span><br><span class="hljs-attr">userlist_file</span>=/etc/vsftpd/vsftpd.user_list<span class="hljs-comment">#定义限制/允许用户登录的文件</span><br><span class="hljs-attr">banner_file</span>=/etc/vsftpd/banner<span class="hljs-comment">#定义登录信息文件的位置</span><br><span class="hljs-attr">banned_email_file</span>=/etc/vsftpd.banned_emails<span class="hljs-comment">#禁止使用的匿名用户登陆时作为密码的电子邮件地址</span><br><span class="hljs-attr">xferlog_file</span>=/var/log/vsftpd.log<span class="hljs-comment">#日志文件位置</span><br><span class="hljs-attr">message_file</span>=.message<span class="hljs-comment">#目录信息文件</span><br></code></pre></td></tr></table></figure><h4 id="2-10、目录定义"><a href="#2-10、目录定义" class="headerlink" title="2.10、目录定义"></a>2.10、目录定义</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">user_config_dir=<span class="hljs-regexp">/etc/</span>vsftpd/userconf<span class="hljs-comment">#定义用户配置文件的目录</span><br>local_root=<span class="hljs-comment">#此项设置每个用户登陆后的根目录</span><br><span class="hljs-comment">#定义本地用户登陆的根目录，注意定义根目录可以是相对路径也可以是绝对路径，相对路径是针对用户家目录来说的</span><br>anon_root=<span class="hljs-regexp">/var/</span>ftp<span class="hljs-comment">#匿名用户登陆后的根目录，默认/var/ftp</span><br></code></pre></td></tr></table></figure><h4 id="2-11、用户连接选项"><a href="#2-11、用户连接选项" class="headerlink" title="2.11、用户连接选项"></a>2.11、用户连接选项</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">max_clients</span>=<span class="hljs-number">100</span><span class="hljs-comment">#可接受的最大client数目</span><br><span class="hljs-attr">max_per_ip</span>=<span class="hljs-number">5</span><span class="hljs-comment">#每个ip的最大client数目</span><br><span class="hljs-attr">connect_from_port_20</span>=<span class="hljs-literal">YES</span><span class="hljs-comment">#使用标准的20端口来连接ftp</span><br><span class="hljs-attr">listen_address</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">0.2</span><span class="hljs-comment">#绑定到某个IP,其它IP不能访问</span><br><span class="hljs-attr">listen_port</span>=<span class="hljs-number">2121</span><span class="hljs-comment">#绑定到某个端口</span><br><span class="hljs-attr">ftp_data_port</span>=<span class="hljs-number">2020</span><span class="hljs-comment">#数据传输端口</span><br><span class="hljs-attr">pasv_max_port</span>=<span class="hljs-number">0</span><span class="hljs-comment">#pasv连接模式时可以使用port 范围的上界，默认值0表示任意</span><br><span class="hljs-attr">pasv_min_port</span>=<span class="hljs-number">0</span><span class="hljs-comment">#pasv连接模式时可以使用port 范围的下界，默认值0表示任意</span><br></code></pre></td></tr></table></figure><h4 id="2-12、数据传输选项"><a href="#2-12、数据传输选项" class="headerlink" title="2.12、数据传输选项"></a>2.12、数据传输选项</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">anon_max_rate</span>=<span class="hljs-number">51200</span>  <span class="hljs-comment">#匿名用户的传输比率(b/s)</span><br><span class="hljs-attr">local_max_rate</span>=<span class="hljs-number">5120000</span>  <span class="hljs-comment">#本地用户的传输比率(b/s)</span><br></code></pre></td></tr></table></figure><h4 id="2-13、安全选项"><a href="#2-13、安全选项" class="headerlink" title="2.13、安全选项"></a>2.13、安全选项</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">idle_session_timeout</span>=<span class="hljs-number">600</span> <span class="hljs-comment">#用户会话空闲后10分钟</span><br><span class="hljs-attr">data_connection_timeout</span>=<span class="hljs-number">120</span> <span class="hljs-comment">#将数据连接空闲2分钟断</span><br><span class="hljs-attr">accept_timeout</span>=<span class="hljs-number">60</span>  <span class="hljs-comment">#将客户端空闲1分钟后断</span><br><span class="hljs-attr">connect_timeout</span>=<span class="hljs-number">60</span>  <span class="hljs-comment">#中断1分钟后又重新连接</span><br><span class="hljs-attr">local_max_rate</span>=<span class="hljs-number">50000</span>  <span class="hljs-comment">#本地用户传输率50K</span><br><span class="hljs-attr">anon_max_rate</span>=<span class="hljs-number">30000</span>  <span class="hljs-comment">#匿名用户传输率30K</span><br><span class="hljs-attr">pasv_min_port</span>=<span class="hljs-number">50000</span>  <span class="hljs-comment">#将客户端的数据连接端口改在</span><br><span class="hljs-attr">pasv_max_port</span>=<span class="hljs-number">60000</span>  <span class="hljs-comment">#50000—60000之间</span><br><span class="hljs-attr">max_clients</span>=<span class="hljs-number">200</span>   <span class="hljs-comment">#FTP的最大连接数</span><br><span class="hljs-attr">max_per_ip</span>=<span class="hljs-number">4</span>   <span class="hljs-comment">#每IP的最大连接数</span><br><span class="hljs-attr">listen_port</span>=<span class="hljs-number">5555</span>  <span class="hljs-comment">#从5555端口进行数据连接</span><br><span class="hljs-attr">local_enable</span>=<span class="hljs-literal">YES</span>      <span class="hljs-comment"># 允许使用本地帐户进行FTP用户登录验证</span><br><span class="hljs-attr">allow_writeable_chroot</span>=<span class="hljs-literal">YES</span> <span class="hljs-comment"># 如果启用了限定用户在其主目录下需要添加这个配置，解决报错 500 OOPS: vsftpd: refusing to run with writable root inside chroot()</span><br></code></pre></td></tr></table></figure><h4 id="2-14、“不安全的服务，不支持FTP-over-TLS”"><a href="#2-14、“不安全的服务，不支持FTP-over-TLS”" class="headerlink" title="2.14、“不安全的服务，不支持FTP over TLS”"></a>2.14、“不安全的服务，不支持FTP over TLS”</h4><p>配置vsftpd在centos上使用SSL/TLS</p><h5 id="2-14-1、建立vsftpd使用的凭证数据，CentOS建立凭证的地方-etc-pki-tls-certs"><a href="#2-14-1、建立vsftpd使用的凭证数据，CentOS建立凭证的地方-etc-pki-tls-certs" class="headerlink" title="2.14.1、建立vsftpd使用的凭证数据，CentOS建立凭证的地方/etc/pki/tls/certs/"></a>2.14.1、建立vsftpd使用的凭证数据，CentOS建立凭证的地方/etc/pki/tls/certs/</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>pki<span class="hljs-regexp">/tls/</span>certs/<br><br>make vsftpd.pem<span class="hljs-comment">#建立证书解析配置</span><br>Country Name:CN<br>State or Province Name:CHINA<br>Locality Name:<br>Organization Name: <br>...<br>Common Name:kongweiliao<br>Email Address []:lia*****ei@outlook.com<br><br>cp -a vsftpd.pem <span class="hljs-regexp">/etc/</span>vsftpsd/<br>ll <span class="hljs-regexp">/etc/</span>vsftpd/vsftpd.pem<br></code></pre></td></tr></table></figure><h5 id="2-14-2、修改vsftpd-conf"><a href="#2-14-2、修改vsftpd-conf" class="headerlink" title="2.14.2、修改vsftpd.conf"></a>2.14.2、修改vsftpd.conf</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">+<br><span class="hljs-attribute">ssl_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">force_anon_data_ssl</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">force_anon_logins_ssl</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">force_local_data_ssl</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">force_local_logins_ssl</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">ssl_tlsv1</span>=<span class="hljs-literal">YES</span>#tlsv1,tlsv2,tlsv3; 首选tlsv1,默认<span class="hljs-literal">YES</span>；次选tlsv2,tlsv3，默认<span class="hljs-literal">NO</span><br><span class="hljs-attribute">rsa_cert_file</span>=/etc/vsftpd/vsftpd.pem<br></code></pre></td></tr></table></figure><p><img src="/2019/11/15/FTP%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/filezillaFTPoverSTL.png" alt="1"></p><h3 id="3、防火墙设置"><a href="#3、防火墙设置" class="headerlink" title="3、防火墙设置"></a>3、防火墙设置</h3><p>查看防火墙状态：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># systemctl status firewalld.service</span><br></code></pre></td></tr></table></figure><p>一般情况下，如果外部无法链接 vsftp ，排除网络的问题，很有可能是防火墙在作祟。</p><p>开启防火墙：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># systemctl start firewalld.service</span><br></code></pre></td></tr></table></figure><p>关闭防火墙：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># systemctl stop firewalld.service</span><br></code></pre></td></tr></table></figure><p>重启防火墙：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># systemctl restart firewalld.service</span><br></code></pre></td></tr></table></figure><p>禁止开机启动：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># systemctl disable firewalld.service</span><br></code></pre></td></tr></table></figure><p>开启开机启动：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># systemctl enable firewalld.service</span><br></code></pre></td></tr></table></figure><p>说明：如果你不愿意关闭防火墙，需要防火墙添加FTP服务。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> --<span class="hljs-comment">permanent</span> --<span class="hljs-comment">zone=public</span> --<span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">service=ftp</span><br><span class="hljs-comment">firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> --<span class="hljs-comment">reload</span> <br></code></pre></td></tr></table></figure><h3 id="4、检测能否连接成功"><a href="#4、检测能否连接成功" class="headerlink" title="4、检测能否连接成功"></a>4、检测能否连接成功</h3><p>先在 linux 系统上进行检测：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># ftp localhost（本主机名称）</span><br></code></pre></td></tr></table></figure><p>出现提示登录用户名，使用匿名用户登录 anonymous（密码未设置，所以为空），输入 ls 命令可显示信息，效果如图：</p><p>在Windows上访问：</p><p>使用 windows ping 一下 linux 服务器，检查是否能联网</p><p>从下图可以看出，windows 能与 linux 网络联通，当可以正常联通网络再进行 ftp 链接测试，</p><p>也可使用 root 帐号进行登录，root 帐号登录之后可以操作系统内任意文件。以下章节列出可以链接之后通过 ftp 软件链接后出现的一些常见问题解决方案。</p><h3 id="5、SELinux状态"><a href="#5、SELinux状态" class="headerlink" title="5、SELinux状态"></a>5、SELinux状态</h3><p>链接 ftp 的时候如果出现无法访问目录列表问题：<br>查看ftp的Selinux状态：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> ~]<span class="hljs-meta"># sestatus -b | grep ftp</span><br></code></pre></td></tr></table></figure><p>将状态改为on：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[root@localhost ~]</span># setsebool -<span class="hljs-selector-tag">P</span> tftp_home_dir on （注意：<span class="hljs-selector-tag">P</span>为大写）<br><span class="hljs-selector-attr">[root@localhost ~]</span># setsebool -<span class="hljs-selector-tag">P</span> ftpd_full_access on （注意：<span class="hljs-selector-tag">P</span>为大写） <br></code></pre></td></tr></table></figure><h3 id="6、FTP连接常见错误代码"><a href="#6、FTP连接常见错误代码" class="headerlink" title="6、FTP连接常见错误代码"></a>6、FTP连接常见错误代码</h3><p>说明： 配置的ftp无法连接，会返回错误代码。具体错误代码又代表了什么呢？</p><h4 id="6-1、Connect-连接被拒绝："><a href="#6-1、Connect-连接被拒绝：" class="headerlink" title="6.1、Connect 连接被拒绝："></a>6.1、Connect 连接被拒绝：</h4><blockquote><p>可能原因是vsftpd服务没被启动</p></blockquote><h4 id="6-2、500-OOPS"><a href="#6-2、500-OOPS" class="headerlink" title="6.2、500 OOPS:"></a>6.2、500 OOPS:</h4><h5 id="6-2-1、cannot-open-user-list-file："><a href="#6-2-1、cannot-open-user-list-file：" class="headerlink" title="6.2.1、cannot open user list file："></a>6.2.1、cannot open user list file：</h5><blockquote><p>可能原因是不存在文件“/etc/vsftpd/user_list”或文件中不存在该帐户，解决：解决: cho username &gt;&gt; /etc/vsftpd/user_list</p></blockquote><h5 id="6-2-2、cannot-open-chroot-user-list-file-500-OOPS-could-not-read-chroot-list-file-etc-vsftpd-chroot-list："><a href="#6-2-2、cannot-open-chroot-user-list-file-500-OOPS-could-not-read-chroot-list-file-etc-vsftpd-chroot-list：" class="headerlink" title="6.2.2、cannot open chroot() user list file | 500 OOPS: could not read chroot() list file:/etc/vsftpd/chroot_list："></a>6.2.2、cannot open chroot() user list file | 500 OOPS: could not read chroot() list file:/etc/vsftpd/chroot_list：</h5><blockquote><p>可能原因是不存在文件“/etc/vsftpd/chroot_list”</p></blockquote><h5 id="6-2-3、missing-value-in-config-file"><a href="#6-2-3、missing-value-in-config-file" class="headerlink" title="6.2.3、missing value in config file:"></a>6.2.3、missing value in config file:</h5><blockquote><p>可能原因是配置文件“=”等号前值有问题，或只有一个空格</p></blockquote><h5 id="6-2-4、bad-bool-value-in-config-file"><a href="#6-2-4、bad-bool-value-in-config-file" class="headerlink" title="6.2.4、bad bool value in config file:"></a>6.2.4、bad bool value in config file:</h5><blockquote><p>可能原因是配置文件=”等号后值有问题</p></blockquote><h5 id="6-2-5、unrecognised-variable-in-config-file"><a href="#6-2-5、unrecognised-variable-in-config-file" class="headerlink" title="6.2.5、unrecognised variable in config file:"></a>6.2.5、unrecognised variable in config file:</h5><blockquote><p>可能原因是参数前有空格</p></blockquote><h5 id="6-2-6、chdir，child-died-chroot："><a href="#6-2-6、chdir，child-died-chroot：" class="headerlink" title="6.2.6、chdir，child died, chroot："></a>6.2.6、chdir，child died, chroot：</h5><blockquote><p>可能原因是用户主目录没有权限或没有主目录，或者还是selinux影响的</p></blockquote><h5 id="6-2-7、vsftpd-both-local-and-anonymous-access-disabled"><a href="#6-2-7、vsftpd-both-local-and-anonymous-access-disabled" class="headerlink" title="6.2.7、vsftpd: both local and anonymous access disabled!"></a>6.2.7、vsftpd: both local and anonymous access disabled!</h5><blockquote><p>匿名用户和本地用户登录都被禁用</p></blockquote><h5 id="6-2-8、vsftpd-refusing-to-run-with-writable-root-inside-chroot-："><a href="#6-2-8、vsftpd-refusing-to-run-with-writable-root-inside-chroot-：" class="headerlink" title="6.2.8、vsftpd: refusing to run with writable root inside chroot() ："></a>6.2.8、vsftpd: refusing to run with writable root inside chroot() ：</h5><blockquote><p>如果启用了限定用户在其主目录下需要添加这个配置，解决报错  allow_writeable_chroot=YES </p></blockquote><h4 id="6-3、522"><a href="#6-3、522" class="headerlink" title="6.3、522"></a>6.3、522</h4><p>522 SSL connection failed; session reuse required: see require_ssl_reuse option in vsftpd.conf man page。原来是FTP的require_ssl_reuse=YES导致的，当选项<strong>require_ssl_reuse</strong>设置为<code>YES</code>时，所有SSL数据连接都需要显示SSL会话重用;证明他们知道与控制信道相同的主秘钥。 </p><p>这个问题可能导致客户端到服务器能够正常连接，但是客户端看不到服务器上的任何内容。</p><h4 id="6-3、530-："><a href="#6-3、530-：" class="headerlink" title="6.3、530 ："></a>6.3、530 ：</h4><h5 id="6-3-1、Permission-denied："><a href="#6-3-1、Permission-denied：" class="headerlink" title="6.3.1、Permission denied："></a>6.3.1、Permission denied：</h5><blockquote><p>可能原因是userlist_enable=YES并且/etc/vsftpd/user_list中包含要登录的ftp用户名，即user_list禁止了该用户的登录、或者可能是没有指定userlist_file=/etc/vsftpd/user_list</p></blockquote><h5 id="6-3-2、Login-incorrect："><a href="#6-3-2、Login-incorrect：" class="headerlink" title="6.3.2、Login incorrect："></a>6.3.2、Login incorrect：</h5><blockquote><p>要确保用户名、密码是正确的；</p><p>可能原因是登录的ftp用户名被包含在禁止登录列表/etc/vsftpd/ftpusers中  ；</p><p>也可能是配置文件中少了一行pam_service_name=vsftpd ；</p></blockquote><p>Linux-PAM（即linux可插入认证模块）</p><blockquote><p>检查/etc/pam.d/vsftpd 文件里面lib的路径；</p><p>检查/etc/pam.d/vsftpd 文件内容是否导致local用户和虚拟用户登录冲突（具体的见之后配置虚拟用户的案例7.1.3）；</p><p>编辑/etc/pam.d/vsftp文件，注释掉auth required pam_shells.so（这个语句的意思是只有包含shell的用户才能登录）；</p></blockquote><h5 id="6-3-3、Non-anonymous-sessions-must-use-encryption："><a href="#6-3-3、Non-anonymous-sessions-must-use-encryption：" class="headerlink" title="6.3.3、Non-anonymous sessions must use encryption："></a>6.3.3、Non-anonymous sessions must use encryption：</h5><blockquote><p>服务器的强制，非匿名用户必须使用加密连接</p></blockquote><h4 id="6-4、GnuTLS-error-12-A-TLS-fatal-alert-has-been-received："><a href="#6-4、GnuTLS-error-12-A-TLS-fatal-alert-has-been-received：" class="headerlink" title="6.4、GnuTLS error -12: A TLS fatal alert has been received："></a>6.4、GnuTLS error -12: A TLS fatal alert has been received：</h4><blockquote><p>Filezilla最新版本认为vsftpd默认的加密算法”DES-CBC3-SHA”不够安全而拒绝连接导致的。有两种办法解决该问题，一是降级你的Filezilla客户端版本到3.5.3以下，二是更改服务器端vsftpd的配置,增加参数：ssl_ciphers=HIGH</p></blockquote><h4 id="6-5、ECONNREFUSED-–-Connection-refused-by-server："><a href="#6-5、ECONNREFUSED-–-Connection-refused-by-server：" class="headerlink" title="6.5、ECONNREFUSED – Connection refused by server："></a>6.5、ECONNREFUSED – Connection refused by server：</h4><blockquote><p>当启用隐式ssl连接，用filezilla、winscp客户端连接时报错，因为vsftpd此时服务器端的端口还是21，但是客户端确以990来连接。修改客户端连接时使用的参数或者服务器的通过参数listen_port设置端口为990，问题解决</p></blockquote><h3 id="7、案例"><a href="#7、案例" class="headerlink" title="7、案例"></a>7、案例</h3><h4 id="7-1、案例一、建立基于虚拟用户的FTP服务器，并根据以下要求配置FTP服务器。"><a href="#7-1、案例一、建立基于虚拟用户的FTP服务器，并根据以下要求配置FTP服务器。" class="headerlink" title="7.1、案例一、建立基于虚拟用户的FTP服务器，并根据以下要求配置FTP服务器。"></a>7.1、案例一、建立基于虚拟用户的FTP服务器，并根据以下要求配置FTP服务器。</h4><blockquote><p>配置FTP匿名用户的主目录为/var/ftp/anon；下载带宽限制为100kB/s ；建立一个名为abc，口令为xyz的FTP账户；下载带宽限制为500kB/s；设置FTP服务器同时登录到FTP服务器的最大链接数为100；每个IP最大链接数为3；用户空闲时间超过限值为5分钟。</p></blockquote><h5 id="7-1-1、创建目录-var-fpt-anon"><a href="#7-1-1、创建目录-var-fpt-anon" class="headerlink" title="7.1.1、创建目录/var/fpt/anon"></a>7.1.1、创建目录/var/fpt/anon</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">mkdir</span> /var/fpt/anon <br>建立一个名为<span class="hljs-keyword">abc</span>，口令为xyz的FTP账户<br>useradd <span class="hljs-keyword">abc</span><br>passwd <span class="hljs-keyword">abc</span> <br></code></pre></td></tr></table></figure><h5 id="7-1-2、本地的Local用户配置"><a href="#7-1-2、本地的Local用户配置" class="headerlink" title="7.1.2、本地的Local用户配置"></a>7.1.2、本地的Local用户配置</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">vim /etc/vsftpd/vsftpd.conf<br>-&gt;<br><span class="hljs-attribute">anonymous_enable</span>=<span class="hljs-literal">YES</span>#允许匿名登录<br><span class="hljs-attribute">anon_root</span>=/var/ftp/anon#配置FTP匿名用户的主目录为/var/ftp/anon<br><span class="hljs-attribute">anon_max_rate</span>=100#下载带宽限制为100kB/s<br><span class="hljs-attribute">local_enable</span>=<span class="hljs-literal">YES</span>#允许本地用户登录<br><span class="hljs-attribute">local_max_rate</span>=500下载带宽限制为500kB/s<br><span class="hljs-attribute">max_clients</span>=100#设置FTP服务器同时登录到FTP服务器的最大链接数为100<br><span class="hljs-attribute">max_per_ip</span>=3#每个IP最大链接数为3<br><span class="hljs-attribute">connect_timeout</span>=300#用户空闲时间超过限值为5分钟<br></code></pre></td></tr></table></figure><h5 id="7-1-3、下面是虚拟用户配置"><a href="#7-1-3、下面是虚拟用户配置" class="headerlink" title="7.1.3、下面是虚拟用户配置"></a>7.1.3、下面是虚拟用户配置</h5><p>添加虚拟用户口令文件</p><p>添加虚拟用户名和密码，一行用户名，一行密码，以此类推。奇数行为用户名，偶数行为密码。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>vsftpd/virtuser<br>-&gt;<br>tom<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>将virtuser文件的其他用户访问权限改成0，防止其他用户轻易的得到密码。<br>修改之前：-rw-r–r– 1 root root    47 Nov 15 16:14 virtusers 其它用户对此文件可读。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod <span class="hljs-number">640</span> <span class="hljs-regexp">/etc/</span>vsftpd/virtuser<br></code></pre></td></tr></table></figure><p>生成数据库文件</p><p>使用db_load命令生成虚拟用户口令认证文件，如果不能使用db_load命令请先安装db4_utils</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> –qa |grep db<span class="hljs-number">4</span>-utils#查看是否安装<br><span class="hljs-attribute">rpm</span> –ivh db<span class="hljs-number">4</span>-utils-<span class="hljs-number">4</span>.<span class="hljs-number">3</span>.<span class="hljs-number">29</span>-<span class="hljs-number">9</span>.fc<span class="hljs-number">6</span>.i<span class="hljs-number">386</span>.rpm#安装<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">db_load -T -t hash -f <span class="hljs-regexp">/etc/</span>vsftpd<span class="hljs-regexp">/virtuser /</span>etc<span class="hljs-regexp">/vsftpd/</span>virtuser.db<br>chmod <span class="hljs-number">600</span> <span class="hljs-regexp">/etc/</span>vsftpd/vuser.db<br></code></pre></td></tr></table></figure><p>编辑/etc/pam.d/vsftpd</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>pam.d/vsftpd<br>-&gt;<br>auth      sufficient   pam_userdb.so  db=<span class="hljs-regexp">/etc/</span>vsftpd/virtuser<br>account   sufficient   pam_userdb.so  db=<span class="hljs-regexp">/etc/</span>vsftpd/virtuser<br></code></pre></td></tr></table></figure><blockquote><p>误区：网上查阅过许多配置虚拟用户的资料，大多都是说将/etc/pam.d/vsftpd中的原来的auth和account内容注释掉，但是这样做的话会导致local用户无法访问ftp服务。<br>加入以下：<br>auth      required   pam_userdb.so  db=/etc/vsftpd/virtuser<br>account   required   pam_userdb.so  db=/etc/vsftpd/virtuser</p><p>若要虚拟和本地用户都能够访问ftp服务<br>加入以下：<br>auth      sufficient   pam_userdb.so  db=/etc/vsftpd/virtuser<br>account   sufficient   pam_userdb.so  db=/etc/vsftpd/virtuser<br>除此之外，还应该注意新添加的这两行在文件中的位置</p></blockquote><p>编辑vsftpd.conf映射虚拟用户</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">vim /etc/vsftpd/vsftpd.conf<br>-&gt;<br><span class="hljs-attribute">guest_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">guest_username</span>=abc<br></code></pre></td></tr></table></figure><p><img src="/2019/11/15/FTP%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/ftp.png" alt="1"></p><h4 id="7-2、案例二、一个简单的公司部门FTP服务"><a href="#7-2、案例二、一个简单的公司部门FTP服务" class="headerlink" title="7.2、案例二、一个简单的公司部门FTP服务"></a>7.2、案例二、一个简单的公司部门FTP服务</h4><p>1、新建一分区，10G空间，ext3 文件系统，挂在到 /ftp下，作为 ftp服务器数据存放地方。<br>2、四个部门：dep1，dep2， dep3， dep4，分别对应目录 /ftp/dep1，/ftp/dep2，/ftp/dep3，/ftp/dep4。另外设定一个公共目录 /ftp/public。<br>3、五个用户：admin，user1，user2，user3，user4。其中：user 1/2/3/4分别对应部门dep 1/2/3/4，他们只能访问自己所属部门的目录和public目录。如：user1只能访问dep1和public目录，不能访问其它目录。admin为管理员用户，可以访问 ftp 服务器上的任何目录。<br>4、用户访问权限限制：user1/2/3/4在所能访问的目录，具有上传文件、下载文件的功能，但是不能够删除文件、更改文件权限等功能。admin管理员用户对所有目录具有文件上传、下载、删除、权限更改等功能。<br>5、对每个部门定制一个 quota，设置该账户的文件配额为1000个；磁盘配额为2G。<br>6、匿名用户不能访问。</p><h5 id="7-2-1、增加一块硬盘，然后分区，把分区挂载情况写入-etc-fstab"><a href="#7-2-1、增加一块硬盘，然后分区，把分区挂载情况写入-etc-fstab" class="headerlink" title="7.2.1、增加一块硬盘，然后分区，把分区挂载情况写入/etc/fstab"></a>7.2.1、增加一块硬盘，然后分区，把分区挂载情况写入/etc/fstab</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">fdisk <span class="hljs-regexp">/dev/</span>hdb<br>mkfs ext3 <span class="hljs-regexp">/dev/</span>hdb1<br>mkidr /ftp<br>mount <span class="hljs-regexp">/dev/</span>hdb1 /ftp -o usrquota,grpquota <br>vim <span class="hljs-regexp">/etc/</span>fstab<br>加入下面一句:<br><span class="hljs-regexp">/dev/</span>hdb1       /ftp      ext3     defaults,usrquota,grpquota      <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><h5 id="7-2-2、建立用户组和用户和相应的文件夹并更改权限，达到题目要求"><a href="#7-2-2、建立用户组和用户和相应的文件夹并更改权限，达到题目要求" class="headerlink" title="7.2.2、建立用户组和用户和相应的文件夹并更改权限，达到题目要求"></a>7.2.2、建立用户组和用户和相应的文件夹并更改权限，达到题目要求</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">groupadd</span> dep<span class="hljs-number">1</span><br><span class="hljs-attribute">groupadd</span> dep<span class="hljs-number">2</span><br><span class="hljs-attribute">groupadd</span> dep<span class="hljs-number">3</span><br><span class="hljs-attribute">groupadd</span> dep<span class="hljs-number">4</span><br><span class="hljs-attribute">groupadd</span> **e <br><span class="hljs-attribute">usradd</span>  -G dep<span class="hljs-number">1</span>,**e user<span class="hljs-number">1</span><br><span class="hljs-attribute">usradd</span>  -G dep<span class="hljs-number">2</span>,**e user<span class="hljs-number">2</span><br><span class="hljs-attribute">usradd</span>  -G dep<span class="hljs-number">3</span>,**e user<span class="hljs-number">3</span><br><span class="hljs-attribute">usradd</span>  -G dep<span class="hljs-number">4</span>,**e user<span class="hljs-number">4</span><br><span class="hljs-attribute">usradd</span>  -G dep<span class="hljs-number">1</span>,dep<span class="hljs-number">2</span>,dep<span class="hljs-number">3</span>,dep<span class="hljs-number">4</span>,**e admin <br><span class="hljs-attribute">passwd</span> user<span class="hljs-number">1</span><br><span class="hljs-attribute">passwd</span> user<span class="hljs-number">2</span><br><span class="hljs-attribute">passwd</span> user<span class="hljs-number">3</span><br><span class="hljs-attribute">passwd</span> user<span class="hljs-number">4</span><br><span class="hljs-attribute">passwd</span> admin <br><span class="hljs-attribute">mkdir</span> /ftp/dep<span class="hljs-number">1</span><br><span class="hljs-attribute">mkdir</span> /ftp/dep<span class="hljs-number">2</span><br><span class="hljs-attribute">mkdir</span> /ftp/dep<span class="hljs-number">3</span><br><span class="hljs-attribute">mkdir</span> /ftp/dep<span class="hljs-number">4</span><br><span class="hljs-attribute">mkdir</span> /ftp/public <br><span class="hljs-attribute">chmod</span> uesr<span class="hljs-number">1</span>:dep<span class="hljs-number">1</span> /ftp/dep<span class="hljs-number">1</span><br><span class="hljs-attribute">chmod</span> uesr<span class="hljs-number">2</span>:dep<span class="hljs-number">2</span> /ftp/dep<span class="hljs-number">2</span><br><span class="hljs-attribute">chmod</span> uesr<span class="hljs-number">3</span>:dep<span class="hljs-number">3</span> /ftp/dep<span class="hljs-number">3</span><br><span class="hljs-attribute">chmod</span> uesr<span class="hljs-number">4</span>:dep<span class="hljs-number">4</span> /ftp/dep<span class="hljs-number">4</span><br><span class="hljs-attribute">chmod</span> admin:**e /ftp/public <br><span class="hljs-attribute">chmod</span> <span class="hljs-number">770</span> /ftp/dep<span class="hljs-number">1</span><br><span class="hljs-attribute">chmod</span> <span class="hljs-number">770</span> /ftp/dep<span class="hljs-number">2</span><br><span class="hljs-attribute">chmod</span> <span class="hljs-number">770</span> /ftp/dep<span class="hljs-number">3</span><br><span class="hljs-attribute">chmod</span> <span class="hljs-number">770</span> /ftp/dep<span class="hljs-number">4</span><br><span class="hljs-attribute">chmod</span> <span class="hljs-number">770</span> /ftp/pubic <br></code></pre></td></tr></table></figure><p>最终结果如下 :</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rw-------<span class="hljs-number"> 1 </span>root  root     <span class="hljs-number"> 8192 </span>Jul<span class="hljs-number"> 26 </span>11:46 aquota.group<br>-rw-------<span class="hljs-number"> 1 </span>root  root     <span class="hljs-number"> 7168 </span>Jul<span class="hljs-number"> 26 </span>11:46 aquota.user<br>drwxrwx---<span class="hljs-number"> 2 </span>user1 dep1     <span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 25 </span>20:47 dep1<br>drwxrwx---<span class="hljs-number"> 2 </span>user2 dep2     <span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 25 </span>20:47 dep2<br>drwxrwx---<span class="hljs-number"> 2 </span>user3 dep3     <span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 25 </span>20:47 dep3<br>drwxrwx---<span class="hljs-number"> 2 </span>user4 dep4     <span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 25 </span>20:47 dep4<br>drwx------<span class="hljs-number"> 2 </span>root  root    <span class="hljs-number"> 16384 </span>Jul<span class="hljs-number"> 25 </span>20:44 lost+found<br>drwxrwx---<span class="hljs-number"> 2 </span>admin **e <span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 25 </span>20:48 public <br></code></pre></td></tr></table></figure><h5 id="7-2-3、创建quota，配置磁盘配额"><a href="#7-2-3、创建quota，配置磁盘配额" class="headerlink" title="7.2.3、创建quota，配置磁盘配额"></a>7.2.3、创建quota，配置磁盘配额</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mount <span class="hljs-regexp">/dev/</span>hdb1 /ftp -o usrquota,grpquota<br>quotacheck -cuvg <span class="hljs-regexp">/dev/</span>sdb1<br>quotaon -a<br>edquota -g dep1 <br>-&gt;Disk quotas <span class="hljs-keyword">for</span> <span class="hljs-keyword">group</span> dep1 (gid <span class="hljs-number">503</span>):<br>  Filesystem                   blocks       soft       hard     inodes     soft     hard<br>  <span class="hljs-regexp">/dev/</span>hdb1                         <span class="hljs-number">0</span>    <span class="hljs-number">1024000</span>    <span class="hljs-number">2048000</span>          <span class="hljs-number">0</span>      <span class="hljs-number">500</span>     <span class="hljs-number">1000</span> <br>edquota -g -p dep1 dep2 dep3 dep4(-u -g将源用户组和群组的quota设置套用至其他用户或群组。) <br></code></pre></td></tr></table></figure><h5 id="7-2-4、编辑vsftpd配置文件"><a href="#7-2-4、编辑vsftpd配置文件" class="headerlink" title="7.2.4、编辑vsftpd配置文件"></a>7.2.4、编辑vsftpd配置文件</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># vim /etc/vsftpd/vsftpd.conf </span><br><span class="hljs-attribute">anonymous_enable</span>=<span class="hljs-literal">NO</span> <br>加入<br><span class="hljs-attribute">local_root</span>=/ftp<br><span class="hljs-attribute">user_config_dir</span>=/etc/vsftpd/ftp_config_dir  <br><br>开启chroot <br><span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">chroot_list_file</span>=/etc/vsftpd/chroot_list <br></code></pre></td></tr></table></figure><h5 id="7-2-5、建立用户的独立配置文件"><a href="#7-2-5、建立用户的独立配置文件" class="headerlink" title="7.2.5、建立用户的独立配置文件"></a>7.2.5、建立用户的独立配置文件</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mkdir <span class="hljs-regexp">/etc/</span>vsftpd/ftp_config_dir<br>vim <span class="hljs-regexp">/etc/</span>vsftpd<span class="hljs-regexp">/ftp_config_dir/u</span>ser1 <br><br>-&gt;cmds_allowed=ABOR,ACCT,APPE,CWD,CDUP,HELP,LIST,MODE,MDTM,NOOP,NLST,PASS,PASV,PORT,PWD,QUIT,REIN,RETR,SITE,<span class="hljs-keyword">SIZE</span>,STOR,STAT,STOU,STRU,SYST,TYPE,USER <br><br>cp <span class="hljs-regexp">/etc/</span>vsftpd<span class="hljs-regexp">/ftp_config_dir/u</span>ser1 <span class="hljs-regexp">/etc/</span>vsftpd<span class="hljs-regexp">/ftp_config_dir/u</span>ser2<br>cp <span class="hljs-regexp">/etc/</span>vsftpd<span class="hljs-regexp">/ftp_config_dir/u</span>ser1 <span class="hljs-regexp">/etc/</span>vsftpd<span class="hljs-regexp">/ftp_config_dir/u</span>ser3<br>cp <span class="hljs-regexp">/etc/</span>vsftpd<span class="hljs-regexp">/ftp_config_dir/u</span>ser1 <span class="hljs-regexp">/etc/</span>vsftpd<span class="hljs-regexp">/ftp_config_dir/u</span>ser4<br></code></pre></td></tr></table></figure><h4 id="7-3、案例三、userlist-enable和userlist-deny配置项"><a href="#7-3、案例三、userlist-enable和userlist-deny配置项" class="headerlink" title="7.3、案例三、userlist_enable和userlist_deny配置项"></a>7.3、案例三、userlist_enable和userlist_deny配置项</h4><p>建立三个用户chkin1 、chkin2、 chkin3，将chkin1添加到/etc/vsftpd/ftpusers文件中，将chkin2添加到/etc/vsftpd/user_list文件中，chkin3不添加到这两个文件中。</p><p>1、当userlist_enable=NO时，ftpusers文件中的用户将被禁止访问ftp服务。此时只有chkin2和chkin3能够访问ftp服务。</p><p>2、当userlist_enable=YES，userlist_deny=NO时,FTP服务器只允许user_list中的用户访问。此时只有chkin2能够访问ftp服务。</p><p>3、当userlist_enable=YES，userlist_deny=YES时，user_list和ftpusers中的用户均不能访问FTP服务。此时仅chkin3能访问FTP服务。</p><h3 id="8、补充内容"><a href="#8、补充内容" class="headerlink" title="8、补充内容"></a>8、补充内容</h3><h4 id="8-1、如何对磁盘限额"><a href="#8-1、如何对磁盘限额" class="headerlink" title="8.1、如何对磁盘限额"></a>8.1、如何对磁盘限额</h4><p>用quota对/etc/fstab进行限制，然后对特定用户进行限制</p><h4 id="8-2、如何让绑定IP到vsFTP？"><a href="#8-2、如何让绑定IP到vsFTP？" class="headerlink" title="8.2、如何让绑定IP到vsFTP？"></a>8.2、如何让绑定IP到vsFTP？</h4><p>也就是说，如何让用户只能通过某个IP来访问FTP。其实这个功能很有意思。如果绑定的是内网的IP，外部是没有办法访问的。如果绑定的是对外服务的IP，内网也只能通过对外服务的IP来访问FTP 。</p><p>在/etc/vsftpd/vsftpd.conf中加一行，以我的局域网为例，请看第一帖中的操作环境，这样外网就不能访问我的FTP了，内网也可能通过192.168.0.2来访问FTP<br>listen_address=192.168.0.2 </p><p>加完后，要重启vsFTP服务器 </p><h4 id="8-3、Linux-PAM"><a href="#8-3、Linux-PAM" class="headerlink" title="8.3、Linux-PAM"></a>8.3、Linux-PAM</h4><p>Linux-PAM（即linux可插入认证模块）是一套共享库,使本地系统管理员可以随意选择程序的认证方式。</p><p><a href="https://www.cnblogs.com/kevingrace/p/8671964.html">Linux下PAM模块学习总结</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-pam/">了解和配置PAM</a></p><p><strong>虚拟用户和本地用户不能共存的错误排除过程</strong></p><p>网上大部分教程教建立虚拟用户，将/etc/pam.d/vsftpd中的原来的auth和account内容注释掉，加入以下内容：</p><blockquote><p>auth      required   pam_userdb.so  db=/etc/vsftpd/virtuser<br>account   required   pam_userdb.so  db=/etc/vsftpd/virtuser</p></blockquote><p>1、在配置vsftpd的过程中，听信了网上的妖言，把vsftpd配了一遍，发现配完，虚拟用户和本地用户不能共存，即虚拟用户可以登录ftp，但是本地用户不能登录的ftp。</p><p>2、上网找过很多内容都找不到解决方法，大家貌似都没有这样的问题，或者找不到解决办法。</p><p>3、在看众多教程中有看到过和本方法一样的配置，但是那份内容里面完全没有提到/etc/pam.d/vsftpd里面为什么要这样写</p><p>4、本地用户无法登录，那应该是pam验证的时候就没有给本地用户过</p><p>如果把**/etc/pam.d/vsftpd** 中的<strong>auth required pam_userdb.so db=/etc/vsftpd/vuser_passwd</strong>和<strong>account required pam_userdb.so db=/etc/vsftpd/vuser_passwd</strong>注释掉，然后把里面其它的内容都打开注释。</p><p>这时候再尝试，发现本地用户能登录</p><p>5、这也证明了是pam模块认证配置冲突的问题让虚拟用户和本地用户不能共存</p><p><strong>required：</strong>堆栈中的所有 Required 模块必须看作一个成功的结果。如果一个或多个 Required 模块失败，则实现堆栈中的所有 Required 模块，但是将返回第一个错误。</p><p>也就意味着，required需要所有内容都满足才行，当我们前两条配置虚拟用户登录验证通过后，继续向下面的配置条目进行验证，验证是否是本地用户时结果发现不是，又因为，验证本地用户的control_flag也为required，所以这时候，就会返回错误，也即验证不成功。</p><p>6、所以我们不能同时设置虚拟用户和本地用户的control_flag为required。按照上面的网址所说：</p><p><strong>sufficient：</strong>如果标记为 sufficient 的模块成功并且先前没有 Required 或 sufficient 模块失败，则忽略堆栈中的所有其余模块并返回成功。</p><p>7、我们可以把虚拟用户的验证配置放在最前面，且把control_flag设为sufficient。这样的话，如果遇到是虚拟用户，那么可以通过验证，如果是本地用户，忽略掉sufficient的两条配置规则，只要满足required就行，所以也能通过验证。</p><p><img src="/2019/11/15/FTP%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/ftp.png" alt="2"></p><h4 id="8-4、MySql数据库中创建用户口令数据库"><a href="#8-4、MySql数据库中创建用户口令数据库" class="headerlink" title="8.4、MySql数据库中创建用户口令数据库"></a>8.4、MySql数据库中创建用户口令数据库</h4><h5 id="8-4-1、安装MySql"><a href="#8-4-1、安装MySql" class="headerlink" title="8.4.1、安装MySql"></a>8.4.1、安装MySql</h5><h5 id="8-4-2、建立本地映射用户并设置宿主目录权限"><a href="#8-4-2、建立本地映射用户并设置宿主目录权限" class="headerlink" title="8.4.2、建立本地映射用户并设置宿主目录权限"></a>8.4.2、建立本地映射用户并设置宿主目录权限</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@CentOS <span class="hljs-regexp">/]#useradd –d /</span>home<span class="hljs-regexp">/vftpsite –s /</span>sbin/nologin vftpuser<br>[root@CentOS <span class="hljs-regexp">/]#chmod 700 /</span>home/vftpsite<br></code></pre></td></tr></table></figure><h5 id="8-4-3、配置vsftpd-conf（设置虚拟用户配置项）"><a href="#8-4-3、配置vsftpd-conf（设置虚拟用户配置项）" class="headerlink" title="8.4.3、配置vsftpd.conf（设置虚拟用户配置项）"></a>8.4.3、配置vsftpd.conf（设置虚拟用户配置项）</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[root@CentOS /]</span><span class="hljs-comment">#vi /etc/vsftpd/vsftpd.conf</span><br><span class="hljs-attr">guest_enable</span>=<span class="hljs-literal">YES</span> <span class="hljs-comment">#开启虚拟用户</span><br><span class="hljs-attr">guest_username</span>=vftpuser <span class="hljs-comment">#FTP虚拟用户对应的系统用户</span><br><span class="hljs-attr">pam_service_name</span>=vsftpd <span class="hljs-comment">#PAM认证文件</span><br></code></pre></td></tr></table></figure><h5 id="8-4-4、建立虚拟用户数据库，数据库名如vftpusers"><a href="#8-4-4、建立虚拟用户数据库，数据库名如vftpusers" class="headerlink" title="8.4.4、建立虚拟用户数据库，数据库名如vftpusers"></a>8.4.4、建立虚拟用户数据库，数据库名如vftpusers</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@CentOS /</span>]<span class="hljs-meta">#mysql –u root –p</span><br>mysql&gt; create database vftpuser;   <span class="hljs-meta">#建立虚拟用户数据库，库名vftpuser</span><br>mysql&gt; use vftpuser;  <span class="hljs-meta">#进入vftpuser数据库</span><br><br><span class="hljs-meta">#建立虚拟用户口令表，表名users</span><br>mysql&gt; <span class="hljs-function">create table <span class="hljs-title">users</span>(<span class="hljs-params">name <span class="hljs-built_in">char</span>(<span class="hljs-number">16</span></span>) binary,passwd <span class="hljs-title">char</span>(<span class="hljs-params"><span class="hljs-number">16</span></span>) binary)</span>;  <br><br><span class="hljs-meta">#建立两个虚拟用户，bobyuan和markwang</span><br>mysql&gt; <span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">users</span> (<span class="hljs-params">name,passwd</span>) <span class="hljs-title">values</span> (<span class="hljs-params"><span class="hljs-string">&#x27;bobyuan&#x27;</span>,password(<span class="hljs-string">&#x27;111&#x27;</span></span>))</span>; <br>mysql&gt; <span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">users</span> (<span class="hljs-params">name,passwd</span>) <span class="hljs-title">values</span> (<span class="hljs-params"><span class="hljs-string">&#x27;markwang&#x27;</span>,password(<span class="hljs-string">&#x27;111&#x27;</span></span>))</span>;<br><span class="hljs-meta">#注：在这里我用这种方法添加的虚拟用户密码都是经过MySQL加密的，加密后的密码pam-mysql不能识</span><br><span class="hljs-meta">#别（MySQL和pam-mysql兼容性有些问题），因此本次实验使用明文保存密码。</span><br><br><span class="hljs-meta">#逐个添加用户</span><br>mysql&gt; <span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">users</span> (<span class="hljs-params">name,passwd</span>) <span class="hljs-title">values</span> (<span class="hljs-params"><span class="hljs-string">&#x27;bobyuan&#x27;</span>, <span class="hljs-string">&#x27;111&#x27;</span></span>)</span>;<br>mysql&gt; <span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">users</span> (<span class="hljs-params">name,passwd</span>) <span class="hljs-title">values</span> (<span class="hljs-params"><span class="hljs-string">&#x27;markwang&#x27;</span>,‘<span class="hljs-number">111&#x27;</span></span>)</span>;<br><br><span class="hljs-meta">#批量添加用户</span><br>[<span class="hljs-meta">root@CentOS /</span>]<span class="hljs-meta">#vim vftpuser.txt</span><br><span class="hljs-meta">#添加用户名和密码，注意字段数据之间要用Tab键隔开。</span><br>bobyuan  <span class="hljs-number">111</span><br>markwang <span class="hljs-number">111</span><br><br>mysql&gt;use vftpuser;<br>mysql&gt;load data local infile <span class="hljs-string">&quot;/vftpuser.txt&quot;</span> <span class="hljs-keyword">into</span> table users;<br>mysql&gt;flush privileges;<br><br>mysql&gt; grant <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> vftpuser.users to vftpuser@localhost identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;111111&#x27;</span>;  <span class="hljs-meta">#授权vftpuser这个账号可以读取vftpuser数据库的user表</span><br><br></code></pre></td></tr></table></figure><h5 id="8-4-5、验证设置是否成功"><a href="#8-4-5、验证设置是否成功" class="headerlink" title="8.4.5、验证设置是否成功"></a>8.4.5、验证设置是否成功</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[root@CentOS /]#mysql –u vftpuser –p<br>mysql&gt;<span class="hljs-keyword">show</span> databases;<br>mysql&gt;use vftpuser;<br>mysql&gt;<span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br>mysql&gt;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users;<br>mysql&gt;quit<br></code></pre></td></tr></table></figure><h5 id="8-4-6、编译MySql的PAM认证模块"><a href="#8-4-6、编译MySql的PAM认证模块" class="headerlink" title="8.4.6、编译MySql的PAM认证模块"></a>8.4.6、编译MySql的PAM认证模块</h5><p>查看/usr/lib64/security目录下有没有MySQL对应的PAM模块pam-mysql。</p><p>如果没有则下载pam-mysql安装（<a href="http://sourceforge.net/projects/pam-mysql%EF%BC%89%EF%BC%8C">http://sourceforge.net/projects/pam-mysql），</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//</span>prdownloads.sourceforge.net<span class="hljs-regexp">/pam-mysql/</span>pam_mysql-<span class="hljs-number">0.7</span>RC1.tar.gz<br></code></pre></td></tr></table></figure><p>我下载的是pam_mysql-0.7RC1.tar.gz。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@CentOS</span> /]<span class="hljs-meta">#cd /usr/local/src</span><br>[root<span class="hljs-symbol">@CentOS</span> src]<span class="hljs-meta">#tar –zxvf pam_mysql-0.7RC1.tar.gz</span><br>[root<span class="hljs-symbol">@CentOS</span> src]<span class="hljs-meta">#cd pam_mysql-0.7RC1</span><br>[root<span class="hljs-symbol">@CentOS</span> pam_mysql<span class="hljs-number">-0.7</span>RC1]<span class="hljs-meta"># ./configure --with-pam=/usr --with-mysql=/usr --with-pam-mods-dir=/usr/lib64/security</span><br>[root<span class="hljs-symbol">@CentOS</span> pam_mysql<span class="hljs-number">-0.7</span>RC1]<span class="hljs-meta">#make</span><br>[root<span class="hljs-symbol">@CentOS</span> pam_mysql<span class="hljs-number">-0.7</span>RC1]<span class="hljs-meta">#make install</span><br></code></pre></td></tr></table></figure><h5 id="8-4-7、编辑vsftpd的PAM认证文件"><a href="#8-4-7、编辑vsftpd的PAM认证文件" class="headerlink" title="8.4.7、编辑vsftpd的PAM认证文件"></a>8.4.7、编辑vsftpd的PAM认证文件</h5><p><strong>方法一、在现有的vsftpd文件中</strong></p><p>在/etc/pam.d目录下，编辑vsftpd文件，将里面其他的都注释掉（又是这？不用理它看前面的），添加下面这两行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">auth required pam_mysql.so <span class="hljs-attribute">user</span>=vftpuser <span class="hljs-attribute">passwd</span>=111111 <span class="hljs-attribute">host</span>=localhost <span class="hljs-attribute">db</span>=vftpuser <span class="hljs-attribute">table</span>=users <span class="hljs-attribute">usercolumn</span>=name <span class="hljs-attribute">passwdcolumn</span>=passwd <span class="hljs-attribute">crypt</span>=0<br><br>account required pam_mysql.so <span class="hljs-attribute">user</span>=vftpuser <span class="hljs-attribute">passwd</span>=111111 <span class="hljs-attribute">host</span>=localhost <span class="hljs-attribute">db</span>=vftpuser <span class="hljs-attribute">table</span>=users <span class="hljs-attribute">usercolumn</span>=name <span class="hljs-attribute">passwdcolumn</span>=passwd <span class="hljs-attribute">crypt</span>=0<br></code></pre></td></tr></table></figure><p>crypt=0：表示口令使用明文方式保存在数据库中<br>crypt=1：表示口令使用UNIX的DES加密方式加密后保存在数据库中<br>crypt=2：表示口令使用MySQL的password()函数加密后保存在数据库中<br>crypt=3：表示口令使用MD5散列值的方式保存在数据库中</p><p><strong>方法二、新建用于认证的配置文件/etc/pam.d/vsftpd.vusers</strong></p><p>/usr/local/src/pam_mysql-0.7RC1/README  这个文件有详细解释</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">auth required /usr/lib64/security/pam_mysql.so <span class="hljs-attribute">user</span>=vsftpd <span class="hljs-attribute">passwd</span>=vsftpd  <span class="hljs-attribute">host</span>=127.0.0.1 <span class="hljs-attribute">db</span>=vsftpd <span class="hljs-attribute">table</span>=users <span class="hljs-attribute">usercolumn</span>=name <span class="hljs-attribute">passwdcolumn</span>=password <span class="hljs-attribute">crypt</span>=2<br>account required /usr/lib64/security/pam_mysql.so <span class="hljs-attribute">user</span>=vsftpd <span class="hljs-attribute">passwd</span>=vsftpd <span class="hljs-attribute">host</span>=127.0.0.1 <span class="hljs-attribute">db</span>=vsftpd <span class="hljs-attribute">table</span>=users <span class="hljs-attribute">usercolumn</span>=name <span class="hljs-attribute">passwdcolumn</span>=password <span class="hljs-attribute">crypt</span>=2<br></code></pre></td></tr></table></figure><p>修改主配置文件/etc/vsftpd/vsftpd.conf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pam_service_name</span>=vsftpd.vusers  <span class="hljs-comment">##这个是上一步我们创建的文件的文件名</span><br></code></pre></td></tr></table></figure><h5 id="8-4-8、重启vsftpd服务"><a href="#8-4-8、重启vsftpd服务" class="headerlink" title="8.4.8、重启vsftpd服务"></a>8.4.8、重启vsftpd服务</h5><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@CentOS</span> /]<span class="hljs-meta">#systemctl restart vsftpd</span><br></code></pre></td></tr></table></figure><h5 id="8-4-9、测试虚拟用户登录FTP"><a href="#8-4-9、测试虚拟用户登录FTP" class="headerlink" title="8.4.9、测试虚拟用户登录FTP"></a>8.4.9、测试虚拟用户登录FTP</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">C:\User\Administrator&gt;<span class="hljs-keyword">ftp</span> <span class="hljs-number">192.168</span><span class="hljs-number">.120</span><span class="hljs-number">.240</span><br>Connected <span class="hljs-built_in">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.120</span><span class="hljs-number">.240</span>.<br><span class="hljs-number">220</span> Welcome <span class="hljs-built_in">to</span> BOB FTP server<br>User (<span class="hljs-number">192.168</span><span class="hljs-number">.120</span><span class="hljs-number">.240</span>:(<span class="hljs-literal">none</span>)): bobyuan<br><span class="hljs-number">331</span> Please specify <span class="hljs-keyword">the</span> password.<br>Password:<br><span class="hljs-number">230</span> Login successful.<br><span class="hljs-keyword">ftp</span>&gt; quit<br><span class="hljs-number">221</span> Goodbye.<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/116970u/p/10788285.html">解决服务器发回了不可路由的地址。使用服务器地址代替的问题</a>             </p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FTP</tag>
      
      <tag>Linux</tag>
      
      <tag>vsftpd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2019/11/14/Maven/"/>
    <url>/2019/11/14/Maven/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Maven-一个优秀的项目构建工具"><a href="#1、Maven-一个优秀的项目构建工具" class="headerlink" title="1、Maven:一个优秀的项目构建工具"></a>1、Maven:一个优秀的项目构建工具</h3><h4 id="1-1、什么是Maven"><a href="#1-1、什么是Maven" class="headerlink" title="1.1、什么是Maven"></a>1.1、什么是Maven</h4><p>Maven的含义：**<a href="https://baike.baidu.com/item/Maven">Maven</a>**项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件<a href="https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">项目管理工具</a>。</p><p>Maven 是一个项目管理和整合工具。Maven 为开发者提供了一套完整的构建生命周期框架。开发团队几乎不用花多少时间就能够自动完成工程的基础构建配置，因为 Maven 使用了一个标准的目录结构和一个默认的构建生命周期。</p><p>在有多个开发团队环境的情况下，Maven 能够在很短的时间内使得每项工作都按照标准进行。因为大部分的工程配置操作都非常简单并且可复用，在创建报告、检查、构建和测试自动配置时，Maven 可以让开发者的工作变得更简单。</p><p><strong>Maven</strong>的优势:<strong><code>自动构建</code>,<code>jar包依赖管理</code>,<code>契约编程</code></strong></p><p><img src="/2019/11/14/Maven/story.png" alt="story"></p><blockquote><ul><li>POM：project object model 项目对象模型</li><li>DOM document object model 文档对象模型</li><li>pom.xml是maven的核心配置文件，构建过程相关的一切设置都在这个文件中配置，相当于动态web工程的web.xml文件</li></ul></blockquote><h5 id="1-1-1、自动构建"><a href="#1-1-1、自动构建" class="headerlink" title="1.1.1、自动构建"></a>1.1.1、自动构建</h5><p>使用Maven可以为我们完成很多相应的功能：清理代码，自动编译，完成测试，生成站点报告，进行打包(jar,war)，项目部署。</p><ol><li>清理代码:相当于我们运行clear的效果</li><li>自动编译:可以为咱们自动完成编译(类似于执行javac生成class文件)</li><li>完成测试:实现测试功能，帮咱们完成</li><li>生成报告:可以较为方便的实现对项目的管理</li><li>打包:普通项目打jar包，web项目打成war包</li><li>项目部署:只需要一句命令<strong>mvn jetty:run</strong>即可实现项目的部署</li></ol><p><img src="/2019/11/14/Maven/autoc.png" alt="1"></p><h5 id="1-1-2、Jar包依赖管理"><a href="#1-1-2、Jar包依赖管理" class="headerlink" title="1.1.2、Jar包依赖管理"></a>1.1.2、Jar包依赖管理</h5><p>咱们刚学过框架的集成，导包确实是一个比较痛苦的过程。特别是我们导入一个功能jar包，而它又依赖于其它的jar包【但我们怎么知道有哪些依赖包】，靠死记硬背，即花时间又没有太大的意义，而Maven完美的解决了这个问题，我们只需要导入功能包，它会为我们<strong>自动把对应的依赖包导入</strong>。</p><p>不过使用maven导包需要我们进行相应的xml配置(<strong>pom.xml</strong>),好吧，对初学者来说这个xml配置看起来也确实是比较麻烦，不过大家不用担心。等你学了Maven的仓库，一切都会变得easy起来。</p><h5 id="1-1-3、契约编程"><a href="#1-1-3、契约编程" class="headerlink" title="1.1.3、契约编程"></a>1.1.3、契约编程</h5><p>约定好项目的基本结构。咱们使用Maven，项目的结构就必需是Maven要求的结构，刚开始使用这种结构确实让人很别扭，但是，这种契约编程却让代码结构有<strong>统一的规范</strong>,让多人(多团队)开发变得更加的简单。</p><p><img src="/2019/11/14/Maven/tools.png" alt="1"></p><h4 id="1-2、Maven的安装与配置"><a href="#1-2、Maven的安装与配置" class="headerlink" title="1.2、Maven的安装与配置"></a>1.2、Maven的安装与配置</h4><p>Maven是一个基于Java的工具，所以第一件事就是安装JDK。</p><h5 id="1-2-1、安装JDK，已经安装可跳过！"><a href="#1-2-1、安装JDK，已经安装可跳过！" class="headerlink" title="1.2.1、安装JDK，已经安装可跳过！"></a>1.2.1、安装JDK，已经安装可跳过！</h5><p>JDK下载地址: <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>配置环境变量：</p><p>JAVA_HOME</p><p>Path+=%JAVA_HOME%\bin</p><p>测试：cmd&lt;java -version</p><h5 id="1-2-2、安装Maven"><a href="#1-2-2、安装Maven" class="headerlink" title="1.2.2、安装Maven"></a>1.2.2、安装Maven</h5><p>从网上下载 Maven：<strong><a href="http://maven.apache.org/download.html">http://maven.apache.org/download.html</a></strong></p><p>解压安装、配置环境变量</p><p>测试：mvn -v</p><p>mvn会在当前路径寻找src和pom.xml</p><p>自动生成两个文件夹：C:\Users\Administrator.m2\repository 本地仓库目录  </p><h5 id="1-2-3、配置本地仓库"><a href="#1-2-3、配置本地仓库" class="headerlink" title="1.2.3、配置本地仓库"></a>1.2.3、配置本地仓库</h5><p>Maven会自动为我们添加相应的jar包，而这个jar包会先在<strong>本地仓库</strong>中查找，如果本地仓库中找不到，则会在中央仓库（网络上）去进行下载。</p><p>注意：最好将本地仓库配置在非系统盘。</p><p>本地的默认仓库在C盘（系统盘）中，<strong>用户家目录的.m2目录下</strong>。</p><h6 id="第一步：移动settings-xml文件"><a href="#第一步：移动settings-xml文件" class="headerlink" title="第一步：移动settings.xml文件"></a><strong>第一步：移动settings.xml文件</strong></h6><p><strong>全局的配置文件：</strong>找到你的Maven安装路径，进入MAVEN_HOME/conf/settings.xml</p><p><strong>用户的配置文件：</strong>用户根路径C:\Users\Administrator/.m2/settings.xml 单个用户的,修改</p><p>修改settings.xml文件，将中央仓库切换为阿里远程仓库</p><blockquote><p>中央仓库:Maven的默认的远程仓库(<a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a>)</p><p>私服:是一种特殊的远程仓库，它是架设在局域网内的仓库</p><p>镜像：用来替代中央仓库，速度一般比中央仓库快(百度 csdn，oschina,<strong>阿里云</strong>)</p></blockquote><p>在maven的settings.xml文件里的mirrors结点，添加如下子节点：（两个settings.xml文件都要修改）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/14/Maven/settings.png" alt="1"></p><h6 id="第二步：准备好本地仓库"><a href="#第二步：准备好本地仓库" class="headerlink" title="第二步：准备好本地仓库"></a>第二步：准备好本地仓库</h6><p>创建一个文件夹作为本地仓库，如：D:\Program Files\apache-maven-3.6.1\repo</p><p><img src="/2019/11/14/Maven/repo.png" alt="1"></p><h6 id="第三步：配置文件中设置路径到本地仓库"><a href="#第三步：配置文件中设置路径到本地仓库" class="headerlink" title="第三步：配置文件中设置路径到本地仓库"></a>第三步：配置文件中设置路径到本地仓库</h6><p>settings.xml文件中：</p><p>增加<localRepository>D:/OpenSource/repository</localRepository>，如图所示：</p><p><img src="/2019/11/14/Maven/repo1.png" alt="1"></p><p><img src="/2019/11/14/Maven/repo2.png" alt="1"></p><h4 id="1-3、Maven常用命令"><a href="#1-3、Maven常用命令" class="headerlink" title="1.3、Maven常用命令"></a>1.3、Maven常用命令</h4><h5 id="1-3-1、测试Maven常用命令（重点）"><a href="#1-3-1、测试Maven常用命令（重点）" class="headerlink" title="1.3.1、测试Maven常用命令（重点）"></a>1.3.1、测试Maven常用命令（重点）</h5><p>注：前面几步只是环境搭建，命令才是我们需要掌握的重点</p><p>CMD进入工程目录pom.xml同级一层目录，有编译、测试、打包。。。</p><blockquote><ol><li>   编译主程序：执行 mvn compile命令，查看根目录变化</li><li>   编译测试程序：执行mvn test-compile</li><li>   清理：mvn clean命令，然后再次查看根目录变化</li><li>   mvn clean compile命令, 查看根目录变化</li><li>   mvn clean test命令，查看根目录变化</li><li>   打包：mvn clean package命令,查看根目录变化</li><li>   mvn source:jar命令,查看根目录变化,源码包</li><li>   生成站点：mvn clean site命令,查看根目录变化</li><li>   安装：mvn install命令,查看本地仓库变化，将自己的mvn安装到仓库，解决以来某些依赖问题</li><li>   生成Eclipse的需要2个文件mvn eclipse:eclipse</li><li>   maven打包不执行测试用例的命令mvn package -D maven.test.skip=true</li></ol></blockquote><h4 id="1-4、Maven导包"><a href="#1-4、Maven导包" class="headerlink" title="1.4、Maven导包"></a>1.4、Maven导包</h4><h5 id="1-4-1、认识pom-xml的基本配置（重点）"><a href="#1-4-1、认识pom-xml的基本配置（重点）" class="headerlink" title="1.4.1、认识pom.xml的基本配置（重点）"></a>1.4.1、认识pom.xml的基本配置（重点）</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 组id：包名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.itsource.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 模块名：和工程名一致 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 版本号 --&gt;</span><br>SNAPSHOT快照，不稳定，随时都在修改bug<br>RELEASE 释放，稳定版本<br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 项目名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-comment">&lt;!-- jar文件依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只能在测试里面使用src/test/java --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-4-2、（依赖）修改pom-xml的导包配置"><a href="#1-4-2、（依赖）修改pom-xml的导包配置" class="headerlink" title="1.4.2、（依赖）修改pom.xml的导包配置"></a>1.4.2、（依赖）修改pom.xml的导包配置</h5><p>maven解析依赖信息时会到本地仓库中查找被以来的jar包，有时自己编写的jar并未安装在本地仓库中</p><p>mvn install 将自己的mvn安装到仓库，解决以来某些依赖问题</p><pre><code>依赖范围：&lt;scope&gt;compile|test|provided&lt;/scope&gt;    compile:典型的有spring-core:【主程序[yes]、测试程序[yes]、参与打包[yes]、开发[yes]、参与部署[yes]、运行[yes]】    test:以juint为例：test范围，测试范围对主程序无用 【主程序[no]、测试程序[yes]、参与打包[no]、参与部署[no]】    provided:与compile比较：以提供的servlet-api.jar来看，开发时没有servlet环境，而部署运行时不需要提供 【参与开发[yes]、参与部署[no]、参与运行[no]】依赖的传递性：    直接依赖   和   传递依赖    可传递依赖不必在每个模块工程中都重复声明，在最 “下面” 的工程依赖一次即可    非compile范围的依赖不能传递，需要在各模块各自依赖依赖排除(小概率情况)：排除不稳定的依赖jar包，不希望加入当前工程    &lt;exclusions&gt;&lt;exclusion&gt;&lt;groupId&gt;&lt;artifactId&gt;依赖原则：解决模块工程之间的jar包冲突问题    情景一：所需依赖不同层级，路径最短优先    情景二：所需依赖同一层， 先声明的dependency优先统一管理依赖版本：    情景一：spring-*-4.0.0.*个版本spring依赖包版本都是4.0.0，如若统一升级到4.1.1        手工逐个更改        配置更改&lt;properties&gt;&lt;自定义标签名&gt;4.1.1.RELEASE&lt;/自定义标签名&gt;&lt;/properties&gt;            &lt;dependency&gt;...&lt;version&gt;$&#123;自定义标签名&#125;&lt;/version&gt;&lt;/dependency&gt;    properties并不是只能用于依赖版本控制</code></pre><p>加入导包配置（环境）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jar文件依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>加入导包配置后的jar包：确定本地仓库有相应的jar包从本地导入，否则若电脑有联网可以从中央库下载。</p><p><img src="/2019/11/14/Maven/pom.png" alt="1"></p><h5 id="1-4-3、（坐标）互联网搜索坐标（网络连接畅通）"><a href="#1-4-3、（坐标）互联网搜索坐标（网络连接畅通）" class="headerlink" title="1.4.3、（坐标）互联网搜索坐标（网络连接畅通）"></a>1.4.3、（坐标）互联网搜索坐标（网络连接畅通）</h5><p>坐标的组成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>上述，坐标与仓库定位:org/springframework/spring-orm/3.0.5.RELEASE/spring-orm-3.0.5.RELEASE.jar</p><p><strong><groupId></groupId></strong> 组id：定义当前Maven项目隶属项目,包名，一般是公司、组织名称倒叙+项目包名</p><p><strong><artifactId></artifactId></strong> 模块id：定义实际项目中的一个模块,模块名(工程名称)</p><p>**<version>**：定义当前项目的当前版本</version></p><p><strong>SNAPSHOT</strong>快照版本，就是开发版本</p><p><strong>RELEASE</strong>释放版本，正式版本，稳定 使用其他机构提供的jar文件,必须使用释放版本</p><p><strong>packaging</strong>：定义该项目的打包方式(jar/war) 默认值jar</p></blockquote><p>咱们只需要加一个包，它就会把这个包以及对应的依赖包全部导入，这确实是太棒了，但是又有同学会觉得，即便是这样，引入这一个包的xml也还是挺麻烦的。</p><p>其实，对于这个引入，也是可以直接在网上搜索：</p><p>网址：<a href="http://mvnrepository.com/">http://mvnrepository.com/</a></p><p>进入网站直接进行搜索：</p><p><img src="/2019/11/14/Maven/mvnrepo.png" alt="img"></p><p>从搜索结果中选择一个自己需要的：</p><p><img src="/2019/11/14/Maven/mvnrepo1.png" alt="img"></p><p>选择一个相应版本：</p><p><img src="/2019/11/14/Maven/mvnrepo2.png" alt="1"></p><p>将数据拷贝过来即可：</p><p><img src="/2019/11/14/Maven/mvnrepo3.png" alt="1"></p><h5 id="1-4-4、生命周期-插件-目标"><a href="#1-4-4、生命周期-插件-目标" class="headerlink" title="1.4.4、生命周期/插件/目标"></a>1.4.4、生命周期/插件/目标</h5><p>各构件环节执行顺序</p><ul><li>maven核心程序中定义抽象的生命周期，生命周期中各阶段的具体任务由插件来完成</li><li>maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中的各个阶段，不论现在要执行生命周期的哪一阶段，都是从这个生命周期的最初的位置开始执行的。</li><li>插件和目标：<pre><code>生命周期的各个阶段仅仅定义要执行的任务是什么各个阶段和插件的目标是对应的相似的目标由特定的插件来完成</code></pre></li></ul><h5 id="1-4-5、继承"><a href="#1-4-5、继承" class="headerlink" title="1.4.5、继承"></a>1.4.5、继承</h5><pre><code>现状：    hello        依赖junit4.0    helloFriend    依赖junit4.0    helloFriends    依赖junit4.9需求：统一管理各模块中对junit依赖的版本解决思路：将junit依赖统一提取到“父”工程中，在子工程声明junit依赖时不声明版本，以父工程统一设定为准    步骤：创建maven父工程，打包方式pom        --》子工程声明对父工程的引用&lt;parent&gt;&lt;groupId&gt;&lt;artifactId&gt;&lt;relativePath&gt;以当前基准的父工程的pom.xml路径        --》删除子工程坐标重复        --》父工程统一junit依赖&lt;dependencyManagement&gt;&lt;dependencies&gt;&lt;denpendency&gt;&lt;groupId&gt;&lt;artifactId&gt;&lt;version&gt;        --》删除子工程junit版本号控制</code></pre><p><img src="/2019/11/14/Maven/inh.png" alt="1"></p><h5 id="1-4-6、聚合"><a href="#1-4-6、聚合" class="headerlink" title="1.4.6、聚合"></a>1.4.6、聚合</h5><p>一键安装各个参与聚合的模块</p><p><modules><module>指定各子工程的相对路径，并且不需要考虑顺序</module><module></module>…</modules></p><h4 id="1-5、Maven的插件"><a href="#1-5、Maven的插件" class="headerlink" title="1.5、Maven的插件"></a>1.5、Maven的插件</h4><p>其实Maven的本质是一个插件框架，它的核心并不执行任何具体的构建任务，所以这些任务都是交给插件还完成的，例如编译源代码是由maven- compiler-plugin完成的。</p><p>Maven 插件通常被用来：</p><blockquote><p>1、创建 jar 文件    2、创建 war 文件    3、编译代码文件    </p><p>4、代码单元测试    5、创建工程文档    6、创建工程报告</p></blockquote><p>下面是插件代码：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> //这是一顶层标签，内容有省略</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>pss<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="xml">              <span class="hljs-comment">&lt;!-- Maven的编译插件--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="xml">               <span class="hljs-comment">&lt;!-- jetty插件--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mortbay.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.1.15.v20140411<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">webAppConfig</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">contextPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">contextPath</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">webAppConfig</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="1-6、仓库的认识"><a href="#1-6、仓库的认识" class="headerlink" title="1.6、仓库的认识"></a>1.6、仓库的认识</h4><p>在 Maven 的术语中，仓库是一个位置（place），例如目录，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。</p><p>Maven的仓库有两种:<code>本地仓库</code>与<code>远程仓库</code></p><h5 id="1-6-1、本地仓库："><a href="#1-6-1、本地仓库：" class="headerlink" title="1.6.1、本地仓库："></a>1.6.1、本地仓库：</h5><blockquote><ul><li>解释:当前电脑上部署的仓库目录，为当前电脑提供maven工程服务</li><li>默认路径:~/.m2/repository/</li><li>注:每个用户只有一个本地仓库 </li></ul></blockquote><h5 id="1-6-2、远程仓库："><a href="#1-6-2、远程仓库：" class="headerlink" title="1.6.2、远程仓库："></a>1.6.2、远程仓库：</h5><blockquote><ul><li>私服(Nexus)：局域网环境</li><li>中央仓库：Internet上，为世界maven工程服务</li><li>中央仓库的镜像：分担中央仓库的流量压力，提升访问速度</li></ul></blockquote><h5 id="1-6-3、仓库内容："><a href="#1-6-3、仓库内容：" class="headerlink" title="1.6.3、仓库内容："></a>1.6.3、仓库内容：</h5><blockquote><ul><li>maven工程</li><li>maven自身需要的插件</li><li>第三方的框架工具jar</li><li>我们自己的maven工程 mvn install 将自己的mvn安装到仓库，解决以来某些依赖问题</li></ul></blockquote><h4 id="1-7、Maven项目创建"><a href="#1-7、Maven项目创建" class="headerlink" title="1.7、Maven项目创建"></a>1.7、Maven项目创建</h4><h5 id="1-7-1、创建一个新项目"><a href="#1-7-1、创建一个新项目" class="headerlink" title="1.7.1、创建一个新项目"></a>1.7.1、创建一个新项目</h5><p><img src="/2019/11/14/Maven/new1.png" alt="1"></p><h5 id="1-7-2、选择对应的Maven项目"><a href="#1-7-2、选择对应的Maven项目" class="headerlink" title="1.7.2、选择对应的Maven项目"></a>1.7.2、选择对应的Maven项目</h5><p><img src="/2019/11/14/Maven/new2.png" alt="1"></p><h5 id="1-7-3、填写组id（GroupId）与模块id（ArtifactId）"><a href="#1-7-3、填写组id（GroupId）与模块id（ArtifactId）" class="headerlink" title="1.7.3、填写组id（GroupId）与模块id（ArtifactId）"></a>1.7.3、填写组id（GroupId）与模块id（ArtifactId）</h5><p><img src="/2019/11/14/Maven/new3.png" alt="1"></p><h5 id="1-7-4、直接创建（选择Maven仓库设置，有的IDE集成的有Maven有的是自己安装的Maven）"><a href="#1-7-4、直接创建（选择Maven仓库设置，有的IDE集成的有Maven有的是自己安装的Maven）" class="headerlink" title="1.7.4、直接创建（选择Maven仓库设置，有的IDE集成的有Maven有的是自己安装的Maven）"></a>1.7.4、直接创建（选择Maven仓库设置，有的IDE集成的有Maven有的是自己安装的Maven）</h5><p><img src="/2019/11/14/Maven/new4.png" alt="1"></p><h5 id="1-7-5、项目名与项目位置"><a href="#1-7-5、项目名与项目位置" class="headerlink" title="1.7.5、项目名与项目位置"></a>1.7.5、项目名与项目位置</h5><p>建议放在非系统盘</p><p><img src="/2019/11/14/Maven/new5.png" alt="1"></p><h5 id="1-7-6、创建成功后的目录结构"><a href="#1-7-6、创建成功后的目录结构" class="headerlink" title="1.7.6、创建成功后的目录结构"></a>1.7.6、创建成功后的目录结构</h5><p><img src="/2019/11/14/Maven/new6.png" alt="1"></p><h5 id="1-7-7、解决Maven项目目录结构不正确的问题"><a href="#1-7-7、解决Maven项目目录结构不正确的问题" class="headerlink" title="1.7.7、解决Maven项目目录结构不正确的问题"></a>1.7.7、解决Maven项目目录结构不正确的问题</h5><p>约定的目录结构：为什么要遵守约定的目录结构？</p><p>maven负责这个项目的自动化构建，以编译为例，maven要想自动进行编译，那么他必须要知道Java源文件存放位置。自定义以配置形式告知</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">hello//工程名<br>|<span class="hljs-params">---src//</span>源码<br>|<span class="hljs-params">---</span>|<span class="hljs-params">---main//</span>存放主程序<br>|<span class="hljs-params">---</span>|<span class="hljs-params">---</span>|<span class="hljs-params">---java//</span>存放java源文件<br>|<span class="hljs-params">---</span>|<span class="hljs-params">---</span>|<span class="hljs-params">---resources//</span>存放框架或其它工具的配置文件<br>|<span class="hljs-params">---</span>|<span class="hljs-params">---test//</span>存放测试程序<br>|<span class="hljs-params">---</span>|<span class="hljs-params">---</span>|<span class="hljs-params">---java</span><br>|<span class="hljs-params">---</span>|<span class="hljs-params">---</span>|<span class="hljs-params">---resources</span><br>|<span class="hljs-params">---pom</span>.xml/<span class="hljs-string">/maven</span>工程的核心配置文件<br></code></pre></td></tr></table></figure><p>在使用IDEA创建maven-archetype-webapp项目的时候，我们会发现main文件夹下少了一个java资源文件夹，那么，我们接下来就说一下它的解决方案：</p><p><img src="/2019/11/14/Maven/new7.png" alt="1"></p><p>第一步：选择File-&gt;Project Structure…</p><p><img src="/2019/11/14/Maven/new8.png" alt="1"></p><p>第二步：选择Modules选项卡下面的Sources项，在main文件夹上右键，选择New Folder…并点击OK ,</p><p>输入要创建的文件夹名称确认创建，</p><p>选择创建的文件夹鼠标右键，</p><p>根据目的选择Sources（源文件）、Tests（测试文件）和Resources（资源文件）等。</p><p><img src="/2019/11/14/Maven/new9.png" alt="1"></p><p>设置完成后的目录结构：</p><p><img src="/2019/11/14/Maven/new10.png" alt="1"></p><h5 id="1-7-8、解决创建项目的JDK版本问题"><a href="#1-7-8、解决创建项目的JDK版本问题" class="headerlink" title="1.7.8、解决创建项目的JDK版本问题"></a>1.7.8、解决创建项目的JDK版本问题</h5><p>这个问题在有的idea中会出现，就是创建好项目后，jdk的版本对应不上，那么解决方案有两个:</p><h6 id="方案一-指定maven的配置文件（一劳永逸-建议使用）"><a href="#方案一-指定maven的配置文件（一劳永逸-建议使用）" class="headerlink" title="方案一:指定maven的配置文件（一劳永逸,建议使用）"></a>方案一:指定maven的配置文件（一劳永逸,建议使用）</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">直接修改maven的setting.xml文件<br>在里面添加如下内容：<br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>                             <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span> <br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/2019/11/14/Maven/new11.png" alt="1"></p><h6 id="方案二-针对maven-项目的-pom-文件制定jdk"><a href="#方案二-针对maven-项目的-pom-文件制定jdk" class="headerlink" title="方案二:针对maven 项目的 pom 文件制定jdk"></a>方案二:针对maven 项目的 pom 文件制定jdk</h6><p>摘自网络:<a href="http://blog.csdn.net/geekun/article/details/51325510">http://blog.csdn.net/geekun/article/details/51325510</a></p><p>在<strong>IntelliJ IDEA 15</strong>中使用Maven时，IDEA将默认的编译版本、源码版本设置为jdk5。编译项目的时候出现警告：”Warning:java: 源值1.5已过时, 将在未来所有发行版中删除”，并且无法编译jdk1.5以上的代码。</p><p>出现这样的原因应该是Maven插件的默认配置有问题。解决方法是在”pom.xml”里加入如下代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;properties&gt;</span><br>    &lt;maven.<span class="hljs-keyword">compiler</span>.<span class="hljs-keyword">source</span>&gt;<span class="hljs-number">1.8</span>&lt;/maven.<span class="hljs-keyword">compiler</span>.<span class="hljs-keyword">source</span>&gt;<br>&lt;maven.<span class="hljs-keyword">compiler</span>.target&gt;<span class="hljs-number">1.8</span>&lt;/maven.<span class="hljs-keyword">compiler</span>.target&gt;<br>&lt;/properties&gt;<br></code></pre></td></tr></table></figure><p>然后按”Ctrl+Shift+Alt+S”打开项目配置，设置Modules的Language Level为”8”：</p><p><img src="/2019/11/14/Maven/new12.png" alt="1"></p><p>最后按”Ctrl+Alt+S”打开设置，搜索”Java Compiler”，将默认jdk和当前modual的jdk版本切换为1.8即可：</p><p><img src="/2019/11/14/Maven/new13.png" alt="1">   </p><p>写段JDK8的代码，运行测试一下是否正常：</p><p>注：alt+Enter组合快捷键可以导包</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">list</span> = Arrays.asList(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World!&quot;</span>);<br>        <span class="hljs-built_in">list</span>.stream().forEach(System.out::<span class="hljs-built_in">println</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-7-9、Tomcat中运行Maven项目"><a href="#1-7-9、Tomcat中运行Maven项目" class="headerlink" title="1.7.9、Tomcat中运行Maven项目"></a>1.7.9、Tomcat中运行Maven项目</h5><h6 id="1、Run-gt-Edit-Configurations"><a href="#1、Run-gt-Edit-Configurations" class="headerlink" title="1、Run-&gt;Edit Configurations"></a>1、Run-&gt;Edit Configurations</h6><p><img src="/2019/11/14/Maven/new14.png" alt="1"></p><h6 id="2、填写Tomcat-Server配置名称"><a href="#2、填写Tomcat-Server配置名称" class="headerlink" title="2、填写Tomcat Server配置名称"></a>2、填写Tomcat Server配置名称</h6><p><img src="/2019/11/14/Maven/new15.png" alt="1"></p><h6 id="3、点击deployMent选项卡下的-号，把要发布的项目添加进去"><a href="#3、点击deployMent选项卡下的-号，把要发布的项目添加进去" class="headerlink" title="3、点击deployMent选项卡下的+号，把要发布的项目添加进去"></a>3、点击deployMent选项卡下的+号，把要发布的项目添加进去</h6><p><img src="/2019/11/14/Maven/new16.png" alt="1"></p><p><img src="/2019/11/14/Maven/new17.png" alt="1"></p><h6 id="4、到这我们已经配置完成了，在右上角选择刚刚配置完成的运行项，点击运行即可"><a href="#4、到这我们已经配置完成了，在右上角选择刚刚配置完成的运行项，点击运行即可" class="headerlink" title="4、到这我们已经配置完成了，在右上角选择刚刚配置完成的运行项，点击运行即可"></a>4、到这我们已经配置完成了，在右上角选择刚刚配置完成的运行项，点击运行即可</h6><p><img src="/2019/11/14/Maven/new18.png" alt="1"></p><p><img src="/2019/11/14/Maven/new19.png" alt="1"></p><h4 id="1-8、注意事项"><a href="#1-8、注意事项" class="headerlink" title="1.8、注意事项"></a>1.8、注意事项</h4><p>1、maven的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须由特定的插件完成。<br>插件本身并不包含在maven的核心程序中。<br>2、当我们执行maven命令需要用到某些插件时，maven核心程序首先到本地仓库中查找。<br>3、本地仓库的【默认】位置：家目录.m2\repository<br>4、maven找不到的插件，自动连接外网到中央仓库下载<br>5、无网络连接会导致构建失败<br>6、修改默认本地仓库的位置到事先准备好的目录下查找插件<br>    修改maven\conf\setting.xml  <localRepository>标签 内容改为目的目录</localRepository></p><h4 id="1-9、Eclipse中使用Maven"><a href="#1-9、Eclipse中使用Maven" class="headerlink" title="1.9、Eclipse中使用Maven"></a>1.9、Eclipse中使用Maven</h4><pre><code>已经内置maven不许安装maven插件设置：一般内置的有一个完整的maven核心程序，但鉴于稳定性欠佳一般不用这个内置的，而是添加    使用外部安装的maven核心程序。window-》preference-》maven-》installation-》addwindow-》preference-》maven-》user setting指定conf/settings.xml 进而获取本地仓库目录基本操作：创建maven版Java程序、创建maven版web程序、执行maven命令    file-&gt;new-&gt;maven project-&gt;create a simple project-&gt;...-&gt;finish    maven命令执行 pom.xml鼠标右run as &#123;build|clean|install|...&#125;maven中compile范围的jsp-api.jar与tomcat中jsp-api.jar冲突maven项目导入eclipse，依靠pom.xml识别maven工程，【导入之后同时会创建eclipse工程识别项】</code></pre>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常处理</title>
    <link href="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><p>​         一般来说发生异常之后，会终止之前本应该执行的流程  </p><h4 id="1、什么是Java中的异常"><a href="#1、什么是Java中的异常" class="headerlink" title="1、什么是Java中的异常"></a>1、什么是Java中的异常</h4><p>① Java代码在 <strong>编译</strong> 或 <strong>运行时期</strong> 发生的错误就是异常。  </p><p>② 也可以看成是导致程序终止的一种错误指令流（一旦发生可能会终止程序）</p><p>③ <strong>Exception类：</strong>Java把异常信息封装成了一个类，用来表示Java程序中可能会产生的异常，<strong>创建异常类对象抛出异常相关的信息</strong>（如异常出现的<strong>位置</strong>、<strong>类型</strong>和<strong>原因</strong>等），并要求对产生的异常进行合理的异常处理。</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/Exception.png" alt="1"></p><p>④ <strong>Throwable</strong>是Java 语言中所有错误或异常的超类，即<strong>祖宗类</strong>。  </p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/Throwable.png" alt="1"></p><p>另外，在异常Exception类中，有一个子类要特殊说明一下，<strong>RuntimeException</strong>子类，RuntimeException及它的子类只能在<strong>Java程序运行过程中出现</strong>。</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/Error.png" alt="1"></p><p><strong>与异常Exception平级的有一个Error</strong>，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误<strong>（不应该被捕获的严重问题）</strong>。解决办法只有一个，修改代码避免Error错误的产生。</p><h4 id="2、最近我们遇到过的异常"><a href="#2、最近我们遇到过的异常" class="headerlink" title="2、最近我们遇到过的异常"></a>2、最近我们遇到过的异常</h4><h5 id="①-数组越界-ArrayIndexOutOfBoundsException"><a href="#①-数组越界-ArrayIndexOutOfBoundsException" class="headerlink" title="① 数组越界: ArrayIndexOutOfBoundsException"></a>① 数组越界: <strong>ArrayIndexOutOfBoundsException</strong></h5><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/AIOB.png" alt="aiob"></p><h5 id="②-除数为0-ArithmeticException-by-zero"><a href="#②-除数为0-ArithmeticException-by-zero" class="headerlink" title="② 除数为0: **ArithmeticException: / by zero  **"></a>② 除数为0: **ArithmeticException: / by zero  **</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span><span class="hljs-operator"> / </span><span class="hljs-number">0</span>;<br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br>at cn.kongwei_liao.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExceptionDemo</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExceptionDemo</span>.</span></span>java:<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>一旦发生了异常，就终止了jvm的运行，除数为0，出现了异常，jvm终止了运行。下面输出”end”就没有运行了。</p><h5 id="③-空指针异常-NullPointerException"><a href="#③-空指针异常-NullPointerException" class="headerlink" title="③ 空指针异常: NullPointerException"></a>③ 空指针异常: <strong>NullPointerException</strong></h5><h5 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h5><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/throwable1.png" alt="1"></p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/Exception1.png" alt="1"></p><p><strong>小结：</strong></p><p>1、一般来说一个异常类就表示一种异常情况，Java中定义了很多异常类表示很多的异常情况。</p><p>2、在实际开发中异常情况有很多，Java不可能把所有的异常情况都列出来，所以我们可以自定义异常类来处理我们自己关心的异常。</p><p>3、处理异常目的：</p><ol><li><p>给用户有良好的反馈</p></li><li><p>不能让异常影响程序下面正常的运行</p></li></ol><p>4、出现异常时，异常被一层一层向上抛出，最终抛给JVM，但是一般不要抛给JVM，而是应该在某一层被<strong>异常处理程序</strong>处理掉。</p><h4 id="3、异常的处理方式"><a href="#3、异常的处理方式" class="headerlink" title="3、异常的处理方式"></a>3、异常的处理方式</h4><p>程序出现了异常，我们需要处理，保证功能能顺利完成。怎么处理？<strong>有两种方式</strong></p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/liangzhong.png" alt="1"></p><p>看下面一张截图：</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/exception.jpg" alt="ex"></p><p>分析：</p><p>1、本希望第一句和第三句都正常执行，但是： 在第二句遇到了异常，程序就终止了</p><p>2、为什么程序就终止了呢？</p><p>第10行产生一个异常对象，我们没有做任何的处理，被交由JVM处理的。JVM的处理方式就是把异常信息打印到控制台，并且退出JVM。</p><p>3、如何使第二句出现异常后，不退出JVM？把出现异常的原因记录起来或者打印出来，方便开发者定位问题，然后继续运行第三句代码。</p><p>4、我们可以catch它，然后根据catch到的异常做对应的异常处理，这样便不必退出JVM。</p><p>例如，计算器，发现除数为0后，按照正常情况下，应该终止计算器，关闭它。但是没有，人家处理了，你还可以继续运算。因为计算器自己处理了这个异常。</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/clip_image001.png" alt="img"></p><h5 id="方式一：try-catch-finally结构处理异常"><a href="#方式一：try-catch-finally结构处理异常" class="headerlink" title="方式一：try-catch-finally结构处理异常"></a>方式一：try-catch-finally结构处理异常</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs awk">try&#123;<br><span class="hljs-regexp">//</span> 写可能出现异常的代码，可以有很多句代码<br><br><span class="hljs-regexp">//</span>throw new Exception();<br><span class="hljs-regexp">//</span>产生异常，直接捕获处理，throw后不能再有语句，语句不可达，编译器拒绝编译<br>&#125;catch(异常类型 变量名)&#123;<br><span class="hljs-regexp">//</span> 处理异常，并不是把上面的代码改正确。<br><span class="hljs-regexp">//</span> 常见的一些方式：<br><span class="hljs-regexp">//</span> ①打印异常的信息到控制台；<br><span class="hljs-regexp">//</span>处理方式<span class="hljs-number">1</span> ：异常原因  一般处理后给前台页面返回，给用户提示问题原因 <br>String message = e.getMessage();<br>System.out.println(message);<br><br><span class="hljs-regexp">//</span>处理方式<span class="hljs-number">2</span> ：异常类型和异常原因<br>String str = e.toString();<br>System.out.println(str);<br><br><span class="hljs-regexp">//</span>处理方式<span class="hljs-number">3</span>：打印日志 推荐 给程序员看的<br>e.printStackTrace(); <br><br><span class="hljs-regexp">//</span>② 可以把异常信息保存到一个文件中，可以持久的存储起来；<br><span class="hljs-regexp">//</span> 因为实际项目有可能有很多异常打印到控制台，不能随时关注，这时就需要将日志保存。<br><br><span class="hljs-regexp">//</span>③ 可以抓住之后，向外在抛出另外的一个异常（了解），就是谁调用谁处理。<br>&#125;finally&#123;<br><span class="hljs-regexp">//</span>不论有无异常一定会被执行的语句；<br><span class="hljs-regexp">//</span>这里一般放：关闭流或者释放资源的代码<br><br><span class="hljs-regexp">//</span>在return之前执行，但是return的还是执行finally块之前的内容；<br><span class="hljs-regexp">//</span>此处不应该放任何的业务代码，尤其是返回一个数据（很多面试题里可能会方法）<br><br><span class="hljs-regexp">//</span>不管上面是否有异常产生，这里的代码都会执行（除非前面有执行退出JVM的代码如System.<span class="hljs-keyword">exit</span>()）<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/clip_image002.jpg" alt="img"></p><h5 id="获得异常信息的方式"><a href="#获得异常信息的方式" class="headerlink" title="获得异常信息的方式"></a>获得异常信息的方式</h5><p>在API中随意查看一个异常类，比如ArithmeticException或者在eclipse中查看源码，发现<strong>异常类中基本上全是构造方法，所有的方法都在超类Throwable中。</strong></p><p>也就是说，有关我们的代码出现了异常，这些所有的异常信息都被封装到Throwable中，我们去Throwable中找对应的方法，看源码(api)发现：</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/throwable1.png" alt="1"></p><h6 id="①-在Throwable类中定义了一个字段：-保存异常描述信息"><a href="#①-在Throwable类中定义了一个字段：-保存异常描述信息" class="headerlink" title="① 在Throwable类中定义了一个字段： 保存异常描述信息"></a>① 在Throwable类中定义了一个字段： 保存异常描述信息</h6><p>通过<strong>ArithmeticException</strong>源码<strong>一直跟踪super方法</strong>，直到异常的顶层<strong>Throwable类</strong>发现一个<strong>detailMessage字段</strong>，这个字段来存储异常信息。</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/detailMessage.png" alt="1"></p><h6 id="②-在Throwable父类中定义了多个方法用来获得对象中的异常描述信息"><a href="#②-在Throwable父类中定义了多个方法用来获得对象中的异常描述信息" class="headerlink" title="② 在Throwable父类中定义了多个方法用来获得对象中的异常描述信息"></a>② 在Throwable父类中定义了多个方法用来获得对象中的异常描述信息</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">String</span> getMessage()  返回此 <span class="hljs-built_in">throwable</span> 的详细消息字符串 <br><span class="hljs-keyword">String</span> toString() 返回此 <span class="hljs-built_in">throwable</span> 的简短描述 <br><span class="hljs-keyword">void</span> printStackTrace() 调用此方法会把完整异常信息打印到控制台<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">try &#123;<br><span class="hljs-attribute">System.out.println(1 / 0);</span><br><span class="hljs-attribute">&#125; catch (ArithmeticException e) &#123;</span><br><span class="hljs-attribute">System.out.println(e.getMessage());//返回此 throwable 的详细消息字符串</span>: by zero<br>System<span class="hljs-variable">.out</span><span class="hljs-variable">.println</span>(e<span class="hljs-variable">.toString</span>());//返回此 <span class="hljs-attribute">throwable 的简短描述</span>:java<span class="hljs-variable">.lang</span><span class="hljs-variable">.ArithmeticException</span>: / by zero<br>e<span class="hljs-variable">.printStackTrace</span>();//将此 <span class="hljs-attribute">throwable 及其追踪输出至标准错误流</span>:<br>/**<br> * java<span class="hljs-variable">.lang</span><span class="hljs-variable">.ArithmeticException</span>: / by zero at cn<span class="hljs-variable">.itsource</span><span class="hljs-variable">.wrapper</span><span class="hljs-variable">.Test</span><span class="hljs-variable">.main</span>(Test<span class="hljs-variable">.java</span>:7)<br> */<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="我们在开发中一般怎么用异常信息呢？"><a href="#我们在开发中一般怎么用异常信息呢？" class="headerlink" title="我们在开发中一般怎么用异常信息呢？"></a>我们在开发中一般怎么用异常信息呢？</h5><p>错误信息越详细越好，帮助我们快速定位和解决问题。</p><p>当然也要考虑容量问题。假如打印过多的信息，会占用服务器资源和影响执行效率(开发遇坑，导致性能很低下。)</p><p>一般使用：e.printStackTrace();但是会把这个信息<strong>单独记录在其他位置</strong>，方便维护。<strong>具体看自己公司的架构而定。</strong></p><h5 id="多异常处理以及执行流程分析"><a href="#多异常处理以及执行流程分析" class="headerlink" title="多异常处理以及执行流程分析"></a>多异常处理以及执行流程分析</h5><h6 id="①：什么是多异常？"><a href="#①：什么是多异常？" class="headerlink" title="①：什么是多异常？"></a>①：什么是多异常？</h6><p>就是说我们写一个功能代码，里面可能出现<strong>多种类型的异常</strong>。就要多异常。我们怎么处理呢？</p><h6 id="②：多异常的处理"><a href="#②：多异常的处理" class="headerlink" title="②：多异常的处理"></a>②：多异常的处理</h6><p><strong>A、笼统：可以写一个大的（父类）异常来捕获异常，就是用Exception。</strong></p><p>但是这样不好，要被扣工资的，你自己写的代码都知不道可能会出现什么问题，以后维护、交接或者测试的时候就不能尽量的避免已知的问题。</p><p>上句言外之意就是：提前告知测试人员或者同事：注意哈！我这里可能出问题哦，我也不晓得除啥子问题，反正呢，这个地方你注意点就是了，除了问题不要来找我，我是提前给你说了的哈（推卸责任，不负责）；</p><p>所以在负责任的情况下应尽量告知他人此处可能出现的<strong>具体何种异常</strong>，不应笼统。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//举例如下：定义个除法，计算两个参数的熵。<br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(div(&quot;2&quot;, &quot;0&quot;));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(div(&quot;a&quot;, &quot;0&quot;));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(div(&quot;10&quot;, &quot;2&quot;));<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算两个整数的商的方法 String ---》 int / Integer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> div(String a, String b) &#123;<br><span class="hljs-type">Integer</span> ret = <span class="hljs-number">0</span>;<br>try &#123;<br><span class="hljs-type">Integer</span> i1 = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(a);<br><span class="hljs-type">Integer</span> i2 = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(b);<br>ret = i1 / i2;<br>&#125; catch (<span class="hljs-keyword">Exception</span> e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/clip_image003.jpg" alt="img"></p><p><strong>B、尽量细化异常，一层一层的catch。</strong></p><p>只有当你不能明确知道自己的代码会出现什么异常，万不得已情况下才使用一个最大的Exception来捕获异常。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//举例如下：定义个除法，计算两个参数的熵。</span><br><span class="hljs-comment">//main方法省略，具体见之前的例子</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">int</span> div(<span class="hljs-keyword">String</span> a, <span class="hljs-keyword">String</span> b) &#123;<br><span class="hljs-keyword">Integer</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">Integer</span> i1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Integer</span>(a);<br><span class="hljs-keyword">Integer</span> i2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Integer</span>(b);<br>ret = i1 / i2;<br>&#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>e.printStackTrace();<br>System.out.println(<span class="hljs-string">&quot;数字解析错误&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>e.printStackTrace();<br>System.out.println(<span class="hljs-string">&quot;亲，除数不能为0哦&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> e) &#123;<br>e.printStackTrace();<br>System.out.println(<span class="hljs-string">&quot;未知错误！&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/clip_image004.jpg" alt="img"></p><h6 id="多异常处理分析总结如下"><a href="#多异常处理分析总结如下" class="headerlink" title="多异常处理分析总结如下"></a>多异常处理分析总结如下</h6><p>1、多异常处理的结构，可以有多个catch;</p><p>2、多个catch中的异常类型，子类放在前面，父类在后面</p><p>3、一旦try中产生了一个异常对象，立即就会从第一个catch开始匹配，一旦被抓住就执行catch中的代码，然后整个try-catch块就结束</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">/*<br>catch细化规则：<br>要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，平级之间没有顺序关系。<br>*/<br>try&#123;<br>throw new Exception();<span class="hljs-regexp">//</span>产生异常，直接捕获处理<br><span class="hljs-regexp">//</span>throw后不能再有语句，语句不可达，编译器拒绝编译<br>&#125;catch(XxxException e)&#123;<span class="hljs-regexp">//</span>子<br><span class="hljs-regexp">//</span>处理方式<br>&#125;catch(YyyException e)&#123;<span class="hljs-regexp">//</span>父<br><span class="hljs-regexp">//</span>处理方式<br>&#125;catch(ZzzException e)&#123;<span class="hljs-regexp">//</span>祖<br><span class="hljs-regexp">//</span>处理方式<br>&#125;<br></code></pre></td></tr></table></figure><p>4、如果所有的catch都抓不住，可能就相当于我们没有处理到，又可能由JVM处理</p><h5 id="finally结构"><a href="#finally结构" class="headerlink" title="finally结构"></a>finally结构</h5><p>finally这个里面的代码，表示无论如何，都要执行，除非**System.exit()**退出JVM  </p><p>实例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//main方法省略，具体见之前的例子<br><span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> div(String a, String b) &#123;<br><span class="hljs-type">Integer</span> ret = <span class="hljs-number">0</span>;<br>try &#123;<br><span class="hljs-type">Integer</span> i1 = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(a);<br><span class="hljs-type">Integer</span> i2 = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(b);<br>ret = i1 / i2;<br>&#125; catch (NumberFormatException e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;数字解析错误&quot;);<br>&#125; catch (ArithmeticException e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;亲，除数不能为0哦&quot;);<br>&#125; catch (<span class="hljs-keyword">Exception</span> e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;未知错误！&quot;);<br>&#125;finally&#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;我是Finally:&quot;+&quot;a=&quot;+a+&quot;;b=&quot;+b);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/clip_image005.jpg" alt="img"></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">try</span><span class="hljs-meta">&#123;...&#125;</span>catch(异常类型 e)<span class="hljs-meta">&#123;...&#125;</span><span class="hljs-keyword">finally</span><span class="hljs-meta">&#123;...&#125;</span><br><br>或者（有时候为了释放某些资源（例如锁），但必须保证异常往上层抛出，可以采用）<br><span class="hljs-keyword">try</span><span class="hljs-meta">&#123;...&#125;</span><span class="hljs-keyword">finally</span><span class="hljs-meta">&#123;...//释放锁操作&#125;</span><br></code></pre></td></tr></table></figure><h5 id="方式二：Throws向上层抛出异常"><a href="#方式二：Throws向上层抛出异常" class="headerlink" title="方式二：Throws向上层抛出异常"></a>方式二：Throws向上层抛出异常</h5><p>当我们有些异常自己处理不了，或者不方便处理，或者其他原因，我们就把异常抛出去，<strong>抛给方法的调用者处理</strong>。</p><p>调用者调用一个会向外抛异常的函数时，需要对该函数进行异常处理（继续向上抛出或者try-catch处理）。</p><p>目前，大家能处理的异常就处理，尽量不要抛。  </p><p>关键字：throws</p><p>语法：在方法上，<strong>“{”前写关键字throws</strong> ，后面写异常类，**可以同时抛多种异常类(用,分隔)**。  </p><p>实例：</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/clip_image006.jpg" alt="img"></p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/clip_image007.jpg" alt="img"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//main方法省略，详见之前案例</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">int</span> div(<span class="hljs-keyword">String</span> a, <span class="hljs-keyword">String</span> b) throws NumberFormatException, ArithmeticException&#123;<br><span class="hljs-comment">//方法内部不提供异常处理，而是将异常向外抛出</span><br><span class="hljs-keyword">Integer</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">Integer</span> i1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Integer</span>(a);<br><span class="hljs-keyword">Integer</span> i2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Integer</span>(b);<br>ret = i1 / i2;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、异常的分类"><a href="#4、异常的分类" class="headerlink" title="4、异常的分类"></a>4、异常的分类</h4><h5 id="①-运行时异常：-RuntimeException以及它的所有的子类"><a href="#①-运行时异常：-RuntimeException以及它的所有的子类" class="headerlink" title="① 运行时异常： RuntimeException以及它的所有的子类"></a>① 运行时异常： RuntimeException以及它的所有的子类</h5><p>方法中抛出运行时期异常，方法定义中无throws声明，调用者也无异常处理运行时期异常（调用者可以用try进行运行时异常处理）一旦发生,需要程序人员修改源代码.</p><p>在代码编译的时候不会提示错误，比如我们常见的NullPointerException，ArrayIndexOutOfBoundsException等  </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-keyword">null</span>;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">str</span>.length());<span class="hljs-comment">//编译的时候，不会报错，运行后就会报错。因为str没有创建对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="②-非运行时异常-：-Exception以及它的所有子类除去RuntimeException体系的其它异常"><a href="#②-非运行时异常-：-Exception以及它的所有子类除去RuntimeException体系的其它异常" class="headerlink" title="② 非运行时异常 ： Exception以及它的所有子类除去RuntimeException体系的其它异常"></a>② 非运行时异常 ： Exception以及它的所有子类除去RuntimeException体系的其它异常</h5><p>此类异常在编译时期必须处理  ；</p><p>在IDE编译的时候<strong>会有提示</strong>： 要么try处理，要么throws向外抛出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat();<br><span class="hljs-keyword">try</span> &#123;<br>sdf.parse(<span class="hljs-string">&quot;2017-04-24&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：不要太过意的记住哪些是运行时哪些时非运行时异常，在写的时候，如果是非运行时异常，会有错误提示(红色)对异常的处理。</p><h4 id="5、自定义异常"><a href="#5、自定义异常" class="headerlink" title="5、自定义异常"></a>5、自定义异常</h4><p>我们见到的上面提到的异常是Java列出的常见的，而实际开发中还有更多更多的异常情况，java中不可能有所有情况的异常；</p><p>有的时候不能满足我们的需要，此时我们可以继承Exception类，实现自定义异常。</p><h5 id="自定义异常的流程-amp-自定义异常的语法："><a href="#自定义异常的流程-amp-自定义异常的语法：" class="headerlink" title="自定义异常的流程&amp;自定义异常的语法："></a>自定义异常的流程&amp;自定义异常的语法：</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//继承其它异常，编写自定义异常</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">异常类名</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br><span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = 自动生成;<span class="hljs-comment">//用于序列化</span><br>写两个构造（自动生成）<br>无参构造<br>有参构造<br>&#125;<br></code></pre></td></tr></table></figure><p>1、自定义一个异常类</p><p>例如： <strong>Java中设计好的</strong>一个异常类 NumberFormatException</p><p>2、设计一段代码（方法），这里面就会产生上面的一个异常对象</p><p>例如：Java中在写Integer的构造方法的时候，其内部就会创建一个异常对象并向外抛出</p><p>3、有人调用上面的方法，然后对异常进行处理</p><p>例如： 我们自己在调用构造方法创建对象</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">try&#123;<br><span class="hljs-type">Integer</span> i = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(&quot;abc&quot;);<br>&#125;catch(NumberFormatException e)&#123;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(“出异常了”);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><p>我们需要做上面的3件事情</p><p>1、自定义一个异常类MultipleException：假设当我们用户注册的时候，如果用户名已经存在了</p><p>语法：</p><p>① 自定义一个类    ② 继承 <strong>Exception</strong> 或者 <strong>RuntimeException</strong>    </p><p>③ 提供一个公共无参数的构造方法和一个String参数的构造方法（比如参考：NumberFormatException）</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/NumberFormatException.png" alt="1"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//参照NumberFormatException自定写一个自定义的多用户异常类</span><br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultipleException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br><span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">1</span>L;<br><br><span class="hljs-comment">//无参的构造方法</span><br>public <span class="hljs-type">MultipleException</span>() &#123;<br><span class="hljs-keyword">super</span>();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有参的构造方法</span><br><span class="hljs-comment"> * @param s 信息提示</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-type">MultipleException</span>(<span class="hljs-type">String</span> s) &#123;<br><span class="hljs-keyword">super</span>(s);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、设计一个注册Register的方法，根据条件判断在适当的时候抛出（产生）一个上面1的异常对象，抛出去。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//用户注册</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Register</span> &#123;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span>[] users = &#123; <span class="hljs-string">&quot;小王&quot;</span>, <span class="hljs-string">&quot;小李&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span> &#125;;<span class="hljs-comment">// 写一个数组，模拟已经注册的用户</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户注册功能</span><br><span class="hljs-comment"> * @param userName</span><br><span class="hljs-comment"> *            新注册的用户名</span><br><span class="hljs-comment"> * @throws MultipleException</span><br><span class="hljs-comment"> *             用户名存在的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">String</span> userName)</span> throws MultipleException </span>&#123;<br><span class="hljs-comment">// 遍历已经存在的用户名，判断是否新注册的用户名已经存在</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; users.length; i++) &#123;<br><span class="hljs-comment">// 条件判断，如果用户名不为空，且已经存在，则抛出一个MultipleException异常</span><br><span class="hljs-keyword">if</span> (userName != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; userName.equals(users[i])) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MultipleException(<span class="hljs-string">&quot;亲，用户名：&quot;</span> + userName + <span class="hljs-string">&quot;已经注册，请重新输入!&quot;</span>);<br><span class="hljs-comment">// throw:在方法里向调用者抛出异常</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//没有重复，则注册成功</span><br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;恭喜你，注册成功!玩的开心！！&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、我们去调用注册的方法来注册一个账号  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Register.<span class="hljs-keyword">register</span>(<span class="hljs-string">&quot;小刚&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (MultipleException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Register.<span class="hljs-keyword">register</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (MultipleException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、throw和throws"><a href="#6、throw和throws" class="headerlink" title="6、throw和throws"></a>6、throw和throws</h4><p>用throw主动制造异常，throw后不能再有语句，语句不可达，编译器拒绝编译；</p><p>如果抛出（throw）的是<strong>编译时期（必须要处理的）异常</strong>，必须在方法声明处抛出（throws）；</p><p>声明throws的方法被调用者调用时必须异常处理（继续抛出或就地try-catch处理），无论运行异常编译异常  。</p><p><img src="/2019/11/14/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/throws.png" alt="1"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java异常处理</tag>
      
      <tag>Exception</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面试题集汇总</title>
    <link href="/2019/11/13/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E6%B1%87%E6%80%BB/"/>
    <url>/2019/11/13/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>1、<a href="https://www.cnblogs.com/xiaoxi/p/7364623.html">java 面试题整理（不定期更新）</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java垃圾回收</title>
    <link href="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="堆-Heap-和非堆-Non-heap-内存"><a href="#堆-Heap-和非堆-Non-heap-内存" class="headerlink" title="堆(Heap)和非堆(Non-heap)内存"></a><strong>堆(Heap)和非堆(Non-heap)内存</strong></h3><p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”</p><p>“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。</p><p>可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的，非堆就是JVM留给自己用的，</p><h3 id="什么是自动垃圾回收？"><a href="#什么是自动垃圾回收？" class="headerlink" title="什么是自动垃圾回收？"></a><strong>什么是自动垃圾回收？</strong></h3><p>自动垃圾回收是一种在堆内存中找出哪些对象在被使用，还有哪些对象没被使用，并且将后者删掉的机制。所谓使用中的对象（已引用对象），指的是程序中有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收掉。</p><p>在用 C 之类的编程语言时，程序员需要自己手动分配和释放内存。而 Java 不一样，它有垃圾回收器，释放内存由回收器负责。本文接下来将介绍垃圾回收机制的基本过程。</p><h3 id="垃圾回收机制的基本过程"><a href="#垃圾回收机制的基本过程" class="headerlink" title="垃圾回收机制的基本过程"></a>垃圾回收机制的基本过程</h3><h4 id="第一步：标记（发现无用对象）"><a href="#第一步：标记（发现无用对象）" class="headerlink" title="第一步：标记（发现无用对象）"></a><strong>第一步：标记（发现无用对象）</strong></h4><p>垃圾回收的第一步是标记。垃圾回收器此时会找出哪些内存在使用中，还有哪些不是。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/a.jpg" alt="img"></p><p>上图中，蓝色表示已引用对象，橙色表示未引用对象。垃圾回收器要检查完所有的对象，才能知道哪些有被引用，哪些没。如果系统里所有的对象都要检查，那这一步可能会相当耗时间。</p><h4 id="第二步：清除（回收被无用对象占用的内存空间）"><a href="#第二步：清除（回收被无用对象占用的内存空间）" class="headerlink" title="第二步：清除（回收被无用对象占用的内存空间）"></a><strong>第二步：清除（回收被无用对象占用的内存空间）</strong></h4><p>回收被无用对象占用的内存空间–jvm堆内存（运行时数据区，用以保存类的实例，即对象），使之再次被程序使用(<strong>一般是在CPU空闲或者内存不足时</strong>)。</p><p>Java语言没有显式的提供分配内存和删除内存的方法，一些开发人员将<code>引用对象设置为null</code>或者<code>调用System.gc()</code>或者<code>Runtime.getRuntime.gc()</code>来释放内存(<strong>后两种方法仅是建议，慎重使用</strong>)；</p><p>注：事实上，除了释放没用对象占用的内存空间外，垃圾回收也可以清除内存纪录碎片（由于创建对象和垃圾回收器释放丢弃对象所占的内存空间）</p><p>删掉标记出的未引用对象。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/b.jpg" alt="img"></p><p>内存分配器会保留指向可用内存的引用，以供分配新对象。</p><h4 id="第三步：压缩"><a href="#第三步：压缩" class="headerlink" title="第三步：压缩"></a><strong>第三步：压缩</strong></h4><p>为了提升性能，删除了未引用对象后，还可以将剩下的已引用对象放在一起（压缩），这样就能更简单快捷地分配新对象了。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/c.jpg" alt="img"></p><h3 id="为什么需要分代垃圾收集？"><a href="#为什么需要分代垃圾收集？" class="headerlink" title="为什么需要分代垃圾收集？"></a><strong>为什么需要分代垃圾收集？</strong></h3><p>之前说过，逐一标记和压缩 Java 虚拟机里的所有对象非常低效：分配的对象越多，垃圾回收需时就越久。不过，根据统计，大部分的对象，其实用没多久就不用了。</p><p>来看个例子吧。（下图中，竖轴代表已分配的字节，而横轴代表程序运行时间）</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/d.jpg" alt="img"></p><p>上图可见，存活（没被释放）的对象随运行时间越来越少。而图中左侧的那些峰值，也表明了大部分对象其实都挺短命的。</p><h4 id="JVM-分代"><a href="#JVM-分代" class="headerlink" title="JVM 分代"></a><strong>JVM 分代</strong></h4><p>根据之前的规律，就可以用来提升JVM的效率了。方法是，把堆分成几个部分（就是所谓的分代），分别是<code>新生代</code>、<code>老年代</code>，以及<code>永生代</code>。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/910900.png" alt="img"></p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/e.jpg" alt="img"></p><p><strong>新生代:<strong>所有新生对象会被分配在新生代内存。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。一旦新生代内存满了，就会开始对死掉的对象，进行所谓的**<em>\</em>小型垃圾回收Minor GC\</strong></strong>过程。一片新生代内存里，死掉的越多，回收过程就越快；至于那些还活着的对象，此时就会老化，并最终老到进入老年代内存。</p><p><strong>Stop the World 事件</strong>—— 小型垃圾回收属于一种叫 “Stop the World” 的事件。在这种事件发生时，所有的程序线程都要暂停，直到事件完成（比如这里就是完成了所有回收工作）为止。</p><p>**老年代:**用来保存长时间存活的对象。通常，设置一个阈值，当达到该年龄时，年轻代对象会被移动到老年代。最终老年代也会被回收。这个事件成为 Major GC。</p><p>Major GC 也会触发STW（Stop the World）。通常，Major GC会慢很多，因为它涉及到所有存活对象。所以，对于响应性的应用程序，应该尽量避免Major GC。还要注意，Major GC的STW的时长受年老代垃圾回收器类型的影响。</p><p>**永久代:**用于存放静态文件，如今Java类、方法等包含JVM用于描述应用程序中类和方法的元数据。永久代是由JVM在运行时根据应用程序使用的类来填充的。此外，Java SE类库和方法也存储在这里。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<N>进行设置。</N></p><p>如果JVM发现某些类不再需要，并且其他类可能需要空间，则这些类可能会被回收。</p><h4 id="世代垃圾收集过程"><a href="#世代垃圾收集过程" class="headerlink" title="世代垃圾收集过程"></a><strong>世代垃圾收集过程</strong></h4><p>现在你已经理解了为什么堆被分成不同的代，现在是时候看看这些空间是如何相互作用的。 后面的图片将介绍JVM中的对象分配和老化过程。</p><p><strong>第一、新生代：</strong>首先，将任何新对象分配给 eden 空间。 两个 survivor 空间都是空的。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/f.jpg" alt="img"></p><p>当 eden区填满时，会触发轻微的垃圾收集，还存活的对象将被复制到Survivor区。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/g.jpg" alt="img"></p><p>引用的对象被移动到第一个 survivor 空间。 清除 eden 空间时，将删除未引用的对象。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/h.jpg" alt="img"></p><p>在下一次Minor GC中，Eden区也会做同样的操作。删除未被引用的对象，并将被引用的对象移动到Survivor区。然而这里，他们被移动到了第二个Survivor区（S1）。此外，第一个Survivor区（S0）中，在上一次Minor GC幸存的对象，会增加年龄，并被移动到S1中。待所有幸存对象都被移动到S1后，<code>S0和Eden区都会被清空</code>。注意，Survivor区中<code>有了不同年龄的对象</code>。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/i.jpg" alt="img"></p><p>在下一次Minor GC中，会重复同样的操作。不过，这一次Survivor区会交换<code>(Survivor的From和To身份交替互换)</code>。被引用的对象移动到S0。幸存的对象增加年龄。Eden区和S1被清空。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/j.jpg" alt="img"></p><p>此幻灯片演示了 promotion。 在较小的GC之后，当老化的物体达到一定的<code>年龄阈值</code>（在该示例中为8）时，它们从年轻一代晋升到老一代。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/k.jpg" alt="img"></p><p><strong>第二、年老代：</strong></p><p>在<code>年轻代</code>中经历了N次垃圾回收后仍然存活的对象，就会被放到<code>年老代</code>中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Snipaste_2019-11-13_11-17-10.png" alt="img"></p><p>所以这几乎涵盖了年轻一代的整个过程。 最终，将主要对老一代进行GC，清理并最终压缩该空间。</p><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/m.jpg" alt="img"></p><h3 id="什么情况会触发垃圾回收？"><a href="#什么情况会触发垃圾回收？" class="headerlink" title="什么情况会触发垃圾回收？"></a>什么情况会触发垃圾回收？</h3><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor GC和Full GC。</p><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC:"></a><strong>Minor GC:</strong></h4><p> 一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区，然后整理Survivor的两个区。</p><p>这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。</p><p>因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><h4 id="Full-GC："><a href="#Full-GC：" class="headerlink" title="Full GC："></a><strong>Full GC：</strong></h4><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Full GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。</p><p>有如下原因<code>可能导致</code>Full GC：</p><blockquote><p>1、年老代（Tenured）被写满</p><p>2、持久代（Perm）被写满</p><p>3、System.gc()被显示调用</p><p>4、上一次GC之后Heap的各域分配策略动态变化</p></blockquote><p><img src="/2019/11/13/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Snipaste_2019-11-13_15-28-53.png" alt="m"></p><blockquote><ol><li>一个对象实例化时，先去查看Eden有没有足够的空间</li><li>如果有，不进行垃圾回收，对象直接分配在Eden存储</li><li>如果Eden内存已满，会进行一次Minor GC</li><li>然后再进行判断Eden的内存是否足够</li><li>如果仍然不足，则去看存活区的内存是否足够</li><li>如果内存足够，把Eden部分活跃对象保存再存活区，然后把对象保存在Eden</li><li>如果内存不足，向老年代发出请求，查询老年代的内存是否足够</li><li>如果老年代内存足够，将部分存活区的活跃对象存入老年代，然后把Eden的活跃对象放入存活区，新的对象依旧保存在Eden</li><li>如果老年代内存不足，会进行一次full gc,之后老年代会再进行判断 内存是否足够,如果足够 同上.</li><li>如果还不足，会抛出 OutOfMemoryError</li></ol></blockquote><p>资料查询：</p><p>1、分歧：当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个）（YGC，年轻代垃圾回收），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><p>2、<a href="https://www.cnblogs.com/xiaoxi/p/6486852.html">Java垃圾回收（GC）机制详解</a></p><p>3、<a href="https://www.cnblogs.com/liuligang/p/10624077.html">java垃圾回收</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java垃圾回收</tag>
      
      <tag>Garbage Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>单线程</p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Snipaste_2019-11-13_17-27-01.png" alt="1"></p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。</p><p>说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。</p><p>很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。</p><blockquote><ul><li>多线程：指的是这个程序（一个进程）运行时产生了不止一个线程</li><li>并行与并发： <ul><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li></ul></li></ul></blockquote><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/CAPP.png" alt="img"></p><h4 id="并发（Concurrent）与并行（Parallel）"><a href="#并发（Concurrent）与并行（Parallel）" class="headerlink" title="并发（Concurrent）与并行（Parallel）"></a>并发（Concurrent）与并行（Parallel）</h4><blockquote><p><strong>线程安全</strong>：经常用来描绘一段代码</p><p>在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。</p><p>实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化，多个线程读取相同的资源就是安全的。</p><p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。</p><p>如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</p><p>反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如： </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TicketThread implements Runnable &#123;<br><span class="hljs-built_in">int</span> tickets = <span class="hljs-number">100</span>;<span class="hljs-comment">//火车票数量</span><br>@Override<br>public void run<span class="hljs-literal">()</span> &#123;<br><span class="hljs-comment">//出售火车票</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">//当火车票小于0张，则停止售票</span><br><span class="hljs-keyword">if</span>(tickets &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * t1,t2,t3</span><br><span class="hljs-comment"> * 假设只剩一张票</span><br><span class="hljs-comment"> * t1过来了，他一看有票，他就进（判断语句里）来了，但是他突然肚子不舒服，然后他就去上卫生间了</span><br><span class="hljs-comment"> * t2也过来了，他一看也有票，他也进（判断语句里）来了，但是他的肚子也不舒服，他也去上卫生间了</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * t1上完了卫生间回来了，开始售票</span><br><span class="hljs-comment"> * tickets = 0;</span><br><span class="hljs-comment"> * t2也上完卫生间回来了，他也进行售票</span><br><span class="hljs-comment"> *  tickets = -1; </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br>&#125; catch (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;:&quot;</span> +tickets--);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>同步</strong>：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。</p><p>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。<code>所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作</code>。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p><p>如上面的代码简单加入<code>@synchronized</code>关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p><ol><li>实例方法:</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br><span class="hljs-keyword">this</span>.count += value;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。</p><ol start="2"><li>静态方法:</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br>count += value;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态方法的同步是指同步在该方法所在的类对象上。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</p><ol start="3"><li>实例方法中的同步块:</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">int value</span>)</span>&#123;<br> <span class="hljs-function"><span class="hljs-title">synchronized</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.count += value;<br> &#125;<br><span class="hljs-comment">//    Object obj=new Object();</span><br><span class="hljs-comment">//    synchronized(obj)&#123;</span><br><span class="hljs-comment">//       this.count += value;</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。</p><p>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">log1</span><span class="hljs-params">(<span class="hljs-keyword">String</span> msg1, <span class="hljs-keyword">String</span> msg2)</span></span>&#123;<br>   <span class="hljs-built_in">log</span>.writeln(msg1);<br>   <span class="hljs-built_in">log</span>.writeln(msg2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log2</span><span class="hljs-params">(<span class="hljs-keyword">String</span> msg1, <span class="hljs-keyword">String</span> msg2)</span></span>&#123;<br>   synchronized(<span class="hljs-keyword">this</span>)&#123;<br>      <span class="hljs-built_in">log</span>.writeln(msg1);<br>      <span class="hljs-built_in">log</span>.writeln(msg2);<br>   &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>静态方法中的同步块:</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">log1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg1, <span class="hljs-built_in">String</span> msg2</span>)</span>&#123;<br>    log.writeln(msg1);<br>    log.writeln(msg2);<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">log2</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg1, <span class="hljs-built_in">String</span> msg2</span>)</span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">synchronized</span>(<span class="hljs-params">MyClass.<span class="hljs-keyword">class</span></span>)</span>&#123;<br>       log.writeln(msg1);<br>       log.writeln(msg2);<br>    &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法不允许同时被线程访问。如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 问题出现的原因：</span><br><span class="hljs-comment"> * 要有多个线程</span><br><span class="hljs-comment"> * 要有被多个线程所共享的数据</span><br><span class="hljs-comment"> * 多个线程并发的访问共享的数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 在火车上上厕所</span><br><span class="hljs-comment"> * 张三来了，一看门是绿的，他就进去了，把门锁上了，门就变红了</span><br><span class="hljs-comment"> * 李四来了，一看门市红色的，他就只能憋着</span><br><span class="hljs-comment"> * 张三用完了厕所，把锁打开了，门就变成了绿色</span><br><span class="hljs-comment"> * 李四一看门变绿了，他就进去了，把门锁上，门就变红了</span><br><span class="hljs-comment"> * 王五来了，一看们是红色的，他也只能憋着</span><br><span class="hljs-comment"> * 李四用完测试了，把锁打开了，肚子又不舒服了，扭头回去了，又把门锁上了，</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * synchronized:同步（锁），可以修饰代码块和方法，被修饰的代码块和方法一旦被某个线程访问，则直接锁住，其他的线程将无法访问</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 同步代码块：</span><br><span class="hljs-comment"> * synchronized(锁对象)&#123;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 注意：锁对象需要被所有的线程所共享</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 同步：安全性高，效率低</span><br><span class="hljs-comment"> * 非同步：效率高，但是安全性低</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> TicketThread implements Runnable &#123;<br><span class="hljs-built_in">int</span> tickets = <span class="hljs-number">100</span>;<span class="hljs-comment">//火车票数量</span><br>Object obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<span class="hljs-comment">//锁对象需要被所有的线程所共享</span><br><br>@Override<br>public void run<span class="hljs-literal">()</span> &#123;<br><span class="hljs-comment">//出售火车票</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>synchronized (obj) &#123;<br><br><span class="hljs-keyword">if</span>(tickets &gt; <span class="hljs-number">0</span>) &#123;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br>&#125; catch (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;:&quot;</span> +tickets--);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/////////////////////////////////////////////////////</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 同步方法:使用关键字synchronized修饰的方法，一旦被一个线程访问，则整个方法全部锁住，其他线程则无法访问</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * synchronized</span><br><span class="hljs-comment"> * 注意：</span><br><span class="hljs-comment"> * 非静态同步方法的锁对象是this</span><br><span class="hljs-comment"> * 静态的同步方法的锁对象是当前类的字节码对象，静态方法没有this</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> TicketThread implements Runnable &#123;<br>static <span class="hljs-built_in">int</span> tickets = <span class="hljs-number">100</span>;<span class="hljs-comment">// 火车票数量</span><br>Object obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Object()</span>;<br>@Override<br>public void run<span class="hljs-literal">()</span> &#123;<br><span class="hljs-comment">// 出售火车票</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">/*synchronized (obj) &#123;</span><br><span class="hljs-comment">method();</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-comment">//method();</span><br>method2<span class="hljs-literal">()</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">private</span> synchronized void <span class="hljs-keyword">method</span><span class="hljs-literal">()</span> &#123;<br><span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123; <br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br>&#125; catch (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;:&quot;</span> + tickets--);<br>&#125;<br>&#125;<br><span class="hljs-keyword">private</span> static synchronized void method2<span class="hljs-literal">()</span> &#123;<br><span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br>&#125; catch (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;:&quot;</span> + tickets--);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/////////////////////////////////////////////////////</span><br>public <span class="hljs-keyword">class</span> TicktetTest &#123;<br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br><span class="hljs-comment">//创建线程对象</span><br>TicketThread tt = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TicketThread()</span>;<br><br>Thread t = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">tt</span>)</span>;<br>t.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;窗口1&quot;</span>)</span>;<br>Thread t2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">tt</span>)</span>;<br>t2.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;窗口2&quot;</span>)</span>;<br>Thread t3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">tt</span>)</span>;<br>t3.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;窗口3&quot;</span>)</span>;<br><br><span class="hljs-comment">//启动线程对象</span><br>t.start<span class="hljs-literal">()</span>;<br>t2.start<span class="hljs-literal">()</span>;<br>t3.start<span class="hljs-literal">()</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="扎马步：线程的状态（线程通信）"><a href="#扎马步：线程的状态（线程通信）" class="headerlink" title="扎马步：线程的状态（线程通信）"></a>扎马步：线程的状态（线程通信）</h4><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p><p>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。</p><p>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，<code>线程必须在同步块里调用wait()或者notify()</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.kongwei_liao.ThreadsDemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWaitNotify</span> </span>&#123;<br><br><span class="hljs-comment">//MonitorObject myMonitorObject = new MonitorObject();</span><br>  <span class="hljs-built_in">boolean</span> wasSignalled = <span class="hljs-literal">false</span>;<br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doWait</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">//    synchronized(myMonitorObject)&#123;</span><br>  <span class="hljs-function"><span class="hljs-title">synchronized</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span>&#123;<br>      <span class="hljs-keyword">while</span>(!wasSignalled)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//          myMonitorObject.wait();</span><br>        <span class="hljs-built_in">this</span>.wait();<br>         &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>         <br>         &#125;<br>      &#125;<br>      <span class="hljs-comment">//clear signal and continue running.</span><br>      wasSignalled = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">doNotify</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">//    synchronized(myMonitorObject)&#123;</span><br>  <span class="hljs-function"><span class="hljs-title">synchronized</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span>&#123;<br>      wasSignalled = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//      myMonitorObject.notify();</span><br>      <span class="hljs-built_in">this</span>.notify();<br>    &#125;<br>  &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意以下几点：</p><blockquote><p>1、不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常。</p><p>2、一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。</p><p>3、为了避免丢失信号，必须把它们保存在信号类里。如上面的wasSignalled变量。</p><p>4、假唤醒：由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做<code>自旋锁</code>。</p><p>5、不要在字符串常量或全局对象中调用wait()。即上面MonitorObject不能是字符串常量或是全局对象。每一个MyWaitNotify的实例都拥有一个属于自己的监视器对象，而不是在空字符串上调用wait()/notify()。</p></blockquote><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/status.png" alt="img"></p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/status2.png" alt="img"></p><p>各种状态一目了然，值得一提的是“Blocked”这个状态：</p><p>线程在Running的过程中可能会遇到阻塞Blocked情况</p><blockquote><ol><li>调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。</li><li>调用wait()，使该线程处于<code>等待池(wait blocked pool)</code>,直到notify()/notifyAll()，线程被唤醒被放到<code>锁定池(lock blocked pool )</code>，释放同步锁使线程回到可运行状态（Runnable）</li><li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li></ol></blockquote><p>此外，在Runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个Running状态的线程转入Runnable。</p><h4 id="练内功：每个对象都有的方法和机制"><a href="#练内功：每个对象都有的方法和机制" class="headerlink" title="练内功：每个对象都有的方法和机制"></a>练内功：每个对象都有的方法和机制</h4><h5 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h5><p>方法一：实现Runnable接口</p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20191113163347390.png" alt="image-20191113163347390"></p><blockquote><p>1、定义类实现Runnable接口。</p><p>2、覆盖接口中的run方法。。</p><p>3、创建Thread类的对象</p><p>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。</p><p>5、调用Thread类的start方法开启线程。</p></blockquote><p>方法摘要：</p><blockquote><p>void run()使用实现接口Runnable的对象创建一个线程时，启动线程时调用</p></blockquote><p>第一种编写线程执行代码的方式是新建一个实现了java.lang.Runnable接口的类的实例，实例中的方法可以被线程调用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span> &#123;</span><br>   public void run()&#123;<br>    System.out.println(<span class="hljs-string">&quot;MyRunnable running&quot;</span>);<br>   &#125;<br>&#125;<br> <br>Thread thread = new Thread(new MyRunnable());<br>thread.start();<br><br>/<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">/匿名创建/</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br>Runnable myRunnable = new Runnable()&#123;<br>   public void run()&#123;<br>     System.out.println(<span class="hljs-string">&quot;Runnable running&quot;</span>);<br>   &#125;<br>&#125;<br>Thread thread = new Thread(myRunnable);<br>thread.start();<br></code></pre></td></tr></table></figure><p>方法二：继承Thread类，重写run方法</p><blockquote><p>1.定义一个类继承Thread。</p><p>2.重写run方法。</p><p>3.创建子类对象，就是创建线程对象。</p><p>4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法</p></blockquote><p>Thread实现了java.lang.Runnable接口，创建Thread子类的一个实例并重写run方法，run方法会在调用start()方法之后被执行。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl">public class MyThread extends Thread &#123;<br>   public void run()&#123;<br>     System.out.println(<span class="hljs-string">&quot;MyThread running&quot;</span>);<br>   &#125;<br>&#125;<br><br>MyThread myThread = new MyThread();<br>myTread.start();<br><br>//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">/匿名创建/</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>/<br>Thread thread = new Thread()&#123;<br>   public void run()&#123;<br>     System.out.println(<span class="hljs-string">&quot;Thread Running&quot;</span>);<br>   &#125;<br>&#125;;<br>thread.start();<br></code></pre></td></tr></table></figure><p>synchronized, wait, notify是任何对象都具有的<code>同步工具</code>。</p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/tools.png" alt="img"></p><h5 id="Monitor监视器"><a href="#Monitor监视器" class="headerlink" title="Monitor监视器"></a><strong>Monitor监视器</strong></h5><p>他们是应用于同步问题的人工线程调度工具。讲其本质，实现就要明确Monitor这个概念，Java中的每一个对象都有一个监视器，来检测并发代码的重入。在非多线程编码时该Monitor不发挥作用，反之如果在synchronized范围内，监视器发挥作用。</p><p>wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait以后，其它线程可以进入同步块执行。</p><p>当某段代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。</p><p>再讲用法：</p><ul><li><p><strong>synchronized</strong>单独使用： </p></li><li><p>代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  <br>       <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>         ..<span class="hljs-keyword">do</span> something<br>       &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>直接用于方法： 相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。 </li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby">  public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable1</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span> &#123;</span><br>     public synchronized void run() &#123;  <br>          ..<span class="hljs-keyword">do</span> something<br>     &#125;<br>  &#125;<br>  /<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">/创建线程/</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br>  public static void main(String[]args) &#123;<br>  Thread MT1=new Thread(new MyRunnable1());<br>  MT1.start();<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>synchronized, wait, notify</strong>结合:典型场景生产者消费者问题</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生产者生产出来的产品交给店员</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> synchronized void produce()<br>  &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.product &gt;= MAX_PRODUCT)<br>      &#123;<br>          <span class="hljs-keyword">try</span><br>          &#123;<br>              wait();  <br>              System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;产品已满,请稍候再生产&quot;</span>);<br>          &#125;<br>          <span class="hljs-keyword">catch</span>(InterruptedException e)<br>          &#123;<br>              e.printStackTrace();<br>          &#125;<br>          <span class="hljs-keyword">return</span>;<span class="hljs-comment">//</span><br>      &#125;<br><br>      <span class="hljs-keyword">this</span>.product++;<br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;生产者生产第&quot;</span> + <span class="hljs-keyword">this</span>.product + <span class="hljs-string">&quot;个产品.&quot;</span>);<br>      notifyAll();   <span class="hljs-comment">//通知等待区的消费者可以取出产品了</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 消费者从店员取产品</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> synchronized void consume()<br>  &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.product &lt;= MIN_PRODUCT)<br>      &#123;<br>          <span class="hljs-keyword">try</span> <br>          &#123;<br>              wait(); <br>              System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;缺货,稍候再取&quot;</span>);<br>          &#125; <br>          <span class="hljs-keyword">catch</span> (InterruptedException e) <br>          &#123;<br>              e.printStackTrace();<br>          &#125;<br>          <span class="hljs-keyword">return</span>;<span class="hljs-comment">//</span><br>      &#125;<br><br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;消费者取走了第&quot;</span> + <span class="hljs-keyword">this</span>.product + <span class="hljs-string">&quot;个产品.&quot;</span>);<br>      <span class="hljs-keyword">this</span>.product--;<br>      notifyAll();   <span class="hljs-comment">//通知等待去的生产者可以生产产品了</span><br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a><strong>Volatile关键字</strong></h5><p>多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次<code>load and save</code>)。</p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/volatile.png" alt="img"></p><p>针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。<code>在线程安全的情况下加volatile会牺牲性能</code>。</p><h4 id="太祖长拳：基本线程类"><a href="#太祖长拳：基本线程类" class="headerlink" title="太祖长拳：基本线程类"></a>太祖长拳：基本线程类</h4><p>基本线程类指的是Thread类，Runnable接口和Callable接口</p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Thread1.png" alt="t"></p><p>方法摘要：</p><blockquote><p>构造方法：</p><ul><li>Thread()分配新的Thread对象；</li><li>Thread(Runnable target)分配新的Thread对象。</li></ul><p>成员方法：</p><ul><li>void start()使该线程开始执行；Java虚拟机调用该线程的run方法；</li><li>void run()该线程要执行的操作，需要自己来重写</li><li>String getName()返回线程名</li><li>void setName(String Name)改变线程名称</li><li>public static yield() 当前线程可转让CPU控制权，让别的就绪状态的线程运行（线程切换）</li><li>public join()在一个线程中调用other.join(),将等待other执行完后 再继续本线程。</li><li>static void sleep(long millis)在指定的毫秒数内让当前正在执行的线程休眠。</li><li>public interrupt()//后两个函数皆可以被打断</li></ul></blockquote><p>Thread类实现了Runnable接口，启动一个线程：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">public class MyThread extends Thread &#123;<span class="hljs-regexp">//</span>继承Thread类，重写run方法<br>   public void run()&#123;<br>     System.out.println(<span class="hljs-string">&quot;MyThread running&quot;</span>);<br>   &#125;<br>&#125;<br>//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">/创建线程/</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>/<br>MyThread <span class="hljs-keyword">my</span> = new MyThread();<br>my.start();<br></code></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title></a></h5><h5 id="关于中断："><a href="#关于中断：" class="headerlink" title="关于中断："></a><strong>关于中断：</strong></h5><p>它并不像stop方法那样会中断一个正在运行的线程。</p><p>线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。</p><p>中断只会影响到<code>wait状态、sleep状态和join状态</code>。被打断的线程会抛出InterruptedException。</p><p>Thread.interrupted()检查当前线程是否发生中断，返回boolean<br>synchronized在获锁的过程中是不能被中断的。</p><p>中断是一个状态！interrupt()方法只是将这个状态置为true而已。</p><p>所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。</p><p>如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体。</p><h5 id="Thread类最佳实践："><a href="#Thread类最佳实践：" class="headerlink" title="Thread类最佳实践："></a><strong>Thread类最佳实践</strong>：</h5><p>写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。</p><h5 id="如何获取线程中的异常"><a href="#如何获取线程中的异常" class="headerlink" title="如何获取线程中的异常"></a><strong>如何获取线程中的异常</strong></h5><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Thread.png" alt="img"></p><p>不能用try,catch来获取线程中的异常</p><h5 id="Runnable与Thread类似"><a href="#Runnable与Thread类似" class="headerlink" title="Runnable与Thread类似"></a><strong>Runnable</strong>与Thread类似</h5><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><strong>Callable</strong></h5><p>future模式：并发模式的一种，可以有两种形式，即<code>无阻塞</code>和<code>阻塞</code>，分别是isDone和get。其中Future对象用来存放该线程的返回值以及状态</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ExecutorService e = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(3)</span>;<br> <span class="hljs-comment">//submit方法有多重参数版本，及支持callable也能够支持runnable接口类型.</span><br>Future future = e.submit(<span class="hljs-keyword">new</span> my<span class="hljs-constructor">Callable()</span>);<br>future.is<span class="hljs-constructor">Done()</span> <span class="hljs-comment">//return true,false 无阻塞</span><br>future.get<span class="hljs-literal">()</span> <span class="hljs-comment">// return 返回值，阻塞直到该线程运行结束</span><br></code></pre></td></tr></table></figure><h4 id="九阴正经：高级多线程控制类"><a href="#九阴正经：高级多线程控制类" class="headerlink" title="九阴正经：高级多线程控制类"></a>九阴正经：高级多线程控制类</h4><p>以上都属于内功心法，接下来是实际项目中常用到的工具了，Java1.5提供了一个非常高效实用的<code>多线程包:java.util.concurrent</code>, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。</p><h5 id="1-ThreadLocal类"><a href="#1-ThreadLocal类" class="headerlink" title="1.ThreadLocal类"></a><strong>1.ThreadLocal类</strong></h5><p>用处：保存线程的独立变量。对一个线程类（继承自Thread)<br>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。</p><p>实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。<br>主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。</p><h5 id="2-原子类（AtomicInteger、AtomicBoolean……）"><a href="#2-原子类（AtomicInteger、AtomicBoolean……）" class="headerlink" title="2.原子类（AtomicInteger、AtomicBoolean……）"></a><strong>2.原子类（AtomicInteger、AtomicBoolean……）</strong></h5><p>如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//返回值为boolean</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AtomicInteger</span>.</span></span>compare<span class="hljs-constructor">AndSet(<span class="hljs-params">int</span> <span class="hljs-params">expect</span>,<span class="hljs-params">int</span> <span class="hljs-params">update</span>)</span><br></code></pre></td></tr></table></figure><p>该方法可用于<code>实现乐观锁</code>，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(b.value.compare<span class="hljs-constructor">AndSet(<span class="hljs-params">old</span>, <span class="hljs-params">value</span>)</span>)&#123;<br>   return ;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>   <span class="hljs-comment">//try again</span><br>   <span class="hljs-comment">//if that fails, rollback and log</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>AtomicReference</strong><br>对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。<br>这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号</p><h5 id="3-Lock类"><a href="#3-Lock类" class="headerlink" title="3.Lock类"></a><strong>3.Lock类</strong></h5><p>lock: 在java.util.concurrent.locks包内。共有三个类：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-built_in">ReentrantLock</span><br>ReentrantReadWriteLock<br>ReentrantReadWriteLock.ReadLock<br>ReentrantReadWriteLock.WriteLock<br></code></pre></td></tr></table></figure><p>主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。</p><p>区别如下：</p><blockquote><p>lock更灵活，可以自由定义多把锁的加锁解锁顺序（synchronized要按照先加的后解顺序） 提供多种加锁方案，<code>lock 阻塞式</code>,<code> trylock 无阻塞式</code>, <code>lockInterruptily 可打断式</code>， 还有<code>trylock的带超时时间版本</code>。 本质上和监视器锁（即synchronized是一样的） 能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。 和Condition类的结合。 性能更高，对比如下图：(Throughput吞吐量)</p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/thre.png" alt="img"></p><p>synchronized和Lock性能对比</p></blockquote><h6 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h6><p>可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。<br>使用方法是：</p><blockquote><p>1.先new一个实例</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">static</span> ReentrantLock r=<span class="hljs-keyword">new</span> <span class="hljs-type">ReentrantLock</span>();<br></code></pre></td></tr></table></figure><p>2.加锁</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">r</span><span class="hljs-selector-class">.lock</span>()或<span class="hljs-selector-tag">r</span><span class="hljs-selector-class">.lockInterruptibly</span>();<br></code></pre></td></tr></table></figure><p>此处也是个不同，后者可被打断。当a线程lock后，b线程阻塞，此时如果是lockInterruptibly，那么在调用b.interrupt()之后，b线程退出阻塞，并放弃对资源的争抢，进入catch块。（如果使用后者，必须throw interruptable exception 或catch）　　　　</p><p>3.释放锁　　　</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">r</span><span class="hljs-selector-class">.unlock</span>()<br></code></pre></td></tr></table></figure><p><code>必须做！何为必须做呢，要放在finally里面。</code>以防止异常跳出了正常流程，导致灾难。这里补充一个小知识点，finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.ThreadsDemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReentrantLock</span></span>&#123;<br><br><span class="hljs-keyword">boolean</span> isLocked = <span class="hljs-keyword">false</span>;<br>    Thread  lockedBy = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lockedCount = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        Thread callingThread = Thread.currentThread();<br>        <span class="hljs-keyword">while</span>(isLocked &amp;&amp; lockedBy != callingThread)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>        &#125;<br>        isLocked = <span class="hljs-keyword">true</span>;<br>        lockedCount++;<br>        lockedBy = callingThread;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Thread.currentThread() == <span class="hljs-keyword">this</span>.lockedBy)&#123;<br>            lockedCount--;<br>            <span class="hljs-keyword">if</span>(lockedCount == <span class="hljs-number">0</span>)&#123;<br>                isLocked = <span class="hljs-keyword">false</span>;<br>                notify();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>MyReentrantLock mrl=<span class="hljs-keyword">new</span> MyReentrantLock();<br>mrl.lock();<br><span class="hljs-keyword">try</span> &#123;<br><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>mrl.unlock();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h6 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><strong>ReentrantReadWriteLock</strong></h6><p>可重入读写锁（读写锁的一个实现）</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">ReentrantReadWriteLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantReadWriteLock()<br>ReadLock <span class="hljs-keyword">r</span> = <span class="hljs-keyword">lock</span>.readLock()<span class="hljs-comment">;</span><br>WriteLock <span class="hljs-keyword">w</span> = <span class="hljs-keyword">lock</span>.writeLock()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>两者都有lock,unlock方法。写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码</p><h5 id="4-容器类"><a href="#4-容器类" class="headerlink" title="4.容器类"></a><strong>4.容器类</strong></h5><p>这里就讨论比较常用的两个：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">BlockingQueue</span><br><span class="hljs-attribute">ConcurrentHashMap</span><br></code></pre></td></tr></table></figure><h6 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><strong>BlockingQueue</strong></h6><p>阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列），有兴趣可以研究</p><p>BlockingQueue在队列的基础上添加了多线程协作的功能：</p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/contain.png" alt="img"></p><p>BlockingQueue<br>除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span> &#123;</span><br>    <span class="hljs-keyword">private</span> List <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit = <span class="hljs-number">10</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.limit = limit;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Object item)</span> throws InterruptedException </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.<span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>() == <span class="hljs-keyword">this</span>.limit) &#123;<br>            wait();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.<span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            notifyAll();<br>        &#125;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">queue</span>.add(item);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> synchronized Object <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> throws InterruptedException </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.<span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            wait();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.<span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>() == <span class="hljs-keyword">this</span>.limit) &#123;<br>            notifyAll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-built_in">queue</span>.<span class="hljs-built_in">remove</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常见的阻塞队列有：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ArrayListBlockingQueue</span><br><span class="hljs-attribute">LinkedListBlockingQueue</span><br><span class="hljs-attribute">DelayQueue</span><br><span class="hljs-attribute">SynchronousQueue</span><br></code></pre></td></tr></table></figure><h6 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h6><p>高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap</p><h5 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5.信号量"></a><strong>5.信号量</strong></h5><p>java.util.concurrent.Semaphore</p><h5 id="6-管理类"><a href="#6-管理类" class="headerlink" title="6.管理类"></a><strong>6.管理类</strong></h5><p>管理类的概念比较泛，用于管理线程，本身不是多线程的，但提供了一些机制来利用上述的工具做一些封装。<br>了解到的值得一提的管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean<br><strong>ThreadPoolExecutor</strong><br>如果不了解这个类，应该了解前面提到的ExecutorService，开一个自己的线程池非常方便：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ExecutorService e = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">CachedThreadPool()</span>;<br>ExecutorService e = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">SingleThreadExecutor()</span>;<br>ExecutorService e = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(3)</span>;<br><span class="hljs-comment">// 第一种是可变大小线程池，按照任务数来分配线程，</span><br><span class="hljs-comment">// 第二种是单线程池，相当于FixedThreadPool(1)</span><br><span class="hljs-comment">// 第三种是固定大小线程池。</span><br><span class="hljs-comment">// 然后运行</span><br>e.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyRunnableImpl()</span>);<br></code></pre></td></tr></table></figure><p>该类内部是通过ThreadPoolExecutor实现的，掌握该类有助于理解线程池的管理，本质上，他们都是ThreadPoolExecutor类的各种实现版本。请参见javadoc：</p><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/javadoc.png" alt="img"></p><p>ThreadPoolExecutor参数解释</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">corePoolSize:</span>池内线程初始值与最小值，就算是空闲状态，也会保持该数量线程。<br><span class="hljs-symbol">maximumPoolSize:</span>线程最大值，线程的增长始终不会超过该值。<br>keepAliveTime：当池内线程数高于corePoolSize时，经过多少时间多余的空闲线程才会被回收。回收前处于wait状态<br>unit：<br>时间单位，可以使用TimeUnit的实例，如TimeUnit.MILLISECONDS　<br><span class="hljs-symbol">workQueue:</span>待入任务（Runnable）的等待场所，该参数主要影响调度策略，如公平与否，是否产生饿死(starving)<br><span class="hljs-symbol">threadFactory:</span>线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。<br></code></pre></td></tr></table></figure><p>Java通过Executors提供四种线程池，分别为：</p><blockquote><p>newCachedThreadPool</p><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p><p>newFixedThreadPool </p><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><p>newScheduledThreadPool </p><p>创建一个大小无限制的线程池。此线程池支持定时以及周期性执行任务。</p><p>newSingleThreadExecutor</p><p>创建一个单线程的线程池。此线程池支持定时以及周期性执行任务。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></blockquote><p><img src="/2019/11/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Snipaste_2019-11-13_09-26-28.png" alt="i"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型</title>
    <link href="/2019/11/12/Java%E6%B3%9B%E5%9E%8B/"/>
    <url>/2019/11/12/Java%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="啥是泛型？"><a href="#啥是泛型？" class="headerlink" title="啥是泛型？"></a>啥是泛型？</h4><p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。</p><p>简单的理解：就是在设计类（接口等）的时候，没有给规定具体是什么类型的参数，在实例化或调用的时候再传入具体的类型，告诉编译器这是什么类型。</p><p>注意：</p><ol><li><p>泛型不会影响程序的运行的速度，因为在编译期就会直接编译成具体的类型。</p></li><li><p>使用泛型的方法或实例化泛型的类，只能用传入引用数据类型，不能传入基本数据类型</p></li></ol><h4 id="规则限制："><a href="#规则限制：" class="headerlink" title="规则限制："></a>规则限制：</h4><p>1、泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。<br>2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。<br>3、泛型的类型参数可以有多个。<br>4、泛型的参数类型可以使用extends语句，例如<T extends superclass>。习惯上称为“有界类型”。<br>5、泛型的参数类型还可以是通配符类型。例如Class&lt;?&gt; classType = Class.forName(“java.lang.String”);</T></p><p>泛型作用</p><p>泛型的作用：在编译的时候检查<a href="https://baike.baidu.com/item/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/7308285">类型安全</a>，并且所有的<a href="https://baike.baidu.com/item/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/4463315">强制转换</a>都是自动和<a href="https://baike.baidu.com/item/%E9%9A%90%E5%BC%8F/957024">隐式</a>的，以提高代码的重用率。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 准备一个List用来存储公司员工对象  假设有一个类 Employee</span><br>List  emp = <span class="hljs-keyword">new</span> ArrayList();<br>emp.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;张三&quot;</span>));<br>emp.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;李三&quot;</span>));<br>emp.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;王三&quot;</span>));<br>由于List中可以存储任意类型的数据，因此可以这样<br>emp.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;王麻子&quot;</span>);<br>emp.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;旺财&quot;</span>));<br><br><br><span class="hljs-comment">// 写一个发工资的方法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">Object</span> o : emp)&#123;<br>syso(<span class="hljs-string">&quot;给&quot;</span>+o.getName() + <span class="hljs-number">50000</span>);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">上面代码可能引发的问题： 当我们获得一个字符串  或者一条狗的时候可能就调用不出来getName()方法</span><br><span class="hljs-comment">结果： 从业务上来讲，emp集合中只应该放Employee类型的数据，但是List可以放任意的类型的数据，在编译的时候我们无法阻止</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如何解决？使用泛型  ---》限定我们上面的emp中只能够放Employee</span><br><span class="hljs-comment">List&lt;Employee&gt;  emp = new ArrayList&lt;Employee&gt;();</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h4 id="泛型类（接口）的设计"><a href="#泛型类（接口）的设计" class="headerlink" title="泛型类（接口）的设计"></a>泛型类（接口）的设计</h4><p>需求：设计一个点类Point,其中设计字段 x y;</p><p>问题：里面的字段x y 使用什么类型好呢？ double  int  。。。</p><p>效果：需要设计上面的类，满足不同的人的需求，有些希望使用double  int..</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Point</span>&#123;<br>  <span class="hljs-built_in">double</span> x;<br>  <span class="hljs-built_in">double</span> y;<br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Point</span>&#123;<br>  <span class="hljs-built_in">int</span> x;<br>  <span class="hljs-built_in">int</span> y;<br>&#125; <br><span class="hljs-comment">//一个类本质看成是一个模板，然后希望是一个通用的模板：</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Point</span>&#123;<br>  数据类型 x;<br>  数据类型 y;<br>&#125; <br></code></pre></td></tr></table></figure><p>希望在设计类的时候，其中的数据类型我们就写一个符号，泛指所有的类型，但是不指具体的某种类型</p><p>当有人使用我们上面的模板来创建一个对象的时候他们自己可以指定自己的类型</p><p>怎么做：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Point</span>&lt;数据类型&gt;&#123;  <span class="hljs-comment">// 表示在类声明了一个符号 数据类型，是一种泛指</span><br>  数据类型 x;<br>  数据类型 y;<br>&#125; <br></code></pre></td></tr></table></figure><p>规范的写法应该是使用一些字母（常见的字母）：</p><p>E  Element 元素</p><p>T  Type  类型</p><p>K     Key   键</p><p>V  Value  值</p><p>也可以支持多个泛型参数例如Map&lt;K,V&gt;</p><h4 id="泛型的具体使用案例"><a href="#泛型的具体使用案例" class="headerlink" title="泛型的具体使用案例"></a>泛型的具体使用案例</h4><p>1、把学生对象存入TreeSet中，自然排序 或者 比较器</p><p>2、统计字符串中字母个数的示例</p><p><img src="/2019/11/12/Java%E6%B3%9B%E5%9E%8B/clip_image002.jpg" alt="im"></p><p>泛型的上、下限</p><p><img src="/2019/11/12/Java%E6%B3%9B%E5%9E%8B/clip_im002.jpg" alt="img"></p><p><img src="/2019/11/12/Java%E6%B3%9B%E5%9E%8B/clip_im02.jpg" alt="img"></p><h4 id="泛型方法的设计和使用"><a href="#泛型方法的设计和使用" class="headerlink" title="泛型方法的设计和使用"></a>泛型方法的设计和使用</h4><p><img src="/2019/11/12/Java%E6%B3%9B%E5%9E%8B/clip_im01.png" alt="img"></p><p>错误原因： 在类设计上面。因为被static修饰的方法，是在类加载的时候就加载的到静态区中，而这时候加载到jvm中的T类型，JVM根本就不知道是什么类型。</p><p>解决方法：在方法上加一个泛型</p><p><img src="/2019/11/12/Java%E6%B3%9B%E5%9E%8B/ge001.png" alt="img"></p><p>什么是泛型方法</p><p>1、就是把泛型类型的声明放在某个方法上面，只需将泛型参数列表置于返回值前；只能够本方法上或者内部可以使用这个符号；</p><p>2、泛型类，声明的泛型类型可以使用到整个类的</p><p>3、泛型方法来说，是再调用方法的时候传入的实际参数为真实的类型</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>限制泛型</p><blockquote><p>1）<T extends collection>这里的限定使用关键字extends，后面可以是类也可以是接口。但这里的extends已经不是继承的含义了，应该理解为T类型是实现Collection接口的类型，或者T是继承了XX类的类型。<br>2）&lt;T extends SomeClass &amp; interface1 &amp; interface2 &amp; interface3&gt;</T></p></blockquote><p>通配符泛型</p><blockquote><p>1、如果只指定了&lt;?&gt;，而没有extends，则默认是允许Object及其下的任何Java类了。也就是任意类。<br>2、通配符泛型不单可以向上限制，如&lt;? extends Collection&gt;，还可以向下限制，如&lt;? super Double&gt;，表示类型只能接受Double及其上层父类类型，如Number、Object类型的实例。<br>3、泛型类定义可以有多个泛型参数，中间用逗号隔开，还可以定义泛型接口，泛型方法。这些都与泛型类中泛型的使用规则类似。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多态</title>
    <link href="/2019/11/06/Java%E5%A4%9A%E6%80%81/"/>
    <url>/2019/11/06/Java%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态?"></a>什么是多态?</h3><p>简单理解 : 看成一种事物多种形态</p><blockquote><p>Animal a1 = new Human();</p><p>a1是人？是动物？还是Bee？它的类型是什么？</p><ul><li>运行时类型：对象的真正类型，从上面代码来看就是等号‘=’右边的类型；</li><li>编译时类型：在编译的阶段，编译器在意的类型是等号 ‘=’ 左边的类型；</li><li>当编译时类型和运行时类型不一致时—&gt;产生多态。</li></ul></blockquote><blockquote><p>Animal a = new Human();<br>Human p = new Human();<br>多态的写法的好处 ： 可以屏蔽不同的子类之间的实现差异</p></blockquote><p><strong>字段没有覆写一说：实际开发中一般不会再子类中定义一个和父类同名的字段</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.Polymorphism;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;动物出行！\n&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> cn.kongwei_liao.<span class="hljs-type">Polymorphism</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><span class="hljs-meta">@Override</span><br>public void walk() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Human双足行走！\n&quot;</span>);<br>&#125;<br>public void playGames() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;人类A伟又在打电动哦！\n&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> cn.kongwei_liao.<span class="hljs-type">Polymorphism</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><span class="hljs-meta">@Override</span><br>public void walk() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Bee飞行！\n&quot;</span>);<br>&#125;<br>public void jiMi() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;小蜜蜂采集de花蜜，维尼可爱吃了！\n&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs awk">package cn.kongwei_liao.Polymorphism;<br><br>public class Test &#123;<br><br>public static void main(String[] args) &#123;<br><span class="hljs-regexp">//</span> TODO Auto-generated method stub<br>Object obj;<br>obj = new Animal();<br><span class="hljs-regexp">//</span>obj.walk();<span class="hljs-regexp">//</span>Error:The method walk() is undefined <span class="hljs-keyword">for</span> the type Object<br><br>Animal anm=new Animal();<br>anm.walk();<br><br>anm=new Human();<br>anm.walk();<br><span class="hljs-regexp">//</span>anm.playGames();<span class="hljs-regexp">//</span>Error:The method playGames() is undefined <span class="hljs-keyword">for</span> the type Animal<br><br>anm=new Bee();<br>anm.walk();<br><br>Human hu=new Human();<br>hu.playGames();<br><br><span class="hljs-regexp">//</span>Human hum = (Human)anm;<span class="hljs-regexp">//</span>anm引用Bee类型对象<br><span class="hljs-regexp">//</span>hum.walk();<br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassCastException: <br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>cn.kongwei_liao.Polymorphism.<br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>Bee cannot be cast to cn.kongwei_liao.Polymorphism.Human<br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>at cn.kongwei_liao.Polymorphism.Test.main(Test.java:<span class="hljs-number">20</span>)<br><br>Bee bee=(Bee)anm;<span class="hljs-regexp">//</span>anm当前引用Bee类型对象<br>bee.walk();<br>bee.jiMi();<br><br><span class="hljs-regexp">//</span>Human h=new Bee();<span class="hljs-regexp">//</span>Error:Type mismatch: cannot convert from Bee to Human<br><br>&#125;<br>&#125;<br>/*<br> * 编译过程：<br> * 第十四行Animal是Human的父类，编译器编译通过<br> * 第十五、十六行：(编译器把anm看成是Animal) 编译的时候会到anm的编译类型中找是否有walk方法和playGames方法;<br> * 如果没有,会继续向anm的编译类型的父类中一直向上找;<br> * 如果都没有找到,编译报错;<br> * 如果找到了编译通过(不会向下到子类中,找的时候就是编译的时候是不会执行代码的)。<br> * <br> * 运行过程：<br> * 第十五行：先到运行时类型(Person)找walk方法,如果找到就执行,否则就向上到父类中找并执行。<br> *<br> * 思考 : 有没有可能编译通过了,而运行找不到方法...    不可能!永远不会出现这种情况<br> */<br><br></code></pre></td></tr></table></figure><p><img src="/2019/11/06/Java%E5%A4%9A%E6%80%81/staticfunccx.png" alt="1"></p><p><img src="/2019/11/06/Java%E5%A4%9A%E6%80%81/1.png" alt="2"></p><h3 id="多态方法调用以及参数传递"><a href="#多态方法调用以及参数传递" class="headerlink" title="多态方法调用以及参数传递"></a>多态方法调用以及参数传递</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> cn.kongwei_liao.<span class="hljs-type">Polymorphism</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><span class="hljs-meta">@Override</span><br>public void walk() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Bee飞行！&quot;</span>);<br>&#125;<br>public void jiMi() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;小蜜蜂采集de花蜜，维尼可爱吃了！&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> cn.kongwei_liao.<span class="hljs-type">Polymorphism</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bee1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bee</span></span>&#123;<br>public void jiMi() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Bee1采集de槐树花蜜！&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.Polymorphism;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bee2</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jiMi</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Bee2采集de油菜花蜜！&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.kongwei_liao.Polymorphism;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">walk</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Human双足行走！&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">playGames</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;人类A伟又在打电动哦！&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">have</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-comment">//Error:The method have() of type Human must override or implement a supertype method</span><br>System.out.println(<span class="hljs-string">&quot;Human吃饭！&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">have</span>(<span class="hljs-params">Bee bee</span>)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;吃&quot;</span>);<br>bee.jiMi();<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> cn.kongwei_liao.Polymorphism;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><br>Bee bee1=<span class="hljs-keyword">new</span> <span class="hljs-type">Bee</span>();<br>Bee bee2=<span class="hljs-keyword">new</span> <span class="hljs-type">Bee</span>();<br><br>hu.have(bee1);<span class="hljs-comment">//Human.have(Bee bee):传入Bee的继承类Bee1的对象，但调用的是Bee的jiMi()</span><br>hu.have(bee2);<br><br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*编译，或者传递的过程中传递的是对象的地址；</span><br><span class="hljs-comment">*运行结果：看谁（真正的对象）在调用jiMi()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/06/Java%E5%A4%9A%E6%80%81/%E5%A4%9A%E6%80%81%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8.png" alt="3"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面对对象</tag>
      
      <tag>多态</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一讲：为什么学习网络协议</title>
    <link href="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <url>/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>第1讲 | 为什么要学习网络协议？</p><p>《圣经》中有一个通天塔的故事，大致是说，上帝为了阻止人类联合起来，就让人类说不同的语言。人类 没法儿沟通，达不成“协议”，通天塔的计划就失败了。 但是千年以后，有一种叫“程序猿”的物种，敲着一种这个群体通用的语言，连接着全世界所有的人，打 造这互联网世界的通天塔。如今的世界，正是因为互联网，才连接在一起。 当 “Hello World!” 从显示器打印出来的时候，还记得你激动的心情吗？ public class </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">HelloWorld &#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123; <br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>); <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>如果你是程序员，一定看得懂上面这一段文字。这是每一个程序员向计算机世界说“你好，世界”的方 式。但是，你不一定知道，这段文字也是一种协议，是人类和计算机沟通的协议，只有通过这种协议，计 算机才知道我们想让它做什么。 协议三要素 当然，这种协议还是更接近人类语言，机器不能直接读懂，需要进行翻译，翻译的工作教给编译器，也就 是程序员常说的 compile。这个过程比较复杂，其中的编译原理非常复杂，我在这里不进行详述。  </p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/1.png" alt="1"></p><p>但是可以看得出，计算机语言作为程序员控制一台计算机工作的协议，具备了<code>协议的三要素</code>。</p><ul><li><code>语法</code>，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。 </li><li><code>语义</code>，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来 说就没有意义。 </li><li><code>顺序</code>，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。</li></ul><p>会了计算机语言，你就能够教给一台计算机完成你的工作了。恭喜你，入门了！ </p><p>但是，要想打造互联网世界的通天塔，只教给一台机器做什么是不够的，你需要学会教给一大片机器做什 么。这就需要网络协议。只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。 </p><p>这个时候，你可能会问，网络协议长啥样，这么神奇，能干成啥事？我先拿一个简单的例子，让你尝尝鲜，然后再讲一个大事。 </p><p>当你想要买一个商品，常规的做法就是打开浏览器，输入购物网站的地址。浏览器就会给你显示一个缤纷 多彩的页面。 </p><p>那你有没有深入思考过，浏览器是如何做到这件事情的？它之所以能够显示缤纷多彩的页面，是因为它收 到了一段来自 HTTP 协议的“东西”。我拿网易考拉来举例，格式就像下面这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.1 200 OK <br>Date: Tue, 27 Mar 2018 16:50:26 GMT <br>Content-Type: text/html;charset=UTF-8 <br>Content-Language: zh-CN <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://pages.kaola.com/&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span> 网易考拉 3 周年主会场 <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>这符合协议的三要素吗？我带你来看一下。 </p><ul><li>首先，符合语法，也就是说，只有按照上面那个格式来，浏览器才认。例如，上来是状态，然后是首部， 然后是内容。 </li><li>第二，符合语义，就是要按照约定的意思来。例如，状态 200，表述的意思是网页成功返回。如果不成功，就是我们常见的“404”。 </li><li>第三，符合顺序，你一点浏览器，就是发送出一个 HTTP 请求，然后才有上面那一串 HTTP 返回的东西。 浏览器显然按照协议商定好的做了，后一个五彩缤纷的页面就出现在你面前了。 我们常用的网络协议有哪些？ </li></ul><p>接下来揭秘我要说的大事情，“双十一”。这和我们要讲的网络协议有什么关系呢？ </p><p>在经济学领域，有个伦纳德∙里德（Leonard E. Read）创作的《铅笔的故事》。这个故事通过一个铅笔的 诞生过程，来讲述复杂的经济学理论。这里，我也用一个下单的过程，看看互联网世界的运行过程中，都 使用了哪些网络协议。 </p><p>你先在浏览器里面输入 <a href="https://www.kaola.com/">https://www.kaola.com</a> ，这是一个URL。浏览器只知道名字 是“<a href="http://www.kaola.com”,但是不知道具体的地点,所以不知道应该如何访问.于是,它打开地址簿去查/">www.kaola.com”，但是不知道具体的地点，所以不知道应该如何访问。于是，它打开地址簿去查</a> 找。可以使用一般的地址簿协议DNS（本地DNS？）去查找，还可以使用另一种更加精准的地址簿查找协议HTTPDNS（DNS服务器）。 无论用哪一种方法查找，终都会得到这个地址：106.114.138.24。这个是IP地址，是互联网世界的“门牌号”。</p><p>知道了目标地址，浏览器就开始打包它的请求。对于普通的浏览请求，往往会使用HTTP协议；但是对于购物的请求，往往需要进行加密传输，因而会使用HTTPS协议。无论是什么协议，里面都会写明“你要买什么和买多少”。 </p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/2.png" alt="2"></p><p>DNS、HTTP、HTTPS 所在的层我们称为应用层。经过应用层封装后，浏览器会将应用层的包交给下一层 去完成，通过<code> socket编程</code>来实现。下一层是传输层。传输层有两种协议，一种是<code>无连接的协议UDP</code>，一 种是<code>面向连接的协议TCP</code>。对于支付来讲，往往使用 TCP 协议。所谓的面向连接就是，TCP 会保证这个包 能够到达目的地。如果不能到达，就会重新发送，直至到达。 </p><p>TCP 协议里面会有两个<code>端口</code>，一个是<code>浏览器监听的端口</code>，一个是电商的<code>服务器监听的端口</code>。操作系统往往通过端口来判断，它得到的包应该给哪个进程。</p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/3.png" alt="3"></p><p>传输层封装完毕后，浏览器会将包交给操作系统的网络层。网络层的协议是<code> IP 协议</code>。在 IP 协议里面会有<code>源IP地址</code>，即浏览器所在机器的IP地址和<code>目标IP地址</code>，也即电商网站所在服务器的IP地址。</p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/4.png" alt="4"></p><p>操作系统既然知道了目标 IP 地址，就开始想如何根据这个门牌号找到目标机器。操作系统往往会判断，这 个目标 IP 地址是本地人，还是外地人。如果是本地人，从门牌号就能看出来，但是显然电商网站不在本 地，而在遥远的地方。</p><p>操作系统知道要离开本地去远方。虽然不知道远方在何处，但是可以这样类比一下：如果去国外要去海 关，去外地就要去网关。而操作系统启动的时候，就会被 <code>DHCP 协议配置 IP 地址</code>，以及<code>默认的网关的 IP地址 192.168.1.1</code>。 </p><p>操作系统如何将 IP 地址发给网关(网关在本地)呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是 192.168.1.1  啊？网关会回答它，我就是，我的本地地址在村东头。这个本地地址就是MAC地址，而大吼的那一声是 ARP协议。</p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/5.png" alt="5"></p><p>于是操作系统将 IP 包交给了下一层，也就是MAC 层。网卡再将包发出去。由于这个包里面是有 MAC 地 址的，因而它能够到达网关。 </p><p>网关收到包之后，会根据自己的知识，判断下一步应该怎么走。<code>网关往往是一个路由器</code>，到某个 IP 地址应该怎么走，这个叫作<code>路由表</code>。 </p><p>路由器有点像玄奘西行路过的一个个国家的一个个城关。每个城关都连着两个国家，每个国家相当于一个 局域网，在每个国家内部，都可以使用本地的地址 MAC 进行通信。 </p><p>一旦跨越城关，就需要拿出 IP 头来，里面写着贫僧来自东土大唐（就是源 IP 地址），欲往西天拜佛求经 （指的是目标 IP 地址）。路过宝地，借宿一晚，明日启行，请问接下来该怎么走啊？ </p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/6.png" alt="6"></p><p>城关往往是知道这些“知识”的，因为城关和临近的城关也会经常沟通。到哪里应该怎么走，这种沟通的协议称为<code>路由协议</code>，常用的有<code>OSPF</code>和<code>BGP</code>。 </p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/7.png" alt="7"></p><p>城关与城关之间是一个国家，当网络包知道了下一步去哪个城关，还是要使用国家内部的 MAC 地址，通过下一个城关的 MAC 地址，找到下一个城关，然后再问下一步的路怎么走，一直到走出最后一个城关。 最后一个城关知道这个网络包要去的地方。于是，对着这个国家吼一声，谁是目标 IP 啊？目标服务器就会 回复一个 MAC 地址。网络包过关后，通过这个 MAC 地址就能找到目标服务器。 </p><p>目标服务器发现 MAC 地址对上了，取下 MAC 头来，发送给操作系统的网络层。发现 IP 也对上了，就取 下 IP 头。IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即TCP 层。</p><p>在这一层（TCP）里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是 TCP 层的一个说明，即收到之后的回复。当然这个回复，会沿着刚才来的方向走回去，报个平安。 </p><p>因为一旦出了国门，西行路上千难万险，如果在这个过程中，网络包走丢了，例如进了大沙漠，或者被强 盗抢劫杀害怎么办呢？因而到了要报个平安。 </p><p>如果过一段时间还是没到，发送端的 TCP 层会重新发送这个包，还是上面的过程，直到有一天收到平安到 达的回复。这个重试绝非你的浏览器重新将下单这个动作重新请求一次。对于浏览器来讲，就发送了一次 下单请求，TCP 层不断自己闷头重试。除非 TCP 这一层出了问题，例如连接断了，才轮到浏览器的应用层 重新发送下单请求。 </p><p>当网络包平安到达 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在 监听这个端口号，假设一个 Tomcat，将这个包发给电商网站。 </p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/8.png" alt="8"></p><p>电商网站的进程得到 HTTP 请求的内容，知道了要买东西，买多少。往往一个电商网站初接待请求的这 个 Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。例如，这个接待员要告 诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉 支付的进程，应该付多少钱，等等。 </p><p>如果告诉相关的进程呢？往往通过<code>RPC 调用</code>，即远程过程调用的方式来实现。远程过程调用就是当告诉管 理订单进程的时候，接待员不用关心中间的网络互连问题，会由 RPC 框架统一处理。RPC 框架有很多种， 有基于 HTTP 协议放在 HTTP 的报文里面的，有直接封装在 TCP 报文里面的。 </p><p>当接待员发现相应的部门都处理完毕，就回复一个 HTTPS 的包，告知下单成功。这个 HTTPS 的包，会像 来的时候一样，经过千难万险到达你的个人电脑，终进入浏览器，显示支付成功。 </p><p>小结 </p><p>看到了吧，一个简简单单的下单过程，中间牵扯到这么多的协议。而管理一大片机器，更是一件特别有技 术含量的事情。除此之外，像近比较火的云计算、容器、微服务等技术，也都需要借助各种协议，来达 成大规模机器之间的合作。 </p><p>我在这里列一下之后要讲的网络协议，之后我会按照从底层到上层的顺序来讲述。 </p><p><img src="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/9.png" alt="9"></p><p>上面的“双十一”故事只是为了给你一个大致的框架，这里面有些协议，我在故事里已经提到了，有些还 没有提到。在这门课的后一章，当所有的协议都讲过之后，我会再重新讲一遍这个故事，到时候你就能 明白更多的细节。</p><p>最后，学完了这一节，给你留一个问题吧。 当网络包到达一个城关的时候，可以通过路由表得到下一个城关的 IP 地址，直接通过 IP 地址找就可以 了，为什么还要通过本地的 MAC 地址呢？ 欢迎你留言和我讨论。趣谈网络协议，我们下期见！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java继承与包访问权限</title>
    <link href="/2019/11/05/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/"/>
    <url>/2019/11/05/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h3 id="Java继承与包访问权限"><a href="#Java继承与包访问权限" class="headerlink" title="Java继承与包访问权限"></a>Java继承与包访问权限</h3><p><img src="/2019/11/05/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/jicheng.png" alt="jicheng"></p><p><img src="/2019/11/05/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/override.png" alt="override"></p><p><img src="/2019/11/05/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/cp.png" alt="java"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.kongwei_liao.Inheritance;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> pubstr=<span class="hljs-string">&quot;Public Father String!\n&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> pristr=<span class="hljs-string">&quot;private Father String!\n&quot;</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> prostr=<span class="hljs-string">&quot;protected Father String!&quot;</span>;<br><br><span class="hljs-keyword">protected</span> Father_innerClass fif=<span class="hljs-keyword">new</span> Father_innerClass();<br><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;什么时候执行？Father类加载到内存的时候&quot;</span>);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getPubstr</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> pubstr;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setPubstr</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> pubstr</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.pubstr = pubstr;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getPristr</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> pristr;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setPristr</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> pristr</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.pristr = pristr;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getProstr</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> prostr;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setProstr</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> prostr</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.prostr = prostr;<br>&#125;<br><span class="hljs-keyword">public</span> Father_innerClass <span class="hljs-function"><span class="hljs-title">getFif</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> fif;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setFif</span>(<span class="hljs-params">Father_innerClass fif</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.fif = fif;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;private Father function 1!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> long <span class="hljs-function"><span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;public Father function 2!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func3</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;protected Father function 3!\n&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father_innerClass</span></span>&#123;<span class="hljs-comment">//Inner Class</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> pubstr=<span class="hljs-string">&quot;Public String!&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> pristr=<span class="hljs-string">&quot;private String!&quot;</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> prostr=<span class="hljs-string">&quot;protected String!&quot;</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;private Father_innerClass_function 1!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;public Father_innerClass_function 2!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func3</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;protected Father_innerClass_function 3!\n&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//public class Father_fake&#123;</span><br><span class="hljs-comment">////Error:The public type Father_fake must be defined in its own file</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//private class Father_infile&#123;</span><br><span class="hljs-comment">////Error:Illegal modifier for the class Father_infile; only public, abstract &amp; final are permitted</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//protected class Father_protected_infile() &#123;</span><br><span class="hljs-comment">////Error:Illegal modifier for the class Father_protected_infile; only public, abstract &amp; final are permitted</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father_abstract_inOfile</span></span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> pubstr=<span class="hljs-string">&quot;Public String!&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> pristr=<span class="hljs-string">&quot;private String!&quot;</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> prostr=<span class="hljs-string">&quot;protected String!&quot;</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;private function 1!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;public function 2!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func3</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;protected function 3!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//private abstract void func4();//Error:The abstract method func5 in type Father_abstract_inOfile can only set a visibility modifier, one of public or protected</span><br><span class="hljs-comment">//public final abstract void func4();//Error:The abstract method func5 in type Father_abstract_inOfile can only set a visibility modifier, one of public or protected</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">void</span> func4();<br>&#125;<br><br>final <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father_final_inOfile</span></span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> pubstr=<span class="hljs-string">&quot;Public String!&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> pristr=<span class="hljs-string">&quot;private String!&quot;</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">String</span> prostr=<span class="hljs-string">&quot;protected String!&quot;</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;private function 1!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;public function 2!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">func3</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;protected function 3!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//public abstract void func4();//The abstract method func4 in type Father_final_inOfile can only be defined by an abstract class</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs awk">package cn.kongwei_liao.Inheritance;<br><br>public class Son extends Father&#123;<br><span class="hljs-regexp">//</span>public String pubstr = <span class="hljs-string">&quot;public Son String!\n&quot;</span>;<br><span class="hljs-regexp">//</span>private String pristr = <span class="hljs-string">&quot;private Son String!\n&quot;</span>;<br><span class="hljs-regexp">//</span>protected String prostr = <span class="hljs-string">&quot;protected Son String!\n&quot;</span>;<br><br>public String pubSonstr;<br>private String priSonstr;<span class="hljs-regexp">//</span>属性不赋初值null<br>protected String proSonstr;<br><br>public Son() &#123;<br><span class="hljs-regexp">//</span>super();<br>System.out.println(<span class="hljs-string">&quot;new创建对象的时候执行&quot;</span>);<br>pubstr=<span class="hljs-string">&quot;从父类继承来public的pubstr!\n&quot;</span>;<br>prostr=<span class="hljs-string">&quot;从父类继承来protected的prostr!\n&quot;</span>;<br><span class="hljs-regexp">//</span>pristr=<span class="hljs-string">&quot;从父类继承不来private的pristr!\n&quot;</span>;<span class="hljs-regexp">//</span>Error:The field Father.pristr is not visible<br><br>pubSonstr=super.pubstr;<br><span class="hljs-regexp">//</span>priSonstr=super.pristr;<span class="hljs-regexp">//</span>Error:The field Father.pristr is not visible<br>proSonstr=super.prostr;<br><br>System.out.println(<span class="hljs-string">&quot;priSonstr初始化：&quot;</span> + priSonstr);<br>&#125;<br>public Son(String str)&#123;<br>this();<br><span class="hljs-regexp">//</span>super();<span class="hljs-regexp">//</span>ErrorConstructor call must be the first statement <span class="hljs-keyword">in</span> a constructor<br><span class="hljs-regexp">//</span>从上面两行代码看出this和super调用构造方法同时只能存在一个<br>&#125;<br>&#123;<br><br><span class="hljs-regexp">//</span>this();<span class="hljs-regexp">//</span>Error:Constructor call must be the first statement <span class="hljs-keyword">in</span> a constructor<br>System.out.println(<span class="hljs-string">&quot;什么时候执行？Son类加载到内存的时候&quot;</span>);<br>&#125;<br><br>@Override<br>public long func2() &#123;<br>System.out.println(<span class="hljs-string">&quot;重写父类继承来的public的func2()方法！\n&quot;</span>);<br>return <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-regexp">//</span>@Override<br><span class="hljs-regexp">//</span>public int func2() &#123;<span class="hljs-regexp">//</span>Error:The return type is incompatible with Father.func2()<br><span class="hljs-regexp">//</span>System.out.println(<span class="hljs-string">&quot;重写父类继承来的public的func2()方法！\n&quot;</span>);<br><span class="hljs-regexp">//</span>return <span class="hljs-number">0</span>;<br><span class="hljs-regexp">//</span>&#125;<br><span class="hljs-regexp">//</span>在JAVA中，可以在同一个类中存在多个函数，函数名称相同但参数列表不同（参数的数量不同、或数量相同而类型和次序不同，以方便JVM区分到底调用哪个函数）。这就是函数的重载（overlording）。这是类的多态性表现之一。<br><br><br><span class="hljs-regexp">//</span>“重载”不同于“重写”<br><span class="hljs-regexp">//</span>“重写（覆盖）”概念存在于继承关系中，子类可继承父类中的方法而不需要单独编辑，这提供便捷化。但有的时侯，子类不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。<br><span class="hljs-regexp">//</span>父类中存在一个函数，子类中也存在一个同名函数，在了类中对函数重新编辑，做得更具体化。<br><span class="hljs-regexp">//</span>重写的规则：<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>、在子类中可以根据需要对从父类中继承来的方法进行重写。<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>、重写的方法和被重写的方法必须具有相同方法名称、参数列表和返回类型。<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>、重写方法不能使用比被重写的方法更严格的访问权限。<br>public void func2(String str) &#123;<br>System.out.println(<span class="hljs-string">&quot;重写父类继承来的public的func2()方法！\n&quot;</span>);<br>&#125;<br><br><br>public static void main(String[]args) &#123;<br><br>Son son=new Son();<span class="hljs-regexp">//</span>Father和Son类先后加载进内存，然后创建Son实例<br>Default dft=new Default();<br><br>System.out.print(son.pubstr);<br><span class="hljs-regexp">//</span>System.out.print(son.pristr);<span class="hljs-regexp">//</span>Error:The field Father.pristr is not visible<br>System.out.print(son.prostr);<br><br><span class="hljs-regexp">//</span>son.func1();<span class="hljs-regexp">//</span>Error:The method func1() from the type Father is not visible<br>son.func2();<br>son.func3();<br><br><span class="hljs-regexp">//</span>son.fif.func1();<span class="hljs-regexp">//</span>Error:The method func1() from the type Father_innerClass is not visible<br>son.fif.func2();<br>son.fif.func3();<br><br>System.out.println(son.getProstr());<span class="hljs-regexp">//</span>打印：从父类继承来protected的prostr!<br><br>&#125;<br>&#125;<br><br><br>class InhDefault extends Default&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> cn.kongwei_liao.Inheritance;<br><br><span class="hljs-keyword">class</span> <span class="hljs-keyword">Default</span> &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">package cn.kongwei_liao.InhDef;<br><span class="hljs-regexp">//im</span>port cn.kongwei_liao.Inheritance.*;<br><br><span class="hljs-regexp">//</span>public class InhDef extends cn.kongwei_liao.Inheritance.Default&#123;<span class="hljs-regexp">//</span>Error:The type cn.kongwei_liao.Inheritance.Default is not visible<br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span>&#125;<br><br><span class="hljs-regexp">//</span>public class InhDef extends cn.kongwei_liao.Inheritance.Father&#123;<br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>OK<br><span class="hljs-regexp">//</span>&#125;<br>public class InhDef extends cn.kongwei_liao.Inheritance.Son&#123;<br><span class="hljs-regexp">//</span>Ok<br>&#125;<br><br><span class="hljs-regexp">//</span>public class InhDef extends cn.kongwei_liao.Inheritance.InhDefault&#123;<br><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>The type cn.kongwei_liao.Inheritance.InhDefault is not visible，类InhDefault是在Son.java中编写的default类<br><span class="hljs-regexp">//</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承的注意事项："><a href="#继承的注意事项：" class="headerlink" title="继承的注意事项："></a>继承的注意事项：</h3><p>可以重复利用代码</p><p>非私有的字段（非private字段）和方法可以被继承到  </p><p>广义上来说,私有的字段… 是可以被继承到的，同过get、set方法</p><p>Java中类的继承只能够是单继承(一个类只能够有一个直接父类) 一个人只能够有一个亲爹  </p><p>可以支持多重继承(多层级的继承), 一个类可以有子类,子类还可以子类… 子子孙孙无穷尽也…</p><p>每一个类都有一个直接父类,如果没有看到显示的继承代码,那么就隐式继承就Object</p><p>子类覆写了父类的方法,子类中还有(还可以调用)父类中的方法吗?        <strong>super</strong></p><blockquote><p>@Override注解：</p><p>当注释用，方便阅读；<br>    提高可读性；<br>    让编译器执行检查方法的正确性，要求该类必须重写父类的方法，即@Override下面的方法名是否是父类中所有的，如果没有则报错；</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>public void test()&#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br><span class="hljs-meta">@Override</span><br>public void test()&#123;&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：将@Override注释去掉的话，编译器会默认创建了新的方法</p></blockquote><p>阿里的Java开发手册中将加@Override 注解规定为强制，其相应说明如下：getObject()与 get0bject()的问题。一个是字母的O，一个是数字的 0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错</p><pre><code>子类与父类有符合覆写规定的方法时，不加@Override 注解，也是能够覆写的，但是在实际使用时可能会产生一些疑问，到底是调用父类的方法还是子类覆写后的方法呢。而加上注解能增加代码的可读性，看到标签就知道这是从父类重写的方法，在调用时也将调用重写后的方法。并且使用@Override可以准确判断是否覆盖成功。</code></pre><p>子类要想覆写父类的方法，除了方法名和参数列表一样之外，还有以下的注意事项：</p><pre><code>1.被覆盖方法的访问控制级别可以不一样。     例如上例父类的show方法的访问级别为protected的，而子类覆盖的show方法访问级别则为public的。    但子类的访问级别必须要高于父类被覆盖方法的访问级别，如果父类是public的而子类是protected的则是错误的。private &lt; default &lt; public2.方法被定义为private或static或final的则不能被覆盖。3.方法的返回类型。    覆写的方法名称，返回类型，参数及类型必须一致。这里，返回类型其实可以不一样，但类型有限制。    基本数据类型做返回值时，重写方法返回值必须一致。    子类的返回类型可以是更具体的对象，例如可以将Employee类的返回类型改为Object也正确。而倒过来则错误。4.在方法调用时先会在子类中找覆写的方法，如果子类中没有则会在父类中去找。5.方法主体:方法覆写,子类方法和父类方法主体是否可以一样, 可以! 但是没有什么用!</code></pre><p><strong>Static静态变量</strong></p><p>变量分类：</p><ul><li>成员变量 ： 直接定义在类中</li><li>局部变量 ： 除了成员变量之外的都是局部变量（方法内部，形参，代码块中…）</li></ul><p>-————————-</p><p>另一种分类方式：是否有static</p><p>​                    是否有static修饰     生命周期（开始）      生命周期（开始）</p><ul><li>局部变量        没有               方法被调用的时候       方法执行完了</li><li>实例变量        没有                 创建对象的时候          对象被销毁</li><li>类变量              有                  类被加载的时候            类被卸载</li></ul><p>备注：</p><p>1、实例变量和类变量都是属于成员变量</p><p>2、类成员（一般指的是有static修饰的字段或者方法）</p><p>类中的成员（字段，方法，构造方法，内部类。。。）</p><p><strong>访问权限修饰符</strong></p><p>访问权限修饰符的作用</p><p>① 成员 ： private          默认不写（default）          protected             public </p><p>② 作用 ： 主要是控制类以及<strong>类中成员</strong>的访问权限</p><table><thead><tr><th></th><th>同类</th><th>同包</th><th>子类</th><th>公共</th></tr></thead><tbody><tr><td>private(私有)</td><td>√</td><td></td><td></td><td></td></tr><tr><td>默认不写</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected(受保护)</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public(公共)</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><blockquote><p>主要是修饰类中的成员（字段、方法、构造方法、及内部类）;</p><p>public  (默认default)  可以修饰类；</p><p>private   protedted   不能够修饰类（外部类）；</p><p>所有访问权限修饰符都不能够修饰局部变量。</p></blockquote><p><img src="/2019/11/05/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/%E8%AE%BF%E6%9D%83.png" alt="fq"></p><p>访问权限的总结</p><p>① 外部类只能够使用public 或者默认不写； 一般都是public</p><p>② 类中的成员（字段，构造方法，方法）以及内部类是可以使用任何一个</p><p>③ 理论上讲，我们在个成员设置权限的使用应该有小到大逐步放开（实际开发中很多是使用private 或者public）</p><p>④ 访问方式和访问权限不是同一个东西</p><p><strong>this</strong></p><p>① this 表示当前对象(当前对象的地址);</p><p>② 如何判断当前对象时谁? 看this所在的方法正在被谁调用;</p><p>③ 使用场景-1 : 通过this访问当前对象中的成员(字段,方法);</p><p>④ 使用场景-2 :本类中构造方法之间的相互调用;</p><p>this(); 调用本类中无参数的构造方法;</p><p>this(123); 调用本类中具有一个int参数的构造方法;</p><p>必须放在构造器  中的  第一句;</p><p>⑤ 把this(当前对象)看成是一个数据, 就可以作为值返回,作为参数传递…</p><p><strong>什么是super</strong></p><p>何时会用到super? </p><p>在子类中访问父类中的成员（字段 方法 构造方法）。</p><p>①super 表示父类对象;</p><p>②使用场景-1 : 通过super访问父类对象中的成员(非私有字段和方法);</p><p>③使用场景-2 :在子类的构造方法里面访问父类的构造方法; 最常用的!!!!!!!!!!!!</p><p>super(); 调用父类无参数的构造方法;</p><p>super(123); 调用父类中具有一个int参数的构造方法;</p><p>必须是子类的构造方法中的第一句;</p><p>④ 上面的所有访问方式都必须是在有访问权限的条件之下;</p><p>⑤ 一般都会给一个类提供一个公共的无参数的构造方法便于拓展（继承）</p><p>super特殊使用场景 </p><p>在子类中的构造方法里面存在默认(隐式)的调用父类的无参数构造方法(默认只会调用无参数的构造方法);</p><p>如果有显示调用父类的构造方法,那么默认调用就不存在了;</p><p>需要测试的点: </p><p>子类中多个有参数的,默认是否调用父类=无参数的</p><p>父类中有多个构造方法</p><p>父类中只有一个有参数的,没有无参数的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span>  <span class="hljs-symbol">A</span>&#123;<br>   <span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>;   <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">B</span>&#123;<br>   <span class="hljs-built_in">int</span> x =<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Test</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">B</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">A</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> pX()&#123;<br>      <span class="hljs-comment">//System.out.println(x);//Error:The field x is ambiguous</span><br>  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">super</span>.x);<br>  System.<span class="hljs-keyword">out</span>.println(A.x);<br>   &#125;<br>   <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>      new Test().pX();<br>   &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印输出：</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>static</tag>
      
      <tag>访问权限（private、默认、protected和public）</tag>
      
      <tag>this</tag>
      
      <tag>super</tag>
      
      <tag>方法重载与重写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射之getInterfaces()方法</title>
    <link href="/2019/11/05/Java%E5%8F%8D%E5%B0%84%E4%B9%8BgetInterfaces-%E6%96%B9%E6%B3%95/"/>
    <url>/2019/11/05/Java%E5%8F%8D%E5%B0%84%E4%B9%8BgetInterfaces-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式:代理模式</title>
    <link href="/2019/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="设计模式-代理模式"><a href="#设计模式-代理模式" class="headerlink" title="设计模式:代理模式"></a>设计模式:代理模式</h3><p>分别用静态代理模式和动态代理模式实现模拟车站售票，代理车站售票。</p><p><img src="/2019/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/dail.png" alt="dail"></p><p>1、代理模式理解</p><ul><li><p>现实示例理解：当我们需要买火车票时，可以直接到火车站购买，可能不太便利，也可以去找附近的火车票代售点，让代售点帮我们去火车站购买。</p></li><li><p>Java中的解释：</p><ul><li>我们在调用一个类中的方法时，此时，可能需要对此方法的功能有所推展，但是并不想改变原有的封装。</li><li>此时，就是代理类进行对此方法进行功能的扩展，之后由代理类去调用目标方法。</li><li>如果不需要拓展功能，不使用代理类就可以了。</li></ul></li><li><p>代理模式涉及到四个要素：</p><ul><li>调用者：歌迷、合作商等；</li><li>代理对象：歌星助理；</li><li>目标对象（被代理对象）：歌星；</li><li>抽象对象：代理对象和目标对象都共有接口，保证代理对象和真实对象都有相应的功能，对应例子中歌星唱歌前可能需要和其他人谈合作，还要布置场地，唱歌后还要收钱等等由助理负责的事情。</li></ul></li></ul><p>2、静态代理实现：</p><ul><li>创建接口Subject，接口中创建sell()方法；</li><li>创建被代理类Station，实现Subject接口，实现sell方法；</li><li>创建代理类Proxy，实现Subject接口，属性为Station对象，实现sell方法；</li><li>创建购票者类User，创建buy()方法，调用Proxy对象的sell方法实现购票。</li></ul><p><img src="/2019/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxy.png" alt="pr"></p><p>3、动态代理实现：</p><ul><li>创建ProsyHandler代理处理类，实现由Java提供的对动态代理的支持的InvocationHandler接口，实现invoke()方法；（功能是在被代理类Station的sell()方法执行前后添加一些其它功能）</li><li>购票者类User中创建buy_dynamic()方法：<ul><li>创建Station对象station</li><li>创建ProxyHandler对象handler，调用构造方法时传入station对象作为参数；</li><li>调用<code>Java提供的Proxy类的静态方法</code>newProxyInstance()，生成代理对象proxy</li><li>调用proxy的sell()方法完成购票。</li></ul></li></ul><p>4、动态代理的特点：</p><ul><li>代理对象的生成是利用JDK的API，动态的在内存中构建代理对象（需要我们指定创建代理对象/目标对象实现的接口的类型）</li><li>于是，这里原有的方法在没有改变的情况下，对原来的方法进行了二次封装。有时候多个对象调用同一对象时，有着共同的需求，但是在共同需求里又有自己独特的需求，这时候这一部分独特的需求让代理类去处理。</li></ul><p><img src="/2019/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/dproxy.png" alt="dp"></p><p>技术分析</p><p>代理模式定义</p><p>静态代理模式</p><p>动态代理机制以及使用场景</p><p>代理模式实现售票功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Station</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets=<span class="hljs-number">10</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><span class="hljs-keyword">if</span>(tickets&gt;<span class="hljs-number">0</span>) &#123;<br>tickets--;<br>System.out.println(<span class="hljs-string">&quot;购票成功，剩余车票&quot;</span>+tickets);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;购票失败&quot;</span>);<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;<br><span class="hljs-keyword">private</span> Subject station;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyProxy</span><span class="hljs-params">(Subject station)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.station=station;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.println(<span class="hljs-string">&quot;静态代理&quot;</span>);<br>station.sell();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.Pattern;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> Object subject;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxyHandler</span><span class="hljs-params">(Object subject)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.subject=subject;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy,Method method,Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>System.out.println(<span class="hljs-string">&quot;动态代理&quot;</span>);<br>method.invoke(subject, args);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk">package cn.kongwei_liao.Pattern;<br><br>import java.lang.reflect.Proxy;<span class="hljs-regexp">//</span>Java提供Proxy类<br><br>public class User &#123;<br><br><span class="hljs-regexp">//</span>目标对象<br>Subject station=new Station();<span class="hljs-regexp">//</span>Subject是Station实现的接口<br><br>public void buy() &#123;<br><span class="hljs-regexp">//</span>目标对象<br><span class="hljs-regexp">//</span>Subject station=new Station();<span class="hljs-regexp">//</span>Subject是Station实现的接口<br><br><span class="hljs-regexp">//</span>代理对象<br>Subject proxy=new MyProxy(station);<span class="hljs-regexp">//</span>MyProxy也实现了Subject接口<br><br>proxy.sell();<br>&#125;<br>public void buy_dynamic() &#123;<br><span class="hljs-regexp">//</span>目标对象<br><span class="hljs-regexp">//</span>Subject station=new Station();<br><br><span class="hljs-regexp">//</span>代理处理器对象<br>ProxyHandler handler=new ProxyHandler(station);<span class="hljs-regexp">//</span>ProxyHandler实现了InvocationHandler接口的invoke方法<br><br><span class="hljs-regexp">//</span>代理对象，代理Subject station对象<br><span class="hljs-regexp">//</span>Object java.lang.reflect.Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException<br><span class="hljs-regexp">//</span>station.getClass()<span class="hljs-regexp">//g</span>etClass() 返回此 Object 的运行时Class类对象<br><span class="hljs-regexp">//</span>station.getClass().getClassLoader()<span class="hljs-regexp">//</span>ClassLoader主要对类的请求提供服务，当JVM需要某类时，它根据名称向ClassLoader要求这个类，然后由ClassLoader返回 这个类的class对象。<br><span class="hljs-regexp">//</span>station.getClass().getInterfaces()<span class="hljs-regexp">//</span>获得这个对象所实现的接口<br>Subject proxy=(Subject)Proxy.newProxyInstance(station.getClass().getClassLoader(),station.getClass().getInterfaces(),handler);<br>proxy.sell();<br>&#125;<br>public static void main(String[] args) &#123;<br>User user=new User();<br>user.buy();<br>user.buy();<br>user.buy_dynamic();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2019/11/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/pattern.png" alt="pattern"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java:用dom4j解析RSS文件</title>
    <link href="/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/"/>
    <url>/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="Java-用dom4j解析RSS文件"><a href="#Java-用dom4j解析RSS文件" class="headerlink" title="Java:用dom4j解析RSS文件"></a>Java:用dom4j解析RSS文件</h3><p>读取RSS存储在本机的符合RSS2.0标准格式要求的XML文件，逐条解析RSS文件中所有新闻项目并将新闻条目逐条的输出到控制台。</p><p><img src="/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/example.png" alt="ex"></p><p>1、下载RSS文件：浏览器访问新浪体育<a href="http://rss.sina.com.cn/news/allnews/sports.xml%E4%B8%8B%E8%BD%BD%60(%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%88%96%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E4%BF%9D%E5%AD%98)%60RSS%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82">http://rss.sina.com.cn/news/allnews/sports.xml下载`(下载工具下载，或浏览器查看源代码复制粘贴保存)`RSS文件到本地。</a></p><p>2、采用dom4j解析Xml，获取dom4j依赖包，访问<a href="https://dom4j.github.io/%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E3%80%82">https://dom4j.github.io/进行下载。</a></p><p><img src="/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/dom4jdl.png" alt="dom"></p><p>3、创建工程，导入dom4j依赖包</p><p><img src="/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/cj.png" alt="cj"></p><p>4、创建类，创建方法，用于实现RSS文件解析。</p><blockquote><p>（1）、读取XML文件，得到Document对象；</p><p>（2）、得到XML文档的根节点；</p><p>（3）、获得所需子节点；</p><p>（4）、获得结点内容并输出到控制台。</p></blockquote><h3 id="技术分析："><a href="#技术分析：" class="headerlink" title="技术分析："></a>技术分析：</h3><p>1、XML树结构</p><p>2、XML元素和属性</p><p>3、DOM4J解析XML</p><p><img src="/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/XML%E7%BB%93%E6%9E%84.png" alt="dom"></p><p><img src="/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/XML%E7%BB%93%E6%9E%842.png" alt="xm"></p><h3 id="项目完成结构"><a href="#项目完成结构" class="headerlink" title="项目完成结构"></a>项目完成结构</h3><p><img src="/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/xj.png" alt="xj"></p><p><img src="/2019/11/04/Java-%E7%94%A8dom4j%E8%A7%A3%E6%9E%90RSS%E6%96%87%E4%BB%B6/xj2.png" alt="xj2"></p><p><strong>完整代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package cn.kongwei_liao.cnmb;<br><br><span class="hljs-keyword">import</span> java.io.<span class="hljs-built_in">File</span>;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.dom4j.Document;<br><span class="hljs-keyword">import</span> org.dom4j.DocumentException;<br><span class="hljs-keyword">import</span> org.dom4j.Element;<br><span class="hljs-keyword">import</span> org.dom4j.io.SAXReader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseRss</span> &#123;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> filePath=<span class="hljs-string">&quot;NewFile/sports.xml&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>ParseRss parseRss=<span class="hljs-keyword">new</span> ParseRss();<br>parseRss.parse();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;<br>Document doc=null;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//获取Xml文件</span><br><span class="hljs-built_in">File</span> fXml=<span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(filePath);<br><span class="hljs-comment">//判断文件是否存在</span><br><span class="hljs-keyword">if</span>(fXml.<span class="hljs-built_in">exists</span>()&amp;&amp;fXml.isFile()) &#123;<br><span class="hljs-comment">//使用Dom4j解析器</span><br>SAXReader reader=<span class="hljs-keyword">new</span> SAXReader();<br><span class="hljs-comment">//加载XML文件，得到Document对象</span><br>doc =reader.<span class="hljs-built_in">read</span>(fXml);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span>(DocumentException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br>Element root=doc.getRootElement();<br>Element eChannel=root.element(<span class="hljs-string">&quot;channel&quot;</span>);<br>List&lt;Element&gt; itemList=eChannel.elements(<span class="hljs-string">&quot;item&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;itemList.<span class="hljs-built_in">size</span>();i++) &#123;<br>Element item = itemList.<span class="hljs-built_in">get</span>(i);<br><span class="hljs-comment">//获得内容结点</span><br><span class="hljs-keyword">String</span> title=item.elementText(<span class="hljs-string">&quot;title&quot;</span>).trim();<br><span class="hljs-keyword">String</span> author=item.elementText(<span class="hljs-string">&quot;author&quot;</span>).trim();<br><span class="hljs-keyword">String</span> pubDate=item.elementText(<span class="hljs-string">&quot;pubDate&quot;</span>).trim();<br><span class="hljs-keyword">String</span> category=item.elementText(<span class="hljs-string">&quot;category&quot;</span>).trim();<br><span class="hljs-keyword">String</span> description=item.elementText(<span class="hljs-string">&quot;description&quot;</span>).trim();<br><span class="hljs-comment">//输出到控制台</span><br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;News:\n新闻标题：&quot;</span> + title +<br><span class="hljs-string">&quot;\n新闻作者：&quot;</span> + author + <span class="hljs-string">&quot;\n新闻板块：&quot;</span> + category + <br><span class="hljs-string">&quot;\n发布时间：&quot;</span>+pubDate + <span class="hljs-string">&quot;\n新闻描述：&quot;</span> + description + <br><span class="hljs-string">&quot;\n-----------&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java反射生成HTML</title>
    <link href="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/"/>
    <url>/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/</url>
    
    <content type="html"><![CDATA[<h3 id="Java反射生成HTML文件"><a href="#Java反射生成HTML文件" class="headerlink" title="Java反射生成HTML文件"></a>Java反射生成HTML文件</h3><h4 id="1、分析"><a href="#1、分析" class="headerlink" title="1、分析"></a>1、分析</h4><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/xq.png" alt="xq"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/xq2.png" alt="xq2"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/xq3.png" alt="xq3"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/xq4.png" alt="xq4"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/xq5.png" alt="xq5"></p><h4 id="2、设计思路"><a href="#2、设计思路" class="headerlink" title="2、设计思路"></a>2、设计思路</h4><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sjsl.png" alt="sjsl"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sjsl2.png" alt="sjsl2"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sjsl3.png" alt="sjsl3"></p><h4 id="3、技术分析"><a href="#3、技术分析" class="headerlink" title="3、技术分析"></a>3、技术分析</h4><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/jsfx.png" alt="jsfx"></p><h4 id="4、实现步骤"><a href="#4、实现步骤" class="headerlink" title="4、实现步骤"></a>4、实现步骤</h4><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx.png" alt="sx"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx2.png"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx3.png" alt="sx3"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx4.png" alt="sx4"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx5.png" alt="sx5"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx6.png" alt="sx6"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx7.png" alt="sx7"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx8.png" alt="sx8"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx9.png" alt="sx9"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx10.png" alt="sx10"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx11.png" alt="sx11"></p><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/sx12.png" alt="sx12"></p><h3 id="包package-cn-kongwei-liao-cnmb-下创建Person类"><a href="#包package-cn-kongwei-liao-cnmb-下创建Person类" class="headerlink" title="包package cn.kongwei_liao.cnmb;下创建Person类"></a>包package cn.kongwei_liao.cnmb;下创建Person类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.kongwei_liao.cnmb;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Calendar;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> com.annotation.html.*;<br><br><span class="hljs-meta">@HtmlPage</span>(value=<span class="hljs-string">&quot;person.html&quot;</span>,title=<span class="hljs-string">&quot;个人信息&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br><span class="hljs-meta">@HtmlField</span>(label=<span class="hljs-string">&quot;姓名&quot;</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br><br><span class="hljs-meta">@HtmlField</span>(label=<span class="hljs-string">&quot;手机&quot;</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> mobiles;<br><br><span class="hljs-meta">@HtmlField</span>(label=<span class="hljs-string">&quot;年龄&quot;</span>)<br><span class="hljs-keyword">private</span> int age;<br><br><span class="hljs-meta">@HtmlField</span>(label=<span class="hljs-string">&quot;出生年月&quot;</span>,format=<span class="hljs-string">&quot;formatBirth&quot;</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">Date</span> birth;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getMobiles</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> mobiles;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setMobiles</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> mobiles</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.mobiles = mobiles;<br>&#125;<br><span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setAge</span>(<span class="hljs-params">int age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">Date</span> <span class="hljs-function"><span class="hljs-title">getBirth</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> birth;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setBirth</span>(<span class="hljs-params"><span class="hljs-built_in">Date</span> birth</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.birth = birth;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">formatBirth</span>(<span class="hljs-params"></span>)</span> &#123;<br>SimpleDateFormat sdf=<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;y年M月d日&quot;</span>);<br><span class="hljs-keyword">return</span> sdf.format(<span class="hljs-built_in">this</span>.birth);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setBirth</span>(<span class="hljs-params">int y,int m,int d</span>)</span> &#123;<br>Calendar calendar=Calendar.getInstance();<br>calendar.set(y, m-<span class="hljs-number">1</span>, d);<br><span class="hljs-built_in">this</span>.birth=calendar.getTime();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="包package-com-annotation-html-下创建HtmlPage注解类和HtmlField注解类"><a href="#包package-com-annotation-html-下创建HtmlPage注解类和HtmlField注解类" class="headerlink" title="包package com.annotation.html;下创建HtmlPage注解类和HtmlField注解类"></a>包package com.annotation.html;下创建HtmlPage注解类和HtmlField注解类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 设计思路：</span><br><span class="hljs-comment"> * 1、通过自定义注解类，标注出页面的名称，编码规范，以及那些字段需要用来显示，每一个字段的名称和值</span><br><span class="hljs-comment"> * 2、通过Java中的反射机制，来动态获得类中的注解类对象</span><br><span class="hljs-comment"> * 3、通过读取注解类对象中的属性值作为生成HTML文件的参数</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 自定义注解类</span><br><span class="hljs-comment"> * 注解页面信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> com.annotation.html;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.ElementType.TYPE;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Target(TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> HtmlPage &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">lang</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;zh&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">charset</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;utf-8&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">title</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 设计思路：</span><br><span class="hljs-comment"> * 1、通过自定义注解类，标注出页面的名称，编码规范，以及那些字段需要用来显示，每一个字段的名称和值</span><br><span class="hljs-comment"> * 2、通过Java中的反射机制，来动态获得类中的注解类对象</span><br><span class="hljs-comment"> * 3、通过读取注解类对象中的属性值作为生成HTML文件的参数</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 自定义注解类</span><br><span class="hljs-comment"> * 注解类中哪些字段在页面显示</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> com.annotation.html;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Inherited;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> HtmlField &#123;<br><span class="hljs-comment">//public String value() default &quot;&quot;;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">label</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="包package-com-annotation-html-下创建HtmlGenerator类用于解析注解，生成html页面"><a href="#包package-com-annotation-html-下创建HtmlGenerator类用于解析注解，生成html页面" class="headerlink" title="包package com.annotation.html;下创建HtmlGenerator类用于解析注解，生成html页面"></a>包package com.annotation.html;下创建HtmlGenerator类用于解析注解，生成html页面</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 用来读取实体类对象中的注解信息，生成HTML</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> com.annotation.html;<br><br><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.<span class="hljs-keyword">File</span>;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> cn.kongwei_liao.cnmb.Person;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HtmlGenerator &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> createDetailPage(Object obj)&#123;<br><span class="hljs-comment">//1、得到对象的类型对象</span><br><span class="hljs-keyword">Class</span>&lt;?&gt; clz=obj.getClass();<span class="hljs-comment">//反射API，获得对象类型</span><br><span class="hljs-comment">//获取实例对象对应的Class对象  有三种方法</span><br><span class="hljs-comment">//Class&lt;?&gt; clz1=null;//通过类Class的静态方法forName()</span><br><span class="hljs-comment">//try &#123;</span><br><span class="hljs-comment">//clz1=Class.forName(&quot;cn.kongwei_liao.cnmb.Person&quot;);</span><br><span class="hljs-comment">//&#125; catch (ClassNotFoundException e1) &#123;</span><br><span class="hljs-comment">//// TODO Auto-generated catch block</span><br><span class="hljs-comment">//e1.printStackTrace();</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//Class&lt;?&gt; clz2=Person.class;//直接给出对象类文件名</span><br>assert(clz!=<span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment">//2、通过类型得到当前类中的HtmlPage注解类</span><br>HtmlPage htmlPage=clz.getAnnotation(HtmlPage.<span class="hljs-keyword">class</span>);<span class="hljs-comment">//反射API，获得注解对象，获取某个类型的注解</span><br><span class="hljs-comment">//Annotation[] htmlPages=clz.getDeclaredAnnotations();//获取声明的注解（不包括父类中被Inherited修饰的注解）</span><br>assert(htmlPage!=<span class="hljs-keyword">null</span>);<br><span class="hljs-comment">//读取HtmlPage对象中的属性</span><br><span class="hljs-comment">//System.out.println(htmlPage.value());</span><br><br><span class="hljs-comment">//3、读取htmlPage中的value属性，创建html文件</span><br><span class="hljs-keyword">File</span> page =<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(htmlPage.value());<br><span class="hljs-keyword">if</span>(!page.exists()) &#123;<br><span class="hljs-comment">//System.out.println(1);</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//System.out.println(2);</span><br>assert(page.createNewFile()==<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">//System.out.println(3);</span><br>&#125;<span class="hljs-keyword">catch</span>(IOException e) &#123;<br><span class="hljs-comment">//System.out.println(4);</span><br>e.printStackTrace();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//4、创建文件BufferWriter对象</span><br>BufferedWriter writer=<span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><br><span class="hljs-comment">//5、向文件中写html标签</span><br>writer=<span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(page));<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>);<br>writer.<span class="hljs-keyword">write</span>(String.format(<span class="hljs-string">&quot;&lt;html lang=\&quot;%s\&quot;&gt;\n&quot;</span>,htmlPage.lang()));<br><br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;head&gt;\n&quot;</span>);<br>writer.<span class="hljs-keyword">write</span>(String.format(<span class="hljs-string">&quot;&lt;meta charset=\&quot;%s\&quot;&gt;\n&quot;</span>,htmlPage.charset()));<br>writer.<span class="hljs-keyword">write</span>(String.format(<span class="hljs-string">&quot;&lt;title&gt;%s&lt;/title&gt;\n&quot;</span>,htmlPage.title()));<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;/head&gt;\n&quot;</span>);<br><br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span>);<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;table&gt;\n&quot;</span>);<br><br>Field[] fields=clz.getDeclaredFields();<span class="hljs-comment">//反射API，获得类声明的所有字段</span><br><span class="hljs-keyword">for</span>(Field field:fields) &#123;<br>HtmlField htmlField=field.getDeclaredAnnotation(HtmlField.<span class="hljs-keyword">class</span>);<br><br><span class="hljs-keyword">if</span>(htmlField==<span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">continue</span>;<br>field.setAccessible(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将此对象的可访问标志设置为指示的布尔值，</span><br><span class="hljs-comment"> * 值true表示反射对象在使用时应禁止Java语言访问检查，</span><br><span class="hljs-comment"> * false值表示反射对象应强制执行Java语言访问检查。</span><br><span class="hljs-comment"> */</span><br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;tr&gt;&quot;</span>);<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;td&gt;&quot;</span>);<br>writer.<span class="hljs-keyword">write</span>(htmlField.label());<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>);<br><br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;td&gt;&quot;</span>);<br><br><span class="hljs-comment">//try &#123;</span><br><span class="hljs-comment">//Object value=field.get(obj);</span><br><span class="hljs-comment">//writer.write(value.toString());</span><br><span class="hljs-comment">//&#125;catch(IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="hljs-comment">//e.printStackTrace();</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//注释内容的改造</span><br><br>Object value=field.get(obj);<br>String fmt=htmlField.format();<br><span class="hljs-keyword">if</span>(fmt.length()&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><br>Method method=clz.getMethod(fmt);<span class="hljs-comment">//反射API，获得某一个方法对象</span><br>assert(method!=<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">try</span> &#123;<br>writer.<span class="hljs-keyword">write</span>(method.invoke(obj).toString());<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | IllegalArgumentException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span>(NoSuchMethodException | SecurityException | InvocationTargetException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>writer.<span class="hljs-keyword">write</span>(value.toString());<br>&#125;<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>);<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;/tr&gt;&quot;</span>);<br>&#125;<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;/table&gt;\n&quot;</span>);<br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span>);<br><br>writer.<span class="hljs-keyword">write</span>(<span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span>(IOException | IllegalArgumentException | IllegalAccessException e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>writer.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="包package-cn-kongwei-liao-cnmb-创建Test测试类"><a href="#包package-cn-kongwei-liao-cnmb-创建Test测试类" class="headerlink" title="包package cn.kongwei_liao.cnmb;创建Test测试类"></a>包package cn.kongwei_liao.cnmb;创建Test测试类</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> cn.kongwei_liao.cnmb;<br><br><span class="hljs-keyword">import</span> com.annotation.html.HtmlGenerator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args)&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>Person person=<span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>();<br>person.setAge(<span class="hljs-number">20</span>);<br>person.setBirth(<span class="hljs-number">2008</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>);<br>person.setMobiles(<span class="hljs-string">&quot;12345678901&quot;</span>);<br>person.setName(<span class="hljs-string">&quot;王宝强&quot;</span>);<br><br>HtmlGenerator generator=<span class="hljs-keyword">new</span> <span class="hljs-type">HtmlGenerator</span>();<br>generator.createDetailPage(person);<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="运行Test生成的html代码"><a href="#运行Test生成的html代码" class="headerlink" title="运行Test生成的html代码"></a>运行Test生成的html代码</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>个人信息<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>王宝强<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>手机<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>12345678901<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>出生年月<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2008年12月4日<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2019/11/04/Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90HTML/jieguo.png" alt="jieguo"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java细节摘要</title>
    <link href="/2019/11/01/Java%E6%91%98%E8%A6%81/"/>
    <url>/2019/11/01/Java%E6%91%98%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<p>在 Java 的领域里，基本数据类型变量存的是数据本身，</p><p>而引用类型变量存的是保存数据的内存空间地址。</p><p><img src="/2019/11/01/Java%E6%91%98%E8%A6%81/type.png" alt="type"></p><p>为什么会有不同大小的类型，举个例子比如存 5 这个数据怎么存的？</p><p>A.   byte(8位，范围是-128到127)</p><p>B.   short（16位）</p><p>C.   int（32位）</p><p>D.   long (64位)</p><p>给long赋值时，因为整数默认是int类型，要转换为long类型的值，后面加上l或L  </p><p>上面的byte short int long 最大长度可以通过<code>jdk文档</code>去找到 具体的范围。</p><p>同一个整数可以使用不同的进制表示：<code>System.out.println(0b101</code>)需jdk1.7才能按照十进制输出</p><p>默认的进制10进制     二进制： 是 0b 或者 0B开头    八进制： 是0开头   十六进制： 0X (0x) 开头</p><p>Java7 开始 支持数字之间用 _ 分割（12_34_56输出123456）  </p><p>float(单精度32位), 默认浮点数的类型是 double,直接赋值时必须在数字后加上f 或F（ 表示一个浮点数在数字后面加一个F）</p><p>double( 双精度64位)</p><p>区别：对于单精度浮点数，运行速度相比double更快，占内存更小，但是当数值非常大或者     非常小的时候会变得不精确。</p><p>双精度比单精度表示的位数大 精确的位数多,简单地说, float表示的小数点位数少。</p><p>表现形式： 常规 3.14     科学计数法 3.14e2 3.14e-2</p><p>注意：表式的时候会有精度损失（使用浮点数的时候需要注意）</p><p>例如 double num= 1.0, 是一个无限接近1.0的一个值</p><p><strong>那怎么更精确的表示浮点数呢</strong>？<strong>BigDecimal</strong></p><p><strong>结论</strong>：浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。往往产生误差不是 因为数的大小，而是因为数的精度。因此，产生的结果接近但不等于想要的结果。尤其在使用 float 和 double 作精确运 算的时候要特别小心。</p><p>char    16 位[0-65535] (2个字节,16位)。字符常量使用单引号   ‘  ’  包裹起来。</p><p>表现形式：</p><p>‘A’最常用，最直观的方式  </p><p>使用一个数字表示，对应有一个ASCII码表</p><p>例如:char c = 65;//表示 ’A’ 这个字符</p><p><img src="/2019/11/01/Java%E6%91%98%E8%A6%81/ASCii.jpg" alt="ascii">16进制表现形式    ‘A’-》65（10进制）    ‘A’ -》0x41（16进制）怎么表示？ ‘\u0041’</p><p>\r表示接受键盘输入，相当于按下了回车键；</p><p>\n表示换行；</p><p>\t表示相当于Table键制表符，；</p><p>\b表示退格键，相当于Back Space键；</p><p>&#39;表示单引号；</p><p>&#39;‘表示双引号；</p><p>\表示一个斜杠\。</p><p>值只有两个 true false，不能使用 0 1表示</p><p>String是 java中已经设计好的一个类，表示的值是字符串（Java中设计的类和我们自己设计的类的性质是一样的）</p><p>String s = “你好”;</p><p>当String 和 + 一起使用的时候，这时候+ 是拼接字符串的功能</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(“你好”+<span class="hljs-number">2</span>);<span class="hljs-comment">//结果为  你好2</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> b = <span class="hljs-number">10</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(“a=”+a+”,b=”+b); <span class="hljs-comment">//结果为a=5,b=10  </span><br></code></pre></td></tr></table></figure><p><strong>一个类其实就是一种引用数据类型</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>A a; <span class="hljs-comment">// 声明了一个A类型的变量</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>误区</strong> <strong>：</strong> 很多人一开始觉得 Java中提供的类才是一种类型，而我们自己写觉得不是！</p><p>我们自己写的类和Java已经写好的，性质一样,  面向对象会详细讲解这块内容 </p><p><strong>数据类型转换</strong></p><p>①<strong>自动类型</strong>提升byte -》short -》int -》 long            float -》 double  char  boolean</p><p><img src="/2019/11/01/Java%E6%91%98%E8%A6%81/%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87.png" alt="asd"></p><p>​         思考：为什么float 在long 后面？  </p><p>②数据类型的转换：数据的类型转换，比如整数10转换成小数10.0</p><p>③本质任何一个数据也都是有类型的！true , 3.14</p><p><strong>强制类型转换：</strong></p><p>①大数据类型转小数据类型[存储空间大小]</p><p>②相同存储空间不同类型表达值范围不一样      例如：char（无符号）及short（有符号）</p><p><strong>在Java中，boolean类型与所有其他7种类型都不能进行转换。</strong> (byte short int long float double char)  </p><ol><li>  数据类型过长 和 溢出</li></ol><ol start="2"><li>  long, float, double只要两个操作数中有一个是上面类型的，另一个就会被转换成相应类型，并且结果也是该类型</li></ol><ol start="3"><li>  如果2个操作数（包括byte，short，char，int），都将会转换为int类型，并且结果也是int（自动向上转型）</li></ol><ol start="4"><li>  char类型向更高长度类型（例如整型）转换时，会转换为对应的ASCII码值，再做其他类型的自动转换</li></ol><p>需要注意的是：char型具有两个字节，其数值范围是0 ~ 2^16-1，这直接导致byte型不能自动类型提升到char，char和short直接也不会发生自动类型提升（因为值范围问题），同时，byte当然可以直接提升到short型。</p><p> 所以，char 不能和byte short 相互自动转换</p><ol start="5"><li>  特例   </li></ol><p>①——————————————————————-&gt;</p><p>int a = 129;</p><p>byte b = (byte)a;//编译器只看容器不看值</p><p>System.out.println(b);//结果为-127</p><p>②——————————————————————&gt;</p><p>byte b = 100;//可以自动转换</p><p>float  f = 1.3;//不能自动转换</p><p>int a = 2147483647;</p><p>a = a+1;</p><p>System.out.println(a); // 结果为 -2147483648</p><p>高 转 低会导致精度丢失,不同类型的强制转换，可能会导致精度的下降.</p><p>比如说：double 转 float </p><p><strong>示例一</strong>：</p><p>int i1=123;</p><p>​         int i2=456; </p><p>​         float f1 = (float) ((i1+i2)*1.2);//容量大的类型转换为容量小的类型时，要加上强制转换符</p><p><strong>示例二</strong>：</p><p>short i=99;</p><p>char c=(char)i; </p><p>System.out.println(c); </p><p><strong>示例三</strong>：</p><p>byte b1=1;</p><p>byte b2=2;</p><p>byte b3=(byte)(b1+b2); //byte，short，char在计算时首先转换为int，大容//量（int）转换为小容量的类型（byte）时要加强制转换</p><p>​      <strong>特</strong> <strong>例</strong>：</p><p>byte t = 127;//不报错</p><p>int a = 127;</p><p>byte b = (byte)a;//需要强制转换才不报错：编译器只看容器不看值</p><p>System.out.println(b); // 结果为 127</p><p>如果值比long还大 ———–&gt;  怎么办？</p><p>java提供了一个类：BigInteger：用于处理较大整数：目前知道就好…</p><p>​         表达式 ： 由常量、变量、运算符和（） 组成的算式  </p><p>整数（小数）相除的例子  10/3 =3； 10.0/3=3.33333…</p><p>0/0    0.0/0.0       结果是NaN ,任何的NaN都不等于自己（面试题）</p><p>1.0/0.0      Infinity,表示无穷大</p><p><strong>自增自减运算的优先级 比 算术运算符 高</strong>  </p><p><img src="/2019/11/01/Java%E6%91%98%E8%A6%81/%E8%87%AA%E5%A2%9E%E5%87%8F%E8%BF%90%E7%AE%97.png" alt="q"></p><h3 id="比较运算符符号-gt-lt-gt-lt-instanceof"><a href="#比较运算符符号-gt-lt-gt-lt-instanceof" class="headerlink" title="比较运算符符号  ==  !=   &gt; &lt;  &gt;=  &lt;=  instanceof"></a>比较运算符符号  <strong>==  !=   &gt; &lt;  &gt;=  &lt;=  instanceof</strong></h3><p><strong>特别说明</strong>：instanceof 是判断一个对象是否属于某种类类型</p><p>思考：是否可以用于我们之前学习的基本数据类型（回忆一下我们之前学习的数据类型除了基本数据类型 还有什么？）</p><p>常见错误**：</p><p>​      例如：判断一个整数的变量 a里面的数据 在0-100之间</p><p>​      正确写法： a&gt;0  &amp;&amp; a&lt;100</p><p>​      错误写法:  0&lt; a &lt; 100 (java没有这种语法，不支持)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">short</span> s = <span class="hljs-number">3</span>;<br><span class="hljs-attribute">s</span> += <span class="hljs-number">2</span>;//存在隐式转换，隐式转换和自动转换概念不一样<br><span class="hljs-attribute">short</span> s = <span class="hljs-number">3</span>;<br><span class="hljs-attribute">s</span> = s+<span class="hljs-number">2</span>;//结果值是int，int不能自动转换为short<br></code></pre></td></tr></table></figure><p>昨天的面试final和finally的区别</p><p>finaly块里能用continue，break和return吗？</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java细节摘要</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java注解</title>
    <link href="/2019/11/01/Java%E6%B3%A8%E8%A7%A3/"/>
    <url>/2019/11/01/Java%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h3><h4 id="一、认识注解"><a href="#一、认识注解" class="headerlink" title="一、认识注解"></a>一、认识注解</h4><p>　　注解(Annotation)很重要，未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，现在已经有不少的人开始用注解了，注解是JDK1.5之后才有的新特性</p><p>​    JDK1.5之后内部提供的三个注解：</p><p>​        @Deprecated 意思是“<strong>废弃的，过时的</strong>”</p><p>​        @Override 意思是“<strong>重写、覆盖</strong>”</p><p>​        @SuppressWarnings 意思是“<strong>压缩警告</strong></p><blockquote><p>JDK内置注解：Override指“重写，覆盖”/Deprecated指“过时的，废弃的”/SuppressWarnings“镇压警告”</p><p>元注解：Documented/Inherited/Retention/Target/Constraint</p><p>自定义注解</p><p>解析注解</p><p>自定义注解生成SQL语句</p></blockquote><p>注解范例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.kongwei_liao.annotation;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类是用来演示注解(Annotation)的应用的，注解也是JDK1.5新增加的特性之一</span><br><span class="hljs-comment"> * JDK1.5内部提供的三种注解是：<span class="hljs-doctag">@SuppressWarnings</span>(&quot;:deprecation&quot;)、<span class="hljs-doctag">@Deprecated</span>、<span class="hljs-doctag">@Override</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author <span class="hljs-variable">Kongwei_Liao</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类名的命名是有讲究的，类名、属性名、变量名一般是名词，或者是形容词+名词，方法一般是动词，或者是动词+名词，</span><br><span class="hljs-comment"> * 以AnnotationTest作为类名和以TestAnnotation作为类名是有区别的，</span><br><span class="hljs-comment"> * 前者是注解的测试，符合名词的特征，后者是测试注解，听起来就是一个动作名称，是方法的命名特征</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationTest</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-variable">args</span></span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;:deprecation&quot;</span>)<br>    <span class="hljs-comment">//这里就是注解，称为压缩警告，这是JDK内部自带的一个注解，`一个注解就是一个类`，在这里使用了这个注解就是创建了SuppressWarnings类的一个实例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>        System.runFinalizersOnExit(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//The method runFinalizersOnExit(boolean) from the type System is deprecated(过时的，废弃的)</span><br>        <span class="hljs-comment">//这里的runFinalizersOnExit()方法画了一条横线表示此方法已经过时了，不建议使用了</span><br>    &#125;<br>    <span class="hljs-meta">@Deprecated</span> <span class="hljs-comment">//这也是JDK内部自带的一个注解，意思就是说这个方法已经废弃了，不建议使用了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hi,Kongwei_Liao&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//这也是JDK1.5之后内部提供的一个注解，意思就是要重写(覆盖)JDK内部的toString()方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Kongwei_Liao&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    总结：<strong>注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标记</strong>，没有加，则等于没有任何标记，以后，<strong>javac编译器、开发工具和其他程序可以<code>通过反射</code>**来了解你的类及各种元素上有无何种标记，看你的程序有什么标记，就去干相应的事，</strong>标记可以加在包、类，属性、方法，方法的参数以及局部变量上**。</p><p><img src="/2019/11/01/Java%E6%B3%A8%E8%A7%A3/AnnoStruct.jpg" alt="注解结构"></p><p>注解就相当于一个你的源程序要调用的一个类，在源程序中应用某个注解，得事先准备好这个注解类。就像你要调用某个类，得事先开发好这个类。 </p><h3 id="二、自定义注解及其应用"><a href="#二、自定义注解及其应用" class="headerlink" title="二、自定义注解及其应用"></a>二、自定义注解及其应用</h3><p><strong>自定义一个最简单的注解：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> @<span class="hljs-keyword">interface</span> <span class="hljs-symbol">MyAnnotation</span>&#123;&#125;<span class="hljs-comment">//自定义一个最简单的注解</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.annotation;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这是一个自定义的注解(Annotation)类 在定义注解(Annotation)类时使用了另一个注解类Retention</span><br><span class="hljs-comment"> * 在注解类上使用另一个注解类，那么被使用的注解类就称为元注解</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> kongwei_liao</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//Retention注解决定MyAnnotation注解的生命周期</span><br><span class="hljs-meta">@Target( &#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><span class="hljs-comment">//Target注解决定MyAnnotation注解可以加在哪些成分上，如加在类身上，或者属性身上，或者方法身上等成分</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-comment"> * 这个注解的意思是让MyAnnotation注解只在java源文件中存在，编译成.class文件后注解就不存在了</span><br><span class="hljs-comment"> * @Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-comment"> * 这个注解的意思是让MyAnnotation注解在java源文件(.java文件)中存在，编译成.class文件后注解也还存在，</span><br><span class="hljs-comment"> * 被MyAnnotation注解类标识的类被类加载器加载到内存中后MyAnnotation注解就不存在了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 这里是在注解类MyAnnotation上使用另一个注解类，这里的Retention称为元注解。</span><br><span class="hljs-comment"> * Retention注解括号中的&quot;RetentionPolicy.RUNTIME&quot;意思是让MyAnnotation这个注解的生命周期一直程序运行时都存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>把自定义的注解加到某个类上：</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@ MyAnnotation <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">AnnotationUse</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>用反射测试进行测试AnnotationUse的定义上是否有@MyAnnotation</strong></p><p><img src="/2019/11/01/Java%E6%B3%A8%E8%A7%A3/%E5%8F%8D%E5%B0%84API.png" alt="反射"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> cn.kongwei_liao.<span class="hljs-keyword">annotation</span>;<br><br><span class="hljs-meta">@MyAnnotation</span><span class="hljs-comment">//这里是将新创建好的注解类MyAnnotation标记到AnnotaionTest类上</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationUse</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br>        <span class="hljs-comment">// 这里是检查Annotation类是否有注解，这里需要使用反射才能完成对Annotation类的检查</span><br>        <span class="hljs-keyword">if</span> (AnnotationUse.<span class="hljs-keyword">class</span>.isAnnotationPresent(MyAnnotation.<span class="hljs-keyword">class</span>)) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * MyAnnotation是一个类，这个类的实例对象annotation是通过反射得到的，这个实例对象是如何创建的呢？</span><br><span class="hljs-comment">             * 一旦在某个类上使用了@MyAnnotation，那么这个MyAnnotation类的实例对象annotation就会被创建出来了</span><br><span class="hljs-comment">             * 假设很多人考驾照，教练在有些学员身上贴一些绿牌子、黄牌子，贴绿牌子的表示送礼送得比较多的，</span><br><span class="hljs-comment">             * 贴黄牌子的学员表示送礼送得比较少的，不贴牌子的学员表示没有送过礼的，通过这个牌子就可以标识出不同的学员</span><br><span class="hljs-comment">             * 教官在考核时一看，哦，这个学员是有牌子的，是送过礼给他的，优先让有牌子的学员过，此时这个牌子就是一个注解</span><br><span class="hljs-comment">             * 一个牌子就是一个注解的实例对象，实实在在存在的牌子就是一个实实在在的注解对象，把牌子拿下来(去掉注解)注解对象就不存在了</span><br><span class="hljs-comment">             */</span><br>            MyAnnotation <span class="hljs-keyword">annotation</span> = (MyAnnotation) AnnotationUse.<span class="hljs-keyword">class</span><br>                    .getAnnotation(MyAnnotation.<span class="hljs-keyword">class</span>);<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>);<span class="hljs-comment">// 打印MyAnnotation对象，这里输出的结果为：@cn.kongwei_liao.annotation.MyAnnotation()</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、-Retention元注解"><a href="#三、-Retention元注解" class="headerlink" title="三、@Retention元注解"></a>三、@Retention元注解</h3><p>根据反射的测试的问题，引出@Retention元注解的讲解：</p><p>其三种取值：<strong>RetentionPolicy.SOURCE</strong>、<strong>RetentionPolicy.CLASS</strong>、<strong>RetentionPolicy.RUNTIME</strong></p><p>分别对应：Java源文件(.java文件)—-&gt;.class文件—-&gt;内存中的字节码 </p><h3 id="四、-Retention注解说明"><a href="#四、-Retention注解说明" class="headerlink" title="四、 Retention注解说明"></a>四、 Retention注解说明</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Target</span>(ElementType.ANNOTATION_TYPE)<br>public <span class="hljs-variable">@interface</span> Retention &#123;<br><br>    <span class="hljs-selector-tag">RetentionPolicy</span> <span class="hljs-selector-tag">value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs applescript">public enum RetentionPolicy &#123;<br>    /**<br>     * Annotations are <span class="hljs-keyword">to</span> be discarded <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> compiler.<br>     * （注解将被编译器忽略掉）<br>     */<br>    SOURCE,<br><br>    /**<br>     * Annotations are <span class="hljs-keyword">to</span> be recorded <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">class</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> compiler<br>     * <span class="hljs-keyword">but</span> need <span class="hljs-keyword">not</span> be retained <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> VM <span class="hljs-keyword">at</span> <span class="hljs-built_in">run</span> <span class="hljs-built_in">time</span>.  This <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> default<br>     * behavior.<br>     * （注解将被编译器记录在<span class="hljs-built_in">class</span>文件中，但在运行时不会被虚拟机保留，这是一个默认的行为）<br>     */<br>    CLASS,<br><br>    /**<br>     * Annotations are <span class="hljs-keyword">to</span> be recorded <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">class</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> compiler <span class="hljs-keyword">and</span><br>     * retained <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> VM <span class="hljs-keyword">at</span> <span class="hljs-built_in">run</span> <span class="hljs-built_in">time</span>, so they may be <span class="hljs-built_in">read</span> reflectively.<br>     * （注解将被编译器记录在<span class="hljs-built_in">class</span>文件中，而且在运行时会被虚拟机保留，因此它们能通过反射被读取到）<br>     * @see java.lang.reflect.AnnotatedElement<br>     */<br>    RUNTIME<br>&#125;<br></code></pre></td></tr></table></figure><p>​        当在Java源程序上加了一个注解，这个Java源程序要由javac去编译，javac把java源文件编译成.class文件，</p><p>​        在编译成class时可能会把Java源程序上的一些注解给去掉，java编译器(javac)在处理java源程序时，可能会认为这个注解没有用了，于是就把这个注解去掉了，那么此时在编译好的class中就找不到注解了， 这是编译器编译java源程序时对注解进行处理的第一种可能情况，</p><p>​        假设java编译器在把java源程序编译成class时，没有把java源程序中的注解去掉，那么此时在编译好的class中就可以找到注解，当程序使用编译好的class文件时，需要用类加载器把class文件加载到内存中，class文件中的东西不是字节码，class文件里面的东西由类加载器加载到内存中去，</p><p>​        类加载器在加载class文件时，会对class文件里面的东西进行处理，如安全检查，处理完以后得到的最终在内存中的二进制的东西才是字节码，类加载器在把class文件加载到内存中时也有转换，转换时是否把class文件中的注解保留下来，这也有说法，</p><p>​        所以说<strong>一个注解的生命周期有三个阶段：java源文件是一个阶段，class文件是一个阶段，内存中的字节码是一个阶段</strong>,</p><p>​        javac把java源文件编译成.class文件时，有可能去掉里面的注解，类加载器把.class文件加载到内存时也有可能去掉里面的注解，</p><p>​        因此**在自定义注解时就可以使用Retention注解指明自定义注解的生命周期，自定义注解的生命周期是在RetentionPolicy.SOURCE阶段(java源文件阶段)，还是在RetentionPolicy.CLASS阶段(class文件阶段)，或者是在RetentionPolicy.RUNTIME阶段(内存中的字节码运行时阶段)**，</p><p>​        根据<strong>JDK提供的API可以知道默认是在RetentionPolicy.CLASS阶段 (JDK的API写到：the retention policy defaults to RetentionPolicy.CLASS.)</strong></p><blockquote><p><strong>下面看看@Deprecated、@Override、@SuppressWarnings这三个注解的@Retention注解的属性值分别是什么吧</strong></p></blockquote><h4 id="4-1、-Deprecated"><a href="#4-1、-Deprecated" class="headerlink" title="4.1、@Deprecated"></a><strong>4.1、@Deprecated</strong></h4><p>　　Java API中是这样定义的@Deprecated的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Retention</span>(value=RUNTIME)<br>public <span class="hljs-variable">@interface</span> Deprecated<br></code></pre></td></tr></table></figure><h4 id="4-2、-Override"><a href="#4-2、-Override" class="headerlink" title="4.2、@Override"></a><strong>4.2、@Override</strong></h4><p>　　Java API中是这样定义的@Override的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(value=METHOD)<br><span class="hljs-variable">@Retention</span>(value=SOURCE)<br>public <span class="hljs-variable">@interface</span> Override<br></code></pre></td></tr></table></figure><p>　　@Override是给javac(java编译器)看的，编译完以后就@Override注解就没有价值了，@Override注解在源代码中有用，编译成.class文件后@Override注解就没有用了，因此@Override的Retention的属性值是RetentionPolicy.SOURCE</p><h4 id="4-3、-SuppressWarnings"><a href="#4-3、-SuppressWarnings" class="headerlink" title="4.3、@SuppressWarnings"></a><strong>4.3、@SuppressWarnings</strong></h4><p>　　Java API中是这样定义的@SuppressWarnings的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(value=&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)<br><span class="hljs-variable">@Retention</span>(value=SOURCE)<br>public <span class="hljs-variable">@interface</span> SuppressWarnings<br></code></pre></td></tr></table></figure><p>　　@SuppressWarnings是给javac(java编译器)看的，编译器编译完java文件后，@SuppressWarnings注解就没有用了，所以@SuppressWarnings的Retention的属性值是RetentionPolicy.SOURCE</p><h3 id="五、-Target元注解"><a href="#五、-Target元注解" class="headerlink" title="五、@Target元注解"></a>五、@Target元注解</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Target</span>(ElementType.ANNOTATION_TYPE)<br>public <span class="hljs-variable">@interface</span> Target &#123;<br>    <span class="hljs-selector-tag">ElementType</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">value</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">public enum ElementType &#123;<br>    <span class="hljs-comment">/** 类，接口（包括注解类型）或enum声明  */</span><br><span class="hljs-built_in">    TYPE,</span><br>    <span class="hljs-comment">/** 域声明（包括 enum 实例） */</span><br><span class="hljs-built_in">    FIELD,</span><br>    <span class="hljs-comment">/** 方法声明 */</span><br><span class="hljs-built_in">    METHOD,</span><br>    <span class="hljs-comment">/** 参数声明 */</span><br><span class="hljs-built_in">    PARAMETER,</span><br>    <span class="hljs-comment">/** 构造器声明 */</span><br><span class="hljs-built_in">    CONSTRUCTOR,</span><br>    <span class="hljs-comment">/** 局部变量声明  */</span><br><span class="hljs-built_in">    LOCAL_VARIABLE,</span><br>    <span class="hljs-comment">/** Annotation type declaration */</span><br><span class="hljs-built_in">    ANNOTATION_TYPE,</span><br>    <span class="hljs-comment">/**  包声明  */</span><br><span class="hljs-built_in">    PACKAGE,</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 类型参数声明</span><br><span class="hljs-comment">     * @since 1.8</span><br><span class="hljs-comment">     */</span><br><span class="hljs-built_in">    TYPE_PARAMETER,</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 类型的使用</span><br><span class="hljs-comment">     * @since 1.8</span><br><span class="hljs-comment">     */</span><br>    TYPE_USE<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<code>@Target元注解决定了一个注解可以标识到哪些成分上</code>，如标识在在类，或者属性，或者方法等成分身上，@Target默认值为任何元素(成分)</p><p>例如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>@Target(value=&#123;TYPE,<span class="hljs-keyword">FIELD</span>,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)<br><span class="hljs-symbol">2 </span>@Retention(value=SOURCE)<br><span class="hljs-symbol">3 </span>public @interface SuppressWarnings<br></code></pre></td></tr></table></figure><h3 id="六、-Documented元注解"><a href="#六、-Documented元注解" class="headerlink" title="六、 @Documented元注解"></a>六、 @Documented元注解</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Target</span>(ElementType.ANNOTATION_TYPE)<br>public <span class="hljs-variable">@interface</span> Documented &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p> 即拥有这个注解的元素可以被javadoc此类的工具文档化。它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@return,@param 等。  </p><h3 id="七、-Inherited-元注解"><a href="#七、-Inherited-元注解" class="headerlink" title="七、@Inherited 元注解"></a>七、@Inherited 元注解</h3><p> @Inherited注解标记其他的注解用于指明标记的注解是可以被自动继承的。 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Documented</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Target</span>(ElementType.ANNOTATION_TYPE)<br>public <span class="hljs-variable">@interface</span> Inherited &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p> 允许子类继承父类中的注解。即拥有此注解的元素其子类可以继承父类的注解。 </p><h3 id="八、为注解增加属性"><a href="#八、为注解增加属性" class="headerlink" title="八、为注解增加属性"></a>八、为注解增加属性</h3><p>　　注解可以看成是一种<code>特殊的类</code>，既然是类，那自然可以为类添加属性</p><h4 id="8-1-添加属性"><a href="#8-1-添加属性" class="headerlink" title="8.1.添加属性"></a>8.<strong>1.添加属性</strong></h4><p>　<strong>语法：类型 属性名();</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.annotation;<br> <br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-comment">//Retention注解决定MyAnnotation注解的生命周期</span><br><span class="hljs-meta">@Target( &#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义基本属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">color</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//这不是声明的方法吗，为什么在在注解中称为属性**Q1**</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　其实从代码的写法上来看，注解更像是一种<code>特殊的接口</code>，注解的属性定义方式就和接口中定义方法的方式一样，而<code>应用了注解的类可以认为是实现了这个特殊的接口</code></p><h4 id="8-2-应用属性"><a href="#8-2-应用属性" class="headerlink" title="8.2.应用属性"></a>8.<strong>2.应用属性</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> cn.kongwei_liao.<span class="hljs-keyword">annotation</span>;<br><br><span class="hljs-meta">@MyAnnotation(color=<span class="hljs-meta-string">&quot;red&quot;</span>)</span><span class="hljs-comment">//应用MyAnnotation注解的color属性   **Q1 without A**</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnnotationTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法</span><br><span class="hljs-comment">        */</span><br>        MyAnnotation <span class="hljs-keyword">annotation</span> = (MyAnnotation) MyAnnotationTest.<span class="hljs-keyword">class</span>.getAnnotation(MyAnnotation.<span class="hljs-keyword">class</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.color());<span class="hljs-comment">//输出red</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-3-为属性指定缺省值-默认值"><a href="#8-3-为属性指定缺省值-默认值" class="headerlink" title="8.3.为属性指定缺省值(默认值)"></a>8.3.<strong>为属性指定缺省值(默认值)</strong></h4><p>　　<strong>语法：类型 属性名() default 默认值;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//Retention注解决定MyAnnotation注解的生命周期</span><br><span class="hljs-meta">@Target( &#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">color</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;blue&quot;</span>;<span class="hljs-comment">//为属性指定缺省值   **Q1**</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">package</span> cn.kongwei_liao.annotation;<br><br><span class="hljs-keyword">@MyAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MyAnnotationTest &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法</span><br><span class="hljs-comment">         */</span><br>         MyAnnotation annotation = (MyAnnotation) MyAnnotationTest.<span class="hljs-keyword">class</span>.getAnnotation(MyAnnotation.<span class="hljs-keyword">class</span>);<br>         System.<span class="hljs-keyword">out</span>.println(annotation.color());<span class="hljs-comment">//输出color属性的默认值：blue</span><br>        <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-4-value属性"><a href="#8-4-value属性" class="headerlink" title="8.4.value属性"></a><strong>8.4.value属性</strong></h4><p>　　如果一个<code>注解中有一个名称为value的属性</code>，且你只想设置value属性(即其他属性都采用默认值或者你只有一个value属性)，那么可以省略掉“value=”部分。</p><p>　　例如：@SuppressWarnings(“deprecation”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-comment">//Retention注解决定MyAnnotation注解的生命周期</span><br><span class="hljs-meta">@Target( &#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">color</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;blue&quot;</span>;<span class="hljs-comment">//为属性指定缺省值</span><br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//定义一个名称为value的属性    **Q2一定是叫value属性名吗**</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> cn.kongwei_liao.<span class="hljs-keyword">annotation</span>;<br><br><span class="hljs-meta">@MyAnnotation(<span class="hljs-meta-string">&quot;kongwei_liao&quot;</span>)</span><span class="hljs-comment">//等价于@MyAnnotation(value=&quot;kongwei_liao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnnotationTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法</span><br><span class="hljs-comment">         */</span><br>        MyAnnotation <span class="hljs-keyword">annotation</span> = (MyAnnotation) MyAnnotationTest.<span class="hljs-keyword">class</span>.getAnnotation(MyAnnotation.<span class="hljs-keyword">class</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.color());<span class="hljs-comment">//输出color属性的默认值：blue</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.value());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="九、为注解增加高级属性"><a href="#九、为注解增加高级属性" class="headerlink" title="九、为注解增加高级属性"></a>九、为注解增加高级属性</h3><h4 id="9-1、-数组类型的属性"><a href="#9-1、-数组类型的属性" class="headerlink" title="9.1、**数组类型的属性**"></a>9.1、**<code>数组类型</code>的属性**</h4><ul><li>增加数组类型的属性：int[] arrayAttr() default {1,2,4};</li><li>应用数组类型的属性：@MyAnnotation(arrayAttr={2,4,5})</li><li>如果数组属性只有一个值，这时候属性值部分可以省略大括号，如：@MyAnnotation(arrayAttr=2)，这就表示数组属性只有一个值，值为2</li></ul><h4 id="9-2-、-枚举类型的属性"><a href="#9-2-、-枚举类型的属性" class="headerlink" title="9.2.、**枚举类型的属性**"></a>9.2.、**<code>枚举类型</code>的属性**</h4><ul><li>增加枚举类型的属性：EumTrafficLamp lamp() default EumTrafficLamp.RED;</li><li>应用枚举类型的属性：@MyAnnotation(lamp=EumTrafficLamp.GREEN)</li></ul><h4 id="9-3、-注解类型的属性"><a href="#9-3、-注解类型的属性" class="headerlink" title="9.3、**注解类型的属性**"></a>9.3、**<code>注解类型</code>的属性**</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MetaAnnotation注解类为元注解</span><br><span class="hljs-comment"> * @author kongwei_liao</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> @<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetaAnnotation</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> value();<span class="hljs-comment">//元注解MetaAnnotation设置有一个唯一的属性value</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　为注解添加一个注解类型的属性,并指定注解属性的缺省值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">MetaAnnotation annotationAttr() default <span class="hljs-keyword">@MetaAnnotation</span>(<span class="hljs-string">&quot;xdp&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="十、注解综合测试"><a href="#十、注解综合测试" class="headerlink" title="十、注解综合测试"></a>十、注解综合测试</h3><p>EumTrafficLamp.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.annotation;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 交通信号灯颜色枚举</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> kongwei_liao</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EumTrafficLamp</span> </span>&#123;<br>    RED,<span class="hljs-comment">//红</span><br>    YELLOW,<span class="hljs-comment">//黄</span><br>    GREEN<span class="hljs-comment">//绿</span><br>&#125;<br></code></pre></td></tr></table></figure><p>MetaAnnotation.java</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MetaAnnotation注解类为元注解</span><br><span class="hljs-comment"> * @author kongwei_liao</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> @<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetaAnnotation</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> value();<span class="hljs-comment">//元注解MetaAnnotation设置有一个唯一的属性value</span><br>&#125;<br></code></pre></td></tr></table></figure><p>MyAnnotation.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-comment">//Retention注解决定MyAnnotation注解的生命周期</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">color</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;blue&quot;</span>;<span class="hljs-comment">//为属性指定缺省值</span><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为注解添加value属性，这个value属性很特殊，如果一个注解中只有一个value属性要设置，</span><br><span class="hljs-comment">     * 那么在设置注解的属性值时，可以省略属性名和等号不写， 直接写属性值，如<span class="hljs-doctag">@SuppressWarnings</span>(&quot;deprecation&quot;)，</span><br><span class="hljs-comment">     * 这里的MyAnnotation注解设置了两个String类型的属性，color和value，</span><br><span class="hljs-comment">     * 因为color属性指定有缺省值，value属性又是属于特殊的属性，因此使用MyAnnotation注解时</span><br><span class="hljs-comment">     * 可以这样使用MyAnnotation注解：&quot;<span class="hljs-doctag">@MyAnnotation</span>(color=&quot;red&quot;,value=&quot;xdp&quot;)&quot;</span><br><span class="hljs-comment">     * 也可以这样使用：&quot;<span class="hljs-doctag">@MyAnnotation</span>(&quot;kongwei_liao&quot;)&quot;，这样写就表示MyAnnotation注解只有一个value属性要设置，color属性采用缺省值</span><br><span class="hljs-comment">     * 当一个注解只有一个value属性要设置时，是可以省略&quot;value=&quot;的</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//定义一个名称为value的属性</span><br>     <span class="hljs-comment">//添加一个int类型数组的属性</span><br>     <span class="hljs-keyword">int</span>[] arrayAttr() <span class="hljs-keyword">default</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;;<br>     <span class="hljs-comment">//添加一个枚举类型的属性，并指定枚举属性的缺省值，缺省值只能从枚举类EumTrafficLamp中定义的枚举对象中取出任意一个作为缺省值</span><br>     <span class="hljs-function">EumTrafficLamp <span class="hljs-title">lamp</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> EumTrafficLamp.RED</span>;<br>     <span class="hljs-comment">//为注解添加一个注解类型的属性,并指定注解属性的缺省值</span><br>     <span class="hljs-function">MetaAnnotation <span class="hljs-title">annotationAttr</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> @<span class="hljs-title">MetaAnnotation</span><span class="hljs-params">(<span class="hljs-string">&quot;xdp&quot;</span>)</span></span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>MyAnnotationTest.java</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> cn.kongwei_liao.<span class="hljs-keyword">annotation</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这里是将新创建好的注解类MyAnnotation标记到AnnotaionTest类上，</span><br><span class="hljs-comment"> * 并应用了注解类MyAnnotation中定义各种不同类型的的属性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@MyAnnotation(</span><br><span class="hljs-meta">        color=<span class="hljs-meta-string">&quot;red&quot;</span>,</span><br><span class="hljs-meta">        value=<span class="hljs-meta-string">&quot;kongwei_liao&quot;</span>,</span><br><span class="hljs-meta">        arrayAttr=&#123;3,5,6&#125;,</span><br><span class="hljs-meta">       lamp=EumTrafficLamp.GREEN,</span><br><span class="hljs-meta">       annotationAttr=@MetaAnnotation(<span class="hljs-meta-string">&quot;gacl&quot;</span>)</span><br>        )<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnnotationTest</span> </span>&#123;<br>    <span class="hljs-meta">@MyAnnotation(<span class="hljs-meta-string">&quot;将MyAnnotation注解标注到main方法上&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 这里是检查Annotation类是否有注解，这里需要使用反射才能完成对Annotation类的检查</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span>(MyAnnotationTest.<span class="hljs-keyword">class</span>.isAnnotationPresent(MyAnnotation.<span class="hljs-keyword">class</span>)) &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法</span><br><span class="hljs-comment">             * MyAnnotation是一个类，这个类的实例对象annotation是通过反射得到的，这个实例对象是如何创建的呢？</span><br><span class="hljs-comment">             * 一旦在某个类上使用了<span class="hljs-doctag">@MyAnnotation</span>，那么这个MyAnnotation类的实例对象annotation就会被创建出来了</span><br><span class="hljs-comment">             */</span><br>            MyAnnotation <span class="hljs-keyword">annotation</span> = (MyAnnotation) MyAnnotationTest.<span class="hljs-keyword">class</span>.getAnnotation(MyAnnotation.<span class="hljs-keyword">class</span>);<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.color());<span class="hljs-comment">//输出color属性的默认值：red</span><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.value());<span class="hljs-comment">//输出value属性的默认值：kongwei_liao</span><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.arrayAttr().length);<span class="hljs-comment">//这里输出的数组属性的长度的结果为：3，数组属性有三个元素，因此数组的长度为3</span><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.lamp());<span class="hljs-comment">//这里输出的枚举属性值为：GREEN</span><br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.annotationAttr().value());<span class="hljs-comment">//这里输出的注解属性值:gacl</span><br>            <br>            MetaAnnotation ma = <span class="hljs-keyword">annotation</span>.annotationAttr();<span class="hljs-comment">//annotation是MyAnnotation类的一个实例对象</span><br>            System.<span class="hljs-keyword">out</span>.println(ma.value());<span class="hljs-comment">//输出的结果为：gacl</span><br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过引入自定义HTML生成器的注解类，在类中标注出字段以及字段的名称（标签），在运行时动态读取类中的注解信息，直接生成HTML页面，如此可省去大量的JSP页面编写工作。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>注解(Annotation)</tag>
      
      <tag>Retention元注解</tag>
      
      <tag>Target元注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的反射机制:对象拷贝</title>
    <link href="/2019/10/31/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2019/10/31/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="Java中的反射机制：实现对象拷贝"><a href="#Java中的反射机制：实现对象拷贝" class="headerlink" title="Java中的反射机制：实现对象拷贝"></a>Java中的反射机制：实现对象拷贝</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package edu.zzu.stu.liao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> int id;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> nm;<br><span class="hljs-keyword">private</span> int age;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">this</span>.id=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">this</span>.age=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">this</span>.nm=<span class="hljs-string">&quot;张三&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params">int id,<span class="hljs-built_in">String</span> name,int age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.id=id;<br><span class="hljs-built_in">this</span>.age=age;<br><span class="hljs-built_in">this</span>.nm=name;<br>&#125;<br><span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getId</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setId</span>(<span class="hljs-params">int id</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.id=id;<br>&#125;<br><br><span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setAge</span>(<span class="hljs-params">int age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.age=age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getNm</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> nm;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setNm</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.nm=name;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[id=&quot;</span>+id+<span class="hljs-string">&quot;,name=&quot;</span>+nm+<span class="hljs-string">&quot;,age=&quot;</span>+age+<span class="hljs-string">&quot;getClass()=&quot;</span>+getClass()+<span class="hljs-string">&quot;,hashCode()=&quot;</span>+hashCode()+<span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package edu.zzu.stu.liao;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.<span class="hljs-keyword">Method</span>;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> CopyStu &#123;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">copy</span>(<span class="hljs-keyword">Object</span> <span class="hljs-keyword">object</span>) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;<br><br><span class="hljs-keyword">Class</span>&lt;?&gt; classType=<span class="hljs-keyword">object</span>.getClass();<br><br>// 获得Constructor对象,此处获取第一个无参数的构造方法的，需要用无参构造方法来生成一个对象<br>Constructor&lt;?&gt; cons=classType.getConstructor(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>[] &#123;&#125;);<br>// 通过无参构造方法来生成一个对象<br><span class="hljs-keyword">Object</span> objectCopy=cons.newInstance(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[] &#123;&#125;);<br>// 以上两行代码等价于：<br>        // <span class="hljs-keyword">Object</span> objectCopy = classType.newInstance();  // 这行代码无法处理构造函数有参数的情况<br><br>//用第二个带参数的构造方法生成对象<br>//        Constructor cons = classType.getConstructor(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>[] &#123;<span class="hljs-type">int</span>.<span class="hljs-keyword">class</span>, String.<span class="hljs-keyword">class</span>, <span class="hljs-type">int</span>.<span class="hljs-keyword">class</span>&#125;);<br>//        <span class="hljs-keyword">Object</span> objectCopy = cons.newInstance(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[] &#123;<span class="hljs-number">1</span>, &quot;ZhangSan&quot;,<span class="hljs-number">20</span>&#125;);<br>        <br>Field[] fields=classType.getDeclaredFields();<br><span class="hljs-keyword">for</span>(Field field:fields) &#123;<br>//获取成员变量的名字，此处为id，<span class="hljs-type">name</span>，age<br>String fieldName=field.getName();<br><br>//将属性的首字母转换为大写,用来拼接<span class="hljs-keyword">set</span>和<span class="hljs-keyword">get</span>方法名<br>String <span class="hljs-keyword">set</span>=&quot;set&quot;+fieldName.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase()+fieldName.substring(<span class="hljs-number">1</span>);<br>String <span class="hljs-keyword">get</span>=&quot;get&quot;+fieldName.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase()+fieldName.substring(<span class="hljs-number">1</span>);<br><br>//获取<span class="hljs-keyword">get</span>方法对象<br><span class="hljs-keyword">Method</span> method_get=classType.getMethod(<span class="hljs-keyword">get</span>,<span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>[] &#123;&#125;);<br><br>//获取<span class="hljs-keyword">set</span>方法对象<br>//注意转入属性参数类型，通过 <span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>[] &#123;field.getType()&#125;<br><span class="hljs-keyword">Method</span> method_set=classType.getMethod(<span class="hljs-keyword">set</span>,<span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>[] &#123;field.getType()&#125;);//注意转入属性参数类型<br><br>//调用<span class="hljs-keyword">get</span>方法获取源对象的值<br><span class="hljs-keyword">Object</span> returnVal=method_get.invoke(<span class="hljs-keyword">object</span>,<span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[] &#123;&#125;);<br><br>//调用<span class="hljs-keyword">set</span>方法将这个值复制到目的对象中去<br>method_set.invoke(objectCopy, <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[] &#123;returnVal&#125;);<br>&#125;<br><span class="hljs-keyword">return</span> objectCopy;<br>&#125;<br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;<br><br>Student student1=<span class="hljs-built_in">new</span> Student(<span class="hljs-number">1</span>,&quot;xiaoming&quot;,<span class="hljs-number">18</span>);<br><br>CopyStu copyStu=<span class="hljs-built_in">new</span> CopyStu();<br>Student student2=(Student)copyStu.<span class="hljs-keyword">copy</span>(student1);<br><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;student1:&quot;+student1.toString());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;student2:&quot;+student2.toString());<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/10/31/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/result.png" alt="111"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>反射机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo迁移</title>
    <link href="/2019/10/29/Hexo%E8%BF%81%E7%A7%BB/"/>
    <url>/2019/10/29/Hexo%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><h2 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h2><p>首先，安装 <code>hexo-migrator-rss</code> 插件。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-migrator-rss <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>插件安装完成后，执行下列命令，从 RSS 迁移所有文章。<code>source</code> 可以是文件路径或网址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> hexo migrate rss &lt;<span class="hljs-built_in">source</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><p>把 <code>_posts</code> 文件夹内的所有文件复制到 <code>source/_posts</code> 文件夹，并在 <code>_config.yml</code> 中修改 <code>new_post_name</code> 参数。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">new_post_name:</span> <span class="hljs-symbol">:year-</span><span class="hljs-symbol">:month-</span><span class="hljs-symbol">:day-</span><span class="hljs-symbol">:title</span>.md<br></code></pre></td></tr></table></figure><h2 id="Octopress"><a href="#Octopress" class="headerlink" title="Octopress"></a>Octopress</h2><p>把 Octopress <code>source/_posts</code> 文件夹内的所有文件转移到 Hexo 的 <code>source/_posts</code> 文件夹，并修改 <code>_config.yml</code> 中的 <code>new_post_name</code> 参数。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">new_post_name:</span> <span class="hljs-symbol">:year-</span><span class="hljs-symbol">:month-</span><span class="hljs-symbol">:day-</span><span class="hljs-symbol">:title</span>.md<br></code></pre></td></tr></table></figure><h2 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h2><p>首先，安装 <code>hexo-migrator-wordpress</code> 插件。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-migrator-wordpress <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考<a href="http://en.support.wordpress.com/export/">WP支持页面</a>）。</p><p>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 WordPress 导出的文件路径或网址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> hexo migrate wordpress &lt;<span class="hljs-built_in">source</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意</p><p>这个插件并不能完美地实现WordPress-&gt;Hexo的数据转换，尤其是在处理WordPress的分类方面存在问题（见<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter中的分类与标签</a>）。因此，建议您在迁移完成后，手工审阅所有生成的markdown文件，检查其中是否有错误。对于文章数量较大的WordPress站点，这项工作可能要花很长的时间。</p></blockquote><h2 id="Joomla"><a href="#Joomla" class="headerlink" title="Joomla"></a>Joomla</h2><p>首先，安装 <code>hexo-migrator-joomla</code> 插件。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ npm <span class="hljs-keyword">install </span>hexo-migrator-<span class="hljs-keyword">joomla </span>--save<br></code></pre></td></tr></table></figure><p>使用 <a href="http://extensions.joomla.org/extensions/migration-a-conversion/data-import-a-export/12816?qh=YToxOntpOjA7czo1OiJqMnhtbCI7fQ==">J2XML</a> 组件导出 Joomla 文章。<br>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 Joomla 导出的文件路径或网址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> hexo migrate joomla &lt;<span class="hljs-built_in">source</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo开始使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo指令</title>
    <link href="/2019/10/29/Hexo%E6%8C%87%E4%BB%A4/"/>
    <url>/2019/10/29/Hexo%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ hexo <span class="hljs-keyword">init</span> [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href>_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--path</code></td><td>自定义新文章的路径</td></tr><tr><td><code>-r</code>, <code>--replace</code></td><td>如果存在同名文章，将其替换</td></tr><tr><td><code>-s</code>, <code>--slug</code></td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-keyword">new</span> page <span class="hljs-comment">--path about/me</span><br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deploy</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr><tr><td><code>-b</code>, <code>--bail</code></td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td>强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td><code>-c</code>, <code>--concurrency</code></td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--port</code></td><td>重设端口</td></tr><tr><td><code>-s</code>, <code>--static</code></td><td>只使用静态文件</td></tr><tr><td><code>-l</code>, <code>--log</code></td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>, <code>--generate</code></td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-o</code>, <code>--output</code></td><td>设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href>迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ hexo <span class="hljs-comment">--safe</span><br></code></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ hexo <span class="hljs-comment">--debug</span><br></code></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ hexo <span class="hljs-comment">--silent</span><br></code></pre></td></tr></table></figure><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># 使用 custom<span class="hljs-variable">.yml</span> 代替默认的 <span class="hljs-number">_</span><span class="hljs-keyword">config</span><span class="hljs-variable">.yml</span><br>$ hexo server --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span><br># 使用 custom<span class="hljs-variable">.yml</span> 和 custom2<span class="hljs-variable">.json</span>，其中 custom2<span class="hljs-variable">.json</span> 优先级更高<br>$ hexo <span class="hljs-keyword">generate</span> --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span>,custom2<span class="hljs-variable">.json</span>,custom3<span class="hljs-variable">.yml</span><br></code></pre></td></tr></table></figure><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># 使用 custom<span class="hljs-variable">.yml</span> 代替默认的 <span class="hljs-number">_</span><span class="hljs-keyword">config</span><span class="hljs-variable">.yml</span><br>$ hexo server --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span><br># 使用 custom<span class="hljs-variable">.yml</span>, custom2<span class="hljs-variable">.json</span> 和 custom3<span class="hljs-variable">.yml</span>，其中 custom3<span class="hljs-variable">.yml</span> 优先级最高，其次是 custom2<span class="hljs-variable">.json</span><br>$ hexo <span class="hljs-keyword">generate</span> --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span>,custom2<span class="hljs-variable">.json</span>,custom3<span class="hljs-variable">.yml</span><br></code></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ hexo <span class="hljs-comment">--draft</span><br></code></pre></td></tr></table></figure><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ hexo --cwd <span class="hljs-regexp">/path/</span>to/cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo开始使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo配置</title>
    <link href="/2019/10/29/Hexo%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/10/29/Hexo%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>keywords</code></td><td>网站的关键词。使用半角逗号 <code>,</code> 分隔多个关键词。</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td><td></td></tr><tr><td><code>root</code></td><td>网站根目录</td><td></td></tr><tr><td><code>permalink</code></td><td>文章的 <a href>永久链接</a> 格式</td><td><code>:year/:month/:day/:title/</code></td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td><td></td></tr><tr><td><code>pretty_urls</code></td><td>改写 <a href><code>permalink</code></a> 的值来美化 URL</td><td></td></tr><tr><td><code>pretty_urls.trailing_index</code></td><td>是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td><code>true</code></td></tr></tbody></table><blockquote><p>网站存放在子目录</p><p>如果您的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><p>例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 比如，一个页面的永久链接是 </span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//example.com/foo/bar/index.html</span><br><span class="hljs-symbol">pretty_urls:</span>  <br><span class="hljs-symbol">trailing_index:</span> false<br><span class="hljs-meta"># 此时页面的永久链接会变为 http:<span class="hljs-comment">//example.com/foo/bar/</span></span><br></code></pre></td></tr></table></figure><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>source_dir</code></td><td>资源文件夹，这个文件夹用来存放内容。</td><td><code>source</code></td></tr><tr><td><code>public_dir</code></td><td>公共文件夹，这个文件夹用于存放生成的站点文件。</td><td><code>public</code></td></tr><tr><td><code>tag_dir</code></td><td>标签文件夹</td><td><code>tags</code></td></tr><tr><td><code>archive_dir</code></td><td>归档文件夹</td><td><code>archives</code></td></tr><tr><td><code>category_dir</code></td><td>分类文件夹</td><td><code>categories</code></td></tr><tr><td><code>code_dir</code></td><td>Include code 文件夹，<code>source_dir</code> 下的子目录</td><td><code>downloads/code</code></td></tr><tr><td><code>i18n_dir</code></td><td>国际化（i18n）文件夹</td><td><code>:lang</code></td></tr><tr><td><code>skip_render</code></td><td>跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td><td></td></tr></tbody></table><p>例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">skip_render: <span class="hljs-string">&quot;mypage/**/*&quot;</span><br># 将会直接将 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/i</span>ndex.html` 和 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/</span>code.js` 不做改动地输出到 <span class="hljs-string">&#x27;public&#x27;</span> 目录<br># 你也可以用这种方法来跳过对指定文章文件的渲染<br>skip_render: <span class="hljs-string">&quot;_posts/test-post.md&quot;</span><br># 这将会忽略对 <span class="hljs-string">&#x27;test-post.md&#x27;</span> 的渲染<br></code></pre></td></tr></table></figure><blockquote><p>提示</p><p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p></blockquote><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>new_post_name</code></td><td>新文章的文件名称</td><td>:title.md</td></tr><tr><td><code>default_layout</code></td><td>预设布局</td><td>post</td></tr><tr><td><code>auto_spacing</code></td><td>在中文和英文之间加入空格</td><td>false</td></tr><tr><td><code>titlecase</code></td><td>把标题转换为 title case</td><td>false</td></tr><tr><td><code>external_link</code></td><td>在新标签中打开链接</td><td>true</td></tr><tr><td><code>external_link.enable</code></td><td>在新标签中打开链接</td><td><code>true</code></td></tr><tr><td><code>external_link.field</code></td><td>对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td><code>site</code></td></tr><tr><td><code>external_link.exclude</code></td><td>Exclude hostname. Specify subdomain when applicable, including <code>www</code></td><td><code>[]</code></td></tr><tr><td><code>filename_case</code></td><td>把文件名称转换为 (1) 小写或 (2) 大写</td><td>0</td></tr><tr><td><code>render_drafts</code></td><td>显示草稿</td><td>false</td></tr><tr><td><code>post_asset_folder</code></td><td>启动 <a href>Asset 文件夹</a></td><td>false</td></tr><tr><td><code>relative_link</code></td><td>把链接改为与根目录的相对位址</td><td>false</td></tr><tr><td><code>future</code></td><td>显示未来的文章</td><td>true</td></tr><tr><td><code>highlight</code></td><td>代码块的设置</td><td></td></tr><tr><td><code>highlight.enable</code></td><td>开启代码块高亮</td><td><code>true</code></td></tr><tr><td><code>highlight.auto_detect</code></td><td>如果未指定语言，则启用自动检测</td><td><code>false</code></td></tr><tr><td><code>highlight.line_number</code></td><td>显示行数</td><td><code>true</code></td></tr><tr><td><code>highlight.tab_replace</code></td><td>用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</td><td><code>&#39;&#39;</code></td></tr></tbody></table><blockquote><p>相对地址</p><p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>,您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p></blockquote><h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>default_category</code></td><td>默认分类</td><td><code>uncategorized</code></td></tr><tr><td><code>category_map</code></td><td>分类别名</td><td></td></tr><tr><td><code>tag_map</code></td><td>标签别名</td><td></td></tr></tbody></table><h2 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>date_format</code></td><td>日期格式</td><td><code>YYYY-MM-DD</code></td></tr><tr><td><code>time_format</code></td><td>时间格式</td><td><code>HH:mm:ss</code></td></tr><tr><td><code>use_date_for_updated</code></td><td>Use the date of the post in <a href><code>post.updated</code></a> if no updated date is provided in the front-matter. Typically used with Git workflow</td><td><code>true</code></td></tr></tbody></table><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>per_page</code></td><td>每页显示的文章量 (0 = 关闭分页功能)</td><td><code>10</code></td></tr><tr><td><code>pagination_dir</code></td><td>分页目录</td><td><code>page</code></td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>theme</code></td><td>当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td><code>theme_config</code></td><td>主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td></tr><tr><td><code>deploy</code></td><td>部署部分的设置</td></tr><tr><td><code>meta_generator</code></td><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table><h3 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h3><p>在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>include</code></td><td>Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td></tr><tr><td><code>exclude</code></td><td>Hexo 会忽略这些文件和目录</td></tr></tbody></table><p>举例：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># <span class="hljs-meta-keyword">Include</span>/Exclude Files/Folders</span><br><br>include:  <br>    - <span class="hljs-string">&quot;.nojekyll&quot;</span>  <br>    <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/css/_typing.css&#x27;</span>  </span><br>    - <span class="hljs-string">&quot;css/_typing.css&quot;</span>  <br>    <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件，但不包括子目录及其其中的文件。  </span><br>    - <span class="hljs-string">&quot;_css/*&quot;</span>  <br>    <span class="hljs-meta"># 包含 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件和子目录下的任何文件  </span><br>    - <span class="hljs-string">&quot;_css/**/*&quot;</span><br><br>exclude:  <br>    <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/test.js&#x27;</span>  </span><br>    - <span class="hljs-string">&quot;js/test.js&quot;</span>  <br>    <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件、但包括子目录下的所有目录和文件  </span><br>    - <span class="hljs-string">&quot;js/*&quot;</span>  <br>    <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件和子目录下的任何文件 </span><br>    - <span class="hljs-string">&quot;js/**/*&quot;</span>  <br>    <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 目录下的所有文件名以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件，但包括其它文件和子目录下的单文件 </span><br>    - <span class="hljs-string">&quot;js/test*&quot;</span> <br>    <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 及其子目录中任何以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件  </span><br>    - <span class="hljs-string">&quot;js/**/test*&quot;</span>  <br>    <span class="hljs-meta"># 不要用 exclude 来忽略 <span class="hljs-string">&#x27;source/_posts/&#x27;</span> 中的文件。你应该使用 <span class="hljs-string">&#x27;skip_render&#x27;</span>，或者在要忽略的文件的文件名之前加一个下划线 <span class="hljs-string">&#x27;_&#x27;</span>  # 在这里配置一个 </span><br>    - <span class="hljs-string">&quot;_posts/hello-world.md&quot;</span> 是没有用的。<br></code></pre></td></tr></table></figure><p>列表中的每一项都必须用单引号或双引号包裹起来。</p><p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以在文件名之前添加下划线 <code>_</code>。</p><h3 id="使用代替配置文件"><a href="#使用代替配置文件" class="headerlink" title="使用代替配置文件"></a>使用代替配置文件</h3><p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sml"># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; <span class="hljs-keyword">in</span> place <span class="hljs-keyword">of</span> <span class="hljs-symbol">&#x27;_config</span>.yml&#x27;<br>$ hexo server --config custom.yml<br><br># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; &amp; <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;, prioritizing&#x27;custom3.yml&#x27;, <span class="hljs-keyword">then</span> <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span> --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span>,custom2<span class="hljs-variable">.json</span><br></code></pre></td></tr></table></figure><p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p><h3 id="覆盖主题配置"><a href="#覆盖主题配置" class="headerlink" title="覆盖主题配置"></a>覆盖主题配置</h3><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。<br>你可以在站点的 <code>_config.yml</code> 配置文件中配置你的主题，这样你就不需要 fork 一份主题并维护主题独立的配置文件。</p><p>以下是一个覆盖主题配置的例子：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme_config:</span>  <br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;  <br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,  <br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo开始使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/2019/10/29/Hexo/"/>
    <url>/2019/10/29/Hexo/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><blockquote><p>Mac 用户</p><p>您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></blockquote><blockquote><p>For Mac / Linux 用户</p><p>如果你是 macOS 用户，或者是通过软件管理器从默认软件仓库安装 Node.js 的 Linux 用户，在使用 npm 的 <code>-g</code> 参数时可能会遇到一些权限相关的问题。请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题，<strong>并且不要使用 root、sudo 等方法覆盖权限</strong></p></blockquote><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><ul><li><p>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</p></li><li><p>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a> 安装。</p></li><li><p>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></p></li><li><p>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></p></li></ul><blockquote><p>Windows 用户</p><p>由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win">这个页面</a>，收录了存储于百度云的下载地址。</p></blockquote><h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/nvm-sh/nvm">nvm</a>。nvm 的开发者提供了一个自动安装 nvm 的简单脚本：</p><p>cURL:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ curl -o- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/nvm-sh/</span>nvm<span class="hljs-regexp">/v0.34.0/i</span>nstall.sh | sh<br></code></pre></td></tr></table></figure><p>Wget:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ wget -qO- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/nvm-sh/</span>nvm<span class="hljs-regexp">/v0.34.0/i</span>nstall.sh | sh<br></code></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ nvm install <span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><blockquote><p>Windows 用户</p><p>对于 Windows 用户我们推荐使用 <a href="https://github.com/jasongin/nvs/">nvs</a> 而不是 nvm。nvs 具有和 nvm 相似的命令行语法，并且可以通过 Windows Installer (MSI) 安装包进行安装。</p></blockquote><p>或者您也可以下载 <a href="http://nodejs.org/">安装程序</a> 来安装。</p><blockquote><p>Windows 用户</p><p>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选<strong>Add to PATH</strong>选项。<br>另外，您也可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p></blockquote><blockquote><p>Linux 用户</p><p>大部分 Linux 发行版都会在它们的默认软件包仓库中分发 Node.js。第三方仓库 <a href="https://github.com/nodesource/distributions">NodeSource</a> 通常能分发最新版本的 Node.js。</p></blockquote><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h4 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h4><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><h5 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h5><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">package</span>.json<br>&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;hexo&quot;</span>: &#123; <br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span>  <br>    &#125;,  <br>    <span class="hljs-string">&quot;dependencies&quot;</span>: &#123; <br>        <span class="hljs-string">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^3.8.0&quot;</span>,<br>        <span class="hljs-string">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^0.1.5&quot;</span>, <br>        <span class="hljs-string">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^0.1.3&quot;</span>, <br>        <span class="hljs-string">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^0.2.1&quot;</span>,<br>        <span class="hljs-string">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^0.2.0&quot;</span>, <br>        <span class="hljs-string">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^0.3.1&quot;</span>, <br>        <span class="hljs-string">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span>,<br>        <span class="hljs-string">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^0.3.2&quot;</span>,<br>        <span class="hljs-string">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span>  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h5><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h5 id="source"><a href="#source" class="headerlink" title="source"></a>source</h5><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h5 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h5><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo开始使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown编辑hexo媒体资源问题</title>
    <link href="/2019/10/28/Markdown%E7%BC%96%E8%BE%91hexo%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98/"/>
    <url>/2019/10/28/Markdown%E7%BC%96%E8%BE%91hexo%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>使用 <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code> 安装0.0.5版本的hexo-asset-image插件。<br>使用 <code>npm install hexo-asset-image --save</code> 安装的是1.0.0版本的hexo-asset-image插件。<br>两者最直接的区别是映射关系不同。</p><p>前者映射<code>/YYYY/MM/DD/* / * .xxx</code>图片能够显示出来，后者不知道为什么映射为<code>/.com//* * / * .xxx</code> 图片资源不能成功访问。</p><p>后者问题解决办法：<br>第一步：安装插件，在hexo根目录打开Git Bash,执行<br>    <code>npm install hexo-asset-image --save</code><br>第二步：打开hexo的配置文件<code>_config.yml</code><br>找到 <code>post_asset_folder</code>，把这个选项从false改成true<br>第三步：打开<br><code>/node_modules/hexo-asset-image/index.js</code><br>将内容更换为下面的代码（在此感谢Ericam_ 大神：<a href="https://blog.csdn.net/xjm850552586%EF%BC%89">https://blog.csdn.net/xjm850552586）</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;<br>&#125;<br><br><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.config;<br>  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;<br>        <span class="hljs-keyword">var</span> link = data.permalink;<br>    <span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>       <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>       <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br>    <span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;<br>    link = link.substring(beginPos, endPos);<br><br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br> <br>      <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;<br>        ignoreWhitespace: <span class="hljs-literal">false</span>,<br>        xmlMode: <span class="hljs-literal">false</span>,<br>        lowerCaseTags: <span class="hljs-literal">false</span>,<br>        decodeEntities: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br>            <span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br>            <span class="hljs-keyword">var</span> src = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;<br>               !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;<br>              <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br>              <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>              <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br>                <span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;<br>              &#125;);<br>              <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br>                <span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;<br>              &#125;);<br>              <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)<br>                srcArray.shift();<br>              src = srcArray.join(<span class="hljs-string">&#x27;/&#x27;</span>);<br>              $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, config.root + link + src);<br>              <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<br>            <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-built_in">this</span>));<br>        &#125;<br>      &#125;);<br>      data[key] = $.html();<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>第四步：现在就可以插入图片了，比如hexo new post photo之后<br>就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br>在photo.md文件里面按markdown的标准写。</p><p>参考链接：<br><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br><a href="https://blog.csdn.net/qq_38148394/article/details/79997971">https://blog.csdn.net/qq_38148394/article/details/79997971</a></p><p>参考：DCBXZ<br>链接：<a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a><br>来源：简书</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo静态页面脚手架搭建</title>
    <link href="/2019/10/28/scaffold/"/>
    <url>/2019/10/28/scaffold/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo从零开始到完整搭建"><a href="#Hexo从零开始到完整搭建" class="headerlink" title="Hexo从零开始到完整搭建"></a>Hexo从零开始到完整搭建</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很早就想搭建自己的Blog了，但是以前以为需要有自己的域名、服务器（qiong）还要自己编写页面代码（cai），觉得很麻烦（lan）所以这个想法被搁置了很久。也是最近闲来无事翻了翻开源中国，了解了hexo这个玩意，花了一天时间自己搭了一下。</p><ol><li>安装Git</li><li>安装Nodejs</li><li>安装Hexo</li><li>生成SSH并添加到Github</li><li>部署项目并上传</li><li>绑定个人域名</li><li>修改和配置主题</li></ol><h3 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h3><h4 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h4><ul><li><p>git下载地址：<a href="https://git-for-windows.github.io/">https://git-for-windows.github.io/</a></p></li><li><p>安装过程：双击Git-2.23.0-64-bit.exe，接着一路’下一步‘就好</p></li><li><p>安装无误后：cmd输入git –version查看Git的版本</p></li></ul><p><img src="/2019/10/28/scaffold/git-v.png" alt="git-v"></p><h4 id="2、安装nodejs"><a href="#2、安装nodejs" class="headerlink" title="2、安装nodejs"></a>2、安装nodejs</h4><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用</p><ul><li><a href="https://nodejs.org/en/">下载地址</a>(说明：LTS为长期支持版，Current为当前最新版)</li><li>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 <code>Add to PATH</code> ,这样你就不用自己去配置电脑上环境变量了，装完在按 <code>win + r</code> 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</li><li>查看版本：命令<code>node -v</code></li></ul><p><img src="/2019/10/28/scaffold/node-v.png" alt="node-v"></p><h4 id="3、安装Hexo"><a href="#3、安装Hexo" class="headerlink" title="3、安装Hexo"></a>3、安装Hexo</h4><ul><li><p>先创建一个文件夹，如/Hexo，这个文件夹就相当于我们Blog项目目录</p></li><li><p>执行Hexo安装命令：<code>npm i -g hexo</code></p></li><li><p>安装完成后，查看版本：<code>hexo -v</code></p><p><img src="/2019/10/28/scaffold/hexo-v.png" alt="1572250103953"></p></li><li><p><code>cd</code>到先前创建目录，如/Hexo，执行<code>hexo init</code>初始化命令，完成后即可看到自动创建的如下内容：</p><p><img src="/2019/10/28/scaffold/hexo-init.png" alt="hexo-init"></p></li><li><p>解释一下：</p><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li></ul><h4 id="4、搭桥到你的GitHub"><a href="#4、搭桥到你的GitHub" class="headerlink" title="4、搭桥到你的GitHub"></a>4、搭桥到你的GitHub</h4><p>没账号的创建账号，有账号的看下面。</p><ul><li>创建一个repo，名称为<code>yourname.github.io</code>, 其中<code>yourname</code>是你的github名称，按照这个规则创建才有用哦，如下：<br><img src="/2019/10/28/scaffold/newrepo1.png" alt="newrepo1"></li></ul><p>  <img src="/2019/10/28/scaffold/newrepo2.png" alt="newrepo2"></p><ul><li>进入git bash中其实进入cmd一样，配置Github账户信息（YourName和YourEail都替换成你自己的）：<br><img src="/2019/10/28/scaffold/gitbash.png" alt="gitbash"></li></ul><p>  <img src="/2019/10/28/scaffold/gitconfigname.png" alt="gitconfigname"></p><p>  <img src="/2019/10/28/scaffold/gitconfigemail.png" alt="gitconfigemail"></p><p>  <img src="/2019/10/28/scaffold/gitconfig.png" alt="gitconfig"></p><ul><li><p>创建SSH</p><ul><li><p>在Git bash中输入：<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>，生成ssh。然后按下图的方式找到<code>id_rsa.pub</code>文件的内容。<br><img src="/2019/10/28/scaffold/sshdir.png" alt="sshdir"></p></li><li><p>将上面获取的ssh放到github中：<br><img src="/2019/10/28/scaffold/sshcontent.png" alt="sshcontent"></p></li><li><p>添加一个 New SSH key ，title随便取，key就填刚刚那一段。</p></li></ul><p><img src="/2019/10/28/scaffold/githubssh.png" alt="githubssh"></p><ul><li>在gitbash中验证是否添加成功：<code>ssh -T git@github.com</code></li></ul><p><img src="/2019/10/28/scaffold/sshtest.png" alt="sshtest"></p></li></ul><h4 id="5、一步之遥了"><a href="#5、一步之遥了" class="headerlink" title="5、一步之遥了"></a>5、一步之遥了</h4><ul><li>用编辑器打开你的blog项目，修改<code>_config.yml</code>文件的一些配置(冒号之后都是有一个半角空格的)：</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><ul><li>回到Git bash中，进入你的blog目录，分别执行以下命令：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<br>hexo <span class="hljs-keyword">generate</span><br>hexo server<br></code></pre></td></tr></table></figure><p>注：hexo 3.0把服务器独立成个别模块，需要单独安装：<code>npm i hexo-server</code>。</p><ul><li>打开浏览器输入：<code>http://localhost:4000</code></li></ul><h4 id="6、上传到GitHub"><a href="#6、上传到GitHub" class="headerlink" title="6、上传到GitHub"></a>6、上传到GitHub</h4><ul><li>先安装一波：<code>npm install hexo-deployer-git --save</code>（这样才能将你写好的文章部署到github服务器上并让别人浏览到）</li><li>执行命令(建议每次都按照如下步骤部署)：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<br>hexo <span class="hljs-keyword">generate</span><br>hexo deploy<br></code></pre></td></tr></table></figure><p>注意deploy的过程中要输入你的username及passward。如下：</p><p>  <img src="/2019/10/28/scaffold/hexo-deploy.png" alt="hexo-deploy"></p><ul><li>在浏览器中输入<code>http://YourGithubName.github.io</code>就可以看到你的个人博客啦，是不是很兴奋！</li><li>感觉Git bash中东西太多的时候输入<code>clear</code>命令清空一下。</li></ul><h4 id="7、个人域名绑定"><a href="#7、个人域名绑定" class="headerlink" title="7、个人域名绑定"></a>7、个人域名绑定</h4><ul><li><p>第一步购买域名：随便在哪个网站买一个就好了，鄙人是在Tencent购买的kongwei-liao.cn, DNS也是顺道在那买的。</p></li><li><p>第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是<code>kongwei-liao.cn</code>，只能添加一个哦。</p><p><img src="/2019/10/28/scaffold/domainnamebind.png" alt="domainnamebind"></p></li><li><p>到DNS中添加一条记录</p></li></ul><p>其中ip地址为你的Github的地址，可在cmd中ping一下就能看到(<code>ping yourname.github.io</code>)：</p><p>  <img src="/2019/10/28/scaffold/pinggithub.png" alt="pinggithub"></p><ul><li>接着再次部署一下，用你购买的域名打开，就可以看到你的博客啦~</li></ul><h4 id="8-修改及配置主题"><a href="#8-修改及配置主题" class="headerlink" title="8. 修改及配置主题"></a>8. <strong>修改及配置主题</strong></h4><ul><li><p>hexo初始化之后默认的主题是<code>landscape</code> , 然后你可以去<a href="https://hexo.io/themes/">这个地址</a>里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是<code>hueman</code>,看起来挺不错，至少是我喜欢的类型。</p><p><img src="/2019/10/28/scaffold/theme1.png" alt="theme1"></p></li><li><p>跟该主题相关的配置在<code>themes/hueman/_config.yml</code>里面,然后根据你的需要在这配配配就行了。</p><p><img src="/2019/10/28/scaffold/theme2.png" alt="theme2"></p></li><li><p>有的东西我也不知道是啥玩意儿，你要多试多倒腾几次，就能意会啦</p></li><li><p>下面是针对我所选的主题的两小点(别的主题我没看，可能也是类似):</p><p>在导航栏添加点东西</p><ul><li>例如我添加了一个更新日志的模块。</li><li>在主题的配置文件中，menu添加一栏：<code>Board: /board</code>。</li><li>然后在source中添加一个board，即对应上面的名字。然后再创建一个index.md，里面可以写你想写的内容。</li><li>在主题的<code>hueman/langulages/zh-CN.yml</code>中的index适当的位置加：<code>board: &#39;更新日志&#39;</code>，位置和名字是你自己设定。</li><li>重新部署，然后就OK了</li></ul><p>在侧边栏添加点东西</p><ul><li>回到你的主题的配置文件中，找到<code>widgets</code>一栏，在你要添加的位置处添加一条你自定义的名称。例如我的叫<code>communiation</code>且放在了第二行。</li><li>在上面所提到的<code>zh-CN.yml</code>文件中找到sidebar一栏，添加<code>communiation: &#39;你要设的名称&#39;</code>。</li><li>在<code>hueman/layout/widget</code>中添加一个<code>communiation.ejs</code>,填入模板</li></ul><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs erb"><span class="xml">&lt;%</span><span class="ruby"> <span class="hljs-keyword">if</span> (site.posts.length) &#123; </span><span class="xml">%&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget-wrap widget-list&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget-title&quot;</span>&gt;</span>&lt;%=</span><span class="ruby"> __(<span class="hljs-string">&#x27;sidebar.communiation&#x27;</span>) </span><span class="xml">%&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-comment">&lt;!--这里添加你要写的内容--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">&lt;%</span><span class="ruby"> &#125; </span><span class="xml">%&gt;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo开始使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Node.js</tag>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
