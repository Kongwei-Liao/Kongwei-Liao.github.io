

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>Java常见类及其继承关系（三） - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java常见类及其继承关系（三）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-11-11 10:01" pubdate>
        2019年11月11日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      89
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java常见类及其继承关系（三）</h1>
            
            <div class="markdown-body">
              <h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在大学期间，专门有门课程叫数据结构，那数据结构有什么用呢？</p>
<p>简单理解数据结构是用来存储数据的；（比如堆栈，队列，二叉树)</p>
<p>数据结构定义：数据结构是 计算机对数据存储的一种安排；</p>
<h4 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h4><h5 id="变量存储"><a href="#变量存储" class="headerlink" title="变量存储"></a>变量存储</h5><blockquote>
<p>注意：</p>
<p>值和类型匹配问题：数据类型限定了变量可以存储的数据类型</p>
<p>成员变量和局部变量问题：在使用局部变量之前，必须赋值</p>
<p>成员变量有默认值但是默认值都没有多大意义，在做项目的时候，给它赋一些值</p>
</blockquote>
<h5 id="数组存储"><a href="#数组存储" class="headerlink" title="数组存储"></a>数组存储</h5><blockquote>
<p>特点：长度固定，只能够是存储同种类型；  </p>
</blockquote>
<h5 id="自定义存储–顺序表"><a href="#自定义存储–顺序表" class="headerlink" title="自定义存储–顺序表"></a>自定义存储–顺序表</h5><blockquote>
<p>① 希望可以存储任意多个元素；</p>
<p>② 希望可以存储任意类型的数据;</p>
<p><strong>分析：———&gt;</strong></p>
<p>   在Java中，万物皆对象，可以设置一个类表示上面的容器，那怎么设计?</p>
<p><strong>提示：———&gt;</strong></p>
<p>   比如： Integer类 里面有个int value 变量存储值,</p>
<p>​       String类 里面有个 char[] value 字符数组变量存储值.</p>
<p>  如下图所示:</p>
<p>   <img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/clip_image001.png" srcset="/img/loading.gif" alt="1"> <img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/clip_image002.png" srcset="/img/loading.gif" alt="2"></p>
<p><strong>步骤：———&gt;</strong></p>
<p>  ①自定义一个容器类，比如（IntArray类）；</p>
<p>  ②先做到可以存储多个int值，内部使用int数组；</p>
<p>  ③类里面 创建了一个int数组，当int数组满足之后，在创建一个新的数组；并且把老的数组值拷贝到新的数组里面(<strong>实现自动扩容</strong>)；</p>
<p>  <img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/clip_image004.jpg" srcset="/img/loading.gif" alt="im"></p>
<p>自定义类已经设计好了，那用户在操作的时候，怎么使用？也就是怎么存值，怎么取值?</p>
<ul>
<li>  方案一：把里面的数组设置为private，提供get，set方法；通过get就可以取得数组的值；</li>
<li>  方案二：在类里面提供一个方法，比如add，调用一次，就往里面添加一个值；</li>
</ul>
<p>哪种方式好，第一个种好吗，用户在调用的时候，通过get方法，取到了一个数组，在设置的时候，又需要传一个数组. 在操作的时候已经暴露出数组; 但是用户在操作的时候，并不想知道这些具体的实现；</p>
<p>第二种方式，直接提供方法，封装性更强更好;也就是存的时候，提供了一个add方法，调用一次add方法就向容器里面添加一个元素;</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//自定义的</span><br><span class="hljs-comment">//问题：这个自定义容器只能存放int型数据，为什么改成Object[] data;就能存放任意数据类型包括基本数据类型</span><br>package cn.kongwei_liao.DataStruct;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntArray</span> &#123;</span><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 *  ① 定义一个自定义容器类 IntArray</span><br><span class="hljs-comment">        ② 创建一个存放数据的数组 比如 int[] data= new int[10];</span><br><span class="hljs-comment">        ③ 定义一个添加方法 add ，调用一次给当前容器对象添加一个元素</span><br><span class="hljs-comment">        ④ 创建自定义容器类对象，调用add方法，添加元素</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//private int [] data= new int[10];</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> [] data;<br>	<span class="hljs-comment">//定义一个计数器</span><br>	<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span> ;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IntArray</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//data=new int[10];</span><br>		<span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IntArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>		data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>	&#125;<br>	<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 添加方法 add 传入一个参数值</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> str)</span></span>&#123;<br>     <span class="hljs-comment">//date[size] = str;</span><br>     <span class="hljs-comment">//size++;</span><br>		<br>		<span class="hljs-comment">//判断数组已满</span><br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>==data.length) &#123;<br>			<span class="hljs-comment">//自动扩充2倍长度</span><br>			<span class="hljs-keyword">int</span>[] new1=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[data.length*<span class="hljs-number">2</span>];<br>			<span class="hljs-comment">//将老数组内容拷贝的扩容的新数组</span><br>			System.arraycopy(data, <span class="hljs-number">0</span>, new1, <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span>);<br>			<span class="hljs-comment">//原老数组的引用指向新数组</span><br>			data=new1;<br>		&#125;<br>		<br>		data[<span class="hljs-built_in">size</span>++] = str;<br>		<br>	&#125;<br>	<span class="hljs-comment">//覆写toString方法</span><br>	@Override<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-comment">//return Arrays.toString(date);</span><br>		<span class="hljs-comment">//把元素数组的值，拷贝到新数组里面</span><br>		<span class="hljs-keyword">int</span> [] newArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-built_in">size</span>];<br>		System.arraycopy(data, <span class="hljs-number">0</span>, newArr, <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span>);<br>		<span class="hljs-keyword">return</span> Arrays.toString(newArr);<br>	&#125;<br><br>	<span class="hljs-comment">//添加返回数组大小方法：getSize</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//自定义容器查找</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getElementByIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>||index&gt;=<span class="hljs-built_in">size</span>) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">&quot;查找失败！&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">return</span> data[index];<br>	&#125;<br>	<br>	<span class="hljs-comment">//查找指定元素第一次出现的索引</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFirstIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ele)</span> </span>&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">size</span>;i++) &#123;<br>			<span class="hljs-keyword">if</span>(data[i]==ele) &#123;<br>				<span class="hljs-keyword">return</span> i;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">//自定义容器，删除元素</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">deleteElementByIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>		<span class="hljs-comment">//越界判断</span><br>		<span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>||index&gt;=<span class="hljs-built_in">size</span>) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(<span class="hljs-string">&quot;越界！&quot;</span>);<br>		&#125;<br>		<br>		<span class="hljs-comment">//删除元素  原位置index+1</span><br>		System.arraycopy(data, index+<span class="hljs-number">1</span>, data, index, <span class="hljs-built_in">size</span>-index<span class="hljs-number">-1</span>);<br>		<span class="hljs-built_in">size</span>--;<br>		Object ele =data[index];<br>		<span class="hljs-keyword">return</span> ele;<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 删除指定的第一个元素</span><br><span class="hljs-comment">	 * 1、查找元素的第一个下标</span><br><span class="hljs-comment">	 * 2、删除第一个元素</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFirstElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ele)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> index=<span class="hljs-keyword">this</span>.getFirstIndex(ele);<br>		<span class="hljs-keyword">this</span>.deleteElementByIndex(index);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/del.png" srcset="/img/loading.gif" alt="del"></p>
</blockquote>
<p>补充：基本数据类型与Object的关系</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span>&#123;<br>                int  a = <span class="hljs-number">33</span>;<br>        sop(a);    <span class="hljs-comment">//可以说明基本数据类型和Object之间存在多态关系吗？</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">sop</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> obj</span>)</span> &#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>原因：java在寻找最佳匹配方法时无法找到完全匹配的参数时会进行自动提升转换或者其它相应转换。</p>
<p>Debug下查看：</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/debug.png" srcset="/img/loading.gif" alt="de"></p>
<h5 id="自定义存储–链表"><a href="#自定义存储–链表" class="headerlink" title="自定义存储–链表"></a>自定义存储–链表</h5><p>已经使用变量、数组和自定义容器类存放数据；</p>
<blockquote>
<ul>
<li>变量：存储一个值；</li>
<li>数组：存储多个值；</li>
<li>自定义容器：在类中封装一个数组</li>
</ul>
<p>对于变量直接赋值使用; 对于数组，通过下标使用; 对于自定义容器类的操作，我们通过添加add方法，进行使用.它的原理是内部使用数组来存储实现，但是用户并不关心内部怎么实现.</p>
</blockquote>
<p>需求：</p>
<blockquote>
<p>如果在设计一个容器类（自定义一个容器类），对于容器类的操作，一般提供一个add方法，调用add方法的时候，需要传一个值，然后把值存放在容器里面，</p>
<p>但是现在【不用数组】, 那还可以用什么类型方式存储？</p>
</blockquote>
<p>分析：</p>
<blockquote>
<p>现在基于变量的方式来存储，比如一组零散的数据放到容器里面，对于容器类，能够准确的提供方法来添加，能够操作就可以了，我们也不关心怎么存放；</p>
<p>对于这些数据，可能是整型，字符串，假如现在把这些零散的数据都看成对象.</p>
<p>比如使用变量 :  int i1 = 11；  int i2 = 4；</p>
<p>如果看成对象使用Integer的写法：  Integer i11 = 11;  Integer i12 = 4;</p>
<p>如果看成对象来看的话，在堆栈图中是怎样的?</p>
<ul>
<li>栈里面i11，指向堆里面地址，所以操作这些地址就是相当于操作值了。现在我把这些零散的对象连起来。</li>
<li>第一个对象地址，比如0x1234，容器类里面存放一个变量（Integer i11），拿到i11的地址，因为跟其他对象是关联的，那它是不是也就拿到的其他关联上对象的地址。<br><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/clip_image002.jpg" srcset="/img/loading.gif" alt="img"></li>
</ul>
</blockquote>
<p>问题：如何将4和11连接起来？</p>
<blockquote>
<p>分析：</p>
<p>比如现在把Integer i11 变量指向它的引用，相等于把i11存放在容器类里面了，现在</p>
<p>让11对象里面存放4的地址，但是都是Integer 对象，怎么存放别对象的地址？</p>
<p>思路: </p>
<p>根据刚才分析，在容器当中存放一个变量，也就是定义一个变量，指向该对象;</p>
<p>在对象当中，又有变量指向其他对象.这就就连接起来;</p>
<p>现在自定义一个类Node（相当于口袋），类里面定义两个字段，</p>
<ul>
<li> 一个Object类型存放值，</li>
<li> 一个Node类型字段，存放下一个Node对象地址. </li>
</ul>
<p>把11封装成一个Node对象，把对象放到容器里面，但是现在不放在容器里面，而在内部定义Node类型变量first，把first指向11地址；如果在添加一个。比如22，通过一个方法，把22封装成Node对象，然后让11和22联系起来，那怎么让11和22联系起来？</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class <span class="hljs-keyword">Node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">	Object</span> data;//用于添加数据...<br>	<span class="hljs-keyword">Node</span> <span class="hljs-title">node</span>;//用于保存下一个对象的地址<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以在11对象中定义一个变量，让这个变量指向22这个对象，那就应该在Node类里面定义一个变量，这个变量存放什么值，就是存放Node对象，所以应该定义成Node类型。</p>
<p>如下图:</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/clip_image01.png" srcset="/img/loading.gif" alt="img"></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//自定义的</span><br><span class="hljs-keyword">package</span> cn.kongwei_liao.DataStruct;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MyLinkedList &#123;<br><br>	<span class="hljs-keyword">class</span> Node&#123;<br>		Object data;<span class="hljs-comment">//用于添加数据</span><br>		Node <span class="hljs-keyword">next</span>;<span class="hljs-comment">//保存下一结点对象地址</span><br>		Node(Object data)&#123;<br>			<span class="hljs-keyword">this</span>.data=data;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">private</span> Node first;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> add(Object obj) &#123;<br>		<span class="hljs-comment">//将用户传入的数据打包</span><br>		Node n=<span class="hljs-keyword">new</span> Node(obj);<br>		<span class="hljs-comment">//打包好的数据挂到first上面</span><br>		<span class="hljs-comment">//如果是第一次添加直接挂到first上面，否则，因该挂在最后添加的Node对象上面</span><br>		<span class="hljs-keyword">if</span>(first==<span class="hljs-keyword">null</span>) &#123;<br>			first=n;<br>		&#125;<span class="hljs-keyword">else</span> &#123;<br>			Node temp=first;<br>			<span class="hljs-keyword">while</span>(temp.<span class="hljs-keyword">next</span>!=<span class="hljs-keyword">null</span>) &#123;<br>				temp=temp.<span class="hljs-keyword">next</span>;<br>			&#125;<br>			temp.<span class="hljs-keyword">next</span>=n;<br>		&#125;<br>		<span class="hljs-keyword">size</span>++;<br>	&#125;<br>	@Override<br>	<span class="hljs-keyword">public</span> String toString() &#123;<br>		StringBuffer sb=<span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;[&quot;</span>);<br>		Node temp=first;<span class="hljs-comment">//临时变量指向链表头部</span><br>		<span class="hljs-keyword">while</span>(temp!=<span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">if</span>(temp.data!=<span class="hljs-keyword">null</span>&amp;&amp;temp.<span class="hljs-keyword">next</span>!=<span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//数据不为空，且下一结点存在</span><br>				sb.<span class="hljs-keyword">append</span>(temp.data).<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>			&#125;<span class="hljs-keyword">else</span> &#123;<br>				sb.<span class="hljs-keyword">append</span>(temp.data);<span class="hljs-comment">//最后一个结点</span><br>			&#125;<br>			temp=temp.<span class="hljs-keyword">next</span>;<span class="hljs-comment">//temp指向下一个结点</span><br>		&#125;<br>		sb.<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot;]&quot;</span>);<br>		<span class="hljs-keyword">return</span> sb.toString();<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getSize() &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">size</span>;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><blockquote>
<p>1、本阶段会学习：常见的Java中写好的集合框架的类和接口；</p>
<p>2、集合框架： 看成是学习一些Java中设计好的容器类；</p>
<p>3、容器：盛装东西的</p>
<p>4、如何创建容器对象；</p>
<p>5、如何把数据装到容器中—&gt; 调用方法；</p>
<p>6、如何把容器中的数据取出—&gt;还是调用方法；</p>
<p>7、可能的难点：我们会学习各种各样的集合容器类，它们有各自的存储特点，难以选择</p>
<p>解决：分析清楚每一个的特点，实际场景中自己的需求，如果很多都可以，那就随便选</p>
<p>8、在本阶段任务要求：</p>
<p>① 学会使用</p>
<p>② 了解我们提到的Java中的这些容器类的设计原理</p>
<p>9、最近看到类型后面有<E> <T> <K> <V>… 直接忽略，过几天学习的泛型；直接看成Object</p>
<p>10、集合框架中存储的元素全部都是对象，从1.5开始支持自动装箱拆箱，所以基本数据类型也可以直接添加</p>
</blockquote>
<h4 id="所有集合的超类"><a href="#所有集合的超类" class="headerlink" title="所有集合的超类"></a>所有集合的超类</h4><p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/superclass.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/superclass1.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/clip.jpg" srcset="/img/loading.gif" alt="img"></p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>基于数组，查询和修改速度快（相比于LinkedList）；</p>
<p>方法：添加、删除、查询、插入、修改等；</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/alf.png" srcset="/img/loading.gif" alt="alf"></p>
<p>不是同步的（存在线程安全问题），如何解决？？</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/arrayl.png" srcset="/img/loading.gif" alt="al"></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs awk">package cn.kongwei_liao.DataStruct;<br><br>import java.util.ArrayList;<br>import java.util.Iterator;<br>import java.util.ListIterator;<br><br>public class ArrayListDemo &#123;<br><br>	public static void main(String[] args) &#123;<br>		<span class="hljs-regexp">//</span> TODO Auto-generated method stub<br>		ArrayList bag = new ArrayList();<br>		bag.add(<span class="hljs-string">&quot;电脑&quot;</span>);<br>		bag.add(<span class="hljs-number">200</span>);<br>		bag.add(<span class="hljs-string">&quot;鼠标&quot;</span>);<br>		bag.add(<span class="hljs-string">&quot;小人书&quot;</span>);<br>		bag.add(<span class="hljs-string">&quot;教材&quot;</span>);<br>		bag.add(<span class="hljs-string">&quot;牛奶&quot;</span>);<br>		<br><span class="hljs-regexp">//</span>		<span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;bag.size();i++)&#123;<br><span class="hljs-regexp">//</span>			System.out.println(bag.get(i));<br><span class="hljs-regexp">//</span>		&#125;<br>		<br><span class="hljs-regexp">//</span>		<span class="hljs-keyword">for</span>(源中的数据类型 变量名 : 源)&#123;<br><span class="hljs-regexp">//</span><br><span class="hljs-regexp">//</span>		&#125;<br><span class="hljs-regexp">//</span>		注意：源可以是数组或者集合（Iterable的实例）<br><br><span class="hljs-regexp">//</span>		<span class="hljs-keyword">for</span>(Object obj:bag)&#123;<span class="hljs-regexp">//</span>增强<span class="hljs-keyword">for</span>循环（foreach）<br><span class="hljs-regexp">//</span>			System.out.println(obj);<br><span class="hljs-regexp">//</span>		&#125;<br>		<br><span class="hljs-regexp">//</span>		Iterator it = bag.iterator();<br><span class="hljs-regexp">//</span>		<span class="hljs-keyword">while</span>(it.hasNext())&#123;<br><span class="hljs-regexp">//</span>			System.out.println(it.<span class="hljs-keyword">next</span>());<br><span class="hljs-regexp">//</span>		&#125;<br><span class="hljs-regexp">//</span>		<span class="hljs-keyword">while</span>(it.hasNext())&#123;<span class="hljs-regexp">//</span>这一次迭代器遍历输出为空<br><span class="hljs-regexp">//</span>			System.out.println(it.<span class="hljs-keyword">next</span>());<br><span class="hljs-regexp">//</span>		&#125;<br>		<br>		ListIterator iterator = bag.listIterator();<br>		<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>			System.out.println(iterator.<span class="hljs-keyword">next</span>());<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;------------------------------------------&quot;</span>);<br>		<span class="hljs-keyword">while</span>(iterator.hasPrevious())&#123;<span class="hljs-regexp">//</span>如果将上面的向后迭代注释掉，向前迭代的输出为空<br>			System.out.println(iterator.previous());<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>Iterator 就是一个迭代器（也是一个接口）</p>
<p>其中的方法如下：</p>
<blockquote>
<p>boolean hasNext() 判断是否有下一个元素，如果返回true表示有下一个；</p>
<p>Object next() 调用一次获得一个元素（每调用一次指针会向后移动一个）；</p>
<p>void remove() 会从迭代器指向的结合容器中删除一个元素</p>
</blockquote>
<p>一个迭代器，循环完毕就把指针移动到末尾了。</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/iter.jpg" srcset="/img/loading.gif" alt="img"></p>
<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4><p>Iterator 单项的迭代器接口，从左到右依次获得数据，判断是否有下一个；获得下一个</p>
<p>​      |– ListIterator  双向的迭代器接口，它的主要方法如下：</p>
<p>​                             Iterator中有的它也有；</p>
<p>​                             boolean hasPrevious() 判断是否有上一个；</p>
<pre><code>                         Object previous() 获得上一个元素；
</code></pre>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ListIterator iterator = bag.<span class="hljs-built_in">list</span><span class="hljs-constructor">Iterator()</span>;<br><span class="hljs-keyword">while</span>(iterator.has<span class="hljs-constructor">Next()</span>)&#123;<br>	<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(iterator.next<span class="hljs-literal">()</span>);<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;------------------------------------------&quot;</span>);<br><span class="hljs-keyword">while</span>(iterator.has<span class="hljs-constructor">Previous()</span>)&#123;<span class="hljs-comment">//如果将上面的向后迭代注释掉，向前迭代的输出为空</span><br>	<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(iterator.previous<span class="hljs-literal">()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>基于链表结构，添加和删除操作效率高（相对于上面的数组结构）</p>
<p>内部相对于ArrayList而言多了写操作头和尾的方法</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/llf.png" srcset="/img/loading.gif" alt="llf"></p>
<p>可以充当队列和堆栈</p>
<p>不是同步的（存在线程安全问题）</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/ll.png" srcset="/img/loading.gif" alt="img"></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> cn.kongwei_liao.DataStruct;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> class LinkedListDemo &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[]args) &#123;<br>		LinkedList list = <span class="hljs-keyword">new</span> LinkedList();<br>		list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>		list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>		list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br>		list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;D&quot;</span>);<br>		list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;E&quot;</span>);<br>		System.out.<span class="hljs-built_in">println</span>(list);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-built_in">size</span>(); i++) &#123;<br>			System.out.<span class="hljs-built_in">println</span>(list.pop());<span class="hljs-comment">//输出A B C，而D和E没有打印出来，因为每pop一次size减1</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/res.png" srcset="/img/loading.gif" alt="rs"></p>
<h3 id="不重复元素的容器"><a href="#不重复元素的容器" class="headerlink" title="不重复元素的容器"></a>不重复元素的容器</h3><p><strong>如何自定义不能存放重复元素的容器</strong></p>
<blockquote>
<p>1、现在需要我们自己设计一个容器类，不能够添加重复元素（如果元素重复了就添加不进去）</p>
<p>2、在前面我们设计的基于数组的自定义容器类的基础上改版</p>
<p>3、需要在add方法内部判断重复</p>
<p>4、如何判断：</p>
<ul>
<li>每一次调用add会传入一个参数： 用户希望添加的元素 ele</li>
<li>遍历内部的数组，判断数组中是否包含ele</li>
</ul>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-built_in">add</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">str</span>)&#123;<br>			<span class="hljs-comment">//判断当前容器是否已经存在待插入元素</span><br>			<span class="hljs-comment">//方法一</span><br><span class="hljs-comment">//			for(int i=0;i&lt;size;i++) &#123;</span><br><span class="hljs-comment">//				if(data[i].equals(str))</span><br><span class="hljs-comment">//					return false;</span><br><span class="hljs-comment">//			&#125;</span><br>			<span class="hljs-comment">//方法二</span><br>			<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.getFirstIndex(<span class="hljs-built_in">str</span>)&gt;=<span class="hljs-number">0</span>)<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>			<br>			<br>	     <span class="hljs-comment">//date[size] = str;</span><br>	     <span class="hljs-comment">//size++;</span><br>			<br>			<span class="hljs-comment">//判断数组已满</span><br>			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>==data.length) &#123;<br>				<span class="hljs-comment">//自动扩充2倍长度</span><br>				<span class="hljs-keyword">Object</span>[] new1=<span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>[data.length*<span class="hljs-number">2</span>];<br>				<span class="hljs-comment">//将老数组内容拷贝的扩容的新数组</span><br>				System.arraycopy(data, <span class="hljs-number">0</span>, new1, <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span>);<br>				<span class="hljs-comment">//原老数组的引用指向新数组</span><br>				data=new1;<br>			&#125;<br>			<br>			data[<span class="hljs-built_in">size</span>++] = <span class="hljs-built_in">str</span>;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br></code></pre></td></tr></table></figure>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>特点：不重复（不添加重复元素），无序（不保证和添加顺序的一致）</p>
<p>成员方法：</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/HashSetFunctions.png" srcset="/img/loading.gif" alt="hsf"></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package cn.kongwei_liao.DataStruct;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> HashSetDemo &#123;<br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[]args) &#123;<br>		HashSet set1=<span class="hljs-built_in">new</span> HashSet();<br>		set1.<span class="hljs-keyword">add</span>(<span class="hljs-number">123</span>);<br>		set1.<span class="hljs-keyword">add</span>(<span class="hljs-number">123</span>);//未插入HashSet中<br>		<br>		<span class="hljs-type">Integer</span> i1=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">123</span>);<br>		<span class="hljs-type">Integer</span> i2=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">123</span>);<br>		<span class="hljs-type">Integer</span> i3=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">456</span>);<br>		<span class="hljs-type">Integer</span> i4=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">456</span>);<br>		set1.<span class="hljs-keyword">add</span>(i1);//未插入HashSet中<br>		set1.<span class="hljs-keyword">add</span>(i2);//未插入HashSet中<br>		set1.<span class="hljs-keyword">add</span>(i3);<br>		set1.<span class="hljs-keyword">add</span>(i4);//未插入HashSet中<br>		<br>		set1.<span class="hljs-keyword">add</span>(&quot;123&quot;);<br>		<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(set1);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(set1.size());<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/*控制台打印结果</span><br><span class="hljs-comment">[123, 456, 123]</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>需要考虑，HashSet内部到底是如何判断重复的？</p>
<blockquote>
<p>① 通过添加进去的元素的hashCode+eqauls 两者进行比较</p>
<p>② 如果两个对象的hashCode相等 并且 两个对象调用equals结果是true 才认为两个元素重复</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/HSrepeat.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>③  验证上面的规则</p>
<ul>
<li>打印上面示例中的元素的hashCode和equals的结果</li>
<li>尝试自定义类，覆写hashCode 和 equals 这两个方法中的代码随便写</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//这样重写HashCode和equals方法是不对的，想想清楚为什么？？<br>//因为这样重写的是HashSet的HashCode和equals方法，其实应该重写的是待插入对象类的这两个方法<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> HashSetDemo extends HashSet&#123;<br>	@Override<br>	<span class="hljs-built_in">public</span> <span class="hljs-type">int</span> hashCode() &#123;<br>		Random rd=<span class="hljs-built_in">new</span> Random(<span class="hljs-keyword">System</span>.currentTimeMillis());<br>		<span class="hljs-keyword">return</span> rd.nextInt();<br>	&#125;<br>	@Override<br>	<span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> equals(<span class="hljs-keyword">Object</span> obj) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>	<br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[]args) &#123;<br>		HashSetDemo set1=<span class="hljs-built_in">new</span> HashSetDemo();<br>		set1.<span class="hljs-keyword">add</span>(<span class="hljs-number">123</span>);<br>		set1.<span class="hljs-keyword">add</span>(<span class="hljs-number">123</span>);//未插入HashSet中<br>		<br>		<span class="hljs-type">Integer</span> i1=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">123</span>);<br>		<span class="hljs-type">Integer</span> i2=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">123</span>);<br>		<span class="hljs-type">Integer</span> i3=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">456</span>);<br>		<span class="hljs-type">Integer</span> i4=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">456</span>);<br>		set1.<span class="hljs-keyword">add</span>(i1);//未插入HashSet中<br>		set1.<span class="hljs-keyword">add</span>(i2);//未插入HashSet中<br>		set1.<span class="hljs-keyword">add</span>(i3);<br>		set1.<span class="hljs-keyword">add</span>(i4);//未插入HashSet中<br>		<br>		set1.<span class="hljs-keyword">add</span>(&quot;123&quot;);<br>		<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(set1);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(set1.size());<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*本来之意是将重复元素插入HashSet，但上面的代码没有成功</span><br><span class="hljs-comment">[123, 456, 123]</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//MDZZ  上例想明白原因后就想着重写Integer类中的HashCode和equals方法，Integer是被final修饰的。</span><br><span class="hljs-comment">//正确案例</span><br><span class="hljs-comment">//public class HashSetDemo extends HashSet&#123;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSetDemo</span></span>&#123;<br>	int i;<br>	<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">HashSetDemo</span>(<span class="hljs-params">int i</span>)</span> &#123;<br>		<span class="hljs-built_in">this</span>.i=i;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">hashCode</span>(<span class="hljs-params"></span>)</span> &#123;<br>		Random rd=<span class="hljs-keyword">new</span> Random(System.currentTimeMillis());<br>		<span class="hljs-keyword">return</span> rd.nextInt();<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> obj</span>)</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>+i;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[]args</span>)</span> &#123;<br>		HashSet set1=<span class="hljs-keyword">new</span> HashSet();<br>		<br>		HashSetDemo hsd1=<span class="hljs-keyword">new</span> HashSetDemo(<span class="hljs-number">1234</span>);<br>		HashSetDemo hsd2=<span class="hljs-keyword">new</span> HashSetDemo(<span class="hljs-number">1234</span>);<br>		set1.add(hsd1);<br>		set1.add(hsd2);<br>		<br>		System.out.println(set1);<br>		System.out.println(set1.size());<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*重写自定义对象的HashCode和equals方法</span><br><span class="hljs-comment">[1234, 1234]</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>④  实际开发情况分析（<strong>重点</strong>）</p>
<p>1、从上面的示例来看，结果两个都添加进去了，原因：hashCode不等，equals为false</p>
<p>2、从业务上来看（需要向源码时代学生管理系统中添加两个学生信息），觉得这两天数据是同一个人</p>
<p>3、应该怎么做： 在Student中覆写hashCode 和equals方法</p>
<p>4、怎么覆写？</p>
<p>覆写的时候应该参考实际业务中的比较规则，例如姓名，年龄等（还得看Student类中有哪些字段，并且这些字段是业务人员判断的标准）</p>
</blockquote>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>特点：无序（不保证我们添加元素的顺序）；不重复（不能添加重复元素）；</p>
<p>内部存储有一定的顺序</p>
<p>TreeSet一旦添加了第一个元素后就不能在添加其他数据类型的元素，只能添加相同数据类型的元素，除非将容器中所有的元素全部清空，才能添加新的数据类型的元素。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package cn.kongwei_liao.DataStruct;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> TreeSetDemo &#123;<br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>		// TODO Auto-<span class="hljs-keyword">generated</span> <span class="hljs-keyword">method</span> stub<br>		TreeSet ts=<span class="hljs-built_in">new</span> TreeSet();<br>		ts.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>		ts.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>		ts.<span class="hljs-keyword">add</span>(<span class="hljs-number">4</span>);<br>		ts.<span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>);<br>		ts.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);<br>		ts.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);<br>		//ts.<span class="hljs-keyword">add</span>(&quot;3&quot;);//RuntimeException<br>		<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(ts);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(ts.size());<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*明明是乱序添加的，为什么打印结果是有顺序的？</span><br><span class="hljs-comment">[1, 2, 3, 4, 5]</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">结果： 虽然打印结果的顺序和添加顺序可能不一致，但是感觉结果是有某种规则排序的</span><br><span class="hljs-comment">   	  String类也实现了Comparable接口，String对象可以调用compareTo方法</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> cn.kongwei_liao.DataStruct;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><span class="hljs-keyword">public</span> class TreeSetDemo &#123;<br>	<span class="hljs-built_in">int</span> i;<br>	<span class="hljs-keyword">public</span> TreeSetDemo(<span class="hljs-built_in">int</span> i)&#123;<br>		<span class="hljs-keyword">this</span>.i=i;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		TreeSet ts=<span class="hljs-keyword">new</span> TreeSet();<br>		<br>		TreeSetDemo tsd1=<span class="hljs-keyword">new</span> TreeSetDemo(<span class="hljs-number">1</span>);<br>		TreeSetDemo tsd2=<span class="hljs-keyword">new</span> TreeSetDemo(<span class="hljs-number">1</span>);<br>		TreeSetDemo tsd3=<span class="hljs-keyword">new</span> TreeSetDemo(<span class="hljs-number">2</span>);<br>		ts.<span class="hljs-built_in">add</span>(tsd1);<br>		ts.<span class="hljs-built_in">add</span>(tsd2);<br>		ts.<span class="hljs-built_in">add</span>(tsd3);<br>		<br>		System.out.<span class="hljs-built_in">println</span>(ts);<br>		System.out.<span class="hljs-built_in">println</span>(ts.<span class="hljs-built_in">size</span>());<br>	&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">结果： </span><br><span class="hljs-comment">	疑问1：上面的代码添加的都是同种类型的数据，为什么还报错；</span><br><span class="hljs-comment">	疑问2：为什么提示要把Student转成Comparable</span><br><span class="hljs-comment">	正常情况   ----》 TreeSet  或者  Comparable的文档</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/tse.png" srcset="/img/loading.gif" alt="tse"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.DataStruct;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeSetDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> i;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSetDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>		<span class="hljs-keyword">this</span>.i=i;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		TreeSet ts=<span class="hljs-keyword">new</span> TreeSet();<br>		<br>		TreeSetDemo tsd1=<span class="hljs-keyword">new</span> TreeSetDemo(<span class="hljs-number">1</span>);<br>		TreeSetDemo tsd2=<span class="hljs-keyword">new</span> TreeSetDemo(<span class="hljs-number">1</span>);<br>		TreeSetDemo tsd3=<span class="hljs-keyword">new</span> TreeSetDemo(<span class="hljs-number">2</span>);<br>		ts.add(tsd1);<br>		ts.add(tsd2);<br>		ts.add(tsd3);<br>		<br>		<br>		System.out.println(ts);<br>		System.out.println(ts.size());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/compare.png" srcset="/img/loading.gif" alt="c"></p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/ts.jpg" srcset="/img/loading.gif" alt="im"></p>
<blockquote>
<p>TreeSet内部存储数据是按照大小进行排序存储的</p>
<p>问题：对象的大小是谁决定的？TreeSet能确定吗？</p>
<p>例如：</p>
<p>​    需要向TreeSet中添加两个对象元素</p>
<p>​    new Student(“ali”,18)</p>
<p>​    new Student(“ajie”,19)</p>
<p>​    TreeSet不可能也不应该自己想一个规则来决定大小，而应该有我们来指定好规则（如按年龄大小）</p>
<p>​    –》给所有的对象都提供一个比较大小的方法</p>
<p>​    TreeSet怎么比较：直接调用对象上面比较大小的方法看结果</p>
<p>问题：TreeSet早就写好了，我们怎么告诉他们使用哪个比较方法呢？</p>
<p>其实在设计TreeSet之前Java设计了一个接口   Comparable接口     有compareTo(Object obj)比较大小的方法</p>
<p>所以：</p>
<p>​    TreeSet中会调用对象的compareTo(Object obj)方法进行比较</p>
<p>​    我们存入TreeSet的对象必须实现了Comparable接口</p>
</blockquote>
<h3 id="自然排序和定制排序（比较器）"><a href="#自然排序和定制排序（比较器）" class="headerlink" title="自然排序和定制排序（比较器）"></a>自然排序和定制排序（比较器）</h3><h4 id="自然排序-Comparable"><a href="#自然排序-Comparable" class="headerlink" title="自然排序 Comparable"></a>自然排序 Comparable</h4><p>从TreeSet的API文档中点击 “自然排序” —》 Comparable接口中</p>
<blockquote>
<p>文档中的描述：</p>
<p>​    此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法</p>
<p>理解：</p>
<p>​    如果一个类实现了Comparable接口，可以认为这个类的对象具有自然排序的能力（本质就是这个对象可以调用比较的方法compareTo），这种比较和排序的规则就是自然排序</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/clip_im.jpg" srcset="/img/loading.gif" alt="img"></p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/c02.jpg" srcset="/img/loading.gif" alt="img"></p>
</blockquote>
<h4 id="定制排序（比较器）Comparator"><a href="#定制排序（比较器）Comparator" class="headerlink" title="定制排序（比较器）Comparator"></a>定制排序（比较器）Comparator</h4><blockquote>
<p>1、根据上面的分析，如果我们的对象没有实现Comparable接口，感觉就无法添加到TreeSet中去；（这些对象就没有自然排序的能力）；</p>
<p>2、上面的示例设计有点问题：Student类中覆写的compareTo方法按照年龄从小到大排列的，万一有的人也是用我们的Student，希望年龄从大到小进行排列，怎么办？还例如，有人希望按照名字长度排序，怎么办？</p>
<p>不管Student里面使用何种规则都不能满足所有的人</p>
<p>3、解决办法： 可以给TreeSet单独的提供一个比较器（理解为比较的一个工具）</p>
<p>4、Comparator 是一个比较器的接口（标准），必须得有进行比较的方法 ：compare(Object o1,Object o2);</p>
<p>自定义一个类实现Comparator接口，其中写比较规则 —》 比较器的模板</p>
<p>我们现在需要的是一个具体的比较器对象</p>
</blockquote>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/cge002.jpg" srcset="/img/loading.gif" alt="img"></p>
<h4 id="判断重复的标准"><a href="#判断重复的标准" class="headerlink" title="判断重复的标准"></a>判断重复的标准</h4><p>1、如果采用的是自然排序调用对象的compareTo方法，如果返回0 表示相等；</p>
<ul>
<li>大于且返回正数，升序排列 =&gt; 小于且返回负数，升序排列  对应</li>
<li>大于且返回负数，降序排列 =&gt; 小于且返回正数，降序排列      对应</li>
</ul>
<p>2、如果使用的定制排序（比较器），调用比较器的方法compare 返回0 表示相等；</p>
<ul>
<li>大于且返回正数，升序排列 =&gt; 小于且返回负数，升序排列  对应</li>
<li>大于且返回负数，降序排列 =&gt; 小于且返回正数，降序排列      对应</li>
</ul>
<p><strong>如果一个类已经实现了Comparable接口，然后把这个类的对象放入一个具有比较器的TreeSet,那么TreeSet会按照哪种规则来比较呢？</strong></p>
<h3 id="Collection体系"><a href="#Collection体系" class="headerlink" title="Collection体系"></a>Collection体系</h3><p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/Collection.png" srcset="/img/loading.gif" alt="1"></p>
<p>面试经常问的问题：</p>
<p>1、请说说ArrayList LinkedList HashSet  TreeSet 底层的实现原理（建议多多百度几次），目前先了解一个大概</p>
<p>2、请说说==和equals的区别</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="什么是Map？"><a href="#什么是Map？" class="headerlink" title="什么是Map？"></a>什么是Map？</h4><p>Map也是一种容器，API文档描述将键映射到值的对象。一个一射（一个Map对象）不能包含重复的键，每一个键只能映射到一个值。</p>
<p>键、值、键值对和映射</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/map.png" srcset="/img/loading.gif" alt="img"></p>
<blockquote>
<p>Collection体系中，存储的都是单个的数据，数据之间没有关系。</p>
<p>Map和Collection是两个没有关系并列的体系（主要从代码结构来看）</p>
<p>Map的声明：public interface Map{}</p>
</blockquote>
<h5 id="Map的结构"><a href="#Map的结构" class="headerlink" title="Map的结构"></a>Map的结构</h5><p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/MapStruct.png" srcset="/img/loading.gif" alt="map"></p>
<p>Map场景：账号密码、情侣夫妻和二维坐标等；</p>
<h5 id="Map中的重要方法"><a href="#Map中的重要方法" class="headerlink" title="Map中的重要方法"></a>Map中的重要方法</h5><blockquote>
<p>基本方法列表：==========================</p>
<p>1、 Object put(Object key,Object value);  如果当前添加的这个key已经存在了，会覆盖这个键之前的值，返回的是之前的value值</p>
<p>2、 boolean containsKey(Object key) </p>
<p>3、 boolean containsValue(Object value) </p>
<p>4、 Object get(Object key) ;  根据指定的键key找到对应的值，如果没有找到返回 null</p>
<p>5、 remove(Object key) ;   删除指定key对应的那一对</p>
</blockquote>
<blockquote>
<p>重点方法列表：==========================</p>
<p>6、 Collection values()  返回一个Map中的所有的value值</p>
<p>7、 Set keySet()  返回所有的key值的集合</p>
<p>8、 Set entrySet() 返回所有的entry对象</p>
<p>问题： 为什么第一个是返回Collection 二三个返回的是Set?</p>
<p>key  entry都是不能够重复的— Set</p>
</blockquote>
<h4 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h4><p>使用选择：</p>
<ol>
<li>如果只是获取所有一个值，推荐使用  values()方法</li>
<li>如果只是获取所有的key，推荐使用keySet()方法,但是一般不会用，因为只有key，一般没有任何意义</li>
<li>如果获取所有的key-value，就使用entrySet()，不要用先通过keySet()获取key，再用get()获取具体的value，这样会导致二次查询，效率低下</li>
</ol>
<blockquote>
<p>说明： 只考虑我们自己把放进去的key-value都一个一个拿出来</p>
<p>1、foreach 失败了！</p>
<p>​    原因：Map和Iterable没有任何关系</p>
<p>2、普通for/ while / do-while  失败</p>
<p>​    原因： Map中没有通过索引来获得数据的方法</p>
<p>3、迭代器 失败！</p>
<p>​    原因： </p>
<p>​    ① Map没有实现Iterable接口就没有其中获得迭代器的方法；</p>
<p>​    ② Map中也没有自己设计一个获得迭代器的方法</p>
</blockquote>
<p>遍历方法一：</p>
<p>①先获得所有的key  –》 set</p>
<p>②遍历set ，通过调用Object get(Object key) 获得对应的value</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Map m = <span class="hljs-keyword">new</span> HashMap();<br>m.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">90</span>);<br>m.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;小马&quot;</span>, <span class="hljs-number">60</span>);<br>m.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;小郭&quot;</span>, <span class="hljs-number">60</span>);<br>Set keys = m.keySet();<br><span class="hljs-keyword">for</span> (Object k : keys) &#123;<br>	System.out.<span class="hljs-built_in">println</span>(k+<span class="hljs-string">&quot;&lt;----&gt;&quot;</span>+m.<span class="hljs-built_in">get</span>(k));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>遍历方法二：</p>
<p>① 得到所有的Entry对象 ，通过调用方法 Set entrySet();</p>
<p>② 遍历上面的entry 的集合，依次从每一个Entry对象中取出对应的key-value</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Map m = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HashMap()</span>;<br>m.put(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">90</span>);<br>m.put(<span class="hljs-string">&quot;小马&quot;</span>, <span class="hljs-number">60</span>);<br>m.put(<span class="hljs-string">&quot;小郭&quot;</span>, <span class="hljs-number">60</span>);<br>Set entrys = m.entry<span class="hljs-constructor">Set()</span>;<br><span class="hljs-keyword">for</span> (Object en : entrys) &#123;<span class="hljs-comment">//Set实现了Iterable</span><br>	<span class="hljs-comment">// 需要把en强制转成 Entry类型</span><br>	Entry e = (Entry)en;<br>	<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(e.get<span class="hljs-constructor">Key()</span>+<span class="hljs-string">&quot;--&quot;</span>+e.get<span class="hljs-constructor">Value()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Map的特点及使用场景选择"><a href="#Map的特点及使用场景选择" class="headerlink" title="Map的特点及使用场景选择"></a>Map的特点及使用场景选择</h4><p>特点：</p>
<ol>
<li><p>HashMap中k的值没有顺序，常用来做统计。<br>jdk1.8以后hashMap源码 变了，底层优化了</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/treeify1.png" srcset="/img/loading.gif" alt="img"></p>
<p>表示当相同hash值相同的元素大于8个时候，存储结构会变成红黑树来存储，而之前是链表结构</p>
</li>
<li><p>LinkedHashMap吧。它内部维护了一个链表，保持Key插入的顺序。迭代的时候，也是按照插入顺序迭代，而且迭代比HashMap快。</p>
</li>
<li><p>TreeMap的顺序是Key的自然顺序（如整数从小到大，默认是按键值的升序排序），也可以指定比较函数。但不是插入的顺序。</p>
</li>
<li><p>Hashtable与 HashMap类似,它继承自Dictionary类、不同的是:<code>它不允许记录的键或者值为空;</code>它支持<code>线程的同步</code>、即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p>
<p>注意：LinkedHashMap在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会 比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关 </p>
</li>
</ol>
<p>使用选择：</p>
<p>一般情况下我们选用HashMap，因为HashMap的键值对在取出时是随机的，其依据键的hashCode和键的equals方法存取数据，具有很快的访问速度，所以在Map中插入、删除及索引元素时其是效率最高的实现。而TreeMap的键值对在取出时是排过序的，所以效率会低点</p>
<blockquote>
<p>1、Map中，HashMap具有超高的访问速度，如果我们只是在Map 中插入、删除和定位元素，而无关线程安全或者同步问题，HashMap 是最好的选择。</p>
<p>2、如果考虑线程安全或者写入速度的话，可以使用HashTable</p>
<p>3、如果想按怎么存的顺序怎么取，比如队列形式，排队，那么使用LinkedHashMap</p>
<p>4、如果需要让Map按照key进行升序或者降序排序，那就用TreeMap </p>
</blockquote>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/Properties.png" srcset="/img/loading.gif" alt="p"></p>
<p>从上面的关系来看，Properties就可以当成一个特殊的Map进行使用</p>
<blockquote>
<p>① 就是一个特殊的Map,Map中的所有方法，可以调用的;</p>
<p>② 放入Properties中的key-value都是String类型</p>
<p>③ 针对于第二点Properties中提供了特殊的存值和取值的方法，尽量不要用Map的方法</p>
</blockquote>
<p>作用：</p>
<blockquote>
<ul>
<li>将内存中的数据写入到硬盘中</li>
<li>将硬盘中的数据读取到内存中</li>
</ul>
</blockquote>
<p>Properties的重要方法</p>
<blockquote>
<p>1、Object setProperty(String key, String value) </p>
<p>2、String getProperty(String key)</p>
<p>3、String getProperty(String key, String defaultValue) ; 如果通过key没有找到对应的键值对，返回后面的defaultValue</p>
<p>// 下面才是最重要的</p>
<p>4、void list(PrintStream out)    简单理解： 此方法可以把Properties中的数据写入磁盘文件</p>
<p>5、void load(InputStream inStream) 简单理解： 可以把磁盘文件中的数据读取到Properties中来</p>
</blockquote>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/fpro.png" srcset="/img/loading.gif" alt="1"></p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/fpro2.png" srcset="/img/loading.gif" alt="2"></p>
<p>使用场景：读写资源文件</p>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>1、static Object max(Collection coll) 返回容器中的最大值，内部会调用coll中的对象的compareTo方法进行比较大小—自然排序）</p>
<p>2、static Object max(Collection coll，Comparator com) 根据比较器指定的比较规则，返回容器中的最大值，内部会调用比较器的比较方法Compare方法</p>
<p>3、。。。</p>
<p> <img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/collections.png" srcset="/img/loading.gif" alt="c"></p>
<p>队列Queue</p>
<p>先进先出FIFO</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/fifo.png" srcset="/img/loading.gif" alt="img"></p>
<p>堆栈Stack</p>
<p>先进后出（FILO）/后进先出</p>
<p><img src="Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89/FILO.png" srcset="/img/loading.gif" alt="img"></p>
<p>双端队列Deque</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8/">自定义存储</a>
                    
                      <a class="hover-with-bg" href="/tags/ArrayList/">ArrayList</a>
                    
                      <a class="hover-with-bg" href="/tags/LinkedList/">LinkedList</a>
                    
                      <a class="hover-with-bg" href="/tags/HashSet/">HashSet</a>
                    
                      <a class="hover-with-bg" href="/tags/TreeSet/">TreeSet</a>
                    
                      <a class="hover-with-bg" href="/tags/Collection%E4%BD%93%E7%B3%BB/">Collection体系</a>
                    
                      <a class="hover-with-bg" href="/tags/Map/">Map</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/11/12/Java%E6%B3%9B%E5%9E%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java泛型</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/11/10/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB-%E4%BA%8C/">
                        <span class="hidden-mobile">Java常见类及其继承关系(二)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
