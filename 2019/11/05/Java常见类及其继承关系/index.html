

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="liaogangwei的个人主页">
  <meta name="author" content="Kongwei_Liao">
  <meta name="keywords" content="black, foolish, positive">
  <title>Java常见类及其继承关系(一) - Kongwei_Liao</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java常见类及其继承关系(一)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-11-05 16:55" pubdate>
        2019年11月5日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      69
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java常见类及其继承关系(一)</h1>
            
            <div class="markdown-body">
              <h3 id="Java常见类及其继承关系"><a href="#Java常见类及其继承关系" class="headerlink" title="Java常见类及其继承关系"></a>Java常见类及其继承关系</h3><p>以后会学习很多Java中写好的类（学些什么呢？）</p>
<p>实际开发中经常使用到一些类，比如数组的相关方法，字符串的相关方法等等，这些使用频率很高，Java就将常用的方法为我们封装好，为开发者省事、省时间，让开发者真正的去关心自己个人化的业务逻辑实现。所以我们需要学习常用类。</p>
<p>关键一点目的：要看懂人家这个类是干什么的，大致有哪些方法，知道怎么用。其次，可以借鉴人家的优秀思想和规范，进一步加强自己使用api的能力。</p>
<blockquote>
<p>从类的成员入手：</p>
<ul>
<li>构造方法 ： 创建对象的，通过对象来调用方法</li>
<li>字段   ： 重点关注全局常量</li>
<li>方法      ： 重点中重点！ 一个方法看成是一个功能</li>
<li>学习方法：api文档，注释，实例(看不懂就实际运行起来看结果帮助理解),互联网</li>
</ul>
</blockquote>
<ul>
<li>一个类 ： <ul>
<li>字段 ： 私有的内部结果，一般不用管； 全局常量，直接访问使用就可以了 ，Math.PI Integer.SIZE</li>
<li><strong>方法 : 重点，一定会使用，需要记忆常用的方法</strong></li>
<li>构造方法 ： 需要调用实例方法就得先调用构造方法来创建对象</li>
</ul>
</li>
</ul>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>类 <code>Object</code> 是类层次结构的根类,每个类都使用 <code>Object</code> 作为超类。(和接口没有关系)</p>
<p>所有对象（包括数组）都实现这个类的方法 :　所有的对象都可以调用到Object中的方法;</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Student s1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Student()</span>;<br>s1.hash<span class="hljs-constructor">Code()</span>；     <span class="hljs-comment">//OK</span><br><br>String s2 = ``“等等”；<br>s2.hash<span class="hljs-constructor">Code()</span>;  	<span class="hljs-comment">//OK</span><br><br><span class="hljs-built_in">int</span> i = <span class="hljs-number">5</span>;<br>i.hash<span class="hljs-constructor">Code()</span>;   	<span class="hljs-comment">//NO,因为i是一个基本数据类型不是一个类</span><br><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-number">6</span>]</span>;<br>arr.hash<span class="hljs-constructor">Code()</span>;  	<span class="hljs-comment">//OK，数组也是一个类</span><br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/demo.png" srcset="/img/loading.gif" alt="demo"></p>
<h4 id="Object类中的一些方法"><a href="#Object类中的一些方法" class="headerlink" title="Object类中的一些方法"></a>Object类中的一些方法</h4><blockquote>
<p><strong>String toString()</strong> 返回调用此方法的当前对象的字符串表示形式(把当前对象转成字符串)</p>
<p><strong>boolean equals(Object obj)</strong> 比较两个对象是否相等(比较调用此方法的对象是否和传入的obj”相等”)</p>
<p><strong>int hashCode()</strong> 把当前对象转成一个int值</p>
<p><strong>Class&lt;?&gt; getClass()</strong> 返回此 Object 的运行时类(获得一个对象的真正的类型) </p>
</blockquote>
<h4 id="Object中的toString-方法"><a href="#Object中的toString-方法" class="headerlink" title="Object中的toString()方法"></a>Object中的toString()方法</h4><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/toString.png" srcset="/img/loading.gif" alt="to" style="zoom:150%;">

<p>通过上面两种情况的测试，println打印方法内部，打印对象其实打印<code>对象.toString()方法</code>的返回值</p>
<h5 id="下面通过追踪源码-了解"><a href="#下面通过追踪源码-了解" class="headerlink" title="下面通过追踪源码(了解)"></a>下面通过追踪源码(了解)</h5><p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/Snipaste_2019-11-05_17-18-40.png" srcset="/img/loading.gif" alt="l"></p>
<p>分析：分析打印对象的结果为什么是 XXX@1232e3 这种格式</p>
<img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/r.png" srcset="/img/loading.gif" alt="1" style="zoom:150%;">

<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/q.png" srcset="/img/loading.gif" alt="qq"></p>
<p><strong>自己覆写toString方法</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>	<span class="hljs-keyword">private</span> int age;<br>	<span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name,int age</span>)</span>&#123;<br>		<span class="hljs-built_in">this</span>.name=name;<br>		<span class="hljs-built_in">this</span>.age=age;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span>&#123;<br>		<span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;-&quot;</span> + age;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="Object中的equals-方法"><a href="#Object中的equals-方法" class="headerlink" title="Object中的equals()方法"></a>Object中的equals()方法</h5><p><strong>(equals 与 == 的区别)</strong>  </p>
<p>凡是new出来的对象都会在堆中开辟新的空间, 占据不同地址值的空间。</p>
<p>原来Object中定义的equals方法的比较规则就是==,如果我们想要写自己的规则,则需要在我们自己的类中覆写Object的此方法,在方法里面写我们自己的规则!</p>
<ul>
<li>== 和 equals 都是比较是否相等：<ul>
<li>相等 : a 传统的理解一般都是数字值是否相等;    b 在程序中任何东西都是数据,都会比较是否相等</li>
</ul>
</li>
<li><code>== </code>比较的相等：<ul>
<li>基本数据类型:  比较的就是值是否相等;</li>
<li>引用数据类型:  比较的是对象的地址是否一样;<strong>（如果说要比较两个对象的内容是否相同==便不在适用了）</strong></li>
</ul>
</li>
<li><code>equals()</code>比较的相等  (最初定义在根类Object中的)  ：<ul>
<li>基本数据类型 : 不能够使用!  基本数据类型不是对象,不能够调用Object中的方法</li>
<li>引用数据类型 : 在Object的源码中定义的就是==进行比较比较，通过重写equals方法进行对象内容的比较</li>
</ul>
</li>
<li>如果我们没有去覆写过equals方法而是直接调用到了Object中的此方法,那么结果和==比较应用数据类型一样的;</li>
<li>在实际开发中,我们一般比较对象都是通过对象的属性值进行比较(一般比较对象的地址没有多大用处),所以我们会经常覆写Object中的此方法,把自己的规则写在方法里面;</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs perl">//重写equals()方法<br>public boolean equals(Object obj)&#123;<br>//	<span class="hljs-keyword">if</span>(this.name==obj.name &amp;&amp; this.age == obj.age)&#123;<br>//	<span class="hljs-regexp">//</span>Object类中没有name和age这些属性，所以这里会报错<br>//		<span class="hljs-keyword">return</span> true;<br>//	&#125;<span class="hljs-keyword">else</span>&#123;<br>//		<span class="hljs-keyword">return</span> false;<br>//	&#125;<br>//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>/<br>//	Student s = (Student)obj;<br>//	<span class="hljs-keyword">if</span>(this.name==s.name &amp;&amp; this.age == s.age)&#123;<br>//	<span class="hljs-regexp">//</span>这样做仍然是不够完善的，因为类中属性字段不应该是公开public的<br>//	<span class="hljs-regexp">//</span>利用get和set方法完善<br>//		<span class="hljs-keyword">return</span> true;<br>//	&#125;<span class="hljs-keyword">else</span>&#123;<br>//		<span class="hljs-keyword">return</span> false;<br>//	&#125;<br>//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br>//	Student s = (Student)obj;<br>//	<span class="hljs-keyword">if</span>(this.name==s.getName() &amp;&amp; this.age == s.getAge())&#123;<br>//	<span class="hljs-regexp">//</span>this.name类型是String型的是引用类型，在使用==比较时比较有风险，可能比较的是地址，本应该比较的是String型的字面值,所以应该用equals方法比较<br>//		<span class="hljs-keyword">return</span> true;<br>//	&#125;<span class="hljs-keyword">else</span>&#123;<br>//		<span class="hljs-keyword">return</span> false;<br>//	&#125;<br>//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br>	Student s = (Student)obj;<br>	<span class="hljs-keyword">if</span>(this.name.equals(s.getName()) &amp;&amp; this.age==s.getAge&#123;<br>		<span class="hljs-keyword">return</span> true;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">return</span> false;<br>	&#125;<br>&#125;<br>//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br>//****************************************************<span class="hljs-regexp">//</span><br>public boolean equals(Object obj)&#123;<br>	Student s = (Student)obj;<br>	<span class="hljs-keyword">return</span> this.name.equals(s.getName())&amp;&amp;this.age==s.getAge();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>编译器认为 ：obj中没有name， 编译器很傻，看到obj是Object类型，所有Object中是没有name的</p>
<p>但是我们知道obj变量中装的Student对象–&gt;所以把obj 转成Student （还原它的真实类型）</p>
</blockquote>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="什么是包装类"><a href="#什么是包装类" class="headerlink" title="什么是包装类"></a>什么是包装类</h4><p>就是基本数据类型对应的类。提供很多方法和字段，方便我们使用。</p>
<p>基本数据类型：byte short int long float double char boolean==&gt;都是小写，没有方法</p>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，不能像对象一样拥有很对字段和方法。为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个类和基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于java.lang包。先通过直观的代码看看int和Integer，演示一下Integer调用方法的方便性。</p>
<blockquote>
<p>① 包装类型只是将对应基本数据类型封装成一个类而已。</p>
<p>② 包装类型比基本数据类型更方便操作，可以直接使用很多方法。</p>
<p>③ 包装类型和其对应的基本数据类型表示的范围是一样的。</p>
</blockquote>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/Integer%E6%BA%90%E4%BB%A3%E7%A0%81.png" srcset="/img/loading.gif" alt="1"></p>
<h4 id="Java中的包装类有哪些？"><a href="#Java中的包装类有哪些？" class="headerlink" title="Java中的包装类有哪些？"></a>Java中的包装类有哪些？</h4><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类(可以在API文档中查询到)</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="包装类的继承体系"><a href="#包装类的继承体系" class="headerlink" title="包装类的继承体系"></a>包装类的继承体系</h4><p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/ONI.png" srcset="/img/loading.gif" alt="2"></p>
<h4 id="包装类对象的学习（Integer）"><a href="#包装类对象的学习（Integer）" class="headerlink" title="包装类对象的学习（Integer）"></a>包装类对象的学习（Integer）</h4><p>通过一个常用包装类Integer的学习，教会大家学习包装类的方法。主要是通过api文档来学习包装类的创建方式和常用方法的使用</p>
<h5 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h5><p>Integer(int value) </p>
<p>Integer(String s) </p>
<p>为什么要提供这两种转换：</p>
<p>Integer i1 = <strong>new</strong> Integer(123);</p>
<p>Integer i2 = <strong>new</strong> Integer(“123”);</p>
<p>因为在项目很多时候从前台传输数据到后台几乎都是字符串的形式。比如：</p>
<p>我们本来想传一个字符串：”00”到后台，如果不是用字符串的形式的话，以数字传到后台的话，后台接收到的就是数字0，不是”00”.</p>
<h5 id="常用的一些方法：以API文档为准"><a href="#常用的一些方法：以API文档为准" class="headerlink" title="常用的一些方法：以API文档为准"></a>常用的一些方法：以API文档为准</h5><p>八个基本类型的包装类中的成员方法大部分都是类似的，如下是Byte和Short的对比：</p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/Wrap.png" srcset="/img/loading.gif" alt="4"></p>
<p>String类提供的方法：</p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/String.png" srcset="/img/loading.gif" alt="5"></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package cn.kongwei_liao.Classes;<br><br>public <span class="hljs-keyword">class</span> WrappersDemo &#123;<br>	<br>	public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>		byte b=<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//Byte B=new Byte(b);</span><br>		<span class="hljs-comment">//Byte B=1;</span><br>		<span class="hljs-comment">//Byte B=new Byte(&quot;1&quot;);</span><br>		<span class="hljs-comment">//Byte B=Byte.valueOf(b);</span><br>		Byte B=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Byte</span>.</span></span>parse<span class="hljs-constructor">Byte(<span class="hljs-string">&quot;1&quot;</span>)</span>;<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;byte b=&quot;</span>+b+<span class="hljs-string">&quot;;\t&quot;</span>+<span class="hljs-string">&quot;Byte B=&quot;</span>+B+<span class="hljs-string">&quot;;&quot;</span>);		<br>	<br>		short s=<span class="hljs-number">2</span>;<br>		Short S=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Short(<span class="hljs-params">s</span>)</span>;<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;short s=&quot;</span>+s+<span class="hljs-string">&quot;;\t&quot;</span>+<span class="hljs-string">&quot;Short S=&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">S</span>.</span></span>short<span class="hljs-constructor">Value()</span>+<span class="hljs-string">&quot;;&quot;</span>);<br>		<br>		<span class="hljs-built_in">int</span> i=<span class="hljs-number">3</span>;<br>		Integer I=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Integer(<span class="hljs-params">i</span>)</span>;<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;int i=&quot;</span>+i+<span class="hljs-string">&quot;;\t&quot;</span>+<span class="hljs-string">&quot;Integer I=&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">I</span>.</span></span>long<span class="hljs-constructor">Value()</span>+<span class="hljs-string">&quot;;&quot;</span>);<br>		<br>		long l=<span class="hljs-number">4</span>;<br>		Long L=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Long(<span class="hljs-params">l</span>)</span>;<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;long l=&quot;</span>+l+<span class="hljs-string">&quot;;\t&quot;</span>+<span class="hljs-string">&quot;Long L=&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>+<span class="hljs-string">&quot;;&quot;</span>);<br>		<br>		<span class="hljs-built_in">float</span> f=<span class="hljs-number">0.1</span>f;<br>		Float F=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Float(<span class="hljs-params">f</span>)</span>;<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;float f=&quot;</span>+f+<span class="hljs-string">&quot;;\t&quot;</span>+<span class="hljs-string">&quot;Float F=&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">f</span>)</span>+<span class="hljs-string">&quot;;&quot;</span>);<br><br>		double d=<span class="hljs-number">0.2</span>;<br>		Double D=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Double(<span class="hljs-params">d</span>)</span>;<br>		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;double d=&quot;</span>+d+<span class="hljs-string">&quot;;\t&quot;</span>+<span class="hljs-string">&quot;Double D=&quot;</span>+<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">D</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>+<span class="hljs-string">&quot;;&quot;</span>);		<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="包装类的自动拆装箱"><a href="#包装类的自动拆装箱" class="headerlink" title="包装类的自动拆装箱"></a>包装类的自动拆装箱</h5><p>从JDK5开始支持自动拆装箱的</p>
<p>（自动）装箱：把一个基本数据类型的数据赋值给一个其对应的包装类的过程 </p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Integer</span> I1 = <span class="hljs-literal">new</span> <span class="hljs-built_in">Integer</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//手动装箱</span><br><span class="hljs-built_in">Integer</span> I2 = <span class="hljs-number">1</span>;<span class="hljs-comment">//自动装箱 </span><br></code></pre></td></tr></table></figure>
<p>（自动）拆箱：把一个包装类对象赋值给一个其对应的基本数据类型的变量的过程</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> i1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">I1</span>.</span></span><span class="hljs-built_in">int</span><span class="hljs-constructor">Value()</span>;<span class="hljs-comment">//手动拆箱</span><br><span class="hljs-built_in">int</span> i2 = I2;<span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure>
<p>注意 ：自动装箱拆箱只支持 基本数据类型和其对应的包装类  </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Integer</span> i<span class="hljs-number">1</span> = <span class="hljs-number">123</span>;<br><span class="hljs-attribute">Double</span> d<span class="hljs-number">1</span> = <span class="hljs-number">123</span>.<span class="hljs-number">0</span>;<br><span class="hljs-attribute">Integer</span> integer<span class="hljs-number">1</span>=&#x27;a&#x27;;   // 不行  ‘a’是char，对应的包装类是Character<br></code></pre></td></tr></table></figure>


<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><p>简单来说就是整数中(Short,Byte,Integer,Long)的几个包装类内部把常用 [-128,127] 的数据缓存起来了，浮点数是没有的，值太多了。。。</p>
<p>通过这个解释，一是要大家知道有这么一个东西，二是再次强调==和equals的使用，尤其是关心值的时候，请使用equals。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package cn.kongwei_liao.Classes;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> WrapShareSrc &#123;<br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>		<span class="hljs-type">Integer</span> i1=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">123</span>);<br>		<span class="hljs-type">Integer</span> i2=<span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">123</span>);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i1==i2);			//<span class="hljs-keyword">false</span><br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i1.equals(i2));	//<span class="hljs-keyword">true</span><br>		<br>		i1=<span class="hljs-number">123</span>;<br>		i2=<span class="hljs-number">123</span>;<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i1==i2);			//<span class="hljs-keyword">true</span><br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i1.equals(i2));	//<span class="hljs-keyword">true</span><br>		<br>		i1=<span class="hljs-number">128</span>;<br>		i2=<span class="hljs-number">128</span>;<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i1==i2);			//<span class="hljs-keyword">false</span><br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i1.equals(i2));	//<span class="hljs-keyword">true</span><br>	&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *	享元模式：</span><br><span class="hljs-comment"> *  	简单理解就是Integer中把[-128,127]中的数据缓存起来了，</span><br><span class="hljs-comment"> *  	从Integer的源代码中看到一点</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/xiangyuan.png" srcset="/img/loading.gif" alt="xy"></p>
<h5 id="包装类小结："><a href="#包装类小结：" class="headerlink" title="包装类小结："></a>包装类小结：</h5><ul>
<li><p>为什么需要包装类？</p>
<ul>
<li>提供了很多方法和字段，方便我们开发中直接使用</li>
</ul>
</li>
<li><p>基本数据类型和包装类对应关系？</p>
<ul>
<li>包装类是基本数据类型的首字母大写，除了int和char ==》Integer Character</li>
</ul>
</li>
<li><p>包装类的继承体系？</p>
<ul>
<li>自己看图或者查文档</li>
</ul>
</li>
<li><p>解决错误两种方式？</p>
<ul>
<li> 通过exception的类名来定位代码</li>
<li> 通过自己的错误代码信息点击过去</li>
</ul>
</li>
<li><p>拆装箱：</p>
<ul>
<li>装箱：基本数据类型–对应–》包装类 </li>
<li>拆箱：包装类–对应–》基本数据类型</li>
<li>自动装箱：Integer integer=3;</li>
<li>自动拆箱：int i =integer;</li>
<li>自动装箱和拆箱只能是基本数据类型和其对应的包装类。  </li>
</ul>
</li>
<li><p>享元模式：</p>
<ul>
<li> 数字类型：整数 Byte Short Integer Long</li>
<li>  [-128,127]</li>
</ul>
</li>
</ul>
<h3 id="System-Java垃圾回收机制-Runtime"><a href="#System-Java垃圾回收机制-Runtime" class="headerlink" title="System/Java垃圾回收机制/Runtime"></a>System/Java垃圾回收机制/Runtime</h3><h4 id="System中常用方法"><a href="#System中常用方法" class="headerlink" title="System中常用方法"></a>System中常用方法</h4><p>System类包含一些有用的类字段和方法，它不能被实例化。  System将构造方法私有化。</p>
<p>其它不能实例化的原因有：1、接口        2、抽象类        3、枚举        4、私有化构造函数</p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/System.png" srcset="/img/loading.gif" alt="s"></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package cn.kongwei_liao.Classes;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SysDemo &#123;<br><br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>		// TODO Auto-<span class="hljs-keyword">generated</span> <span class="hljs-keyword">method</span> stub<br>		long start = <span class="hljs-keyword">System</span>.currentTimeMillis();<br>		<span class="hljs-type">int</span>[] a= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>		<span class="hljs-type">int</span>[] b=<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>		<span class="hljs-keyword">System</span>.arraycopy(a, <span class="hljs-number">0</span>, b, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:b) &#123;<br>			<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(i+&quot; &quot;);<br>		&#125;<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>		long end = <span class="hljs-keyword">System</span>.currentTimeMillis();<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Start: &quot; + <span class="hljs-keyword">start</span>);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;End: &quot; + <span class="hljs-keyword">end</span>);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;End-Start:&quot; + (<span class="hljs-keyword">end</span>-<span class="hljs-keyword">start</span>));<br>	&#125;<br><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * System 类包含一些有用的类字段和方法。它不能被实例化。</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/Systemf.png" srcset="/img/loading.gif" alt="sf"></p>
<h5 id="System-exit-0"><a href="#System-exit-0" class="headerlink" title="System.exit(0);"></a>System.exit(0);</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">public static int method()&#123;<br>	try&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        System.<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-regexp">//</span><span class="hljs-number">1</span><br>        return <span class="hljs-number">0</span>;<span class="hljs-regexp">//</span><span class="hljs-number">2</span><br>        <span class="hljs-regexp">//</span>System.<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-regexp">//</span><span class="hljs-number">3</span><br>    &#125;finally&#123;<br>        System.out.println(<span class="hljs-string">&quot;good-bye&quot;</span>);<br>    &#125;<br>&#125;<br>/*<br>注掉<span class="hljs-number">3</span>打印输出：<br>Hello<br>注掉<span class="hljs-number">1</span>和<span class="hljs-number">3</span>打印输出：<br>Hello<br>good-bye<br>*/<br></code></pre></td></tr></table></figure>


<h4 id="Java的垃圾回收机制"><a href="#Java的垃圾回收机制" class="headerlink" title="Java的垃圾回收机制"></a>Java的垃圾回收机制</h4><ul>
<li><p>Java中的垃圾：当对象失去所有引用的时候，便成为占用内存的垃圾，需要回收。</p>
</li>
<li><p>Java垃圾回收机制：</p>
<ul>
<li>Java中的垃圾：没有任何引用的对象（目前java的垃圾回收机制是java的饱受争议的诟病）</li>
<li>JVM优化：一般就是优化的垃圾回收时间和内存分配大小</li>
<li>jvm回收垃圾是有自己的机制，不定时，随机的。</li>
<li>说白了，就是你不知道jvm到底什么时候进行回收。</li>
<li>但是我们也可以主动调用方法，但是呢，即使我们主动了，也不一定说jvm就马上进行垃圾回收，也是一个随机的事情，我们只是说自己去对垃圾回收这个事情进行了努力。</li>
</ul>
</li>
<li><p>在Java中提供了两个和垃圾回收相关的方法:</p>
<ul>
<li>Object中的<code>finalize()</code>:  所有的对象都可以调用此方法，当这个对象被回收时就会调用此方法。</li>
<li>System中的<code>gc()</code>:  调用此方法表示我们做了一些努力来回收垃圾。</li>
</ul>
</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//覆写Object的finalize方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> GcTest &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>	@Override<br>	<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> finalize() <span class="hljs-keyword">throws</span> Throwable &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">super</span>.finalize();<br>		System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;我被回收了。。。。&quot;</span>+<span class="hljs-keyword">count</span>++);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//Jvm自己回收</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>		<span class="hljs-comment">//参数垃圾</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>			<span class="hljs-keyword">new</span> Test();<br>		&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/gc1.png" srcset="/img/loading.gif" alt="gc1"></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//人工主动回收</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			<span class="hljs-keyword">new</span> Test();<br>			System.gc();<span class="hljs-comment">//主动回收</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/gc2.png" srcset="/img/loading.gif" alt="gc2"></p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/gc3.png" srcset="/img/loading.gif" alt="gc3"></p>
<h4 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h4><p>每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。  </p>
<p>应用程序不能创建自己的 Runtime 类实例。为什么？请自己看源码</p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/Runtime.png" srcset="/img/loading.gif" alt="rt"></p>
<h5 id="exec-String-command-方法"><a href="#exec-String-command-方法" class="headerlink" title="exec(String command)方法"></a>exec(String command)方法</h5><p>Runtime.getRuntime().exec(“notepad”);</p>
<p>可以指向字符串命令：必须放在c:\windows\system32</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.kongwei_liao.RuntimeDemo;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeDemo</span> </span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">try</span> &#123;<br>			Runtime.getRuntime().exec(<span class="hljs-string">&quot;notepad&quot;</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			<span class="hljs-comment">// TODO Auto-generated catch block</span><br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/Runtime1.png" srcset="/img/loading.gif" alt="rt1"></p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/runtimef.png" srcset="/img/loading.gif" alt="rtf"></p>
<h3 id="字符串相关类String-StringBuffer-StringBuilder"><a href="#字符串相关类String-StringBuffer-StringBuilder" class="headerlink" title="字符串相关类String/StringBuffer/StringBuilder"></a>字符串相关类String/StringBuffer/StringBuilder</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><strong>转换成字符串的方式有哪些？</strong></p>
<blockquote>
<p>1、String.valueOf();</p>
<p>2、toString();</p>
<p>3、+</p>
<p>效率最高的方式为：toString()   &gt;   valueOf()   &gt;   +               为什么？？</p>
</blockquote>
<p>String是Java中写好的一个类：描述一个字符串，非常常用！！！</p>
<p><strong>String对象创建：</strong></p>
<blockquote>
<p>1、String s = “我是一个随便的字符串”;</p>
<p>2、通过调用String类的构造方法</p>
<p>​        String()</p>
<p>​        String(String str)</p>
</blockquote>
<p><strong>关于空字符串</strong>：</p>
<blockquote>
<p>①String str1 = null;//表示str1没有指向一个对象</p>
<p>②String str2 = “”; //有一个对象，对象是空</p>
<p>③String str3 = new String();//  和②差不多</p>
<p>注意一下：在实际的开发中，我们会这样直接申明一个空的而不做任何事情么？绝对不会。所以呢，大家认识到这个就行了，主要是给大家演示加强一下==(值和地址都比较 )和equals(只关心值)。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str1==str2);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str1==str3);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str1.equals(str2));<span class="hljs-comment">//尽量使用一个已知的值去和未知的值比较。尽可能的避免空指针异常。</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2==str3);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2.equals(str3));<br></code></pre></td></tr></table></figure>
<p><strong>字符串的比较/常量池</strong>  </p>
<p>字符串对象引用都是存储在栈中的，如果是<code>编译期</code>已经创建好(直接用<code>双引号</code>定义的，表示这个值是已经确定的，已知的)的就存储在<code>常量池</code>中，如果是<code>运行期（new出来的）</code>才能确定的就存储在<code>堆</code>中。</p>
<p>(注：编译期：就是我们的javac命令，运行期就是java。Eclipse是自动编译的，就是当我把代码写出来后，就运行了javac，生成了class文件。比如：Integer i = new Integer(“A”)这句代码，在我们的编译期不会出错，就是说写了这句代码没有报错(因为能够编译成class文件)，但是运行起来后，就出错了。)</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-built_in">String</span> str1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-built_in">String</span> str2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>System.<span class="hljs-keyword">out</span>.println(str1==str2);//<span class="hljs-literal">true</span>?<span class="hljs-literal">false</span><br>System.<span class="hljs-keyword">out</span>.println(str1.equals(str2)); //<span class="hljs-literal">true</span>?<span class="hljs-literal">false</span><br><br><span class="hljs-built_in">String</span> str3=<span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-built_in">String</span> str4=<span class="hljs-string">&quot;abc&quot;</span>;<br>System.<span class="hljs-keyword">out</span>.println(str3==str4); //<span class="hljs-literal">true</span>?<span class="hljs-literal">false</span><br>System.<span class="hljs-keyword">out</span>.println(str3.equals(str4)); //<span class="hljs-literal">true</span>?<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/str.png" srcset="/img/loading.gif" alt="str1"></p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/str2.png" srcset="/img/loading.gif" alt="str2"></p>
<p>关于常量池的补充说明：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">String</span> s2=<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-comment">//a 和b都是确定的常量，在编译期就能确定就是字母a和字母b（确定的值不是只能是字母，只要是双引号引起来的，都是确定的）这句话编译期生成的class文件相当于String s2=”ab”。如果这个时候常量池中没有ab，则在常量池中产生再将s2的引用指向常量池中ab，有就直接将s2的引用指向常量池中ab。所以不管怎么，结果就是常量池中有了ab这个常量</span><br><br><span class="hljs-keyword">String</span> s3=<span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">//因为s2已经产生了ab常量，所以s3直接在常量池中就找到了，这个时候s2和s3都是指向了常量池中ab，所以s2==s3.</span><br><br>System.out.<span class="hljs-built_in">println</span>(s2==s3);<span class="hljs-comment">//true</span><br><br><span class="hljs-keyword">String</span> s=<span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-keyword">String</span> s1=<span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-comment">//都是确定的值，所以在常量池中产生a和b两个常量。</span><br><br><span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>=s+s1;<br><span class="hljs-comment">//因为String是一旦创建后就不可以改变的。这个+号操作就是说你在改变String str=s,想把它改变成s+s1.</span><br><br><span class="hljs-keyword">String</span> s3=<span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//</span><br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">str</span>==s3);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/%E5%B8%B8%E9%87%8F%E6%B1%A0.png" srcset="/img/loading.gif" alt="clc"></p>
<ul>
<li>最后记住一句话：这种对象的比较能懂就懂，不懂就算了，不要去想。实际开发中根本不会去想这些事情，没有一点用处。但是有些面试官喜欢(省略2个字)。放心，他们也说不清楚。</li>
<li>引用数据类型如果想比较值，使用equals</li>
<li>String类覆写了Object中的equals方法，比价的就是字符串的字面值</li>
</ul>
<h4 id="String中的方法："><a href="#String中的方法：" class="headerlink" title="String中的方法："></a>String中的方法：</h4><ul>
<li><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/String.png" srcset="/img/loading.gif" alt="strf"></li>
</ul>
<h3 id="StringBuffer-StringBuilder-容器"><a href="#StringBuffer-StringBuilder-容器" class="headerlink" title="StringBuffer/StringBuilder(容器)"></a>StringBuffer/StringBuilder(容器)</h3><h4 id="拼接数字示例"><a href="#拼接数字示例" class="headerlink" title="拼接数字示例"></a>拼接数字示例</h4><p>将1到1000,1到10000,1到10w数字拼接起来，看看需要多少时间？</p>
<h4 id="String-StringBuffer-StringBuilder的关系"><a href="#String-StringBuffer-StringBuilder的关系" class="headerlink" title="String/StringBuffer/StringBuilder的关系"></a>String/StringBuffer/StringBuilder的关系</h4><blockquote>
<p>① 这3个类没有直接或者间接的继承关系<code>（不是直系亲属）</code></p>
<pre><code>      StringBuffer sb = “1231432234455”;  报错
</code></pre>
<p>② 都表示字符序列（简单理解为字符串）</p>
<p>​        CharSequence  （字符序列的<strong>接口</strong>）</p>
<p>​               |— String</p>
<p>​               |—-StringBuffer</p>
<pre><code>           |----StringBuilder
</code></pre>
<p>③ 区别</p>
<ul>
<li><p>String : 它的对象一旦被创建那么值和长度就固定不变了</p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/strc.png" srcset="/img/loading.gif"></p>
</li>
<li><p>StringBuffer  : 它的对象内容是可以被改变的;</p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/strbuf.png" srcset="/img/loading.gif"></p>
<ul>
<li>是线程安全的</li>
<li>版本是1.0</li>
<li>效率相对于比StringBuilder要低</li>
</ul>
</li>
<li><p>StringBuilder  : 它的对象内容是可以被改变的;</p>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/strbuld.png" srcset="/img/loading.gif" alt="strb"></p>
<ul>
<li>是线程不安全的</li>
<li>版本是 1.5</li>
<li>相当于StringBuffer效率更高一点</li>
<li>效率相对于比StringBuffer要高</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="StringBuffer-StringBuilder中的常用方法"><a href="#StringBuffer-StringBuilder中的常用方法" class="headerlink" title="StringBuffer/StringBuilder中的常用方法"></a>StringBuffer/StringBuilder中的常用方法</h4><p>① 这两个中的方法几乎是一样的；</p>
<p>② 上面3个都表示字符序列，因此有很多一样的方法（暂时就忽略）</p>
<p>③ 今天重点关注这两个中特有的方法： 更改对象中数据的方法</p>
<p>思考：</p>
<p>  哪些操作可能会改变对象中的数据？</p>
<p>  插入、替换、删除、追加。。。</p>
<p>================================</p>
<p>④ 构造方法：</p>
<ul>
<li>StringBuilder() <ul>
<li>构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。 </li>
<li>初始容量什么意思？</li>
</ul>
</li>
<li>StringBuilder(CharSequence seq) <ul>
<li>构造一个字符串生成器，它包含与指定的 CharSequence 相同的字符。 </li>
<li>new StringBuilder(“懂了吗？”)</li>
<li>new StringBuilder(new StringBuffer(“这下呢？”))</li>
<li>new StringBuilder(new StringBuilder(“。。。。”))</li>
</ul>
</li>
<li>StringBuilder(int capacity) <ul>
<li> 构造一个不带任何字符的字符串生成器，其初始容量由 capacity 参数指定。</li>
</ul>
</li>
<li>StringBuilder(String str) </li>
</ul>
<p>⑤ 常用方法：</p>
<ul>
<li>StringBuilder append(….) </li>
<li>StringBuilder delete(int start, int end) </li>
<li>StringBuilder insert(插入点，插入的数据)</li>
<li>StringBuilder replace(int start, int end, String str) </li>
<li>StringBuilder reverse() 翻转</li>
<li>String substring(int start)    返回一个副本，本身的对象没有被改变</li>
<li>String substring(int start, int end) 返回一个副本，本身的对象没有被改变</li>
</ul>
<h3 id="错误与异常分析"><a href="#错误与异常分析" class="headerlink" title="错误与异常分析"></a>错误与异常分析</h3><p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/Snipaste_2019-11-07_21-36-50.png" srcset="/img/loading.gif" alt="3"></p>
<p>排错方式2种:</p>
<p>方式一：到API文档中查询什么意思 NumberFormatException</p>
<p>方式二：自己根据错误信息定位分析问题：</p>
<p>分析具体这行代码，哪些地方可能出错？</p>
<p>Integer integer = <strong>new</strong> Integer(“你给我转啊”);</p>
<h3 id="Java面试题："><a href="#Java面试题：" class="headerlink" title="Java面试题："></a>Java面试题：</h3><p>1、请你说说int和Integer的区别</p>
<p>​        Int 和 Integer它们都是一个整数，并且范围都是一样的，而int是基本数据类型，而Integer是int包装类，int是没有方法和字段，而Integer提供了大量的方法与字段</p>
<p>2、创建了几个字符串对象的面试题</p>
<p> 注意：一般这种问法不会考虑常量池中的对象，是问堆中的对象，如果是当面问，可以给他说说有常量池这么一个东西，表示你知道有这么回事。</p>
<p>①String s1 = “A” + “hello” // 最多创建1个，最少0个，要看常量池里面有没有Ahello</p>
<p>② String s2 = “A”;// 1</p>
<p>  String s3 = s2 + “hello”;//2</p>
<p>③ String s4 = new String(“A”) + new String(“hello”); 3个</p>
<p>3、String/StringBuffer/StringBuilder 他们的区别</p>
<p>String: 它表示一个字符串，字符串一旦创建了之后，它的长度与内容都是不可变的</p>
<p>StringBuffer:它们都是操作字符串的容器，它们的长度和大小都是可变的，StringBuffer是jdk1.0开始，是线程安全的，效率相对于StringBuilder要低，StringBuilder 是1.5开始的  是线程不安全的 效率相对于比StringBuffer要高</p>
<p>4、编程题体现，请看如下的代码，请说出控制台打印的结果</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>	<span class="hljs-keyword">String</span> s1=<span class="hljs-string">&quot;AAA&quot;</span>;<br>	<span class="hljs-keyword">String</span> s2=<span class="hljs-string">&quot;KKK&quot;</span>;<br>	StringBuffer sb1=<span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;QQQ&quot;</span>);<br>	StringBuffer sb2=<span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;JJJ&quot;</span>);<br><br>	change(s1,s2,sb1,sb2);<br>	System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变后s1=&quot;</span>+s1);<span class="hljs-comment">//</span><br>	System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变后s2=&quot;</span>+s2);<span class="hljs-comment">//</span><br>	System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变后sb1=&quot;</span>+sb1);<span class="hljs-comment">//</span><br><br>	System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变后sb2=&quot;</span>+sb2);<span class="hljs-comment">//</span><br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> change(<span class="hljs-keyword">String</span> s1, <span class="hljs-keyword">String</span> s2, StringBuffer sb1, StringBuffer sb2) &#123;<br>	s1=<span class="hljs-string">&quot;XXX&quot;</span>;<br>	s2=s2.<span class="hljs-built_in">concat</span>(<span class="hljs-string">&quot;666&quot;</span>);<br>	sb1.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;999&quot;</span>);<br>	sb2=sb2.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;777&quot;</span>);<br>	System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变中s1=&quot;</span>+s1);<span class="hljs-comment">//xxx</span><br>	System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变中s2=&quot;</span>+s2);<span class="hljs-comment">//kkk666</span><br>	System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变中sb1=&quot;</span>+sb1);<span class="hljs-comment">//QQQ999</span><br>	System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变中sb2=&quot;</span>+sb2);<span class="hljs-comment">//JJJ777</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2019/11/05/Java%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/qw.png" srcset="/img/loading.gif" alt="qw"></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> <span class="hljs-title">stringReplace</span><span class="hljs-params">(<span class="hljs-keyword">String</span> <span class="hljs-built_in">text</span>)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">text</span>.replace(<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title">bufferReplace</span><span class="hljs-params">(StringBuffer <span class="hljs-built_in">text</span>)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">text</span>.append(<span class="hljs-string">&quot;c&quot;</span>);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> args[])</span> </span>&#123;<br>		<span class="hljs-keyword">String</span> textString = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;java&quot;</span>);<br>		StringBuffer textBuffer = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;java&quot;</span>);<br>		System.out.<span class="hljs-built_in">println</span>(stringReplace(textString) + bufferReplace(textBuffer));<br>System.out.<span class="hljs-built_in">println</span>(textString + textBuffer);<br>	&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">结果输出：</span><br><span class="hljs-comment">Lavajavac</span><br><span class="hljs-comment">javajavac</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/Object/">Object</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/">包装类</a>
                    
                      <a class="hover-with-bg" href="/tags/System/">System</a>
                    
                      <a class="hover-with-bg" href="/tags/Runtime/">Runtime</a>
                    
                      <a class="hover-with-bg" href="/tags/String/">String</a>
                    
                      <a class="hover-with-bg" href="/tags/StringBuilder/">StringBuilder</a>
                    
                      <a class="hover-with-bg" href="/tags/StringBuffer/">StringBuffer</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/11/06/%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">第一讲：为什么学习网络协议</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/11/05/Java%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/">
                        <span class="hidden-mobile">Java继承与包访问权限</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
